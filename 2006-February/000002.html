<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Iometer-svn] r237 - branches/IOMETER-restruct/iometer/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/iometer-svn/2006-February/index.html" >
   <LINK REL="made" HREF="mailto:iometer-svn%40lists.berlios.de?Subject=Re%3A%20%5BIometer-svn%5D%20r237%20-%20branches/IOMETER-restruct/iometer/src&In-Reply-To=%3C200602081909.k18J9Vei014429%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000001.html">
   <LINK REL="Next"  HREF="000003.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Iometer-svn] r237 - branches/IOMETER-restruct/iometer/src</H1>
    <B>cheungming at BerliOS</B> 
    <A HREF="mailto:iometer-svn%40lists.berlios.de?Subject=Re%3A%20%5BIometer-svn%5D%20r237%20-%20branches/IOMETER-restruct/iometer/src&In-Reply-To=%3C200602081909.k18J9Vei014429%40sheep.berlios.de%3E"
       TITLE="[Iometer-svn] r237 - branches/IOMETER-restruct/iometer/src">cheungming at berlios.de
       </A><BR>
    <I>Wed Feb  8 20:09:31 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000001.html">[Iometer-svn] r236 - branches/IOMETER-restruct/iometer/src
</A></li>
        <LI>Next message: <A HREF="000003.html">[Iometer-svn] r238 - trunk/iometer/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2">[ date ]</a>
              <a href="thread.html#2">[ thread ]</a>
              <a href="subject.html#2">[ subject ]</a>
              <a href="author.html#2">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: cheungming
Date: 2006-02-08 20:08:18 +0100 (Wed, 08 Feb 2006)
New Revision: 237

Modified:
   branches/IOMETER-restruct/iometer/src/IOCommon.h
   branches/IOMETER-restruct/iometer/src/IOGrunt.cpp
Log:
fix some strange indent in IOGrunt.cpp.
also revert IOCommon.h back to original, much easier to read. 

so indent can not do a good work on file with tons of #if, #else, ...



Modified: branches/IOMETER-restruct/iometer/src/IOCommon.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 02:20:20 UTC (rev 236)
+++ branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 19:08:18 UTC (rev 237)
@@ -155,6 +155,8 @@
 #ifndef	___IOCOMMON_H_DEFINED___
 #define ___IOCOMMON_H_DEFINED___
 
+
+
 // Check and map the different global defines for Operating
 // System family, Operating System and CPU (see README).
 // ----------------------------------------------------------------------------
@@ -163,8 +165,8 @@
     (!defined(IOMTR_OSFAMILY_NETWARE) &amp;&amp;  defined(IOMTR_OSFAMILY_UNIX) &amp;&amp; !defined(IOMTR_OSFAMILY_WINDOWS)) || \
     (!defined(IOMTR_OSFAMILY_NETWARE) &amp;&amp; !defined(IOMTR_OSFAMILY_UNIX) &amp;&amp;  defined(IOMTR_OSFAMILY_WINDOWS))
  // nop
-#else
-#error ===&gt; ERROR: Check the Operating System to Operating System family mapping!
+#else    
+ #error ===&gt; ERROR: Check the Operating System to Operating System family mapping!
 #endif
 // ----------------------------------------------------------------------------
 // Check the Operating System mapping
@@ -175,8 +177,8 @@
     (!defined(IOMTR_OS_LINUX) &amp;&amp; !defined(IOMTR_OS_NETWARE) &amp;&amp; !defined(IOMTR_OS_OSX) &amp;&amp; !defined(IOMTR_OS_SOLARIS) &amp;&amp;  defined(IOMTR_OS_WIN32) &amp;&amp; !defined(IOMTR_OS_WIN64)) || \
     (!defined(IOMTR_OS_LINUX) &amp;&amp; !defined(IOMTR_OS_NETWARE) &amp;&amp; !defined(IOMTR_OS_OSX) &amp;&amp; !defined(IOMTR_OS_SOLARIS) &amp;&amp; !defined(IOMTR_OS_WIN32) &amp;&amp;  defined(IOMTR_OS_WIN64))
  // nop
-#else
-#error ===&gt; ERROR: You have to define exactly one IOMTR_OS_* global define!
+#else    
+ #error ===&gt; ERROR: You have to define exactly one IOMTR_OS_* global define!
 #endif
 // ----------------------------------------------------------------------------
 // Check the Processor mapping
@@ -189,29 +191,31 @@
     (!defined(IOMTR_CPU_ALPHA) &amp;&amp; !defined(IOMTR_CPU_I386) &amp;&amp; !defined(IOMTR_CPU_IA64) &amp;&amp; !defined(IOMTR_CPU_MIPS) &amp;&amp; !defined(IOMTR_CPU_PPC) &amp;&amp; !defined(IOMTR_CPU_SPARC) &amp;&amp;  defined(IOMTR_CPU_X86_64) &amp;&amp; !defined(IOMTR_CPU_XSCALE)) || \
     (!defined(IOMTR_CPU_ALPHA) &amp;&amp; !defined(IOMTR_CPU_I386) &amp;&amp; !defined(IOMTR_CPU_IA64) &amp;&amp; !defined(IOMTR_CPU_MIPS) &amp;&amp; !defined(IOMTR_CPU_PPC) &amp;&amp; !defined(IOMTR_CPU_SPARC) &amp;&amp; !defined(IOMTR_CPU_X86_64) &amp;&amp;  defined(IOMTR_CPU_XSCALE))
  // nop
-#else
-#error ===&gt; ERROR: You have to define exactly one IOMTR_CPU_* global define!
+#else    
+ #error ===&gt; ERROR: You have to define exactly one IOMTR_CPU_* global define!
 #endif
 // ----------------------------------------------------------------------------
 
+
+
 // Include the different header files
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
-#if defined(IOMTR_OSFAMILY_WINDOWS)	// Only first, because it is needed here!
-#define VC_EXTRALEAN
-#pragma warning (disable: 4242)
-#include &lt;process.h&gt;
-#include &lt;io.h&gt;
-#include &lt;direct.h&gt;
-#include &lt;afxwin.h&gt;
-#include &lt;afxext.h&gt;
-#include &lt;afxcmn.h&gt;
-#include &lt;winioctl.h&gt;
-#include &lt;iomanip&gt;
-#include &lt;winperf.h&gt;
-#include &lt;winreg.h&gt;
-#include &lt;afxmt.h&gt;
-#include &lt;malloc.h&gt;
+#if defined(IOMTR_OSFAMILY_WINDOWS)   // Only first, because it is needed here!
+ #define VC_EXTRALEAN
+ #pragma warning (disable: 4242)
+ #include &lt;process.h&gt;
+ #include &lt;io.h&gt;
+ #include &lt;direct.h&gt;
+ #include &lt;afxwin.h&gt;
+ #include &lt;afxext.h&gt;
+ #include &lt;afxcmn.h&gt;
+ #include &lt;winioctl.h&gt;
+ #include &lt;iomanip&gt;
+ #include &lt;winperf.h&gt;
+ #include &lt;winreg.h&gt;
+ #include &lt;afxmt.h&gt;
+ #include &lt;malloc.h&gt;
 #endif
 // ----------------------------------------------------------------------------
 #include &lt;stdio.h&gt;
@@ -228,192 +232,193 @@
 #include &lt;iostream&gt;
 #include &lt;fstream&gt;
 using namespace std;
-
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE)
-#include &lt;sys/timeval.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;netinet/in.h&gt;		// in_addr_t
-#include &lt;nks/memory.h&gt;
-#include &lt;nks/fsio.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;mmpublic.h&gt;
-#include &lt;malloc.h&gt;
+ #include &lt;sys/timeval.h&gt;
+ #include &lt;sys/time.h&gt;
+ #include &lt;sys/socket.h&gt;
+ #include &lt;unistd.h&gt;
+ #include &lt;signal.h&gt;
+ #include &lt;netinet/in.h&gt;   // in_addr_t
+ #include &lt;nks/memory.h&gt;
+ #include &lt;nks/fsio.h&gt;
+ #include &lt;pthread.h&gt;
+ #include &lt;mmpublic.h&gt;
+ #include &lt;malloc.h&gt;
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX)
-#include &lt;sys/timeb.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;netinet/in.h&gt;		// in_addr_t
+ #include &lt;sys/timeb.h&gt;
+ #include &lt;unistd.h&gt;
+ #include &lt;pthread.h&gt;
+ #include &lt;signal.h&gt;
+ #include &lt;netinet/in.h&gt;   // in_addr_t
 
-#if defined(IOMTR_OS_OSX)
-#include &lt;sys/aio.h&gt;
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-#include &lt;malloc.h&gt;
-#include &lt;aio.h&gt;
-#else
-#error ===&gt; ERROR: You have to define exactly one IOMTR_CPU_* global define!
-#endif
+ #if defined(IOMTR_OS_OSX)
+  #include &lt;sys/aio.h&gt;
+ #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+  #include &lt;malloc.h&gt;
+  #include &lt;aio.h&gt;
+ #else
+  #error ===&gt; ERROR: You have to define exactly one IOMTR_CPU_* global define!
+ #endif
 
-#if defined(IOMTR_OS_LINUX)
-#include &lt;sys/ioctl.h&gt;
+ #if defined(IOMTR_OS_LINUX)
+  #include &lt;sys/ioctl.h&gt;
+ #endif
+ #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
+  #include &lt;syslog.h&gt;
+ #endif
 #endif
-#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-#include &lt;syslog.h&gt;
-#endif
-#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-#include &lt;sys/timeb.h&gt;
-#if (_MSC_VER &lt; 1300) || defined(USING_DDK)
-#include &quot;ostream64.h&quot;
+ #include &lt;sys/timeb.h&gt;
+ #if (_MSC_VER &lt; 1300) || defined(USING_DDK)
+  #include &quot;ostream64.h&quot;
+ #endif
 #endif
-#endif
 // ----------------------------------------------------------------------------
-#include &quot;IOVersion.h&quot;		// version info definitions
+#include &quot;IOVersion.h&quot;   // version info definitions
 // ----------------------------------------------------------------------------
 
+
+
+
 // Define the different data types
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-#define __int64   long long
-#define __int32   long
-#define __int16   short
-#define __int8    char
+ #define __int64   long long
+ #define __int32   long
+ #define __int16   short
+ #define __int8    char
 
-#if defined(IOMTR_SETTING_GCC_M64)
+ #if defined(IOMTR_SETTING_GCC_M64)
   // in the gcc on x86_64 environment long is 64 bits
-#undef __int32
-#define __int32 int
-#endif
+  #undef __int32
+  #define __int32 int
+ #endif
 
-typedef long long _int64;
+ typedef long long	       _int64;
+ //typedef long long	       LARGE_INTEGER; 
+ typedef unsigned long long    DWORDLONG;
 
- //typedef long long           LARGE_INTEGER; 
-typedef unsigned long long DWORDLONG;
-
-#if defined(IOMTR_OSFAMILY_NETWARE)
-#ifndef LONG
-#define LONG	unsigned long
-#endif
-#ifndef WORD
-#define WORD	unsigned short
-#endif
-#elif defined(IOMTR_OSFAMILY_UNIX)
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+  #ifndef LONG
+   #define LONG	unsigned long
+  #endif
+  #ifndef WORD
+   #define WORD	unsigned short
+  #endif
+ #elif defined(IOMTR_OSFAMILY_UNIX)
   // This is OK for x86-64 processors because LONG is only used in Netware or
   // in MeterCtrl.cpp.or safely internally in IOTargetDisk.cpp.
   // It could cause problems because in the x86-64 environment long is 64 bits.
-typedef long LONG;
-
-#if defined(IOMTR_OS_OSX)
-#define off64_t	off_t
-#endif
-#else
-#warning ===&gt; WARNING: You have to do some coding here to get the port done!
-#endif
-
-#if defined(IOMTR_SETTING_GCC_M64)
+  typedef long		       LONG;
+  #if defined(IOMTR_OS_OSX)
+   #define off64_t	off_t  
+  #endif 
+ #else
+  #warning ===&gt; WARNING: You have to do some coding here to get the port done!
+ #endif
+ 
+ #if defined(IOMTR_SETTING_GCC_M64)
   // DWORD is supposed to be an unsigned 32 bit number.
-typedef unsigned int DWORD;
-#else
-typedef unsigned long DWORD;
-#endif
+  typedef unsigned int	       DWORD;
+ #else
+  typedef unsigned long	       DWORD;
+ #endif
+ 
+ typedef int		       INT;
+ typedef int		       BOOL;
+ typedef int		       BOOLEAN;
+ typedef unsigned int	       UINT;
+ typedef unsigned int	      *PUINT;
 
-typedef int INT;
-typedef int BOOL;
-typedef int BOOLEAN;
-typedef unsigned int UINT;
-typedef unsigned int *PUINT;
+ typedef unsigned short	       WCHAR;
+ typedef unsigned short	      *LPWSTR;
 
-typedef unsigned short WCHAR;
-typedef unsigned short *LPWSTR;
+ typedef char		      *LPSTR;
+ typedef unsigned char	       BYTE;
+ typedef const char	      *LPCSTR;
 
-typedef char *LPSTR;
-typedef unsigned char BYTE;
-typedef const char *LPCSTR;
+ typedef void		      *HANDLE;
+ typedef void		      *LPVOID;
 
-typedef void *HANDLE;
-typedef void *LPVOID;
-
  //  The places in the Iometer code that now use CONNECTION used to use
  //  SOCKET. But SOCKET is a defined type in winsock2.h used for network
  //  access. Iometer defined a type called SOCKET used in NetTCP.cpp but 
  //  the original winsock SOCKET was used in IOPortTCP.cpp. Defining
  //  a new CONNECTION type allows me to separate the two different concepts
  //  cleanly.
-typedef void *CONNECTION;
+ typedef void                 *CONNECTION;
+ 
+ typedef int		       SOCKET;
+ typedef const void	      *LPCVOID;
 
-typedef int SOCKET;
-typedef const void *LPCVOID;
+ typedef DWORD		      *LPDWORD;
+ typedef BYTE		      *LPBYTE;
+ typedef LPCSTR		       LPCTSTR;
 
-typedef DWORD *LPDWORD;
-typedef BYTE *LPBYTE;
-typedef LPCSTR LPCTSTR;
-
-typedef unsigned long ULONG_PTR, *PULONG_PTR;
-typedef ULONG_PTR DWORD_PTR;
-#endif
+ typedef unsigned long         ULONG_PTR, *PULONG_PTR;
+ typedef ULONG_PTR             DWORD_PTR;
+#endif 
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-#ifndef USING_DDK
-#if defined(IOMTR_OS_WIN32)
+ #ifndef USING_DDK
+  #if defined(IOMTR_OS_WIN32)
    // dps: Was __int32 in before, but conflicts while conversion
    //      from unsigned __int32 to unsigned long for instance
    //      (using Microsoft Visual C++).
-typedef long LONG_PTR, *PLONG_PTR;
-typedef unsigned long ULONG_PTR, *PULONG_PTR;
-typedef ULONG_PTR DWORD_PTR;
-#endif
-#if defined(IOMTR_OS_WIN64)
-typedef __int64 LONG_PTR, *PLONG_PTR;
-typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
-typedef ULONG_PTR DWORD_PTR;
-#endif
-#endif				// USING_DDK
+   typedef long LONG_PTR, *PLONG_PTR;
+   typedef unsigned long  ULONG_PTR, *PULONG_PTR;
+   typedef ULONG_PTR      DWORD_PTR;
+  #endif
+  #if defined(IOMTR_OS_WIN64)
+   typedef __int64 LONG_PTR, *PLONG_PTR;
+   typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
+   typedef ULONG_PTR        DWORD_PTR;
+  #endif
+ #endif // USING_DDK
  //  The places in the Iometer code that now use CONNECTION used to use
  //  SOCKET. But SOCKET is a defined type in winsock2.h used for network
  //  access. Iometer defined a type called SOCKET used in NetTCP.cpp but 
  //  the original winsock SOCKET was used in IOPortTCP.cpp. Defining
  //  a new CONNECTION type allows me to separate the two different concepts
  //  cleanly.
-typedef ULONG_PTR CONNECTION;
-#endif
+ typedef ULONG_PTR CONNECTION;
+#endif 
 // ----------------------------------------------------------------------------
 
 // Because of some of the memory over writing issues in the 64 bit environment
 // and the typing required by the windows environment, variables need to be cast
 // differently depending on OSFAMILY. this gets the job done... 
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-#define IOMTR_MACRO_INTERLOCK_CAST(a) (long *)
+ #define IOMTR_MACRO_INTERLOCK_CAST(a) (long *)
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
-#define IOMTR_MACRO_INTERLOCK_CAST(a) (a *)
+ #define IOMTR_MACRO_INTERLOCK_CAST(a) (a *)
 #else
-#error ===&gt; ERROR: You have to do some coding here to get the port done!
+ #error ===&gt; ERROR: You have to do some coding here to get the port done!
 #endif
 
 // ----------------------------------------------------------------------------
 
+
 // Definition of the defines itself
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 // Different return values for the Iometer and Dynamo function calls.
-#define IOERROR	-1		// keep negative
+#define IOERROR	-1   // keep negative
 
-#define RETRY_DELAY   200	// msec. to wait before reattempting an action
-#define LONG_DELAY    3000	// msec. to wait before reattempting an action
-#define IDLE_DELAY    1000	// max msec to wait between calls to CGalileoApp::OnIdle()
+#define RETRY_DELAY   200    // msec. to wait before reattempting an action
+#define LONG_DELAY    3000   // msec. to wait before reattempting an action
+#define IDLE_DELAY    1000   // max msec to wait between calls to CGalileoApp::OnIdle()
 
 #define KILOBYTE   1024
 #define MEGABYTE   1048576
 
-#define MAX_NAME	      80	// xca1019: Was 64 - changed according to
-				   // the Solaris 2.6 man page for swapctl(2)
+#define MAX_NAME	      80   // xca1019: Was 64 - changed according to
+                                   // the Solaris 2.6 man page for swapctl(2)
 #define	MAX_CPUS	      32
 #define	MAX_WORKERS	      100
 #define MAX_TARGETS	      512
@@ -440,22 +445,22 @@
 #define CPU_IRQ			     5
 
 // Definitions for network tcp results
-#define TCP_RESULTS           1	// total number of network results
+#define TCP_RESULTS           1   // total number of network results
 // List all specific performance results that are desired.
 #define TCP_SEGMENTS_RESENT   0
 
 // Definitions for network interface results
-#define NI_RESULTS	     3	// total number of network interface results reported
-#define NI_COMBINE_RESULTS   2	// combine some reported results together
+#define NI_RESULTS	     3   // total number of network interface results reported
+#define NI_COMBINE_RESULTS   2   // combine some reported results together
 // List all specific performance results that are desired.
 #define NI_PACKETS	     0
 #define NI_OUT_ERRORS	     1
 #define NI_IN_ERRORS	     2
-#define NI_ERRORS	     1	// combine in and out errors together when saving
+#define NI_ERRORS	     1   // combine in and out errors together when saving
 
 // Initialization parameters for CArray and related classes.
-#define INITIAL_ARRAY_SIZE   0	// Sets the size of the array.
-#define ARRAY_GROW_STEP	     10	// Sets the amount of memory to allocate when the array is grown.
+#define INITIAL_ARRAY_SIZE   0    // Sets the size of the array.
+#define ARRAY_GROW_STEP	     10   // Sets the amount of memory to allocate when the array is grown.
 
 // To record performance statistics, two snapshots of specific counters are needed.
 #define FIRST_SNAPSHOT	 0
@@ -474,65 +479,65 @@
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
  //param does not contain a valid internet address
  // (For Win32 || _WIN64, INADDR_NONE is defined as 0xffffffff)
-#ifndef INADDR_NONE
-#define INADDR_NONE   (in_addr_t)-1
-#endif
+ #ifndef INADDR_NONE
+  #define INADDR_NONE   (in_addr_t)-1
+ #endif
 
  // Needed to get the CDECL stuff thru (under non Windows platforms)
-#define CDECL
+ #define CDECL
 
-#define FALSE			0
-#define TRUE			1
-#define INVALID_HANDLE_VALUE   (HANDLE)-1
-#define INVALID_SOCKET		(~0L)
-#define PERF_NO_INSTANCES	-1
-#define SOCKET_ERROR		-1
-#define SD_BOTH		2
-#define INFINITE		(unsigned)~0
-#define ERROR_IO_PENDING	501
-#define WAIT_TIMEOUT		ERROR_IO_PENDING
-#define ERROR_IO_INCOMPLETE	ERROR_IO_PENDING
+ #define FALSE			0
+ #define TRUE			1
+ #define INVALID_HANDLE_VALUE   (HANDLE)-1
+ #define INVALID_SOCKET		(~0L)
+ #define PERF_NO_INSTANCES	-1
+ #define SOCKET_ERROR		-1
+ #define SD_BOTH		2
+ #define INFINITE		(unsigned)~0
+ #define ERROR_IO_PENDING	501
+ #define WAIT_TIMEOUT		ERROR_IO_PENDING
+ #define ERROR_IO_INCOMPLETE	ERROR_IO_PENDING
 
-#define FILE_ELEMENT		1
-#define CQ_ELEMENT		0
+ #define FILE_ELEMENT		1
+ #define CQ_ELEMENT		0
 
-#if defined(IOMTR_OSFAMILY_NETWARE)
-#define SIGEV_NONE		0
-#define AIO_NOTCANCELED	1
-#endif
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+  #define SIGEV_NONE		0
+  #define AIO_NOTCANCELED	1
+ #endif
 
-#if defined(IOMTR_OS_LINUX)
+ #if defined(IOMTR_OS_LINUX)
   // different Linux kernel has different /proc/stat style.
   // Currently we only support vanilla 2.4 and 2.6 alike
-#define PROCSTATUNKNOWN	0x00
-#define PROCSTAT24STYLE	0x01
-#define PROCSTAT26STYLE	0x02
+  #define PROCSTATUNKNOWN	0x00
+  #define PROCSTAT24STYLE	0x01
+  #define PROCSTAT26STYLE	0x02
+ #endif
 #endif
-#endif
 // ----------------------------------------------------------------------------
 
+
+
 // Define the enumerations, structures etc.
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 enum ReturnVal {
-	ReturnError = IOERROR,	// catch all unexpected errors
-	ReturnSuccess = 0,	// Normal completion
-	ReturnTimeout,		// Operation timed out
-	ReturnPending,		// Request has been queued
-	ReturnAbort,		// Operation aborted
-	ReturnRetry		// Operation was interrupted and can be retried
+	ReturnError   = IOERROR,   // catch all unexpected errors
+	ReturnSuccess = 0,	   // Normal completion
+	ReturnTimeout,		   // Operation timed out
+	ReturnPending,		   // Request has been queued
+	ReturnAbort,		   // Operation aborted
+	ReturnRetry	   	   // Operation was interrupted and can be retried
 };
-
 // Testing states that Iometer and worker threads go through
 enum TestState {
-	TestIdle,		// before Start_Test() and after Stop_Test()
+	TestIdle,	  // before Start_Test() and after Stop_Test()
 	TestPreparing,
-	TestOpening,		// after Start_Test()
-	TestRampingUp,		// after Begin_IO()
-	TestRecording,		// after Record_On()
-	TestRampingDown		// after Record_Off()
+	TestOpening,	  // after Start_Test()
+	TestRampingUp,	  // after Begin_IO()
+	TestRecording,	  // after Record_On()
+	TestRampingDown	  // after Record_Off()
 };
-
 // Specified on the Test Setup tab: which test results to record.
 // (In IOCommon.h because Dynamo uses these as parameters.)
 enum {
@@ -542,127 +547,126 @@
 	RecordNoManagers,
 	RecordNone
 };
-
 // ----------------------------------------------------------------------------
-struct Manager_Info {
-	char version[MAX_VERSION_LENGTH];
-	char names[2][MAX_NETWORK_NAME];
-	unsigned short port_number;	// used only with TCP/IP.
-#if defined(IOMTR_OSFAMILY_NETWARE)
+struct Manager_Info
+{
+	char	       version[MAX_VERSION_LENGTH];
+	char	       names[2][MAX_NETWORK_NAME];
+	unsigned short port_number;   // used only with TCP/IP.
+#if defined(IOMTR_OSFAMILY_NETWARE)	
 	char pad[2];
-#endif
-	int processors;
-	double processor_speed;
+#endif	
+	int	       	   processors;
+	double	       processor_speed;
 };
-
 // Basic result information stored by worker threads.
-struct Raw_Result {
-	DWORDLONG bytes_read;	// Number of bytes transferred.
-	DWORDLONG bytes_written;
-	DWORDLONG read_count;	// Number of I/Os completed.
-	DWORDLONG write_count;
-	DWORDLONG transaction_count;	// Number of transactions completed.
-	DWORDLONG connection_count;
-	unsigned int read_errors;	// Number of errors seen.
+struct Raw_Result
+{
+	DWORDLONG    bytes_read;   	       // Number of bytes transferred.
+	DWORDLONG    bytes_written;
+	DWORDLONG    read_count;	       // Number of I/Os completed.
+	DWORDLONG    write_count;
+	DWORDLONG    transaction_count;	       // Number of transactions completed.
+	DWORDLONG    connection_count;
+	unsigned int read_errors;	       // Number of errors seen.
 	unsigned int write_errors;
-	DWORDLONG max_raw_read_latency;	// Application latencies for an I/O to complete, recorded
-	DWORDLONG read_latency_sum;	// using the processor counter clock.
-	DWORDLONG max_raw_write_latency;
-	DWORDLONG write_latency_sum;
-	DWORDLONG max_raw_transaction_latency;
-	DWORDLONG max_raw_connection_latency;
-	DWORDLONG transaction_latency_sum;
-	DWORDLONG connection_latency_sum;	// Application latencies for a Connection.
-	__int64 counter_time;	// Difference between ending and starting counter time stamps.
+	DWORDLONG    max_raw_read_latency;     // Application latencies for an I/O to complete, recorded
+	DWORDLONG    read_latency_sum;	       // using the processor counter clock.
+	DWORDLONG    max_raw_write_latency;
+	DWORDLONG    write_latency_sum;
+	DWORDLONG    max_raw_transaction_latency;
+	DWORDLONG    max_raw_connection_latency;
+	DWORDLONG    transaction_latency_sum;
+	DWORDLONG    connection_latency_sum;   // Application latencies for a Connection.
+	__int64	     counter_time;	       // Difference between ending and starting counter time stamps.
 };
-
 // Storing results for all targets in a single structure.
-struct Target_Results {
-	int count;		// Number of targets.
-	char pad[4];		// padding
+struct Target_Results
+{
+	int	   count;    // Number of targets.
+	char	   pad[4];   // padding
 	Raw_Result result[MAX_TARGETS];
 };
-
 // Storing results for a worker.  This includes the worker's target results.
-struct Worker_Results {
-	DWORDLONG time[MAX_SNAPSHOTS];	// Processor based counters to provide time stamps.
+struct Worker_Results
+{
+	DWORDLONG      time[MAX_SNAPSHOTS];   // Processor based counters to provide time stamps.
 	Target_Results target_results;
 };
-
 // All CPU related results are stored in a single structure.
-struct CPU_Results {
-	int count;		// Number of processors.
-	char pad[4];		// padding
+struct CPU_Results
+{
+	int    count;	 // Number of processors.
+	char   pad[4];   // padding
 	double CPU_utilization[MAX_CPUS][CPU_RESULTS];
 };
-
 // All network related results are stored in a single structure.
-struct Net_Results {
+struct Net_Results
+{
 	double tcp_stats[TCP_RESULTS];
-	int ni_count;		// Number of NICs.
-	char pad[4];		// padding
+	int    ni_count;   // Number of NICs.
+	char   pad[4];     // padding
 	double ni_stats[MAX_NUM_INTERFACES][NI_RESULTS];
 };
-
 // Results SPECIFIC to a single system.  This is NOT compiled system results.
-struct Manager_Results {
-	__int64 time_counter[MAX_SNAPSHOTS];
+struct Manager_Results
+{
+	__int64	    time_counter[MAX_SNAPSHOTS];
 	CPU_Results cpu_results;
 	Net_Results net_results;
 };
-
 // Result structure used by the manager list, managers, and workers to store
 // results that will be saved.
-struct Results {
-	Raw_Result raw;
-	double IOps;
-	double read_IOps;
-	double write_IOps;
-	double MBps;
-	double read_MBps;
-	double write_MBps;
-	double ave_latency;
-	double max_latency;
-	double ave_read_latency;
-	double max_read_latency;
-	double ave_write_latency;
-	double max_write_latency;
-	double transactions_per_second;
-	double ave_transaction_latency;
-	double max_transaction_latency;
+struct Results
+{
+	Raw_Result   raw;
+	double	     IOps;
+	double	     read_IOps;
+	double	     write_IOps;
+	double	     MBps;
+	double	     read_MBps;
+	double	     write_MBps;
+	double	     ave_latency;
+	double	     max_latency;
+	double	     ave_read_latency;
+	double	     max_read_latency;
+	double	     ave_write_latency;
+	double	     max_write_latency;
+	double	     transactions_per_second;
+	double	     ave_transaction_latency;
+	double	     max_transaction_latency;
 	unsigned int total_errors;
-	double CPU_utilization[CPU_RESULTS];
-	double CPU_effectiveness;
-	double individual_CPU_utilization[MAX_CPUS][CPU_RESULTS];
-	double tcp_statistics[TCP_RESULTS];
-	double ni_statistics[NI_COMBINE_RESULTS];
-	double connections_per_second;
-	double ave_connection_latency;
-	double max_connection_latency;
+	double	     CPU_utilization[CPU_RESULTS];
+	double	     CPU_effectiveness;
+	double	     individual_CPU_utilization[MAX_CPUS][CPU_RESULTS];
+	double	     tcp_statistics[TCP_RESULTS];
+	double	     ni_statistics[NI_COMBINE_RESULTS];
+	double	     connections_per_second;
+	double	     ave_connection_latency;
+	double	     max_connection_latency;
 };
-
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
  // This LPOVERLAPPED typedef is from WINBASE.H
-#if defined(IOMTR_OSFAMILY_NETWARE)
-struct aiocb64 {
-	int aio_fildes;
-	void *aio_buf;
-	size_t aio_nbytes;
-	off_t aio_offset;
-	int aio_flag;
-	int error;
-	int returnval;
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+ struct  aiocb64 {
+ 	int		aio_fildes;
+ 	void		*aio_buf;
+ 	size_t		aio_nbytes;
+ 	off_t		aio_offset;
+ 	int		aio_flag;
+ 	int		error;
+ 	int		returnval;
 #if defined(IOMTR_SETTING_GCC_M64)
-	unsigned int completion_key;
+ 	unsigned int	completion_key;
 #else
-	unsigned long completion_key;
+ 	unsigned long	completion_key;
 #endif
-	struct {
-		int sigev_notify;
-	} aio_sigevent;
-};
-struct timeb {
+ 	struct {
+ 		int sigev_notify;
+ 		}	aio_sigevent;
+	};
+ struct timeb {
 #if defined(IOMTR_SETTING_GCC_M64)
 	int time;
 #else
@@ -671,299 +675,304 @@
 	unsigned short millitm;
 	short timezone;
 	short dstflag;
-};
-#endif
-typedef struct _OVERLAPPED {
-	DWORD Internal;
-	DWORD InternalHigh;
-	DWORD Offset;
-	DWORD OffsetHigh;
+	};
+ #endif
+ typedef struct _OVERLAPPED {   
+	DWORD  Internal;
+       	DWORD  InternalHigh;
+	DWORD  Offset;
+	DWORD  OffsetHigh;
 	HANDLE hEvent;
-} OVERLAPPED, *LPOVERLAPPED;
-typedef struct _LARGE_INTEGER {
+ } OVERLAPPED, *LPOVERLAPPED;
+ typedef struct _LARGE_INTEGER {
 	long LowPart;
 	long HighPart;
-} LARGE_INTEGER;
-struct CQ_Element {
-	struct aiocb64 aiocbp;
-	void *data;
-	int done;
-	int error;
-	int completion_key;
+ } LARGE_INTEGER;
+ struct CQ_Element {
+	struct  aiocb64 aiocbp;
+	void   *data;
+	int	done;
+	int	error;
+	int	completion_key;
 #if defined(IOMTR_SETTING_GCC_M64)
-	long bytes_transferred;
+	long	bytes_transferred;
 #else
-	int bytes_transferred;
+	int	bytes_transferred;
 #endif
-};
-struct IOCQ {
-	CQ_Element *element_list;
+ };
+ struct IOCQ {
+	CQ_Element      *element_list;
 	struct aiocb64 **aiocb_list;
-	int size;
-	int last_freed;
-	int position;
-};
-struct File {
-	int fd;
-	int completion_key;
+	int	         size;
+	int	         last_freed;
+	int	         position;
+ };
+ struct File {
+	int   fd;
+	int   completion_key;
 	IOCQ *iocq;
-#if defined(IOMTR_OSFAMILY_NETWARE)
+ #if defined(IOMTR_OSFAMILY_NETWARE)
 	int type;
-#endif
-};
-#endif
+ #endif
+ };
+#endif 
 // ----------------------------------------------------------------------------
 
+
+
 // Define the global variables
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
-const char NEW_WORKER_COMMAND[] = &quot;start /MIN &quot;;
+const char NEW_WORKER_COMMAND[]    = &quot;start /MIN &quot;;
 const char NEW_WORKER_EXECUTABLE[] = &quot;dynamo&quot;;
-
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
-extern pthread_mutex_t lock_mt;	// we use one global locking mutex
+ extern pthread_mutex_t lock_mt;   // we use one global locking mutex
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_CPU_SPARC) || defined(IOMTR_CPU_PPC)
-extern double processor_speed_to_nsecs;
+ extern double processor_speed_to_nsecs;
 #endif
 // ----------------------------------------------------------------------------
 
+
+
 // Define the different function prototypes and macros for
 // global functions - including the Strip() and IsBigEndian()
 // function (both, OS family based and common)
 // ----------------------------------------------------------------------------
-extern void GetAppFileVersionString(char **ppStrStandard, char **ppStrWithDebug);
+extern void GetAppFileVersionString( char **ppStrStandard, char **ppStrWithDebug );
 
 inline void rotate(char *ptr, int size);
-template &lt; class T &gt; inline void reorder(T &amp;);
-inline void reorder(CPU_Results &amp;, int);
-inline void reorder(Net_Results &amp;, int);
-inline void reorder(Raw_Result &amp;);
+template &lt;class T&gt; inline void reorder(T&amp;);
+inline void reorder(CPU_Results&amp;, int);
+inline void reorder(Net_Results&amp;, int);
+inline void reorder(Raw_Result&amp;);
 
-inline char *Strip(char *pcString)
+inline char *Strip( char *pcString )
 {
-	unsigned int uiLength = strlen(pcString);
-	int I;
-	int iIndex = 0;
-	int iPos1, iPos2;
-
-	for (iPos1 = 0; ((iPos1 &lt; (int)uiLength) &amp;&amp; (pcString[iPos1] == (int)' ')); iPos1++) {	/* NOP */
-	}
-	for (iPos2 = uiLength - 1; ((iPos2 &gt;= 0) &amp;&amp; (pcString[iPos2] == (int)' ')); iPos2--) {	/* NOP */
-	}
-
-	if ((iPos1 != 0) || (iPos2 != ((int)uiLength - 1))) {
-		for (I = iPos1; I &lt;= iPos2; I++) {
-			pcString[iIndex] = pcString[I];
-			iIndex++;
-		}
-		pcString[iIndex] = '\0';
-	}
-
-	return (pcString);
+ unsigned int uiLength = strlen(pcString);
+ int          I;
+ int          iIndex = 0;
+ int          iPos1, iPos2; 
+ 
+ for( iPos1 = 0;            ( (iPos1&lt;(int)uiLength) &amp;&amp; (pcString[iPos1]==(int)' ') ); iPos1++ ) { /* NOP */ }
+ for( iPos2 = uiLength - 1; ( (iPos2&gt;=0)            &amp;&amp; (pcString[iPos2]==(int)' ') ); iPos2-- ) { /* NOP */ }
+ 
+ if( (iPos1 != 0) || (iPos2 != ((int)uiLength - 1)) )
+ {    
+  for( I = iPos1; I &lt;= iPos2; I++ )
+  {
+   pcString[iIndex] = pcString[I];
+   iIndex++;
+  }
+  pcString[iIndex] = '\0';
+ }
+ 
+ return(pcString);
 }
 
-inline int IsBigEndian(void)
+inline int IsBigEndian( void )
 {
-	union EndianUnion {
-		struct EndianStruct {
-			unsigned ubBit1:1;
-			unsigned ubBit2:1;
-			unsigned ubBit3:1;
-			unsigned ubBit4:1;
-			unsigned ubBit5:1;
-			unsigned ubBit6:1;
-			unsigned ubBit7:1;
-			unsigned ubBit8:1;
-			unsigned ubBitN:8;
-		} sStruct;
-		unsigned char ucNumber;
-	} sUnion;
+ union EndianUnion
+ {
+  struct EndianStruct
+  {
+   unsigned ubBit1 :1;
+   unsigned ubBit2 :1;
+   unsigned ubBit3 :1;
+   unsigned ubBit4 :1;
+   unsigned ubBit5 :1;
+   unsigned ubBit6 :1;
+   unsigned ubBit7 :1;
+   unsigned ubBit8 :1;
+   unsigned ubBitN :8;
+  } sStruct;
+  unsigned char ucNumber;
+ } sUnion;
+ sUnion.sStruct.ubBit1 = 0;
+ sUnion.sStruct.ubBit2 = 0;
+ sUnion.sStruct.ubBit3 = 0;
+ sUnion.sStruct.ubBit4 = 0;
+ sUnion.sStruct.ubBit5 = 0;
+ sUnion.sStruct.ubBit6 = 0;
+ sUnion.sStruct.ubBit7 = 0;
+ sUnion.sStruct.ubBit8 = 0;
+ sUnion.sStruct.ubBitN = 0;
+ sUnion.ucNumber       = 5;
 
-	sUnion.sStruct.ubBit1 = 0;
-	sUnion.sStruct.ubBit2 = 0;
-	sUnion.sStruct.ubBit3 = 0;
-	sUnion.sStruct.ubBit4 = 0;
-	sUnion.sStruct.ubBit5 = 0;
-	sUnion.sStruct.ubBit6 = 0;
-	sUnion.sStruct.ubBit7 = 0;
-	sUnion.sStruct.ubBit8 = 0;
-	sUnion.sStruct.ubBitN = 0;
-	sUnion.ucNumber = 5;
-
-	if ((sUnion.sStruct.ubBit1 == 1) &amp;&amp; (sUnion.sStruct.ubBit3 == 1)) {
-		return (0);
-	} /* ##### Little Endian */
-	else {
-		if ((sUnion.sStruct.ubBit6 == 1) &amp;&amp; (sUnion.sStruct.ubBit8 == 1)) {
-			return (1);
-		} /* ##### Big Endian    */
-		else {
-			return (-42);
-		}		/* ##### Unknown       */
-	}
+ if( (sUnion.sStruct.ubBit1 == 1) &amp;&amp; (sUnion.sStruct.ubBit3 == 1) )
+ { return(0); }      /* ##### Little Endian */
+ else
+ {
+  if( (sUnion.sStruct.ubBit6 == 1) &amp;&amp; (sUnion.sStruct.ubBit8 == 1) )
+  { return(1); }     /* ##### Big Endian    */
+  else
+  { return(-42); }   /* ##### Unknown       */
+ }
 }
 
 #if defined(_DEBUG)
-void Dump_Raw_Result(struct Raw_Result *res);
-void Dump_Manager_Results(struct Manager_Results *res);
-void Dump_CPU_Results(struct CPU_Results *res);
-void Dump_Net_Results(struct Net_Results *res);
+ void	Dump_Raw_Result(struct Raw_Result *res);
+ void	Dump_Manager_Results(struct Manager_Results *res);
+ void	Dump_CPU_Results(struct CPU_Results *res);
+ void	Dump_Net_Results(struct Net_Results *res);
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-BOOL SetQueueSize(HANDLE, int);
-HANDLE CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);
-BOOL GetQueuedCompletionStatus(HANDLE, LPDWORD, LPDWORD, LPOVERLAPPED *, DWORD);
+ BOOL    SetQueueSize(HANDLE, int);
+ HANDLE  CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);
+ BOOL    GetQueuedCompletionStatus(HANDLE, LPDWORD, LPDWORD, LPOVERLAPPED *, DWORD);
 
-BOOL ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
-BOOL WriteFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
-HANDLE CreateEvent(void *, BOOL, BOOL, LPCSTR);
-BOOL GetOverlappedResult(HANDLE, LPOVERLAPPED, LPDWORD, BOOL);
+ BOOL    ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
+ BOOL    WriteFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
+ HANDLE  CreateEvent(void *, BOOL, BOOL, LPCSTR);
+ BOOL    GetOverlappedResult( HANDLE, LPOVERLAPPED, LPDWORD, BOOL );
 
-void SetLastError(DWORD);
-DWORD GetLastError(void);
-int WSAGetLastError(void);
-void WSASetLastError(DWORD);
+ void    SetLastError(DWORD);
+ DWORD   GetLastError(void);
+ int     WSAGetLastError(void);
+ void    WSASetLastError(DWORD);
 
-BOOL CloseHandle(HANDLE, int object_type = 0);
-char *_itoa(int, char *, int);
-DWORD WaitForSingleObject(HANDLE h, DWORD milliSecs);
+ BOOL    CloseHandle(HANDLE, int object_type = 0);
+ char   *_itoa(int, char *, int);
+ DWORD   WaitForSingleObject(HANDLE h, DWORD milliSecs);
 
-#ifndef NOMINMAX
-#ifndef max
-#define max(a,b)             (((a) &gt; (b)) ? (a) : (b))
-#endif
-#ifndef min
-#define min(a,b)             (((a) &lt; (b)) ? (a) : (b))
-#endif
-#endif
-#ifndef __max
-#define __max(a,b)            (((a) &lt; (b)) ? (b) : (a))
-#endif
+ #ifndef NOMINMAX
+  #ifndef max
+   #define max(a,b)             (((a) &gt; (b)) ? (a) : (b))
+  #endif
+  #ifndef min
+   #define min(a,b)             (((a) &lt; (b)) ? (a) : (b))
+  #endif
+ #endif 
+ #ifndef __max
+  #define __max(a,b)            (((a) &lt; (b)) ? (b) : (a))
+ #endif
 
-#if defined(IOMTR_OSFAMILY_NETWARE)
-#define _timeb		timeb
-#define _ftime		nwtime
-#define _time			time
-#define _millitm		millitm
-#define Sleep(x)		delay((x))
-#elif defined(IOMTR_OSFAMILY_UNIX)
-#if defined(IOMTR_OS_OSX)
-#define aiocb64 		aiocb
-#define aio_suspend64	aio_suspend
-#define aio_error64		aio_error
-#define aio_cancel64		aio_cancel
-#define aio_read64		aio_read
-#define aio_write64		aio_write
-#define aio_return64		aio_return
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+  #define _timeb		timeb
+  #define _ftime		nwtime
+  #define _time			time
+  #define _millitm		millitm
+  #define Sleep(x)		delay((x))
+ #elif defined(IOMTR_OSFAMILY_UNIX)
+  #if defined(IOMTR_OS_OSX)
+   #define aiocb64 		aiocb
+   #define aio_suspend64	aio_suspend
+   #define aio_error64		aio_error
+   #define aio_cancel64		aio_cancel
+   #define aio_read64		aio_read
+   #define aio_write64		aio_write
+   #define aio_return64		aio_return
 
-#define _timeb		timeval
-#define _ftime(x)		gettimeofday(x,NULL)
-#define _time		tv_sec
-#define _millitm		tv_usec
-#define Sleep(x) 		usleep((x) * 1000)
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-#define _timeb		timeb
-#define _ftime		ftime
-#define _time			time
-#define _millitm		millitm
-#define Sleep(x) 		usleep((x) * 1000)
-#else
-#error ===&gt; ERROR: You have to do some coding here to get the port done!
-#endif
-#else
-#warning ===&gt; WARNING: You have to do some coding here to get the port done!
-#endif
+   #define _timeb		timeval
+   #define _ftime(x)		gettimeofday(x,NULL)
+   #define _time		tv_sec
+   #define _millitm		tv_usec
+   #define Sleep(x) 		usleep((x) * 1000)
+  #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+   #define _timeb		timeb
+   #define _ftime		ftime
+   #define _time			time
+   #define _millitm		millitm
+   #define Sleep(x) 		usleep((x) * 1000)
+  #else
+   #error ===&gt; ERROR: You have to do some coding here to get the port done!
+  #endif
+ #else
+  #warning ===&gt; WARNING: You have to do some coding here to get the port done!
+ #endif
 
-#define LOCK					    \
+ #define LOCK					    \
 	 if (pthread_mutex_lock(&amp;lock_mt))          \
 	 {					    \
 		cout &lt;&lt; &quot;unable to lock&quot; &lt;&lt; endl;   \
 		exit(1);			    \
 	 }
-#define UNLOCK					      \
+ #define UNLOCK					      \
 	 if (pthread_mutex_unlock(&amp;lock_mt))	      \
 	 {					      \
 		cout &lt;&lt; &quot;unable to unlock&quot; &lt;&lt; endl;   \
 		exit(1);			      \
 	 }
 
-#define InterlockedExchange(a,b)   \
+ #define InterlockedExchange(a,b)   \
 	 LOCK;			    \
 	 *(a) = (b);		    \
 	 UNLOCK;
-#define InterlockedDecrement(a)   \
+ #define InterlockedDecrement(a)   \
 	 LOCK;			   \
 	 --*(a);		   \
 	 UNLOCK;
-#define InterlockedIncrement(a)   \
+ #define InterlockedIncrement(a)   \
 	 LOCK;			   \
 	 ++*(a);		   \
 	 UNLOCK;
-#endif
+#endif 
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_LINUX)
-extern DWORDLONG jiffies(void);
-extern DWORDLONG rdtsc(void);
+ extern DWORDLONG jiffies(void);
+ extern DWORDLONG rdtsc(void);
 
-#if defined(IOMTR_CPU_PPC)
-extern DWORD get_tbl();
-extern DWORD get_tbu();
-#endif
+ #if defined(IOMTR_CPU_PPC)
+  extern DWORD get_tbl();
+  extern DWORD get_tbu();
+ #endif
 
-#if defined(IOMTR_CPU_XSCALE)
-extern void double_wordswap(double *d);
-extern void Manager_Info_double_swap(struct Manager_Info *p);
-extern void Manager_Results_double_swap(struct Manager_Results *p);
-extern void CPU_Results_double_swap(struct CPU_Results *p);
-extern void Net_Results_double_swap(struct Net_Results *p);
-#endif
-
-#if defined(_IO)  &amp;&amp; !defined(BLKSSZGET)
-#define BLKSSZGET    _IO(0x12,104)
-#endif
-#if defined(_IOR) &amp;&amp; !defined(BLKBSZGET)
-#define BLKBSZGET    _IOR(0x12,112,size_t)
-#endif
-#if defined(_IO)  &amp;&amp; !defined(BLKGETSIZE)
-#define BLKGETSIZE   _IO(0x12,96)
-#endif
-#if defined(_IO)  &amp;&amp; !defined(BLKGETSIZE64)
-#define BLKGETSIZE64 _IOR(0x12,114, size_t)
-#endif
-#endif
+ #if defined(IOMTR_CPU_XSCALE)
+  extern void double_wordswap(double *d);
+  extern void Manager_Info_double_swap(struct Manager_Info *p);
+  extern void Manager_Results_double_swap(struct Manager_Results *p);
+  extern void CPU_Results_double_swap(struct CPU_Results *p);
+  extern void Net_Results_double_swap(struct Net_Results *p);
+ #endif
+ 
+ #if defined(_IO)  &amp;&amp; !defined(BLKSSZGET)
+  #define BLKSSZGET    _IO(0x12,104)
+ #endif
+ #if defined(_IOR) &amp;&amp; !defined(BLKBSZGET)
+  #define BLKBSZGET    _IOR(0x12,112,size_t)
+ #endif
+ #if defined(_IO)  &amp;&amp; !defined(BLKGETSIZE)
+  #define BLKGETSIZE   _IO(0x12,96)
+ #endif
+ #if defined(_IO)  &amp;&amp; !defined(BLKGETSIZE64)
+  #define BLKGETSIZE64 _IOR(0x12,114, size_t)
+ #endif
+#endif 
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_NETWARE)
-int aio_suspend64(struct aiocb64 **cb, int a, struct timespec *);
-int aio_error64(struct aiocb64 *cb);
-int aio_return64(struct aiocb64 *cb);
-int aio_read64(struct aiocb64 *cb, int type);
-int aio_write64(struct aiocb64 *cb, int type);
-int aio_cancel64(int a, struct aiocb64 *cb);
+ int aio_suspend64(struct aiocb64 **cb, int a, struct timespec *);
+ int aio_error64(struct aiocb64 *cb);
+ int aio_return64(struct aiocb64 *cb);
+ int aio_read64(struct aiocb64 *cb, int type);
+ int aio_write64(struct aiocb64 *cb, int type);
+ int aio_cancel64(int a, struct aiocb64 *cb);
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
+ #ifdef __cplusplus
+ extern &quot;C&quot;
+ {
+ #endif
+ extern LONG  GetTimerMinorTicksPerSecond(void);
+ extern unsigned long kGetProcessorInterruptCount(unsigned int, unsigned int *);
+ extern void  EnterDebugger();
+ extern LONG SSGetLANCommonCounters(unsigned long, unsigned long, unsigned char *, unsigned int);
+ #ifdef __cplusplus
+ }
+ #endif
+
+ extern DWORDLONG rdtsc(void); 
 #endif
-	extern LONG GetTimerMinorTicksPerSecond(void);
-	extern unsigned long kGetProcessorInterruptCount(unsigned int, unsigned int *);
-	extern void EnterDebugger();
-	extern LONG SSGetLANCommonCounters(unsigned long, unsigned long, unsigned char *, unsigned int);
-#ifdef __cplusplus
-}
-#endif
-extern DWORDLONG rdtsc(void);
-#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-extern &quot;C&quot; DWORDLONG rdtsc();
+ extern &quot;C&quot; DWORDLONG rdtsc();
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-extern DWORDLONG rdtsc();
+ extern DWORDLONG rdtsc();
 #endif
 // ----------------------------------------------------------------------------
 
-#endif				// ___IOCOMMON_H_DEFINED___
+
+#endif	// ___IOCOMMON_H_DEFINED___

Modified: branches/IOMETER-restruct/iometer/src/IOGrunt.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOGrunt.cpp	2006-02-08 02:20:20 UTC (rev 236)
+++ branches/IOMETER-restruct/iometer/src/IOGrunt.cpp	2006-02-08 19:08:18 UTC (rev 237)
@@ -162,19 +162,19 @@
 	// Release grunt's I/O data buffers if they are in use.
 	if (data_size)
 #if defined(IOMTR_OSFAMILY_NETWARE)
-		NXMemFree(read_data);
+	NXMemFree(read_data);
 	NXMemFree(write_data);
 #elif defined(IOMTR_OSFAMILY_UNIX)
-		free(read_data);
+	free(read_data);
 	free(write_data);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-		VirtualFree(read_data, 0, MEM_RELEASE);
+	VirtualFree(read_data, 0, MEM_RELEASE);
 	VirtualFree(write_data, 0, MEM_RELEASE);
 #else
 #warning ===&gt; WARNING: You have to do some coding here to get the port done!
 #endif
 
-		Free_Transaction_Arrays();
+	Free_Transaction_Arrays();
 }
 
 //


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000001.html">[Iometer-svn] r236 - branches/IOMETER-restruct/iometer/src
</A></li>
	<LI>Next message: <A HREF="000003.html">[Iometer-svn] r238 - trunk/iometer/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2">[ date ]</a>
              <a href="thread.html#2">[ thread ]</a>
              <a href="subject.html#2">[ subject ]</a>
              <a href="author.html#2">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/iometer-svn">More information about the Iometer-svn
mailing list</a><br>
</body></html>

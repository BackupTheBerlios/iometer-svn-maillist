From cheungming at berlios.de  Wed Feb  8 02:56:54 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Wed, 8 Feb 2006 02:56:54 +0100
Subject: [Iometer-svn] r235 - in branches/IOMETER-restruct/iometer/src: . scripts
Message-ID: <200602080156.k181us92001057@sheep.berlios.de>

Author: cheungming
Date: 2006-02-08 02:56:14 +0100 (Wed, 08 Feb 2006)
New Revision: 235

Modified:
   branches/IOMETER-restruct/iometer/src/AccessDialog.cpp
   branches/IOMETER-restruct/iometer/src/AccessDialog.h
   branches/IOMETER-restruct/iometer/src/AccessSpecList.cpp
   branches/IOMETER-restruct/iometer/src/AccessSpecList.h
   branches/IOMETER-restruct/iometer/src/BigMeter.cpp
   branches/IOMETER-restruct/iometer/src/BigMeter.h
   branches/IOMETER-restruct/iometer/src/ByteOrder.cpp
   branches/IOMETER-restruct/iometer/src/GalileoApp.cpp
   branches/IOMETER-restruct/iometer/src/GalileoApp.h
   branches/IOMETER-restruct/iometer/src/GalileoCmdLine.cpp
   branches/IOMETER-restruct/iometer/src/GalileoCmdLine.h
   branches/IOMETER-restruct/iometer/src/GalileoDefs.h
   branches/IOMETER-restruct/iometer/src/GalileoDoc.cpp
   branches/IOMETER-restruct/iometer/src/GalileoDoc.h
   branches/IOMETER-restruct/iometer/src/GalileoGlobals.cpp
   branches/IOMETER-restruct/iometer/src/GalileoView.cpp
   branches/IOMETER-restruct/iometer/src/GalileoView.h
   branches/IOMETER-restruct/iometer/src/ICFOpenDialog.cpp
   branches/IOMETER-restruct/iometer/src/ICFOpenDialog.h
   branches/IOMETER-restruct/iometer/src/ICFSaveDialog.cpp
   branches/IOMETER-restruct/iometer/src/ICFSaveDialog.h
   branches/IOMETER-restruct/iometer/src/ICF_ifstream.cpp
   branches/IOMETER-restruct/iometer/src/ICF_ifstream.h
   branches/IOMETER-restruct/iometer/src/IOAccess.cpp
   branches/IOMETER-restruct/iometer/src/IOAccess.h
   branches/IOMETER-restruct/iometer/src/IOCQ.h
   branches/IOMETER-restruct/iometer/src/IOCQAIO.cpp
   branches/IOMETER-restruct/iometer/src/IOCQAIO.h
   branches/IOMETER-restruct/iometer/src/IOCQVI.cpp
   branches/IOMETER-restruct/iometer/src/IOCQVI.h
   branches/IOMETER-restruct/iometer/src/IOCommon.h
   branches/IOMETER-restruct/iometer/src/IOCompletionQ.cpp
   branches/IOMETER-restruct/iometer/src/IOGlobals.cpp
   branches/IOMETER-restruct/iometer/src/IOGrunt.cpp
   branches/IOMETER-restruct/iometer/src/IOGrunt.h
   branches/IOMETER-restruct/iometer/src/IOManager.cpp
   branches/IOMETER-restruct/iometer/src/IOManager.h
   branches/IOMETER-restruct/iometer/src/IOManagerLinux.cpp
   branches/IOMETER-restruct/iometer/src/IOManagerNetware.cpp
   branches/IOMETER-restruct/iometer/src/IOManagerOSX.cpp
   branches/IOMETER-restruct/iometer/src/IOManagerSolaris.cpp
   branches/IOMETER-restruct/iometer/src/IOManagerWin.cpp
   branches/IOMETER-restruct/iometer/src/IOMessage.h
   branches/IOMETER-restruct/iometer/src/IOPerformance.cpp
   branches/IOMETER-restruct/iometer/src/IOPerformance.h
   branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp
   branches/IOMETER-restruct/iometer/src/IOPerformanceNetware.cpp
   branches/IOMETER-restruct/iometer/src/IOPerformanceOSX.cpp
   branches/IOMETER-restruct/iometer/src/IOPort.cpp
   branches/IOMETER-restruct/iometer/src/IOPort.h
   branches/IOMETER-restruct/iometer/src/IOPortTCP.cpp
   branches/IOMETER-restruct/iometer/src/IOPortTCP.h
   branches/IOMETER-restruct/iometer/src/IOTarget.cpp
   branches/IOMETER-restruct/iometer/src/IOTarget.h
   branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp
   branches/IOMETER-restruct/iometer/src/IOTargetDisk.h
   branches/IOMETER-restruct/iometer/src/IOTargetTCP.cpp
   branches/IOMETER-restruct/iometer/src/IOTargetTCP.h
   branches/IOMETER-restruct/iometer/src/IOTargetVI.cpp
   branches/IOMETER-restruct/iometer/src/IOTargetVI.h
   branches/IOMETER-restruct/iometer/src/IOTest.h
   branches/IOMETER-restruct/iometer/src/IOTime.cpp
   branches/IOMETER-restruct/iometer/src/IOTransfers.h
   branches/IOMETER-restruct/iometer/src/IOVIPL.cpp
   branches/IOMETER-restruct/iometer/src/IOVIPL.h
   branches/IOMETER-restruct/iometer/src/IOVersion.h
   branches/IOMETER-restruct/iometer/src/LegalBox.cpp
   branches/IOMETER-restruct/iometer/src/LegalBox.h
   branches/IOMETER-restruct/iometer/src/MainFrm.cpp
   branches/IOMETER-restruct/iometer/src/MainFrm.h
   branches/IOMETER-restruct/iometer/src/Manager.cpp
   branches/IOMETER-restruct/iometer/src/Manager.h
   branches/IOMETER-restruct/iometer/src/ManagerList.cpp
   branches/IOMETER-restruct/iometer/src/ManagerList.h
   branches/IOMETER-restruct/iometer/src/ManagerMap.cpp
   branches/IOMETER-restruct/iometer/src/ManagerMap.h
   branches/IOMETER-restruct/iometer/src/MeterCtrl.cpp
   branches/IOMETER-restruct/iometer/src/MeterCtrl.h
   branches/IOMETER-restruct/iometer/src/NetTCP.h
   branches/IOMETER-restruct/iometer/src/NetVI.cpp
   branches/IOMETER-restruct/iometer/src/NetVI.h
   branches/IOMETER-restruct/iometer/src/Network.cpp
   branches/IOMETER-restruct/iometer/src/Network.h
   branches/IOMETER-restruct/iometer/src/PageAccess.cpp
   branches/IOMETER-restruct/iometer/src/PageAccess.h
   branches/IOMETER-restruct/iometer/src/PageDisk.cpp
   branches/IOMETER-restruct/iometer/src/PageDisk.h
   branches/IOMETER-restruct/iometer/src/PageDisplay.cpp
   branches/IOMETER-restruct/iometer/src/PageDisplay.h
   branches/IOMETER-restruct/iometer/src/PageNetwork.cpp
   branches/IOMETER-restruct/iometer/src/PageNetwork.h
   branches/IOMETER-restruct/iometer/src/PageSetup.cpp
   branches/IOMETER-restruct/iometer/src/PageSetup.h
   branches/IOMETER-restruct/iometer/src/PageTarget.h
   branches/IOMETER-restruct/iometer/src/Pulsar.cpp
   branches/IOMETER-restruct/iometer/src/StdAfx.cpp
   branches/IOMETER-restruct/iometer/src/StdAfx.h
   branches/IOMETER-restruct/iometer/src/TextDisplay.cpp
   branches/IOMETER-restruct/iometer/src/TextDisplay.h
   branches/IOMETER-restruct/iometer/src/VINic.cpp
   branches/IOMETER-restruct/iometer/src/VINic.h
   branches/IOMETER-restruct/iometer/src/WaitingForManagers.cpp
   branches/IOMETER-restruct/iometer/src/WaitingForManagers.h
   branches/IOMETER-restruct/iometer/src/Worker.cpp
   branches/IOMETER-restruct/iometer/src/Worker.h
   branches/IOMETER-restruct/iometer/src/WorkerView.cpp
   branches/IOMETER-restruct/iometer/src/WorkerView.h
   branches/IOMETER-restruct/iometer/src/ostream64.h
   branches/IOMETER-restruct/iometer/src/scripts/iom-indent
   branches/IOMETER-restruct/iometer/src/vipl.h
Log:
used iom-indent to format all cpp&h files.



Modified: branches/IOMETER-restruct/iometer/src/AccessDialog.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/AccessDialog.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/AccessDialog.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -62,11 +62,9 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "StdAfx.h"
 #include "AccessDialog.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -77,20 +75,18 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CAccessDialog dialog
 
-
-CAccessDialog::CAccessDialog( Test_Spec *edit_spec, CWnd* pParent )
-	: CDialog(CAccessDialog::IDD, pParent)
+CAccessDialog::CAccessDialog(Test_Spec * edit_spec, CWnd * pParent)
+:  CDialog(CAccessDialog::IDD, pParent)
 {
 	spec = edit_spec;
 	//{{AFX_DATA_INIT(CAccessDialog)
@@ -103,7 +99,7 @@
 	//}}AFX_DATA_INIT
 }
 
-void CAccessDialog::DoDataExchange(CDataExchange* pDX)
+void CAccessDialog::DoDataExchange(CDataExchange * pDX)
 {
 	CDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CAccessDialog)
@@ -149,146 +145,142 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CAccessDialog, CDialog)
-	//{{AFX_MSG_MAP(CAccessDialog)
-	ON_BN_CLICKED(BDelete, OnBDelete)
-	ON_BN_CLICKED(BInsertAfter, OnBInsertAfter)
-	ON_BN_CLICKED(BInsertBefore, OnBInsertBefore)
-	ON_WM_HSCROLL()
-	ON_EN_KILLFOCUS(EBytes, OnKillfocusESizes)
-	ON_EN_KILLFOCUS(EAlignBytes, OnKillfocusEAligns)
-	ON_NOTIFY(UDN_DELTAPOS, SBytes, OnDeltaposSSizes)
-	ON_NOTIFY(UDN_DELTAPOS, SAlignBytes, OnDeltaposSAligns)
-	ON_BN_CLICKED(RAlignSector, OnRAlignSector)
-	ON_BN_CLICKED(RAlignBytes, OnRAlignBytes)
-	ON_EN_KILLFOCUS(EBurstLength, OnChangeBurst)
-	ON_EN_KILLFOCUS(EDelayTime, OnChangeDelay)
-	ON_NOTIFY(UDN_DELTAPOS, SReplyBytes, OnDeltaposSReply)
-	ON_EN_KILLFOCUS(EReplyBytes, OnKillfocusEReply)
-	ON_BN_CLICKED(RNoReply, OnRNoReply)
-	ON_BN_CLICKED(RReplySize, OnRReplySize)
-	ON_NOTIFY(NM_CLICK, LAccess, OnChangeLAccess)
-	ON_EN_KILLFOCUS(EKilobytes, OnKillfocusESizes)
-	ON_EN_KILLFOCUS(EMegabytes, OnKillfocusESizes)
-	ON_NOTIFY(UDN_DELTAPOS, SKilobytes, OnDeltaposSSizes)
-	ON_NOTIFY(UDN_DELTAPOS, SMegabytes, OnDeltaposSSizes)
-	ON_EN_KILLFOCUS(EAlignKilobytes, OnKillfocusEAligns)
-	ON_EN_KILLFOCUS(EAlignMegabytes, OnKillfocusEAligns)
-	ON_NOTIFY(UDN_DELTAPOS, SAlignKilobytes, OnDeltaposSAligns)
-	ON_NOTIFY(UDN_DELTAPOS, SAlignMegabytes, OnDeltaposSAligns)
-	ON_NOTIFY(UDN_DELTAPOS, SReplyKilobytes, OnDeltaposSReply)
-	ON_NOTIFY(UDN_DELTAPOS, SReplyMegabytes, OnDeltaposSReply)
-	ON_EN_KILLFOCUS(EReplyKilobytes, OnKillfocusEReply)
-	ON_EN_KILLFOCUS(EReplyMegabytes, OnKillfocusEReply)
-	ON_NOTIFY(NM_DBLCLK, LAccess, OnChangeLAccess)
-	ON_NOTIFY(LVN_ITEMCHANGED, LAccess, OnChangeLAccess)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CAccessDialog)
+    ON_BN_CLICKED(BDelete, OnBDelete)
+    ON_BN_CLICKED(BInsertAfter, OnBInsertAfter)
+    ON_BN_CLICKED(BInsertBefore, OnBInsertBefore)
+    ON_WM_HSCROLL()
+    ON_EN_KILLFOCUS(EBytes, OnKillfocusESizes)
+    ON_EN_KILLFOCUS(EAlignBytes, OnKillfocusEAligns)
+    ON_NOTIFY(UDN_DELTAPOS, SBytes, OnDeltaposSSizes)
+    ON_NOTIFY(UDN_DELTAPOS, SAlignBytes, OnDeltaposSAligns)
+    ON_BN_CLICKED(RAlignSector, OnRAlignSector)
+    ON_BN_CLICKED(RAlignBytes, OnRAlignBytes)
+    ON_EN_KILLFOCUS(EBurstLength, OnChangeBurst)
+    ON_EN_KILLFOCUS(EDelayTime, OnChangeDelay)
+    ON_NOTIFY(UDN_DELTAPOS, SReplyBytes, OnDeltaposSReply)
+    ON_EN_KILLFOCUS(EReplyBytes, OnKillfocusEReply)
+    ON_BN_CLICKED(RNoReply, OnRNoReply)
+    ON_BN_CLICKED(RReplySize, OnRReplySize)
+    ON_NOTIFY(NM_CLICK, LAccess, OnChangeLAccess)
+    ON_EN_KILLFOCUS(EKilobytes, OnKillfocusESizes)
+    ON_EN_KILLFOCUS(EMegabytes, OnKillfocusESizes)
+    ON_NOTIFY(UDN_DELTAPOS, SKilobytes, OnDeltaposSSizes)
+    ON_NOTIFY(UDN_DELTAPOS, SMegabytes, OnDeltaposSSizes)
+    ON_EN_KILLFOCUS(EAlignKilobytes, OnKillfocusEAligns)
+    ON_EN_KILLFOCUS(EAlignMegabytes, OnKillfocusEAligns)
+    ON_NOTIFY(UDN_DELTAPOS, SAlignKilobytes, OnDeltaposSAligns)
+    ON_NOTIFY(UDN_DELTAPOS, SAlignMegabytes, OnDeltaposSAligns)
+    ON_NOTIFY(UDN_DELTAPOS, SReplyKilobytes, OnDeltaposSReply)
+    ON_NOTIFY(UDN_DELTAPOS, SReplyMegabytes, OnDeltaposSReply)
+    ON_EN_KILLFOCUS(EReplyKilobytes, OnKillfocusEReply)
+    ON_EN_KILLFOCUS(EReplyMegabytes, OnKillfocusEReply)
+    ON_NOTIFY(NM_DBLCLK, LAccess, OnChangeLAccess)
+ON_NOTIFY(LVN_ITEMCHANGED, LAccess, OnChangeLAccess)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
-
 /////////////////////////////////////////////////////////////////////////////
 // CAccessDialog message handlers
-
-BOOL CAccessDialog::OnInitDialog() 
+BOOL CAccessDialog::OnInitDialog()
 {
 	CDialog::OnInitDialog();
-	
-	m_SMegabytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SKilobytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SBytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SAlignMegabytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SAlignKilobytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SAlignBytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SAlignBytes.SetPos( 512 );
-	m_SReplyMegabytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SReplyKilobytes.SetRange( 0, MAX_SIZE_RANGE );
-	m_SReplyBytes.SetRange( 0, MAX_SIZE_RANGE );
 
-	m_SAccess.SetRange(1,100);
-	m_SAccess.SetPageSize( 10 );
-	m_SRead.SetRange(0,100);
-	m_SRead.SetPageSize( 10 );
-	m_SRandom.SetRange(0,100);
-	m_SRandom.SetPageSize( 10 );
+	m_SMegabytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SKilobytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SBytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SAlignMegabytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SAlignKilobytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SAlignBytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SAlignBytes.SetPos(512);
+	m_SReplyMegabytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SReplyKilobytes.SetRange(0, MAX_SIZE_RANGE);
+	m_SReplyBytes.SetRange(0, MAX_SIZE_RANGE);
 
-	size_controls.EBytesCtrl		= &m_EBytes;
-	size_controls.EKilobytesCtrl	= &m_EKilobytes;
-	size_controls.EMegabytesCtrl	= &m_EMegabytes;
-	size_controls.EBytesID			= EBytes;
-	size_controls.EKilobytesID		= EKilobytes;
-	size_controls.EMegabytesID		= EMegabytes;
-	size_controls.SBytesCtrl		= &m_SBytes;
-	size_controls.SKilobytesCtrl	= &m_SKilobytes;
-	size_controls.SMegabytesCtrl	= &m_SMegabytes;
-	size_controls.SBytesID			= SBytes;
-	size_controls.SKilobytesID		= SKilobytes;
-	size_controls.SMegabytesID		= SMegabytes;
-	size_controls.RSelectedID		= 0;
-	size_controls.RNotSelectedID	= 0;
-	
+	m_SAccess.SetRange(1, 100);
+	m_SAccess.SetPageSize(10);
+	m_SRead.SetRange(0, 100);
+	m_SRead.SetPageSize(10);
+	m_SRandom.SetRange(0, 100);
+	m_SRandom.SetPageSize(10);
+
+	size_controls.EBytesCtrl = &m_EBytes;
+	size_controls.EKilobytesCtrl = &m_EKilobytes;
+	size_controls.EMegabytesCtrl = &m_EMegabytes;
+	size_controls.EBytesID = EBytes;
+	size_controls.EKilobytesID = EKilobytes;
+	size_controls.EMegabytesID = EMegabytes;
+	size_controls.SBytesCtrl = &m_SBytes;
+	size_controls.SKilobytesCtrl = &m_SKilobytes;
+	size_controls.SMegabytesCtrl = &m_SMegabytes;
+	size_controls.SBytesID = SBytes;
+	size_controls.SKilobytesID = SKilobytes;
+	size_controls.SMegabytesID = SMegabytes;
+	size_controls.RSelectedID = 0;
+	size_controls.RNotSelectedID = 0;
+
 	// 2462 SDK compiler didn't like the "this->" for Win64 so we'll just remove it
 	//  since it really isn't needed anyway...
-	//size_controls.GetFunc			= this->GetSize;
-	//size_controls.SetFunc			= this->SetSize;
-	size_controls.GetFunc			= GetSize;
-	size_controls.SetFunc			= SetSize;
+	//size_controls.GetFunc                 = this->GetSize;
+	//size_controls.SetFunc                 = this->SetSize;
+	size_controls.GetFunc = GetSize;
+	size_controls.SetFunc = SetSize;
 
-	align_controls.EBytesCtrl		= &m_EAlignBytes;
-	align_controls.EKilobytesCtrl	= &m_EAlignKilobytes;
-	align_controls.EMegabytesCtrl	= &m_EAlignMegabytes;
-	align_controls.EBytesID			= EAlignBytes;
-	align_controls.EKilobytesID		= EAlignKilobytes;
-	align_controls.EMegabytesID		= EAlignMegabytes;
-	align_controls.SBytesCtrl		= &m_SAlignBytes;
-	align_controls.SKilobytesCtrl	= &m_SAlignKilobytes;
-	align_controls.SMegabytesCtrl	= &m_SAlignMegabytes;
-	align_controls.SBytesID			= SAlignBytes;
-	align_controls.SKilobytesID		= SAlignKilobytes;
-	align_controls.SMegabytesID		= SAlignMegabytes;
-	align_controls.RSelectedID		= RAlignBytes;
-	align_controls.RNotSelectedID	= RAlignSector;
+	align_controls.EBytesCtrl = &m_EAlignBytes;
+	align_controls.EKilobytesCtrl = &m_EAlignKilobytes;
+	align_controls.EMegabytesCtrl = &m_EAlignMegabytes;
+	align_controls.EBytesID = EAlignBytes;
+	align_controls.EKilobytesID = EAlignKilobytes;
+	align_controls.EMegabytesID = EAlignMegabytes;
+	align_controls.SBytesCtrl = &m_SAlignBytes;
+	align_controls.SKilobytesCtrl = &m_SAlignKilobytes;
+	align_controls.SMegabytesCtrl = &m_SAlignMegabytes;
+	align_controls.SBytesID = SAlignBytes;
+	align_controls.SKilobytesID = SAlignKilobytes;
+	align_controls.SMegabytesID = SAlignMegabytes;
+	align_controls.RSelectedID = RAlignBytes;
+	align_controls.RNotSelectedID = RAlignSector;
 
 	// 2462 SDK compiler didn't like the "this->" for Win64 so we'll just remove it
 	//  since it really isn't needed anyway...
-	//align_controls.GetFunc			= this->GetAlign;
-	//align_controls.SetFunc			= this->SetAlign;
-	align_controls.GetFunc			= GetAlign;
-	align_controls.SetFunc			= SetAlign;
+	//align_controls.GetFunc                        = this->GetAlign;
+	//align_controls.SetFunc                        = this->SetAlign;
+	align_controls.GetFunc = GetAlign;
+	align_controls.SetFunc = SetAlign;
 
 // RSelectedID MUST be greater than RNotSelectedID, for the sake of GetCheckedRadioButton().
 #if !(RAlignBytes > RAlignSector)
 #error RAlignBytes is not greater than RAlignSector in resource.h!
 #endif
 
-	reply_controls.EBytesCtrl		= &m_EReplyBytes;
-	reply_controls.EKilobytesCtrl	= &m_EReplyKilobytes;
-	reply_controls.EMegabytesCtrl	= &m_EReplyMegabytes;
-	reply_controls.EBytesID			= EReplyBytes;
-	reply_controls.EKilobytesID		= EReplyKilobytes;
-	reply_controls.EMegabytesID		= EReplyMegabytes;
-	reply_controls.SBytesCtrl		= &m_SReplyBytes;
-	reply_controls.SKilobytesCtrl	= &m_SReplyKilobytes;
-	reply_controls.SMegabytesCtrl	= &m_SReplyMegabytes;
-	reply_controls.SBytesID			= SReplyBytes;
-	reply_controls.SKilobytesID		= SReplyKilobytes;
-	reply_controls.SMegabytesID		= SReplyMegabytes;
-	reply_controls.RSelectedID		= RReplySize;
-	reply_controls.RNotSelectedID	= RNoReply;
+	reply_controls.EBytesCtrl = &m_EReplyBytes;
+	reply_controls.EKilobytesCtrl = &m_EReplyKilobytes;
+	reply_controls.EMegabytesCtrl = &m_EReplyMegabytes;
+	reply_controls.EBytesID = EReplyBytes;
+	reply_controls.EKilobytesID = EReplyKilobytes;
+	reply_controls.EMegabytesID = EReplyMegabytes;
+	reply_controls.SBytesCtrl = &m_SReplyBytes;
+	reply_controls.SKilobytesCtrl = &m_SReplyKilobytes;
+	reply_controls.SMegabytesCtrl = &m_SReplyMegabytes;
+	reply_controls.SBytesID = SReplyBytes;
+	reply_controls.SKilobytesID = SReplyKilobytes;
+	reply_controls.SMegabytesID = SReplyMegabytes;
+	reply_controls.RSelectedID = RReplySize;
+	reply_controls.RNotSelectedID = RNoReply;
 
 	// 2462 SDK compiler didn't like the "this->" for Win64 so we'll just remove it
 	//  since it really isn't needed anyway...
-	//reply_controls.GetFunc			= this->GetReply;
-	//reply_controls.SetFunc			= this->SetReply;
-	reply_controls.GetFunc			= GetReply;
-	reply_controls.SetFunc			= SetReply;
+	//reply_controls.GetFunc                        = this->GetReply;
+	//reply_controls.SetFunc                        = this->SetReply;
+	reply_controls.GetFunc = GetReply;
+	reply_controls.SetFunc = SetReply;
 
 // RSelectedID MUST be greater than RNotSelectedID, for the sake of GetCheckedRadioButton().
 #if !(RReplySize > RNoReply)
 #error RReplySize is not greater than RNoReply in resource.h!
 #endif
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 
 	// Initialize the listbox object.
 	InitializeList();
@@ -297,109 +289,91 @@
 	LoadList();
 
 	// If there are any entries in the list, highlight the first one.
-	if ( m_LAccess.GetItemCount() )
-	{
+	if (m_LAccess.GetItemCount()) {
 		item_being_changed = 0;
-		m_LAccess.SetItemState( m_LAccess.GetItemCount() - 1, !LVIS_SELECTED, LVIS_SELECTED );
-		m_LAccess.SetItemState( 0, LVIS_SELECTED, LVIS_SELECTED );
-		SetAll( (Access_Spec *) m_LAccess.GetItemData( 0 ) );
+		m_LAccess.SetItemState(m_LAccess.GetItemCount() - 1, !LVIS_SELECTED, LVIS_SELECTED);
+		m_LAccess.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
+		SetAll((Access_Spec *) m_LAccess.GetItemData(0));
 	}
 
-	UpdateData( TRUE );
+	UpdateData(TRUE);
 
-	return TRUE;  // return TRUE unless you set the focus to a control
-	              // EXCEPTION: OCX Property Pages should return FALSE
+	return TRUE;		// return TRUE unless you set the focus to a control
+	// EXCEPTION: OCX Property Pages should return FALSE
 }
 
-
-
 //
 // Converting a given size (I/O size or byte alignment size) in bytes to a string.
 //
-void CAccessDialog::SizeToText( DWORD size, CString *size_text )
+void CAccessDialog::SizeToText(DWORD size, CString * size_text)
 {
 	// Breaking the size down into MBs, KBs, and bytes.
- 	size_text->Format(	"%4dMB %4dKB %4dB",
-						size / MEGABYTE,
-						(size % MEGABYTE) / KILOBYTE,
-						size % KILOBYTE );
+	size_text->Format("%4dMB %4dKB %4dB", size / MEGABYTE, (size % MEGABYTE) / KILOBYTE, size % KILOBYTE);
 }
 
-
-
 //
 // Get the value of a specified Megabytes/Kilobytes/Bytes control for the currently selected 
 // access spec, as shown by the edit boxes (MB, KB, bytes).
 //
-DWORD CAccessDialog::GetMKBEditbox( MKBControls *which )
+DWORD CAccessDialog::GetMKBEditbox(MKBControls * which)
 {
 	// If any edit boxes are blank, set their sliders to the appropriate current value 
 	// (which, in turn, sets the edit box).
-	if ( !which->EBytesCtrl->LineLength() )
-		which->SBytesCtrl->SetPos( (this->*(which->GetFunc))() % KILOBYTE );
+	if (!which->EBytesCtrl->LineLength())
+		which->SBytesCtrl->SetPos((this->*(which->GetFunc)) () % KILOBYTE);
 
-	if ( !which->EKilobytesCtrl->LineLength() )
-		which->SKilobytesCtrl->SetPos( ( (this->*(which->GetFunc))() % MEGABYTE) / KILOBYTE );
+	if (!which->EKilobytesCtrl->LineLength())
+		which->SKilobytesCtrl->SetPos(((this->*(which->GetFunc)) () % MEGABYTE) / KILOBYTE);
 
-	if ( !which->EMegabytesCtrl->LineLength() )
-		which->SMegabytesCtrl->SetPos( (this->*(which->GetFunc))() / MEGABYTE );
+	if (!which->EMegabytesCtrl->LineLength())
+		which->SMegabytesCtrl->SetPos((this->*(which->GetFunc)) () / MEGABYTE);
 
 	// Verify that the megabyte value has not overflowed.
-	if ( GetDlgItemInt( which->EMegabytesID ) > MAX_SIZE_RANGE )
-	{
-		which->SMegabytesCtrl->SetPos( MAX_SIZE_RANGE );
-		ErrorMessage( "The maximum value supported by Iometer for this control "
-			"is 1023 MB + 1023 KB + 1023 bytes." );
+	if (GetDlgItemInt(which->EMegabytesID) > MAX_SIZE_RANGE) {
+		which->SMegabytesCtrl->SetPos(MAX_SIZE_RANGE);
+		ErrorMessage("The maximum value supported by Iometer for this control "
+			     "is 1023 MB + 1023 KB + 1023 bytes.");
 	}
 
-	return	GetDlgItemInt( which->EBytesID )
-			+ GetDlgItemInt( which->EKilobytesID ) * KILOBYTE
-			+ GetDlgItemInt( which->EMegabytesID ) * MEGABYTE;
+	return GetDlgItemInt(which->EBytesID)
+	    + GetDlgItemInt(which->EKilobytesID) * KILOBYTE + GetDlgItemInt(which->EMegabytesID) * MEGABYTE;
 }
 
-
-
 //
 // Get the value of a specified Megabytes/Kilobytes/Bytes control for the currently selected 
 // access spec, as shown by the spinner controls.
 //
-DWORD CAccessDialog::GetMKBSpinners( MKBControls *which )
+DWORD CAccessDialog::GetMKBSpinners(MKBControls * which)
 {
-	return( which->SBytesCtrl->GetPos() +
-		which->SKilobytesCtrl->GetPos() * KILOBYTE +
-		which->SMegabytesCtrl->GetPos() * MEGABYTE );
+	return (which->SBytesCtrl->GetPos() +
+		which->SKilobytesCtrl->GetPos() * KILOBYTE + which->SMegabytesCtrl->GetPos() * MEGABYTE);
 }
 
-
-
 //
 // Enable or disable a specified Megabytes/Kilobytes/Bytes control.
 //
-void CAccessDialog::EnableMKBControls( MKBControls *which, BOOL enabled )
+void CAccessDialog::EnableMKBControls(MKBControls * which, BOOL enabled)
 {
-	if ( which->RSelectedID && which->RNotSelectedID )
-	{
-		CheckRadioButton( which->RNotSelectedID, which->RSelectedID, 
-			( enabled ? which->RSelectedID : which->RNotSelectedID ) );
+	if (which->RSelectedID && which->RNotSelectedID) {
+		CheckRadioButton(which->RNotSelectedID, which->RSelectedID,
+				 (enabled ? which->RSelectedID : which->RNotSelectedID));
 	}
 
-	which->EMegabytesCtrl->EnableWindow( enabled );
-	which->EKilobytesCtrl->EnableWindow( enabled );
-	which->EBytesCtrl->EnableWindow( enabled );
-	which->SMegabytesCtrl->EnableWindow( enabled );
-	which->SKilobytesCtrl->EnableWindow( enabled );
-	which->SBytesCtrl->EnableWindow( enabled );
+	which->EMegabytesCtrl->EnableWindow(enabled);
+	which->EKilobytesCtrl->EnableWindow(enabled);
+	which->EBytesCtrl->EnableWindow(enabled);
+	which->SMegabytesCtrl->EnableWindow(enabled);
+	which->SKilobytesCtrl->EnableWindow(enabled);
+	which->SBytesCtrl->EnableWindow(enabled);
 }
 
-
-
 //
 // Update the size of the current access specification line when any of
 // the size edit boxes have lost the focus.
 //
-void CAccessDialog::OnKillfocusESizes() 
+void CAccessDialog::OnKillfocusESizes()
 {
-	SetSize( GetMKBEditbox( &size_controls ) );
+	SetSize(GetMKBEditbox(&size_controls));
 }
 
 //
@@ -408,29 +382,27 @@
 //
 void CAccessDialog::OnKillfocusEAligns()
 {
-	if ( GetCheckedRadioButton( RAlignSector, RAlignBytes ) == RAlignBytes )
-		SetAlign( GetMKBEditbox( &align_controls ) );
+	if (GetCheckedRadioButton(RAlignSector, RAlignBytes) == RAlignBytes)
+		SetAlign(GetMKBEditbox(&align_controls));
 }
 
 //
 // Update the reply size of the current access specification line when any of
 // the reply edit boxes have lost the focus.
 //
-void CAccessDialog::OnKillfocusEReply() 
+void CAccessDialog::OnKillfocusEReply()
 {
-	if ( GetCheckedRadioButton( RNoReply, RReplySize ) == RReplySize )
-		SetReply( GetMKBEditbox( &reply_controls ) );
+	if (GetCheckedRadioButton(RNoReply, RReplySize) == RReplySize)
+		SetReply(GetMKBEditbox(&reply_controls));
 }
 
-
-
 //
 // The user has incremented/decremented the access spec size by using
 // one of the spinner controls.
 //
-void CAccessDialog::OnDeltaposSSizes(NMHDR* pNMHDR, LRESULT* pResult) 
+void CAccessDialog::OnDeltaposSSizes(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	OnDeltaposMKB( &size_controls, pNMHDR );
+	OnDeltaposMKB(&size_controls, pNMHDR);
 	*pResult = TRUE;	// Manually process the spinner movements.
 }
 
@@ -438,9 +410,9 @@
 // The user has incremented/decremented the access spec byte alignment by using
 // one of the spinner controls.
 //
-void CAccessDialog::OnDeltaposSAligns(NMHDR* pNMHDR, LRESULT* pResult) 
+void CAccessDialog::OnDeltaposSAligns(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	OnDeltaposMKB( &align_controls, pNMHDR );
+	OnDeltaposMKB(&align_controls, pNMHDR);
 	*pResult = TRUE;	// Manually process the spinner movements.
 }
 
@@ -448,82 +420,63 @@
 // The user has incremented/decremented the access reply size by using
 // one of the spinner controls.
 //
-void CAccessDialog::OnDeltaposSReply(NMHDR* pNMHDR, LRESULT* pResult) 
+void CAccessDialog::OnDeltaposSReply(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	OnDeltaposMKB( &reply_controls, pNMHDR );
+	OnDeltaposMKB(&reply_controls, pNMHDR);
 	*pResult = TRUE;	// Manually process the spinner movements.
 }
 
-
-
 //
 // Handle event when the user has incremented/decremented a Megabytes/Kilobytes/Bytes 
 // control by using one of the spinner controls.
 //
-void CAccessDialog::OnDeltaposMKB( MKBControls *which, NMHDR* pNMHDR )
+void CAccessDialog::OnDeltaposMKB(MKBControls * which, NMHDR * pNMHDR)
 {
-	NM_UPDOWN*	pNMUpDown = (NM_UPDOWN*)pNMHDR;
-	DWORD		edited_size;
+	NM_UPDOWN *pNMUpDown = (NM_UPDOWN *) pNMHDR;
+	DWORD edited_size;
 
 	// Do not process spinner change if the RSelectedID radio button is specified and is not selected.
-	if ( which->RSelectedID && which->RNotSelectedID && 
-			(UINT) GetCheckedRadioButton( which->RNotSelectedID, which->RSelectedID ) 
-				!= which->RSelectedID )
-	{
+	if (which->RSelectedID && which->RNotSelectedID &&
+	    (UINT) GetCheckedRadioButton(which->RNotSelectedID, which->RSelectedID)
+	    != which->RSelectedID) {
 		return;
 	}
-
 	// See if the user edited the value directly, then pressed the spin
 	// control.  If so, force an update of the edited value before processing
 	// the up/down spin.
-	edited_size = GetMKBEditbox( which );
-	if ( GetMKBSpinners( which ) != edited_size )
-	{
-		SetMKBSpinners( which, edited_size );
+	edited_size = GetMKBEditbox(which);
+	if (GetMKBSpinners(which) != edited_size) {
+		SetMKBSpinners(which, edited_size);
 	}
-
 	// Adjust the spinner positions based on their movement.
-	if ( pNMHDR->idFrom == which->SBytesID )
-	{
-		which->SBytesCtrl->SetPos( which->SBytesCtrl->GetPos() + pNMUpDown->iDelta );
-	}
-	else if ( pNMHDR->idFrom == which->SKilobytesID )
-	{
-		which->SKilobytesCtrl->SetPos( which->SKilobytesCtrl->GetPos() + pNMUpDown->iDelta );
-	}
-	else if ( pNMHDR->idFrom == which->SMegabytesID )
-	{
-		which->SMegabytesCtrl->SetPos( which->SMegabytesCtrl->GetPos() + pNMUpDown->iDelta );
-	}
-	else
-	{
+	if (pNMHDR->idFrom == which->SBytesID) {
+		which->SBytesCtrl->SetPos(which->SBytesCtrl->GetPos() + pNMUpDown->iDelta);
+	} else if (pNMHDR->idFrom == which->SKilobytesID) {
+		which->SKilobytesCtrl->SetPos(which->SKilobytesCtrl->GetPos() + pNMUpDown->iDelta);
+	} else if (pNMHDR->idFrom == which->SMegabytesID) {
+		which->SMegabytesCtrl->SetPos(which->SMegabytesCtrl->GetPos() + pNMUpDown->iDelta);
+	} else {
 		ErrorMessage("Unexpected value for idFrom in CAccessDialog::OnDeltaposMKB");
 	}
 
 	// Save the new size.
-	(this->*(which->SetFunc))( GetMKBSpinners( which ) );
+	(this->*(which->SetFunc)) (GetMKBSpinners(which));
 }
 
-
-
 //
 // Insert a new line into the access spec after or before the current one.
 //
-void CAccessDialog::InsertWrapper( BOOL after )
+void CAccessDialog::InsertWrapper(BOOL after)
 {
-	int			current_line;
+	int current_line;
 	Access_Spec *spec = NULL;
 
-	if ( !(spec = new Access_Spec) )
-	{
-		ErrorMessage( "Unable to allocate memory to insert new access "
-			"spec line." );
+	if (!(spec = new Access_Spec)) {
+		ErrorMessage("Unable to allocate memory to insert new access " "spec line.");
 		return;
 	}
-
 	// Get the first selected line.
-	if ( item_being_changed == -1 )
-	{
+	if (item_being_changed == -1) {
 		// Nothing is selected. Create a default entry.
 		item_being_changed = 0;
 		spec->of_size = 100;
@@ -534,205 +487,170 @@
 		spec->align = 0;
 		spec->reply = 0;
 		spec->size = 2048;
-	}
-	else
-	{
+	} else {
 		// If we're inserting after the current selection, we need to find the
 		// last selected line.
-		current_line = m_LAccess.GetNextItem( -1, LVNI_SELECTED );
-		if ( after )
-		{
+		current_line = m_LAccess.GetNextItem(-1, LVNI_SELECTED);
+		if (after) {
 			// Find the last selected line number.
-			while ( current_line != -1 )
-			{
+			while (current_line != -1) {
 				item_being_changed = current_line;
-				current_line = m_LAccess.GetNextItem( current_line, LVNI_SELECTED );
+				current_line = m_LAccess.GetNextItem(current_line, LVNI_SELECTED);
 			}
 
 			// Get the last selected line's information.
-			GetAll( spec );
+			GetAll(spec);
 			item_being_changed++;
-		}
-		else
-		{
+		} else {
 			// We're inserting before the first selected line.
-			if ( current_line != -1 )
+			if (current_line != -1)
 				item_being_changed = current_line;
-			GetAll( spec );
+			GetAll(spec);
 		}
 	}
-	
+
 	// Insert the new line.
-	InsertLine( spec, item_being_changed );
+	InsertLine(spec, item_being_changed);
 }
 
-
-
 //
 // Inserting a new line into the access spec.
 //
-void CAccessDialog::OnBInsertAfter() 
+void CAccessDialog::OnBInsertAfter()
 {
-	InsertWrapper( TRUE );
+	InsertWrapper(TRUE);
 }
 
-void CAccessDialog::OnBInsertBefore() 
+void CAccessDialog::OnBInsertBefore()
 {
-	InsertWrapper( FALSE );
+	InsertWrapper(FALSE);
 }
 
-
-
 //
 // A change has occurred in the access spec list.  Update the GUI
 // to reflect the current selection, if necessary.
 //
-void CAccessDialog::OnChangeLAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CAccessDialog::OnChangeLAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	// If no item is selected or the same item was reselected, ignore the action.
-	int new_selection = m_LAccess.GetNextItem( -1, LVNI_SELECTED );
-	if ( (new_selection == -1) || (new_selection == item_being_changed) )
+	int new_selection = m_LAccess.GetNextItem(-1, LVNI_SELECTED);
+
+	if ((new_selection == -1) || (new_selection == item_being_changed))
 		return;
 
 	// Updating the last selected access spec line before possibly selecting
 	// a new line.  This is needed or the newly selected item will receive the
 	// same update as the previously selected item.
-	if ( item_being_changed != -1 )
-	{
+	if (item_being_changed != -1) {
 		// Force all the other controls' OnKillfocus handlers to be called
 		m_LAccess.SetFocus();
 	}
-
 	// Determine if a new item has been selected.  If not, keep the
 	// currently selected item with the focus.
-	if ( m_LAccess.GetNextItem( -1, LVNI_SELECTED ) != -1 )
-		item_being_changed = m_LAccess.GetNextItem( -1, LVNI_SELECTED );
+	if (m_LAccess.GetNextItem(-1, LVNI_SELECTED) != -1)
+		item_being_changed = m_LAccess.GetNextItem(-1, LVNI_SELECTED);
 
-	m_LAccess.SetItemState( item_being_changed, LVIS_SELECTED, LVIS_SELECTED );
-	SetAll((Access_Spec *) m_LAccess.GetItemData( item_being_changed ));
+	m_LAccess.SetItemState(item_being_changed, LVIS_SELECTED, LVIS_SELECTED);
+	SetAll((Access_Spec *) m_LAccess.GetItemData(item_being_changed));
 
 	*pResult = 0;
 }
 
-
-
 //
 // Checks for the validity of the entered access spec.
 //
 BOOL CAccessDialog::CheckAccess()
 {
-	int		line_index;
-	int		total_access = 0;
+	int line_index;
+	int total_access = 0;
 	CString spec_name;
 	Test_Spec *name_spec;
 
 	// There must be no more than 100 entries, the sum of the "% of Access" 
 	// fields for all the entries must equal 100, and all sizes must be > 0.
-	for (line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++)
-	{
+	for (line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++) {
 		item_being_changed = line_index;
-		if ( GetSize() <= 0 )
-		{
-			ErrorMessage( "A line in the access specification is for 0 bytes.  "
-				"All sizes must be greater than 0." );
+		if (GetSize() <= 0) {
+			ErrorMessage("A line in the access specification is for 0 bytes.  "
+				     "All sizes must be greater than 0.");
 			return FALSE;
 		}
 		total_access += GetAccess();
 	}
-	if ( total_access != 100 )
-	{
-		ErrorMessage( "Percent of Access Specification values must sum to exactly 100." );
+	if (total_access != 100) {
+		ErrorMessage("Percent of Access Specification values must sum to exactly 100.");
 		return FALSE;
 	}
-
 	// Update the spec's name with the name in the edit box.
-	m_EName.GetWindowText( spec_name.GetBuffer( MAX_WORKER_NAME ), MAX_WORKER_NAME );
+	m_EName.GetWindowText(spec_name.GetBuffer(MAX_WORKER_NAME), MAX_WORKER_NAME);
 	spec_name.ReleaseBuffer();
-	spec_name.TrimLeft();				//remove leading & trailing whitespace (bug #363)
+	spec_name.TrimLeft();	//remove leading & trailing whitespace (bug #363)
 	spec_name.TrimRight();
 	m_EName.SetWindowText(spec_name);	//update edit control
 
 	// Check for a blank name
-	if ( spec_name.IsEmpty() )
-	{
-		ErrorMessage( "You must assign a name to this access specification." );
+	if (spec_name.IsEmpty()) {
+		ErrorMessage("You must assign a name to this access specification.");
 		return FALSE;
 	}
-
 	// Check for commas in the name.  Commas invalidate the results file, which is comma separated.
-	if ( spec_name.Find( ',' ) != -1 )
-	{
-		ErrorMessage( "Commas are not allowed in access specification names." );
+	if (spec_name.Find(',') != -1) {
+		ErrorMessage("Commas are not allowed in access specification names.");
 		return FALSE;
 	}
-
 	// Check for duplicate names.
-	name_spec = theApp.access_spec_list.RefByName( (LPCTSTR)spec_name );
-	if ( name_spec && name_spec != spec )
-	{
-		ErrorMessage( "An access specification named \"" + spec_name + "\" already exists.  " +
-					   "Access specification names must be unique." );
+	name_spec = theApp.access_spec_list.RefByName((LPCTSTR) spec_name);
+	if (name_spec && name_spec != spec) {
+		ErrorMessage("An access specification named \"" + spec_name + "\" already exists.  " +
+			     "Access specification names must be unique.");
 		return FALSE;
 	}
 
 	return TRUE;
 }
 
-
-
 //
 // The user has moved a scroll bar on the GUI.  Process the update.
 // Typically, this means that the user has changed one of the following
 // values: % reads, % random, % of size, etc.
 //
-void CAccessDialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
+void CAccessDialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar * pScrollBar)
 {
-	int position = ((CSliderCtrl*)pScrollBar)->GetPos();
+	int position = ((CSliderCtrl *) pScrollBar)->GetPos();
 
 	// Modifying access specification based on slider controls.
-	if( nSBCode == SB_THUMBTRACK || nSBCode == SB_ENDSCROLL )
-	{
-		if ( pScrollBar ==	(CScrollBar*)&m_SAccess )
-		{
-			SetAccess( position );
+	if (nSBCode == SB_THUMBTRACK || nSBCode == SB_ENDSCROLL) {
+		if (pScrollBar == (CScrollBar *) & m_SAccess) {
+			SetAccess(position);
+		} else if (pScrollBar == (CScrollBar *) & m_SRead) {
+			SetReads(position);
+		} else if (pScrollBar == (CScrollBar *) & m_SRandom) {
+			SetRandom(position);
 		}
-		else if ( pScrollBar == (CScrollBar*)&m_SRead )
-		{
-			SetReads( position );
-		}
-		else if ( pScrollBar == (CScrollBar*)&m_SRandom )
-		{	 
-			SetRandom( position );
-		}
 	}
 }
 
-
-
 //
 // The user clicked OK.
 // Save the user's changes to the access spec.
 //
-void CAccessDialog::OnOK() 
+void CAccessDialog::OnOK()
 {
 	int line_index;
 
 	// Set the focus to the OK button, to force any appropriate Killfocus handler to run
 	// (handles the case that the user modifies a control and then hits ENTER).
 	m_BOk.SetFocus();
-	
-	if ( SaveList() )
-	{
+
+	if (SaveList()) {
 		// Delete all working copies of Access_Spec list items.
-		for ( line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++ )
-			delete (Access_Spec *) m_LAccess.GetItemData( line_index );
+		for (line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++)
+			delete(Access_Spec *) m_LAccess.GetItemData(line_index);
 
 		CDialog::OnOK();
 	}
 }
 
-
-
 //
 // User selected sector alignment radio button - disable byte align edit box, other stuff
 //
@@ -740,29 +658,26 @@
 {
 	// Get the current alignment setting.
 	DWORD old_align = GetAlign();
+
 	// Disable the alignment controls.
-	EnableMKBControls( &align_controls, FALSE );
+	EnableMKBControls(&align_controls, FALSE);
 	// Set the alignment in the access spec to "sector".
-	SetAlign( 0 );
+	SetAlign(0);
 	// Set the (disabled) alignment controls to the last value shown.
-	SetMKBSpinners( &align_controls, old_align );
+	SetMKBSpinners(&align_controls, old_align);
 }
 
-
-
 //
 // User selected byte alignment radio button - enable byte align edit box, other stuff
 //
 void CAccessDialog::OnRAlignBytes()
 {
 	// Enable the alignment controls.
-	EnableMKBControls( &align_controls, TRUE );
+	EnableMKBControls(&align_controls, TRUE);
 	// Set the alignment in the access spec to the value shown in the alignment controls.
-	SetAlign( GetMKBSpinners( &align_controls ) );
+	SetAlign(GetMKBSpinners(&align_controls));
 }
 
-
-
 //
 // User selected "No Reply" radio button - disable reply size edit boxes, other stuff
 //
@@ -770,72 +685,63 @@
 {
 	// Get the current reply size.
 	DWORD old_reply = GetReply();
+
 	// Disable the reply controls.
-	EnableMKBControls( &reply_controls, FALSE );
+	EnableMKBControls(&reply_controls, FALSE);
 	// Set the reply size in the access spec to "none".
-	SetReply( 0 );
+	SetReply(0);
 	// Set the (disabled) reply size controls to the last value shown.
-	SetMKBSpinners( &reply_controls, old_reply );
+	SetMKBSpinners(&reply_controls, old_reply);
 }
 
-
-
 //
 // User selected reply size radio button - enable reply size edit boxes, other stuff
 //
 void CAccessDialog::OnRReplySize()
 {
 	// Enable the reply size controls.
-	EnableMKBControls( &reply_controls, TRUE );
+	EnableMKBControls(&reply_controls, TRUE);
 	// Set the reply size in the access spec to the value shown in the reply size controls.
-	SetReply( GetMKBSpinners( &reply_controls ) );
+	SetReply(GetMKBSpinners(&reply_controls));
 }
 
-
-
 //
 // Setting the controls that display the size of the access spec.
 //
-void CAccessDialog::SetMKBSpinners( MKBControls *which, DWORD new_value )
+void CAccessDialog::SetMKBSpinners(MKBControls * which, DWORD new_value)
 {
 	// The byte alignment and reply size spinners should never show zero.
-	if ( ((which == &align_controls) || (which == &reply_controls)) && new_value == 0 )
-	{
+	if (((which == &align_controls) || (which == &reply_controls)) && new_value == 0) {
 		return;
 	}
-
 	// Updating the display.  Since the spin controls are linked to the
 	// edit boxes, we only need to update the spinners.
-	if ( GetFocus() != which->EBytesCtrl )
-		which->SBytesCtrl->SetPos( new_value % KILOBYTE );
-	if ( GetFocus() != which->EKilobytesCtrl )
-		which->SKilobytesCtrl->SetPos( (new_value % MEGABYTE) / KILOBYTE );
-	if ( GetFocus() != which->EMegabytesCtrl )
-		which->SMegabytesCtrl->SetPos( new_value / MEGABYTE );
+	if (GetFocus() != which->EBytesCtrl)
+		which->SBytesCtrl->SetPos(new_value % KILOBYTE);
+	if (GetFocus() != which->EKilobytesCtrl)
+		which->SKilobytesCtrl->SetPos((new_value % MEGABYTE) / KILOBYTE);
+	if (GetFocus() != which->EMegabytesCtrl)
+		which->SMegabytesCtrl->SetPos(new_value / MEGABYTE);
 }
 
-
-
 //
 // Initialize the listbox.
 //
 void CAccessDialog::InitializeList()
 {
 	// Set the list control column names and widths
-	m_LAccess.ModifyStyle( NULL, LVS_SHOWSELALWAYS );
+	m_LAccess.ModifyStyle(NULL, LVS_SHOWSELALWAYS);
 
-	m_LAccess.InsertColumn( LAccessSize, "Size", LVCFMT_CENTER, 121 );
-	m_LAccess.InsertColumn( LAccessOfSize, "% Access", LVCFMT_CENTER, 58, LAccessOfSize );
-	m_LAccess.InsertColumn( LAccessReads, "% Read", LVCFMT_CENTER, 49, LAccessReads );
-	m_LAccess.InsertColumn( LAccessRandom, "% Random", LVCFMT_CENTER, 63, LAccessRandom );
-	m_LAccess.InsertColumn( LAccessDelay, "Delay", LVCFMT_CENTER, 43, LAccessDelay );
-	m_LAccess.InsertColumn( LAccessBurst, "Burst", LVCFMT_CENTER, 36, LAccessBurst );
-	m_LAccess.InsertColumn( LAccessAlignment, "Alignment", LVCFMT_CENTER, 114, LAccessAlignment );
-	m_LAccess.InsertColumn( LAccessReply, "Reply", LVCFMT_CENTER, 114, LAccessReply );
+	m_LAccess.InsertColumn(LAccessSize, "Size", LVCFMT_CENTER, 121);
+	m_LAccess.InsertColumn(LAccessOfSize, "% Access", LVCFMT_CENTER, 58, LAccessOfSize);
+	m_LAccess.InsertColumn(LAccessReads, "% Read", LVCFMT_CENTER, 49, LAccessReads);
+	m_LAccess.InsertColumn(LAccessRandom, "% Random", LVCFMT_CENTER, 63, LAccessRandom);
+	m_LAccess.InsertColumn(LAccessDelay, "Delay", LVCFMT_CENTER, 43, LAccessDelay);
+	m_LAccess.InsertColumn(LAccessBurst, "Burst", LVCFMT_CENTER, 36, LAccessBurst);
+	m_LAccess.InsertColumn(LAccessAlignment, "Alignment", LVCFMT_CENTER, 114, LAccessAlignment);
+	m_LAccess.InsertColumn(LAccessReply, "Reply", LVCFMT_CENTER, 114, LAccessReply);
 }
 
-
-
 //
 // Loads the access spec lines from the application's test spec structure
 // into an MFC list control and into working space in memory.  By using working
@@ -843,50 +749,39 @@
 //
 void CAccessDialog::LoadList()
 {
-	int			spec_line_no = 0;
-	Access_Spec	*new_spec;
+	int spec_line_no = 0;
+	Access_Spec *new_spec;
 
 	// Abort if we encounter an error.
-	if ( spec == NULL )
-	{
-		ErrorMessage( "Unexpectedly found spec == NULL in CAccessDialog::LoadList()" );
+	if (spec == NULL) {
+		ErrorMessage("Unexpectedly found spec == NULL in CAccessDialog::LoadList()");
 		CDialog::OnOK();
 		return;
 	}
-
 	// Clear display before loading accesses.
 	m_LAccess.DeleteAllItems();
 
 	// Update the name edit box with the spec's name.
-	m_EName.SetWindowText( spec->name );
+	m_EName.SetWindowText(spec->name);
 
 	// Update the default assignment settings.
-	m_CDefaultAssignment.SetCurSel( spec->default_assignment );
+	m_CDefaultAssignment.SetCurSel(spec->default_assignment);
 
 	// Fill in the access spec list.
 	// An "of_size" of IOERROR indicates the end of the list if the list isn't full.
 	item_being_changed = 0;
-	while ( spec->access[spec_line_no].of_size != IOERROR
-			&& item_being_changed < MAX_ACCESS_SPECS )
-	{
+	while (spec->access[spec_line_no].of_size != IOERROR && item_being_changed < MAX_ACCESS_SPECS) {
 		// Allocate memory for a new access spec line.
-		if ( !(new_spec = new Access_Spec) )
-		{
-			ErrorMessage( "Unable to allocate memory to insert new access "
-				"spec line." );
+		if (!(new_spec = new Access_Spec)) {
+			ErrorMessage("Unable to allocate memory to insert new access " "spec line.");
 			return;
 		}
-
 		// Add the new access spec line to the display.
-		memcpy( (void*) new_spec, (void*) &(spec->access[spec_line_no++]),
-			sizeof( Access_Spec ) );
-		if ( InsertLine( new_spec, item_being_changed ) )
-		{
+		memcpy((void *)new_spec, (void *)&(spec->access[spec_line_no++]), sizeof(Access_Spec));
+		if (InsertLine(new_spec, item_being_changed)) {
 			item_being_changed++;
 			new_spec = NULL;
-		}
-		else
-		{
+		} else {
 			// Remove the memory for the new spec.  It was not used.
 			// (This should rarely happen.)
 			delete new_spec;
@@ -900,14 +795,12 @@
 	// If there are no entries in the access spec, disable the OK button.  This 
 	// avoids the error message about incomplete access specs for this special 
 	// case.
-	if ( item_being_changed < 0 )
-		m_BOk.EnableWindow( FALSE );
+	if (item_being_changed < 0)
+		m_BOk.EnableWindow(FALSE);
 
 	m_LAccess.SetFocus();
 }
 
-
-
 //
 // Copies the working access spec to a spot in the application's test spec structure.
 // (Saves the changes the user has made to the access spec.)
@@ -917,207 +810,187 @@
 	int line_index;
 
 	// Abort if we encounter an error.
-	if ( spec == NULL )
-	{
-		ErrorMessage( "Unexpectedly found spec == NULL in CAccessDialog::SaveList()" );
+	if (spec == NULL) {
+		ErrorMessage("Unexpectedly found spec == NULL in CAccessDialog::SaveList()");
 		CDialog::OnOK();
 	}
-
 	// Check to make sure the spec is filled in correctly.
-	if ( !CheckAccess() )
+	if (!CheckAccess())
 		return FALSE;
 
 	// Update the spec's name with the name edit box's contents.
-	m_EName.GetWindowText( spec->name, MAX_WORKER_NAME );
-	
+	m_EName.GetWindowText(spec->name, MAX_WORKER_NAME);
+
 	// Store the default assignment setting.
 	spec->default_assignment = m_CDefaultAssignment.GetCurSel();
 
 	// Fill in the access spec from the entries in the GUI list.
-	for ( line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++ )
-	{
+	for (line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++) {
 		item_being_changed = line_index;
-		GetAll( &( spec->access[line_index] ) );
+		GetAll(&(spec->access[line_index]));
 	}
-	
+
 	// If all the spec's lines have not been filled, mark
 	// the last one as the end.
-	if ( line_index < MAX_ACCESS_SPECS )
+	if (line_index < MAX_ACCESS_SPECS)
 		spec->access[line_index].of_size = IOERROR;
 
 	// Indicate that the access was saved properly.
 	return TRUE;
 }
 
-
-
 //
 // Inserting a line into the access specification list.
 //
-BOOL CAccessDialog::InsertLine( Access_Spec *access_spec, int line_no )
+BOOL CAccessDialog::InsertLine(Access_Spec * access_spec, int line_no)
 {
-	int			current_line;
+	int current_line;
 
 	// Verify that we can handle a new line into the access spec.
-	if ( m_LAccess.GetItemCount() == MAX_ACCESS_SPECS )
-	{
-		ErrorMessage( "Can not add another entry to the access spec: the access spec is full" );
+	if (m_LAccess.GetItemCount() == MAX_ACCESS_SPECS) {
+		ErrorMessage("Can not add another entry to the access spec: the access spec is full");
 		return FALSE;
 	}
-
 	// Unselect all selected lines to select only the new line.
-	current_line = m_LAccess.GetNextItem( -1, LVNI_SELECTED );
-	while ( current_line != -1 )
-	{
-		m_LAccess.SetItemState( current_line, !LVIS_SELECTED, LVIS_SELECTED );
-		current_line = m_LAccess.GetNextItem( current_line, LVNI_SELECTED );
+	current_line = m_LAccess.GetNextItem(-1, LVNI_SELECTED);
+	while (current_line != -1) {
+		m_LAccess.SetItemState(current_line, !LVIS_SELECTED, LVIS_SELECTED);
+		current_line = m_LAccess.GetNextItem(current_line, LVNI_SELECTED);
 	}
 
 	// Insert the new spec line and mark it as selected.
 	item_being_changed = line_no;
-	m_LAccess.InsertItem( LVIF_IMAGE | LVIF_STATE | LVIF_PARAM,
-		item_being_changed, NULL, LVIS_SELECTED | LVIS_FOCUSED, 
-		LVIS_SELECTED | LVIS_FOCUSED, 1, (ULONG_PTR) access_spec );
+	m_LAccess.InsertItem(LVIF_IMAGE | LVIF_STATE | LVIF_PARAM,
+			     item_being_changed, NULL, LVIS_SELECTED | LVIS_FOCUSED,
+			     LVIS_SELECTED | LVIS_FOCUSED, 1, (ULONG_PTR) access_spec);
 
 	// Update the controls to reflect the newly inserted line.
-	SetAll( access_spec );
-	
-	m_LAccess.EnsureVisible( item_being_changed, FALSE );
+	SetAll(access_spec);
 
+	m_LAccess.EnsureVisible(item_being_changed, FALSE);
+
 	// Re-enable all of the controls if this is the first item added to the list.
-	if ( m_LAccess.GetItemCount() == 1 )	
-	{
-		m_EMegabytes.EnableWindow( TRUE );
-		m_EKilobytes.EnableWindow( TRUE );
-		m_EBytes.EnableWindow( TRUE );
-		m_SMegabytes.EnableWindow( TRUE );
-		m_SKilobytes.EnableWindow( TRUE );
-		m_SBytes.EnableWindow( TRUE );
-		m_SAccess.EnableWindow( TRUE );
-		m_SRead.EnableWindow( TRUE );
-		m_SRandom.EnableWindow( TRUE );
-		m_EDelayTime.EnableWindow( TRUE );
-		m_EBurstLength.EnableWindow( TRUE );
-		m_RAlignBytes.EnableWindow( TRUE );
-		m_RAlignSector.EnableWindow( TRUE );
-		m_RReplySize.EnableWindow( TRUE );
-		m_RNoReply.EnableWindow( TRUE );
-		m_BInsertBefore.EnableWindow( TRUE );
-		m_BDelete.EnableWindow( TRUE );
-		m_BOk.EnableWindow( TRUE );
+	if (m_LAccess.GetItemCount() == 1) {
+		m_EMegabytes.EnableWindow(TRUE);
+		m_EKilobytes.EnableWindow(TRUE);
+		m_EBytes.EnableWindow(TRUE);
+		m_SMegabytes.EnableWindow(TRUE);
+		m_SKilobytes.EnableWindow(TRUE);
+		m_SBytes.EnableWindow(TRUE);
+		m_SAccess.EnableWindow(TRUE);
+		m_SRead.EnableWindow(TRUE);
+		m_SRandom.EnableWindow(TRUE);
+		m_EDelayTime.EnableWindow(TRUE);
+		m_EBurstLength.EnableWindow(TRUE);
+		m_RAlignBytes.EnableWindow(TRUE);
+		m_RAlignSector.EnableWindow(TRUE);
+		m_RReplySize.EnableWindow(TRUE);
+		m_RNoReply.EnableWindow(TRUE);
+		m_BInsertBefore.EnableWindow(TRUE);
+		m_BDelete.EnableWindow(TRUE);
+		m_BOk.EnableWindow(TRUE);
 
-		if ( GetCheckedRadioButton( RAlignSector, RAlignBytes ) == RAlignBytes )
-		{
-			m_EAlignMegabytes.EnableWindow( TRUE );
-			m_EAlignKilobytes.EnableWindow( TRUE );
-			m_EAlignBytes.EnableWindow( TRUE );
-			m_SAlignMegabytes.EnableWindow( TRUE );
-			m_SAlignKilobytes.EnableWindow( TRUE );
-			m_SAlignBytes.EnableWindow( TRUE );
+		if (GetCheckedRadioButton(RAlignSector, RAlignBytes) == RAlignBytes) {
+			m_EAlignMegabytes.EnableWindow(TRUE);
+			m_EAlignKilobytes.EnableWindow(TRUE);
+			m_EAlignBytes.EnableWindow(TRUE);
+			m_SAlignMegabytes.EnableWindow(TRUE);
+			m_SAlignKilobytes.EnableWindow(TRUE);
+			m_SAlignBytes.EnableWindow(TRUE);
 		}
 
-		if ( GetCheckedRadioButton( RNoReply, RReplySize ) == RReplySize )
-		{
-			m_EReplyMegabytes.EnableWindow( TRUE );
-			m_EReplyKilobytes.EnableWindow( TRUE );
-			m_EReplyBytes.EnableWindow( TRUE );
-			m_SReplyMegabytes.EnableWindow( TRUE );
-			m_SReplyKilobytes.EnableWindow( TRUE );
-			m_SReplyBytes.EnableWindow( TRUE );
+		if (GetCheckedRadioButton(RNoReply, RReplySize) == RReplySize) {
+			m_EReplyMegabytes.EnableWindow(TRUE);
+			m_EReplyKilobytes.EnableWindow(TRUE);
+			m_EReplyBytes.EnableWindow(TRUE);
+			m_SReplyMegabytes.EnableWindow(TRUE);
+			m_SReplyKilobytes.EnableWindow(TRUE);
+			m_SReplyBytes.EnableWindow(TRUE);
 		}
 	}
 
 	return TRUE;
 }
 
-
-
 //
 // Deletes a line in the access spec.
 //
 BOOL CAccessDialog::DeleteLine()
 {
 	// Retrieve the access spec pointer from the list and deallocate the object.
-	delete (Access_Spec *) m_LAccess.GetItemData( item_being_changed );
+	delete(Access_Spec *) m_LAccess.GetItemData(item_being_changed);
 
 	// Remove the line from the listbox.
-	m_LAccess.DeleteItem( item_being_changed );
+	m_LAccess.DeleteItem(item_being_changed);
 
 	// All the entries have been removed.  Disable all related controls.
-	if ( !m_LAccess.GetItemCount() )
-	{
-		m_EMegabytes.EnableWindow( FALSE );
-		m_EKilobytes.EnableWindow( FALSE );
-		m_EBytes.EnableWindow( FALSE );
-		m_SMegabytes.EnableWindow( FALSE );
-		m_SKilobytes.EnableWindow( FALSE );
-		m_SBytes.EnableWindow( FALSE );
-		m_SAccess.EnableWindow( FALSE );
-		m_SRead.EnableWindow( FALSE );
-		m_SRandom.EnableWindow( FALSE );
-		m_EDelayTime.EnableWindow( FALSE );
-		m_EBurstLength.EnableWindow( FALSE );
-		m_RAlignBytes.EnableWindow( FALSE );
-		m_RAlignSector.EnableWindow( FALSE );
-		m_EAlignMegabytes.EnableWindow( FALSE );
-		m_EAlignKilobytes.EnableWindow( FALSE );
-		m_EAlignBytes.EnableWindow( FALSE );
-		m_SAlignMegabytes.EnableWindow( FALSE );
-		m_SAlignKilobytes.EnableWindow( FALSE );
-		m_SAlignBytes.EnableWindow( FALSE );
-		m_RReplySize.EnableWindow( FALSE );
-		m_RNoReply.EnableWindow( FALSE );
-		m_SReplyMegabytes.EnableWindow( FALSE );
-		m_SReplyKilobytes.EnableWindow( FALSE );
-		m_SReplyBytes.EnableWindow( FALSE );
-		m_EReplyMegabytes.EnableWindow( FALSE );
-		m_EReplyKilobytes.EnableWindow( FALSE );
-		m_EReplyBytes.EnableWindow( FALSE );
-		m_BInsertBefore.EnableWindow( FALSE );
-		m_BDelete.EnableWindow( FALSE );
-		m_BOk.EnableWindow( FALSE );
+	if (!m_LAccess.GetItemCount()) {
+		m_EMegabytes.EnableWindow(FALSE);
+		m_EKilobytes.EnableWindow(FALSE);
+		m_EBytes.EnableWindow(FALSE);
+		m_SMegabytes.EnableWindow(FALSE);
+		m_SKilobytes.EnableWindow(FALSE);
+		m_SBytes.EnableWindow(FALSE);
+		m_SAccess.EnableWindow(FALSE);
+		m_SRead.EnableWindow(FALSE);
+		m_SRandom.EnableWindow(FALSE);
+		m_EDelayTime.EnableWindow(FALSE);
+		m_EBurstLength.EnableWindow(FALSE);
+		m_RAlignBytes.EnableWindow(FALSE);
+		m_RAlignSector.EnableWindow(FALSE);
+		m_EAlignMegabytes.EnableWindow(FALSE);
+		m_EAlignKilobytes.EnableWindow(FALSE);
+		m_EAlignBytes.EnableWindow(FALSE);
+		m_SAlignMegabytes.EnableWindow(FALSE);
+		m_SAlignKilobytes.EnableWindow(FALSE);
+		m_SAlignBytes.EnableWindow(FALSE);
+		m_RReplySize.EnableWindow(FALSE);
+		m_RNoReply.EnableWindow(FALSE);
+		m_SReplyMegabytes.EnableWindow(FALSE);
+		m_SReplyKilobytes.EnableWindow(FALSE);
+		m_SReplyBytes.EnableWindow(FALSE);
+		m_EReplyMegabytes.EnableWindow(FALSE);
+		m_EReplyKilobytes.EnableWindow(FALSE);
+		m_EReplyBytes.EnableWindow(FALSE);
+		m_BInsertBefore.EnableWindow(FALSE);
+		m_BDelete.EnableWindow(FALSE);
+		m_BOk.EnableWindow(FALSE);
 	}
 
 	return TRUE;
 }
 
-
-
 //
 // Calls each of the Set functions.
 //
-void CAccessDialog::SetAll( Access_Spec *spec )
+void CAccessDialog::SetAll(Access_Spec * spec)
 {
-	SetSize( spec->size );
-	SetAccess( spec->of_size );
-	SetReads( spec->reads );
-	SetRandom( spec->random );
-	SetDelay( spec->delay );
-	SetBurst( spec->burst );
+	SetSize(spec->size);
+	SetAccess(spec->of_size);
+	SetReads(spec->reads);
+	SetRandom(spec->random);
+	SetDelay(spec->delay);
+	SetBurst(spec->burst);
 
-	SetAlign( spec->align );
-	EnableMKBControls( &align_controls, spec->align );
-	if ( !spec->align )
-	{
+	SetAlign(spec->align);
+	EnableMKBControls(&align_controls, spec->align);
+	if (!spec->align) {
 		// Set the (disabled) alignment controls to 512 bytes (standard sector size).
-		SetMKBSpinners( &align_controls, 512 );
+		SetMKBSpinners(&align_controls, 512);
 	}
 
-	SetReply( spec->reply );
-	EnableMKBControls( &reply_controls, spec->reply );
-	if ( !spec->reply )
-	{
+	SetReply(spec->reply);
+	EnableMKBControls(&reply_controls, spec->reply);
+	if (!spec->reply) {
 		// Set the (disabled) reply size controls to the current transfer size.
-		SetMKBSpinners( &reply_controls, spec->size );
+		SetMKBSpinners(&reply_controls, spec->size);
 	}
 }
 
-
-
 //
 // Calls each of the Get functions.
 //
-void CAccessDialog::GetAll( Access_Spec *spec )
+void CAccessDialog::GetAll(Access_Spec * spec)
 {
 	spec->size = GetSize();
 	spec->of_size = GetAccess();
@@ -1129,324 +1002,301 @@
 	spec->reply = GetReply();
 }
 
-void CAccessDialog::SetAccess( int of_size )
+void CAccessDialog::SetAccess(int of_size)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->of_size = of_size;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->of_size = of_size;
 
 	// Display the change.
-	buffer.Format( "%d", of_size );
-	m_LAccess.SetItemText( item_being_changed, LAccessOfSize, buffer );
+	buffer.Format("%d", of_size);
+	m_LAccess.SetItemText(item_being_changed, LAccessOfSize, buffer);
 
 	// Update the control.
-	m_SAccess.SetPos( of_size );
-	access_txt.Format( "%d Percent", of_size );
+	m_SAccess.SetPos(of_size);
+	access_txt.Format("%d Percent", of_size);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 int CAccessDialog::GetAccess()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->of_size;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->of_size;
 }
 
-void CAccessDialog::SetReads( int reads )
+void CAccessDialog::SetReads(int reads)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->reads = reads;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->reads = reads;
 
 	// Display the change.
-	buffer.Format( "%d", reads );
-	m_LAccess.SetItemText( item_being_changed, LAccessReads, buffer );
+	buffer.Format("%d", reads);
+	m_LAccess.SetItemText(item_being_changed, LAccessReads, buffer);
 
 	// Update the control.
-	m_SRead.SetPos( reads );
-	read_txt.Format( "%d%%\nRead", reads );
-	write_txt.Format( "%d%%\nWrite", 100 - reads );
+	m_SRead.SetPos(reads);
+	read_txt.Format("%d%%\nRead", reads);
+	write_txt.Format("%d%%\nWrite", 100 - reads);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 int CAccessDialog::GetReads()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->reads;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->reads;
 }
 
-void CAccessDialog::SetRandom( int random )
+void CAccessDialog::SetRandom(int random)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->random = random;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->random = random;
 
 	// Display the change.
-	buffer.Format( "%d", random );
-	m_LAccess.SetItemText( item_being_changed, LAccessRandom, buffer );
+	buffer.Format("%d", random);
+	m_LAccess.SetItemText(item_being_changed, LAccessRandom, buffer);
 
 	// Update the control.
-	m_SRandom.SetPos( random );
-	random_txt.Format( "%d%%\nRandom", random );
-	sequential_txt.Format( "%d%%\nSequential", 100 - random );
+	m_SRandom.SetPos(random);
+	random_txt.Format("%d%%\nRandom", random);
+	sequential_txt.Format("%d%%\nSequential", 100 - random);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 int CAccessDialog::GetRandom()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->random;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->random;
 }
 
-void CAccessDialog::SetDelay( int delay )
+void CAccessDialog::SetDelay(int delay)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->delay = delay;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->delay = delay;
 
 	// Display the change.
-	buffer.Format( "%d", delay );
-	m_LAccess.SetItemText( item_being_changed, LAccessDelay, buffer );
+	buffer.Format("%d", delay);
+	m_LAccess.SetItemText(item_being_changed, LAccessDelay, buffer);
 
 	// Update the control.
-	SetDlgItemInt( EDelayTime, delay, FALSE );
+	SetDlgItemInt(EDelayTime, delay, FALSE);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 int CAccessDialog::GetDelay()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->delay;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->delay;
 }
 
-void CAccessDialog::SetBurst( int burst )
+void CAccessDialog::SetBurst(int burst)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->burst = burst;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->burst = burst;
 
 	// Display the change.
-	buffer.Format( "%d", burst );
-	m_LAccess.SetItemText( item_being_changed, LAccessBurst, buffer );
+	buffer.Format("%d", burst);
+	m_LAccess.SetItemText(item_being_changed, LAccessBurst, buffer);
 
 	// Update the control.
-	SetDlgItemInt( EBurstLength, burst, FALSE );
+	SetDlgItemInt(EBurstLength, burst, FALSE);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 int CAccessDialog::GetBurst()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->burst;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->burst;
 }
 
-void CAccessDialog::SetAlign( DWORD align )
+void CAccessDialog::SetAlign(DWORD align)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->align = align;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->align = align;
 
 	// Display the change.
-	if ( align )
-		SizeToText( align, &buffer );
+	if (align)
+		SizeToText(align, &buffer);
 	else
-		buffer.Format( "sector" );
+		buffer.Format("sector");
 
-	m_LAccess.SetItemText( item_being_changed, LAccessAlignment, buffer );
+	m_LAccess.SetItemText(item_being_changed, LAccessAlignment, buffer);
 
 	// Update the controls.
-	SetMKBSpinners( &align_controls, align );
+	SetMKBSpinners(&align_controls, align);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 DWORD CAccessDialog::GetAlign()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->align;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->align;
 }
 
-
-void CAccessDialog::SetReply( DWORD reply )
+void CAccessDialog::SetReply(DWORD reply)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->reply = reply;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->reply = reply;
 
 	// Display the change.
-	if ( reply )
-		SizeToText( reply, &buffer );
+	if (reply)
+		SizeToText(reply, &buffer);
 	else
-		buffer.Format( "none" );
+		buffer.Format("none");
 
-	m_LAccess.SetItemText( item_being_changed, LAccessReply, buffer );
+	m_LAccess.SetItemText(item_being_changed, LAccessReply, buffer);
 
 	// Update the controls.
-	SetMKBSpinners( &reply_controls, reply );
+	SetMKBSpinners(&reply_controls, reply);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 DWORD CAccessDialog::GetReply()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->reply;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->reply;
 }
 
-void CAccessDialog::SetSize( DWORD size )
+void CAccessDialog::SetSize(DWORD size)
 {
 	CString buffer;
 
 	// Change the value in the access spec.
-	((Access_Spec *) m_LAccess.GetItemData( item_being_changed ))->size = size;
+	((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->size = size;
 
 	// Display the change.
-	SizeToText( size, &buffer );
-	m_LAccess.SetItemText( item_being_changed, LAccessSize, buffer );
+	SizeToText(size, &buffer);
+	m_LAccess.SetItemText(item_being_changed, LAccessSize, buffer);
 
 	// Update the controls.
-	SetMKBSpinners( &size_controls, size );
+	SetMKBSpinners(&size_controls, size);
 
 	// If reply size is not currently selected, also set the (disabled) reply size controls
 	// to the new transfer size.
-	if ( (UINT) GetCheckedRadioButton( RNoReply, RReplySize ) != RReplySize )
-		SetMKBSpinners( &reply_controls, size );
+	if ((UINT) GetCheckedRadioButton(RNoReply, RReplySize) != RReplySize)
+		SetMKBSpinners(&reply_controls, size);
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 }
 
 DWORD CAccessDialog::GetSize()
 {
 	// Retrieve a pointer to the access spec for the requested line
 	// and return the requested member of the spec.
-	return ((Access_Spec *) m_LAccess.GetItemData( item_being_changed ) )->size;
+	return ((Access_Spec *) m_LAccess.GetItemData(item_being_changed))->size;
 }
 
-
-
 //
 // Called when the user clicks the Delete button.
 // Removes all selected lines from the access spec.
 //
-void CAccessDialog::OnBDelete() 
+void CAccessDialog::OnBDelete()
 {
 	int first_highlighted_item;
 
 	// Return immediately if nothing is selected.
-	if ( (first_highlighted_item = m_LAccess.GetNextItem( -1, LVNI_SELECTED )) == -1 )
+	if ((first_highlighted_item = m_LAccess.GetNextItem(-1, LVNI_SELECTED)) == -1)
 		return;
 
 	// Loop through all selected items and delete them.
-	while( (item_being_changed = m_LAccess.GetNextItem( -1, LVNI_SELECTED )) != -1 )
+	while ((item_being_changed = m_LAccess.GetNextItem(-1, LVNI_SELECTED)) != -1)
 		DeleteLine();
 
 	item_being_changed = first_highlighted_item;
 
-	if ( item_being_changed != -1 && item_being_changed < m_LAccess.GetItemCount() )
-	{
-		m_LAccess.SetItemState( item_being_changed, LVIS_SELECTED, LVIS_SELECTED );
-		SetAll( (Access_Spec *) m_LAccess.GetItemData( item_being_changed ) );
-	}
-	else if ( m_LAccess.GetItemCount() )
-	{
+	if (item_being_changed != -1 && item_being_changed < m_LAccess.GetItemCount()) {
+		m_LAccess.SetItemState(item_being_changed, LVIS_SELECTED, LVIS_SELECTED);
+		SetAll((Access_Spec *) m_LAccess.GetItemData(item_being_changed));
+	} else if (m_LAccess.GetItemCount()) {
 		item_being_changed = m_LAccess.GetItemCount() - 1;
-		m_LAccess.SetItemState( item_being_changed, LVIS_SELECTED, LVIS_SELECTED );
-		SetAll( (Access_Spec *) m_LAccess.GetItemData( item_being_changed ) );
-	}
-	else
-	{
+		m_LAccess.SetItemState(item_being_changed, LVIS_SELECTED, LVIS_SELECTED);
+		SetAll((Access_Spec *) m_LAccess.GetItemData(item_being_changed));
+	} else {
 		// No more items left in the list.
 		item_being_changed = -1;
 	}
 }
 
-
-
 //
 // Called when the contents of the delay editbox change
 //
-void CAccessDialog::OnChangeDelay( )
+void CAccessDialog::OnChangeDelay()
 {
 	// Update the delay time if it's not blank.
-	if ( m_EDelayTime.LineLength() )
-	{
-		SetDelay( GetDlgItemInt( EDelayTime ) );
-	}
-	else if ( GetFocus() != &m_EDelayTime)
-	{
+	if (m_EDelayTime.LineLength()) {
+		SetDelay(GetDlgItemInt(EDelayTime));
+	} else if (GetFocus() != &m_EDelayTime) {
 		// Entry box is empty and it no longer has focus.
 		// Revert to the value in the access spec.
-		SetDelay( GetDelay() );
+		SetDelay(GetDelay());
 	}
 }
 
-
-
 //
 // Called when the contents of the burst rate editbox change
 //
-void CAccessDialog::OnChangeBurst( )
+void CAccessDialog::OnChangeBurst()
 {
 	// Update the burst rate if it's not blank.
-	if ( m_EBurstLength.LineLength() )
-	{
+	if (m_EBurstLength.LineLength()) {
 		// Prevent a burst length of 0.
-		if ( !GetDlgItemInt( EBurstLength ) )
-		{
-			ErrorMessage( "Burst length cannot be set to 0." );
+		if (!GetDlgItemInt(EBurstLength)) {
+			ErrorMessage("Burst length cannot be set to 0.");
 
 			// Revert to the old value.
-			if ( GetBurst() )
-				SetBurst( GetBurst() );
+			if (GetBurst())
+				SetBurst(GetBurst());
 			else
-				SetBurst( 1 );
+				SetBurst(1);
+		} else {
+			SetBurst(GetDlgItemInt(EBurstLength));
 		}
-		else
-		{
-			SetBurst( GetDlgItemInt( EBurstLength ) );
-		}
-	}
-	else if ( GetFocus() != &m_EBurstLength )
-	{
+	} else if (GetFocus() != &m_EBurstLength) {
 		// Entry box is empty and it no longer has focus.
 		// Revert to the old value.
-		SetBurst( GetBurst() );
+		SetBurst(GetBurst());
 	}
 }
 
-
-
 //
 // Called when the user clicks cancel or otherwise closes the window
 // (Alt-F4, clicking the top right X)
 // This throws away any changes by deleting the working access spec
 // without copying them to the main access spec structure.
 //
-void CAccessDialog::OnCancel() 
+void CAccessDialog::OnCancel()
 {
 	int line_index;
 
 	// Delete all working copies of Access_Spec list items.
-	for ( line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++ )
-		delete (Access_Spec *) m_LAccess.GetItemData( line_index );
+	for (line_index = 0; line_index < m_LAccess.GetItemCount(); line_index++)
+		delete(Access_Spec *) m_LAccess.GetItemData(line_index);
 
 	CDialog::OnCancel();
 }

Modified: branches/IOMETER-restruct/iometer/src/AccessDialog.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/AccessDialog.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/AccessDialog.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,10 +60,9 @@
 #ifndef ACCESS_DIALOG_DEFINED
 #define ACCESS_DIALOG_DEFINED
 
-
 #if _MSC_VER >= 1000
 #pragma once
-#endif // _MSC_VER >= 1000
+#endif				// _MSC_VER >= 1000
 // AccessDialog.h : header file
 //
 
@@ -71,45 +70,42 @@
 #include "GalileoView.h"
 #include "IOTest.h"
 
-class CAccessDialog;	// Forward declaration
+class CAccessDialog;		// Forward declaration
+
 //
 // Structure that defines a group of controls for Megabytes, Kilobytes, and Bytes
 //
-struct MKBControls 
-{
-	CEdit			*EBytesCtrl;
-	CEdit			*EKilobytesCtrl;
-	CEdit			*EMegabytesCtrl;
-	UINT			EBytesID;
-	UINT			EKilobytesID;
-	UINT			EMegabytesID;
-	CSpinButtonCtrl	*SBytesCtrl;
-	CSpinButtonCtrl	*SKilobytesCtrl;
-	CSpinButtonCtrl	*SMegabytesCtrl;
-	UINT			SBytesID;
-	UINT			SKilobytesID;
-	UINT			SMegabytesID;
-	UINT			RSelectedID;	// radio button indicating MKBControls are selected
-	UINT			RNotSelectedID;	// radio button indicating MKBControls are not selected
+struct MKBControls {
+	CEdit *EBytesCtrl;
+	CEdit *EKilobytesCtrl;
+	CEdit *EMegabytesCtrl;
+	UINT EBytesID;
+	UINT EKilobytesID;
+	UINT EMegabytesID;
+	CSpinButtonCtrl *SBytesCtrl;
+	CSpinButtonCtrl *SKilobytesCtrl;
+	CSpinButtonCtrl *SMegabytesCtrl;
+	UINT SBytesID;
+	UINT SKilobytesID;
+	UINT SMegabytesID;
+	UINT RSelectedID;	// radio button indicating MKBControls are selected
+	UINT RNotSelectedID;	// radio button indicating MKBControls are not selected
 	// RSelectedID MUST be greater than RNotSelectedID, for the sake of GetCheckedRadioButton().
 	// If there are no controlling radio buttons, set both to zero.
-	DWORD			(CAccessDialog::*GetFunc)();		// pointer to getter function
-	void			(CAccessDialog::*SetFunc)( DWORD );	// pointer to setter function
+	 DWORD(CAccessDialog::*GetFunc) ();	// pointer to getter function
+	void (CAccessDialog::*SetFunc) (DWORD);	// pointer to setter function
 	// GetFunc and SetFunc are POINTERS TO MEMBER FUNCTIONS, which have a special syntax.
-	// Given:							MKBControls *which;
-	// To assign FUNCNAME to SetFunc:	which->SetFunc = this->FUNCNAME;
-	// To call FUNCNAME with VALUE:		(this->*(which->SetFunc))( VALUE );
+	// Given:                                                       MKBControls *which;
+	// To assign FUNCNAME to SetFunc:       which->SetFunc = this->FUNCNAME;
+	// To call FUNCNAME with VALUE:         (this->*(which->SetFunc))( VALUE );
 };
 
-
 #define MAX_SIZE_RANGE	KILOBYTE - 1
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CAccessDialog dialog
 
-class CAccessDialog : public CDialog
-{
+class CAccessDialog:public CDialog {
 	// LAccess subitems (integer values should remain
 	// unchanged for backward file format compatibility)
 	enum {
@@ -124,122 +120,120 @@
 	};
 
 // Construction
-public:
-	CAccessDialog( Test_Spec *edit_spec, CWnd* pParent = NULL);   // standard constructor
+      public:
+	 CAccessDialog(Test_Spec * edit_spec, CWnd * pParent = NULL);	// standard constructor
 
-protected:
+      protected:
 // Dialog Data
 	//{{AFX_DATA(CAccessDialog)
 	enum { IDD = IDD_ACCESSDLG };
-	CButton	m_RReplySize;
-	CButton	m_RNoReply;
-	CButton	m_RAlignSector;
-	CButton	m_RAlignBytes;
-	CSpinButtonCtrl	m_SReplyMegabytes;
-	CSpinButtonCtrl	m_SReplyKilobytes;
-	CSpinButtonCtrl	m_SReplyBytes;
-	CEdit	m_EReplyMegabytes;
-	CEdit	m_EReplyKilobytes;
-	CEdit	m_EReplyBytes;
-	CSpinButtonCtrl	m_SAlignMegabytes;
-	CSpinButtonCtrl	m_SAlignKilobytes;
-	CSpinButtonCtrl	m_SAlignBytes;
-	CEdit	m_EAlignMegabytes;
-	CEdit	m_EAlignKilobytes;
-	CEdit	m_EAlignBytes;
-	CEdit	m_EBytes;
-	CEdit	m_EMegabytes;
-	CEdit	m_EKilobytes;
-	CComboBox	m_CDefaultAssignment;
-	CSpinButtonCtrl	m_SMegabytes;
-	CSpinButtonCtrl	m_SKilobytes;
-	CSpinButtonCtrl	m_SBytes;
-	CButton	m_BOk;
-	CEdit	m_EName;
-	CSliderCtrl	m_SRead;
-	CSliderCtrl	m_SRandom;
-	CSliderCtrl	m_SAccess;
-	CListCtrl	m_LAccess;
-	CEdit	m_EDelayTime;
-	CEdit	m_EBurstLength;
-	CButton	m_BInsertBefore;
-	CButton	m_BInsertAfter;
-	CButton	m_BDelete;
-	CString	access_txt;
-	CString	random_txt;
-	CString	read_txt;
-	CString	sequential_txt;
-	CString	transfer_txt;
-	CString	write_txt;
+	CButton m_RReplySize;
+	CButton m_RNoReply;
+	CButton m_RAlignSector;
+	CButton m_RAlignBytes;
+	CSpinButtonCtrl m_SReplyMegabytes;
+	CSpinButtonCtrl m_SReplyKilobytes;
+	CSpinButtonCtrl m_SReplyBytes;
+	CEdit m_EReplyMegabytes;
+	CEdit m_EReplyKilobytes;
+	CEdit m_EReplyBytes;
+	CSpinButtonCtrl m_SAlignMegabytes;
+	CSpinButtonCtrl m_SAlignKilobytes;
+	CSpinButtonCtrl m_SAlignBytes;
+	CEdit m_EAlignMegabytes;
+	CEdit m_EAlignKilobytes;
+	CEdit m_EAlignBytes;
+	CEdit m_EBytes;
+	CEdit m_EMegabytes;
+	CEdit m_EKilobytes;
+	CComboBox m_CDefaultAssignment;
+	CSpinButtonCtrl m_SMegabytes;
+	CSpinButtonCtrl m_SKilobytes;
+	CSpinButtonCtrl m_SBytes;
+	CButton m_BOk;
+	CEdit m_EName;
+	CSliderCtrl m_SRead;
+	CSliderCtrl m_SRandom;
+	CSliderCtrl m_SAccess;
+	CListCtrl m_LAccess;
+	CEdit m_EDelayTime;
+	CEdit m_EBurstLength;
+	CButton m_BInsertBefore;
+	CButton m_BInsertAfter;
+	CButton m_BDelete;
+	CString access_txt;
+	CString random_txt;
+	CString read_txt;
+	CString sequential_txt;
+	CString transfer_txt;
+	CString write_txt;
 	//}}AFX_DATA
 
-	Test_Spec	*spec;
+	Test_Spec *spec;
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CAccessDialog)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 
-	MKBControls		size_controls;
-	MKBControls		align_controls;
-	MKBControls		reply_controls;
+	 MKBControls size_controls;
+	MKBControls align_controls;
+	MKBControls reply_controls;
 
 	// Verifies that everything is okay when the user clicks OK.
-	BOOL	CheckAccess();
+	BOOL CheckAccess();
 
 	// These are the functions which deal with the access spec listbox.
-	void	InitializeList();
-	void	LoadList();
-	BOOL	SaveList();
-	void	InsertWrapper( BOOL after );
-	BOOL	InsertLine( Access_Spec *access_spec, int line_no );
-	BOOL	DeleteLine();
+	void InitializeList();
+	void LoadList();
+	BOOL SaveList();
+	void InsertWrapper(BOOL after);
+	BOOL InsertLine(Access_Spec * access_spec, int line_no);
+	BOOL DeleteLine();
 
 	// Each function gets a value from the working access_spec.
 	// (GetAll calls each of the other functions)
-	void	GetAll( Access_Spec *spec );
-	int		GetAccess();
-	int		GetReads();
-	int		GetRandom();
-	int		GetDelay();
-	int		GetBurst();
-	DWORD	GetAlign();
-	DWORD	GetSize();
-	DWORD	GetReply();
+	void GetAll(Access_Spec * spec);
+	int GetAccess();
+	int GetReads();
+	int GetRandom();
+	int GetDelay();
+	int GetBurst();
+	DWORD GetAlign();
+	DWORD GetSize();
+	DWORD GetReply();
 
 	// Each function sets a value in the working access_spec,
 	// updates that value in the access spec listbox,
 	// and changes the controls to reflect the change.
 	// (SetAll calls each of the other functions)
-	void	SetAll( Access_Spec *spec );
-	void	SetAccess(	int of_size );
-	void	SetReads(	int reads );
-	void	SetRandom(	int random );
-	void	SetDelay(	int delay );
-	void	SetBurst(	int burst );
-	void	SetAlign(	DWORD align );
-	void	SetSize(	DWORD size );
-	void	SetReply(	DWORD reply );
+	void SetAll(Access_Spec * spec);
+	void SetAccess(int of_size);
+	void SetReads(int reads);
+	void SetRandom(int random);
+	void SetDelay(int delay);
+	void SetBurst(int burst);
+	void SetAlign(DWORD align);
+	void SetSize(DWORD size);
+	void SetReply(DWORD reply);
 
-
-	void	SizeToText( DWORD size, CString *size_text );
+	void SizeToText(DWORD size, CString * size_text);
 	// Set the spinners, which in turn set the edit boxes.
-	void	SetMKBSpinners( MKBControls *which, DWORD new_value );
+	void SetMKBSpinners(MKBControls * which, DWORD new_value);
 	// Get the size reported by the spinners.
-	DWORD	GetMKBSpinners( MKBControls *which );
+	DWORD GetMKBSpinners(MKBControls * which);
 	// Get the size reported by the edit boxes.
-	DWORD	GetMKBEditbox( MKBControls *which );
+	DWORD GetMKBEditbox(MKBControls * which);
 	// Handle a change in one of the spinners.
-	void	OnDeltaposMKB( MKBControls *which, NMHDR* pNMHDR );
+	void OnDeltaposMKB(MKBControls * which, NMHDR * pNMHDR);
 	// Enable or disable the controls.
-	void	EnableMKBControls( MKBControls *which, BOOL enabled );
+	void EnableMKBControls(MKBControls * which, BOOL enabled);
 
-
 	int item_being_changed;
 
 	// Generated message map functions
@@ -248,27 +242,27 @@
 	afx_msg void OnBDelete();
 	afx_msg void OnBInsertAfter();
 	afx_msg void OnBInsertBefore();
-	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
+	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar * pScrollBar);
 	afx_msg void OnKillfocusESizes();
 	afx_msg void OnKillfocusEAligns();
 	virtual void OnOK();
-	afx_msg void OnDeltaposSSizes(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnDeltaposSAligns(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnDeltaposSSizes(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnDeltaposSAligns(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnRAlignSector();
 	afx_msg void OnRAlignBytes();
-	afx_msg void OnChangeBurst( );
-	afx_msg void OnChangeDelay( );
+	afx_msg void OnChangeBurst();
+	afx_msg void OnChangeDelay();
 	virtual void OnCancel();
-	afx_msg void OnDeltaposSReply(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnDeltaposSReply(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnKillfocusEReply();
 	afx_msg void OnRNoReply();
 	afx_msg void OnRReplySize();
-	afx_msg void OnChangeLAccess(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnChangeLAccess(NMHDR * pNMHDR, LRESULT * pResult);
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
 //{{AFX_INSERT_LOCATION}}
 // Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 
-#endif // !defined(ACCESS_DIALOG_DEFINED)
+#endif				// !defined(ACCESS_DIALOG_DEFINED)

Modified: branches/IOMETER-restruct/iometer/src/AccessSpecList.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/AccessSpecList.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/AccessSpecList.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -69,13 +69,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "AccessSpecList.h"
 #include "GalileoApp.h"
 #include "GalileoView.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -86,29 +84,29 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 //
 // Initializing the pointer list.
 //
 AccessSpecList::AccessSpecList()
 {
 	// Initialize the pointer array.
-	spec_list.SetSize( INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP );
+	spec_list.SetSize(INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP);
 
 	// Insert the idle spec as the first in the row
 	InsertIdleSpec();
 
 	// Insert a default spec that will be assigned
 	// (in former days, this one was assigned to all workers that log in)
-	Test_Spec* spec = New();
-	strcpy( spec->name, "Default" );
+	Test_Spec *spec = New();
+
+	strcpy(spec->name, "Default");
 	spec->default_assignment = FALSE;	// [AssignAll|AssignDisk|...]
 
 	// Insert the default specifications
@@ -116,449 +114,444 @@
 	InsertDefaultSpecs();
 }
 
-
-
 //
 // Inserts the idle spec.
 //
 void AccessSpecList::InsertIdleSpec()
 {
 	// Set idle spec.
-	Test_Spec* spec = New();
-	_snprintf( spec->name, MAX_NAME, IDLE_NAME );
+	Test_Spec *spec = New();
+
+	_snprintf(spec->name, MAX_NAME, IDLE_NAME);
 	spec->access[0].of_size = IOERROR;	// indicates the end of the spec.
-										// Note that the end is the first
-										// line of the spec, making it
-										// empty.
+	// Note that the end is the first
+	// line of the spec, making it
+	// empty.
 }
 
-
-
 //
 // Inserts the different default specifications.
 //
 void AccessSpecList::InsertDefaultSpecs()
 {
-	Test_Spec* spec;
+	Test_Spec *spec;
 
 	// 512 Bytes
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "512B; 100%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 512;
-	spec->access[0].reads   = 100;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "512B; 100%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 512;
+	spec->access[0].reads = 100;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "512B; 75%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 512;
-	spec->access[0].reads   = 75;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "512B; 75%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 512;
+	spec->access[0].reads = 75;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "512B; 50%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 512;
-	spec->access[0].reads   = 50;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "512B; 50%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 512;
+	spec->access[0].reads = 50;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "512B; 25%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 512;
-	spec->access[0].reads   = 25;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "512B; 25%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 512;
+	spec->access[0].reads = 25;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "512B; 0%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 512;
-	spec->access[0].reads   = 0;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "512B; 0%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 512;
+	spec->access[0].reads = 0;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	// 4096 Bytes / 4 Kilo Bytes
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "4K; 100%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 4096;
-	spec->access[0].reads   = 100;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "4K; 100%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 4096;
+	spec->access[0].reads = 100;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "4K; 75%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 4096;
-	spec->access[0].reads   = 75;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "4K; 75%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 4096;
+	spec->access[0].reads = 75;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "4K; 50%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 4096;
-	spec->access[0].reads   = 50;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "4K; 50%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 4096;
+	spec->access[0].reads = 50;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "4K; 25%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 4096;
-	spec->access[0].reads   = 25;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "4K; 25%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 4096;
+	spec->access[0].reads = 25;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "4K; 0%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 4096;
-	spec->access[0].reads   = 0;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "4K; 0%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 4096;
+	spec->access[0].reads = 0;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	// 16384 Bytes / 16 Kilo Bytes
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "16K; 100%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 16384;
-	spec->access[0].reads   = 100;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "16K; 100%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 16384;
+	spec->access[0].reads = 100;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "16K; 75%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 16384;
-	spec->access[0].reads   = 75;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "16K; 75%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 16384;
+	spec->access[0].reads = 75;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "16K; 50%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 16384;
-	spec->access[0].reads   = 50;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "16K; 50%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 16384;
+	spec->access[0].reads = 50;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "16K; 25%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 16384;
-	spec->access[0].reads   = 25;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "16K; 25%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 16384;
+	spec->access[0].reads = 25;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "16K; 0%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 16384;
-	spec->access[0].reads   = 0;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "16K; 0%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 16384;
+	spec->access[0].reads = 0;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	// 32768 Bytes / 32 Kilo Bytes
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "32K; 100%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 32768;
-	spec->access[0].reads   = 100;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "32K; 100%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 32768;
+	spec->access[0].reads = 100;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "32K; 75%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 32768;
-	spec->access[0].reads   = 75;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "32K; 75%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 32768;
+	spec->access[0].reads = 75;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "32K; 50%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 32768;
-	spec->access[0].reads   = 50;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "32K; 50%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 32768;
+	spec->access[0].reads = 50;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "32K; 25%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 32768;
-	spec->access[0].reads   = 25;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "32K; 25%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 32768;
+	spec->access[0].reads = 25;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "32K; 0%% Read; 0%% random" );
-	spec->access[0].of_size	= 100;
-	spec->access[0].size	= 32768;
-	spec->access[0].reads   = 0;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	_snprintf(spec->name, MAX_NAME, "32K; 0%% Read; 0%% random");
+	spec->access[0].of_size = 100;
+	spec->access[0].size = 32768;
+	spec->access[0].reads = 0;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
 	// Brings all specifications into one
 
 	spec = New();
-	_snprintf( spec->name, MAX_NAME, "All in one" );
+	_snprintf(spec->name, MAX_NAME, "All in one");
 
-	spec->access[0].of_size	= 5;
-	spec->access[0].size	= 512;
-	spec->access[0].reads   = 100;
-	spec->access[0].random	= 0;
-	spec->access[0].delay	= 0;
-	spec->access[0].burst	= 1;
-	spec->access[0].align	= 0;
-	spec->access[0].reply	= 0;
+	spec->access[0].of_size = 5;
+	spec->access[0].size = 512;
+	spec->access[0].reads = 100;
+	spec->access[0].random = 0;
+	spec->access[0].delay = 0;
+	spec->access[0].burst = 1;
+	spec->access[0].align = 0;
+	spec->access[0].reply = 0;
 
-	spec->access[1].of_size	= 5;
-	spec->access[1].size	= 512;
-	spec->access[1].reads   = 75;
-	spec->access[1].random	= 0;
-	spec->access[1].delay	= 0;
-	spec->access[1].burst	= 1;
-	spec->access[1].align	= 0;
-	spec->access[1].reply	= 0;
+	spec->access[1].of_size = 5;
+	spec->access[1].size = 512;
+	spec->access[1].reads = 75;
+	spec->access[1].random = 0;
+	spec->access[1].delay = 0;
+	spec->access[1].burst = 1;
+	spec->access[1].align = 0;
+	spec->access[1].reply = 0;
 
-	spec->access[2].of_size	= 5;
-	spec->access[2].size	= 512;
-	spec->access[2].reads   = 50;
-	spec->access[2].random	= 0;
-	spec->access[2].delay	= 0;
-	spec->access[2].burst	= 1;
-	spec->access[2].align	= 0;
-	spec->access[2].reply	= 0;
+	spec->access[2].of_size = 5;
+	spec->access[2].size = 512;
+	spec->access[2].reads = 50;
+	spec->access[2].random = 0;
+	spec->access[2].delay = 0;
+	spec->access[2].burst = 1;
+	spec->access[2].align = 0;
+	spec->access[2].reply = 0;
 
-	spec->access[3].of_size	= 5;
-	spec->access[3].size	= 512;
-	spec->access[3].reads   = 25;
-	spec->access[3].random	= 0;
-	spec->access[3].delay	= 0;
-	spec->access[3].burst	= 1;
-	spec->access[3].align	= 0;
-	spec->access[3].reply	= 0;
+	spec->access[3].of_size = 5;
+	spec->access[3].size = 512;
+	spec->access[3].reads = 25;
+	spec->access[3].random = 0;
+	spec->access[3].delay = 0;
+	spec->access[3].burst = 1;
+	spec->access[3].align = 0;
+	spec->access[3].reply = 0;
 
-	spec->access[4].of_size	= 5;
-	spec->access[4].size	= 512;
-	spec->access[4].reads   = 0;
-	spec->access[4].random	= 0;
-	spec->access[4].delay	= 0;
-	spec->access[4].burst	= 1;
-	spec->access[4].align	= 0;
-	spec->access[4].reply	= 0;
+	spec->access[4].of_size = 5;
+	spec->access[4].size = 512;
+	spec->access[4].reads = 0;
+	spec->access[4].random = 0;
+	spec->access[4].delay = 0;
+	spec->access[4].burst = 1;
+	spec->access[4].align = 0;
+	spec->access[4].reply = 0;
 
-	spec->access[5].of_size	= 5;
-	spec->access[5].size	= 4096;
-	spec->access[5].reads   = 100;
-	spec->access[5].random	= 0;
-	spec->access[5].delay	= 0;
-	spec->access[5].burst	= 1;
-	spec->access[5].align	= 0;
-	spec->access[5].reply	= 0;
+	spec->access[5].of_size = 5;
+	spec->access[5].size = 4096;
+	spec->access[5].reads = 100;
+	spec->access[5].random = 0;
+	spec->access[5].delay = 0;
+	spec->access[5].burst = 1;
+	spec->access[5].align = 0;
+	spec->access[5].reply = 0;
 
-	spec->access[6].of_size	= 5;
-	spec->access[6].size	= 4096;
-	spec->access[6].reads   = 75;
-	spec->access[6].random	= 0;
-	spec->access[6].delay	= 0;
-	spec->access[6].burst	= 1;
-	spec->access[6].align	= 0;
-	spec->access[6].reply	= 0;
+	spec->access[6].of_size = 5;
+	spec->access[6].size = 4096;
+	spec->access[6].reads = 75;
+	spec->access[6].random = 0;
+	spec->access[6].delay = 0;
+	spec->access[6].burst = 1;
+	spec->access[6].align = 0;
+	spec->access[6].reply = 0;
 
-	spec->access[7].of_size	= 5;
-	spec->access[7].size	= 4096;
-	spec->access[7].reads   = 50;
-	spec->access[7].random	= 0;
-	spec->access[7].delay	= 0;
-	spec->access[7].burst	= 1;
-	spec->access[7].align	= 0;
-	spec->access[7].reply	= 0;
+	spec->access[7].of_size = 5;
+	spec->access[7].size = 4096;
+	spec->access[7].reads = 50;
+	spec->access[7].random = 0;
+	spec->access[7].delay = 0;
+	spec->access[7].burst = 1;
+	spec->access[7].align = 0;
+	spec->access[7].reply = 0;
 
-	spec->access[8].of_size	= 5;
-	spec->access[8].size	= 4096;
-	spec->access[8].reads   = 25;
-	spec->access[8].random	= 0;
-	spec->access[8].delay	= 0;
-	spec->access[8].burst	= 1;
-	spec->access[8].align	= 0;
-	spec->access[8].reply	= 0;
+	spec->access[8].of_size = 5;
+	spec->access[8].size = 4096;
+	spec->access[8].reads = 25;
+	spec->access[8].random = 0;
+	spec->access[8].delay = 0;
+	spec->access[8].burst = 1;
+	spec->access[8].align = 0;
+	spec->access[8].reply = 0;
 
-	spec->access[9].of_size	= 5;
-	spec->access[9].size	= 4096;
-	spec->access[9].reads   = 0;
-	spec->access[9].random	= 0;
-	spec->access[9].delay	= 0;
-	spec->access[9].burst	= 1;
-	spec->access[9].align	= 0;
-	spec->access[9].reply	= 0;
+	spec->access[9].of_size = 5;
+	spec->access[9].size = 4096;
+	spec->access[9].reads = 0;
+	spec->access[9].random = 0;
+	spec->access[9].delay = 0;
+	spec->access[9].burst = 1;
+	spec->access[9].align = 0;
+	spec->access[9].reply = 0;
 
-	spec->access[10].of_size	= 5;
-	spec->access[10].size		= 16384;
-	spec->access[10].reads		= 100;
-	spec->access[10].random		= 0;
-	spec->access[10].delay		= 0;
-	spec->access[10].burst		= 1;
-	spec->access[10].align		= 0;
-	spec->access[10].reply		= 0;
+	spec->access[10].of_size = 5;
+	spec->access[10].size = 16384;
+	spec->access[10].reads = 100;
+	spec->access[10].random = 0;
+	spec->access[10].delay = 0;
+	spec->access[10].burst = 1;
+	spec->access[10].align = 0;
+	spec->access[10].reply = 0;
 
-	spec->access[11].of_size	= 5;
-	spec->access[11].size		= 16384;
-	spec->access[11].reads		= 75;
-	spec->access[11].random		= 0;
-	spec->access[11].delay		= 0;
-	spec->access[11].burst		= 1;
-	spec->access[11].align		= 0;
-	spec->access[11].reply		= 0;
+	spec->access[11].of_size = 5;
+	spec->access[11].size = 16384;
+	spec->access[11].reads = 75;
+	spec->access[11].random = 0;
+	spec->access[11].delay = 0;
+	spec->access[11].burst = 1;
+	spec->access[11].align = 0;
+	spec->access[11].reply = 0;
 
-	spec->access[12].of_size	= 5;
-	spec->access[12].size		= 16384;
-	spec->access[12].reads		= 50;
-	spec->access[12].random		= 0;
-	spec->access[12].delay		= 0;
-	spec->access[12].burst		= 1;
-	spec->access[12].align		= 0;
-	spec->access[12].reply		= 0;
+	spec->access[12].of_size = 5;
+	spec->access[12].size = 16384;
+	spec->access[12].reads = 50;
+	spec->access[12].random = 0;
+	spec->access[12].delay = 0;
+	spec->access[12].burst = 1;
+	spec->access[12].align = 0;
+	spec->access[12].reply = 0;
 
-	spec->access[13].of_size	= 5;
-	spec->access[13].size		= 16384;
-	spec->access[13].reads		= 25;
-	spec->access[13].random		= 0;
-	spec->access[13].delay		= 0;
-	spec->access[13].burst		= 1;
-	spec->access[13].align		= 0;
-	spec->access[13].reply		= 0;
+	spec->access[13].of_size = 5;
+	spec->access[13].size = 16384;
+	spec->access[13].reads = 25;
+	spec->access[13].random = 0;
+	spec->access[13].delay = 0;
+	spec->access[13].burst = 1;
+	spec->access[13].align = 0;
+	spec->access[13].reply = 0;
 
-	spec->access[14].of_size	= 5;
-	spec->access[14].size		= 16384;
-	spec->access[14].reads		= 0;
-	spec->access[14].random		= 0;
-	spec->access[14].delay		= 0;
-	spec->access[14].burst		= 1;
-	spec->access[14].align		= 0;
-	spec->access[14].reply		= 0;
+	spec->access[14].of_size = 5;
+	spec->access[14].size = 16384;
+	spec->access[14].reads = 0;
+	spec->access[14].random = 0;
+	spec->access[14].delay = 0;
+	spec->access[14].burst = 1;
+	spec->access[14].align = 0;
+	spec->access[14].reply = 0;
 
-	spec->access[15].of_size	= 5;
-	spec->access[15].size		= 32768;
-	spec->access[15].reads		= 100;
-	spec->access[15].random		= 0;
-	spec->access[15].delay		= 0;
-	spec->access[15].burst		= 1;
-	spec->access[15].align		= 0;
-	spec->access[15].reply		= 0;
+	spec->access[15].of_size = 5;
+	spec->access[15].size = 32768;
+	spec->access[15].reads = 100;
+	spec->access[15].random = 0;
+	spec->access[15].delay = 0;
+	spec->access[15].burst = 1;
+	spec->access[15].align = 0;
+	spec->access[15].reply = 0;
 
-	spec->access[16].of_size	= 5;
-	spec->access[16].size		= 32768;
-	spec->access[16].reads		= 75;
-	spec->access[16].random		= 0;
-	spec->access[16].delay		= 0;
-	spec->access[16].burst		= 1;
-	spec->access[16].align		= 0;
-	spec->access[16].reply		= 0;
+	spec->access[16].of_size = 5;
+	spec->access[16].size = 32768;
+	spec->access[16].reads = 75;
+	spec->access[16].random = 0;
+	spec->access[16].delay = 0;
+	spec->access[16].burst = 1;
+	spec->access[16].align = 0;
+	spec->access[16].reply = 0;
 
-	spec->access[17].of_size	= 5;
-	spec->access[17].size		= 32768;
-	spec->access[17].reads		= 50;
-	spec->access[17].random		= 0;
-	spec->access[17].delay		= 0;
-	spec->access[17].burst		= 1;
-	spec->access[17].align		= 0;
-	spec->access[17].reply		= 0;
+	spec->access[17].of_size = 5;
+	spec->access[17].size = 32768;
+	spec->access[17].reads = 50;
+	spec->access[17].random = 0;
+	spec->access[17].delay = 0;
+	spec->access[17].burst = 1;
+	spec->access[17].align = 0;
+	spec->access[17].reply = 0;
 
-	spec->access[18].of_size	= 5;
-	spec->access[18].size		= 32768;
-	spec->access[18].reads		= 25;
-	spec->access[18].random		= 0;
-	spec->access[18].delay		= 0;
-	spec->access[18].burst		= 1;
-	spec->access[18].align		= 0;
-	spec->access[18].reply		= 0;
+	spec->access[18].of_size = 5;
+	spec->access[18].size = 32768;
+	spec->access[18].reads = 25;
+	spec->access[18].random = 0;
+	spec->access[18].delay = 0;
+	spec->access[18].burst = 1;
+	spec->access[18].align = 0;
+	spec->access[18].reply = 0;
 
-	spec->access[19].of_size	= 5;
-	spec->access[19].size		= 32768;
-	spec->access[19].reads		= 0;
-	spec->access[19].random		= 0;
-	spec->access[19].delay		= 0;
-	spec->access[19].burst		= 1;
-	spec->access[19].align		= 0;
-	spec->access[19].reply		= 0;
+	spec->access[19].of_size = 5;
+	spec->access[19].size = 32768;
+	spec->access[19].reads = 0;
+	spec->access[19].random = 0;
+	spec->access[19].delay = 0;
+	spec->access[19].burst = 1;
+	spec->access[19].align = 0;
+	spec->access[19].reply = 0;
 
-	spec->access[20].of_size	= IOERROR;
+	spec->access[20].of_size = IOERROR;
 }
 
-
-
 //
 // Removes all AccessSpecObjects form memory and removes all references 
 // from the pointer array.
@@ -568,116 +561,103 @@
 	DeleteAll();
 }
 
-
-
 //
 // Creates a new AccessSpecObject and adds a pointer to it to the end of
 // the pointer array.
 //
-Test_Spec* AccessSpecList::New()
+Test_Spec *AccessSpecList::New()
 {
-	Test_Spec* spec = new Test_Spec;
-	if ( !spec )
+	Test_Spec *spec = new Test_Spec;
+
+	if (!spec)
 		return NULL;
 	// Make the default new access spec
-	InitAccessSpecLine(&(spec->access[0]));	
+	InitAccessSpecLine(&(spec->access[0]));
 	spec->access[1].of_size = IOERROR;
 
 	// Set the access spec to not load by default.
 	spec->default_assignment = FALSE;
-	
+
 	// Name the new access spec.
-	NextUntitled( spec->name );
+	NextUntitled(spec->name);
 
 	// Add the new access spec to the end of the array.
-	spec_list.Add( spec );
+	spec_list.Add(spec);
 
 	// Return the index in the pointer array of the newly added object's pointer.
 	return spec;
 }
 
-
-
 //
 // Creates a copy of the specified access spec, and returns a copy.
 //
-Test_Spec* AccessSpecList::Copy( Test_Spec *source_spec )
+Test_Spec *AccessSpecList::Copy(Test_Spec * source_spec)
 {
 	int copy_number;
 	CString name;
-	Test_Spec* spec;
+	Test_Spec *spec;
 
 	// Create a new spec and check the validity of source_spec.
-	if ( !(spec = New()) || IndexByRef( source_spec ) == IOERROR )
+	if (!(spec = New()) || IndexByRef(source_spec) == IOERROR)
 		return NULL;
 
 	// Copy the source spec into the newly created one.
-	memcpy( spec, source_spec, sizeof Test_Spec );
+	memcpy(spec, source_spec, sizeof Test_Spec);
 
 	// Assign a unique name: Copy of 'name of source spec' ('unique copy number').
-	name.Format( "Copy of %s", spec->name );
+	name.Format("Copy of %s", spec->name);
 	copy_number = 1;
-	do
-	{
-		sprintf( spec->name, "%s (%d)", name, copy_number++ );
-	}
-	while ( RefByName( spec->name ) != spec );
+	do {
+		sprintf(spec->name, "%s (%d)", name, copy_number++);
+	} while (RefByName(spec->name) != spec);
 
 	return spec;
 }
 
-
-
 //
 // Deletes the specified Test_Spec object, as well as the related entry in 
 // the pointer array.  Also removes any reference that spec by any worker.
 //
-void AccessSpecList::Delete( Test_Spec *spec )
+void AccessSpecList::Delete(Test_Spec * spec)
 {
 	// Check for an invalid pointer.
-	if ( IndexByRef( spec ) == IOERROR )
+	if (IndexByRef(spec) == IOERROR)
 		return;
 
 	// Remove any references to this access spec from the workers.
-	theApp.manager_list.RemoveAccessSpec( spec );
+	theApp.manager_list.RemoveAccessSpec(spec);
 
 	// Remove the reference to the access spec from the array.
-	spec_list.RemoveAt( IndexByRef( spec ) );
+	spec_list.RemoveAt(IndexByRef(spec));
 
 	// Remove the access spec from memory.
 	delete spec;
 }
 
-
-
 //
 // Deletes all the access spec objects and their related entries.
 //
 void AccessSpecList::DeleteAll()
 {
-	while ( spec_list.GetSize() )
-	{
-		delete spec_list[ spec_list.GetUpperBound() ];
-		spec_list.RemoveAt( spec_list.GetUpperBound() );
+	while (spec_list.GetSize()) {
+		delete spec_list[spec_list.GetUpperBound()];
+
+		spec_list.RemoveAt(spec_list.GetUpperBound());
 	}
 	theApp.manager_list.RemoveAllAccessSpecs();
 }
 
-
-
 //
 // Returns the pointer to the access spec object specified by the index.
 //
-Test_Spec* AccessSpecList::Get(int index)
+Test_Spec *AccessSpecList::Get(int index)
 {
-	if ( index >= 0 && index < spec_list.GetSize() )
+	if (index >= 0 && index < spec_list.GetSize())
 		return spec_list[index];
 	else
 		return NULL;
 }
 
-
-
 //
 // Returns the number of entries in the array.
 //
@@ -686,50 +666,44 @@
 	return spec_list.GetSize();
 }
 
-
-
 //
 // Returns a pointer to a spec of a given name, if it exists.
 //
-Test_Spec* AccessSpecList::RefByName( const char* check_name )
+Test_Spec *AccessSpecList::RefByName(const char *check_name)
 {
 	Test_Spec *spec;
 	int spec_count = spec_list.GetSize();
-	for ( int s = 0; s < spec_count; s++ )
-	{
-		spec = Get( s );
-		if ( _stricmp( spec->name, check_name ) == 0 )
+
+	for (int s = 0; s < spec_count; s++) {
+		spec = Get(s);
+		if (_stricmp(spec->name, check_name) == 0)
 			return spec;
 	}
 	return NULL;
 }
 
-
-
 //
 // Returns the index of a spec given a reference to that spec.
 // This function is used to validate spec pointers.
 // Also used in Delete() to index into the array, and in 
 // Save() to determine which specs where running. 
 //
-int AccessSpecList::IndexByRef( const Test_Spec* spec )
+int AccessSpecList::IndexByRef(const Test_Spec * spec)
 {
 	int spec_count = spec_list.GetSize();
-	for ( int index = 0; index < spec_count; index++ )
-	{
-		if ( Get( index ) == spec )
+
+	for (int index = 0; index < spec_count; index++) {
+		if (Get(index) == spec)
 			return index;
 	}
 	return IOERROR;
 }
 
-
-
 //
 // Saving the access specification list to a result file.
 // Saves only the currently active access specs.
 //
-BOOL AccessSpecList::SaveResults( ostream& outfile )
+BOOL AccessSpecList::SaveResults(ostream & outfile)
 {
 	int i, j;
 	int access_count, manager_count, worker_count, current_access_index;
@@ -741,12 +715,11 @@
 	outfile << "'Access specifications" << endl;
 
 	access_count = Count();
-	spec_active = new BOOL[ access_count ];
+	spec_active = new BOOL[access_count];
 
 	// Determine which access specs are active for the current test
 	// Start by marking all access specs inactive.
-	for ( i = 1; i < access_count; i++ )
-	{
+	for (i = 1; i < access_count; i++) {
 		spec_active[i] = FALSE;
 	}
 
@@ -754,28 +727,23 @@
 	// Now go through all the workers and mark each worker's current access spec 
 	// as active, IF the worker is actually doing anything in this test.
 	manager_count = theApp.manager_list.ManagerCount();
-	for ( i = 0; i < manager_count; i++ )
-	{
-		mgr = theApp.manager_list.GetManager( i );
+	for (i = 0; i < manager_count; i++) {
+		mgr = theApp.manager_list.GetManager(i);
 		worker_count = mgr->WorkerCount();
-		for ( j = 0; j < worker_count; j++ )
-		{
-			wkr = mgr->GetWorker( j );
-			if ( wkr->ActiveInCurrentTest() )
-			{
-				spec_active[ IndexByRef( wkr->GetAccessSpec( 
-								current_access_index ) ) ] = TRUE;
+		for (j = 0; j < worker_count; j++) {
+			wkr = mgr->GetWorker(j);
+			if (wkr->ActiveInCurrentTest()) {
+				spec_active[IndexByRef(wkr->GetAccessSpec(current_access_index))] = TRUE;
 			}
 		}
 	}
 
 	// Save all the active access specs except the idle spec.
-	for ( i = 1; i < access_count; i++ )
-	{
-		if ( !spec_active[i] )
+	for (i = 1; i < access_count; i++) {
+		if (!spec_active[i])
 			continue;
 
-		spec = Get( i );
+		spec = Get(i);
 
 		outfile << "'Access specification name,default assignment" << endl;
 		outfile << spec->name << "," << spec->default_assignment << endl;
@@ -783,19 +751,17 @@
 		// Write access specifications to a file, data comma separated.
 		outfile << "'size,% of size,% reads,% random,delay,burst,align,reply" << endl;
 
-		for ( int line_index = 0; line_index < MAX_ACCESS_SPECS; line_index++ )
-		{
-			if ( spec->access[line_index].of_size == IOERROR )
+		for (int line_index = 0; line_index < MAX_ACCESS_SPECS; line_index++) {
+			if (spec->access[line_index].of_size == IOERROR)
 				break;
 			outfile
-				<< spec->access[line_index].size << ","
-				<< spec->access[line_index].of_size << ","
-				<< spec->access[line_index].reads << ","
-				<< spec->access[line_index].random << ","
-				<< spec->access[line_index].delay << ","
-				<< spec->access[line_index].burst << ","
-				<< spec->access[line_index].align << ","
-				<< spec->access[line_index].reply << endl;
+			    << spec->access[line_index].size << ","
+			    << spec->access[line_index].of_size << ","
+			    << spec->access[line_index].reads << ","
+			    << spec->access[line_index].random << ","
+			    << spec->access[line_index].delay << ","
+			    << spec->access[line_index].burst << ","
+			    << spec->access[line_index].align << "," << spec->access[line_index].reply << endl;
 		}
 	}
 
@@ -806,8 +772,6 @@
 	return TRUE;
 }
 
-
-
 //
 // Saves the access specification list to a config file.
 // Saves ALL specs, whether they are active or not.
@@ -816,27 +780,24 @@
 // functions was identical, but there are differences now, and there will
 // continue to be more in the future.
 //
-BOOL AccessSpecList::SaveConfig( ostream& outfile )
+BOOL AccessSpecList::SaveConfig(ostream & outfile)
 {
 	int i, line_index;
 	int access_count;
 	Test_Spec *spec;
 
-	outfile << "'ACCESS SPECIFICATIONS ================="
-			   "========================================" << endl;
+	outfile << "'ACCESS SPECIFICATIONS =================" "========================================" << endl;
 
 	access_count = Count();
 
 	// Save all the active access specs except the idle spec (0).
-	for ( i = 1; i < access_count; i++ )
-	{
-		spec = Get( i );
+	for (i = 1; i < access_count; i++) {
+		spec = Get(i);
 
 		outfile << "'Access specification name,default assignment" << endl;
 		outfile << "\t" << spec->name << ",";
-		
-		switch (spec->default_assignment)
-		{
+
+		switch (spec->default_assignment) {
 		case AssignNone:
 			outfile << "NONE" << endl;
 			break;
@@ -851,26 +812,24 @@
 			break;
 		default:
 			ErrorMessage("Error saving access specification list.  Access specification "
-					+ (CString)spec->name + " has an illegal default assignment.");
+				     + (CString) spec->name + " has an illegal default assignment.");
 			return FALSE;
 		}
 
 		// Write access specifications to a file, data comma separated.
 		outfile << "'size,% of size,% reads,% random,delay,burst,align,reply" << endl;
 
-		for ( line_index = 0; line_index < MAX_ACCESS_SPECS; line_index++ )
-		{
-			if ( spec->access[line_index].of_size == IOERROR )
+		for (line_index = 0; line_index < MAX_ACCESS_SPECS; line_index++) {
+			if (spec->access[line_index].of_size == IOERROR)
 				break;
 			outfile << "\t"
-				<< spec->access[line_index].size << ","
-				<< spec->access[line_index].of_size << ","
-				<< spec->access[line_index].reads << ","
-				<< spec->access[line_index].random << ","
-				<< spec->access[line_index].delay << ","
-				<< spec->access[line_index].burst << ","
-				<< spec->access[line_index].align << ","
-				<< spec->access[line_index].reply << endl;
+			    << spec->access[line_index].size << ","
+			    << spec->access[line_index].of_size << ","
+			    << spec->access[line_index].reads << ","
+			    << spec->access[line_index].random << ","
+			    << spec->access[line_index].delay << ","
+			    << spec->access[line_index].burst << ","
+			    << spec->access[line_index].align << "," << spec->access[line_index].reply << endl;
 		}
 	}
 
@@ -879,8 +838,6 @@
 	return TRUE;
 }
 
-
-
 //
 // Checks the config file version number and calls the appropriate load function.
 // Also handles the replace flag.
@@ -888,14 +845,13 @@
 // If replace is TRUE, all access specs are removed before the restore,
 // otherwise, the loaded specs are merged with the preexisting specs.
 //
-BOOL AccessSpecList::LoadConfig( const CString& infilename, BOOL replace )
+BOOL AccessSpecList::LoadConfig(const CString & infilename, BOOL replace)
 {
 	ICF_ifstream infile(infilename);
 	long version;
 	BOOL retval;
 
-	if ( replace )
-	{
+	if (replace) {
 		// Clear memory and display before loading accesses.
 		DeleteAll();
 		InsertIdleSpec();
@@ -905,25 +861,22 @@
 	if (version == -1)
 		return FALSE;
 
-	if ( !infile.SkipTo("'ACCESS SPECIFICATIONS") )
+	if (!infile.SkipTo("'ACCESS SPECIFICATIONS"))
 		return TRUE;	// no access spec list to restore (this is OK)
 
 	// Check to see whether to load a per-worker access spec, or an old style access spec.
-	if ( version >= 19980521 )
-	{
+	if (version >= 19980521) {
 		retval = LoadConfigNew(infile);
 
 		// There's no need to assign the default access specs here.
 		// They will be assigned automatically when workers are created
 		// (by the Worker constructor itself), and they will be removed
 		// by the Manager::LoadConfig code if they shouldn't be assigned.
-	}
-	else
-	{
+	} else {
 		retval = LoadConfigOld(infile);
 
 		// If replacing, assign default specs to workers.
-		if ( replace )
+		if (replace)
 			theApp.manager_list.AssignDefaultAccessSpecs();
 	}
 
@@ -932,91 +885,77 @@
 	return retval;
 }
 
-
-
 //
 // Loads the global access spec list from a file.
 // Does not support old style saved configurations.
 //
-BOOL AccessSpecList::LoadConfigNew( ICF_ifstream& infile )
+BOOL AccessSpecList::LoadConfigNew(ICF_ifstream & infile)
 {
 	CString key, value;
 	CString token;
 	int line_index;
 	int total_access;
-	Test_Spec* spec;
+	Test_Spec *spec;
 
-	while (1)
-	{
-		if ( !infile.GetPair(key, value) )
-		{
+	while (1) {
+		if (!infile.GetPair(key, value)) {
 			ErrorMessage("File is improperly formatted.  Expected an "
-				"access specification or \"END access specifications\".");
+				     "access specification or \"END access specifications\".");
 			return FALSE;
 		}
 
-		if ( key.CompareNoCase("'END access specifications") == 0 )
-		{
+		if (key.CompareNoCase("'END access specifications") == 0) {
 			break;
 		}
-		if ( key.CompareNoCase("'Access specification name,default assignment") == 0 )
-		{
-			if ( spec = RefByName( (LPCTSTR)value.Left( value.Find( ',' ) ) ) )
-			{
+		if (key.CompareNoCase("'Access specification name,default assignment") == 0) {
+			if (spec = RefByName((LPCTSTR) value.Left(value.Find(',')))) {
 #ifdef VERBOSE
-				ErrorMessage( "An access specification named \""
-					+ value.Left( value.Find( ',' ) )
-					+ "\" already exists.  It will be replaced by "
-					"the new access specification." );
+				ErrorMessage("An access specification named \"" + value.Left(value.Find(','))
+					     + "\" already exists.  It will be replaced by "
+					     "the new access specification.");
 #endif
-			}
-			else
-			{
+			} else {
 				// No previous access spec by this name.  Create a new one.
 				spec = New();
 
 				// Sanity check.
-				if ( !spec )
-				{
-					ErrorMessage( "Error while loading file.  Out of memory.  "
-						"Error occured in AccessSpecList::LoadConfig()" );
+				if (!spec) {
+					ErrorMessage("Error while loading file.  Out of memory.  "
+						     "Error occured in AccessSpecList::LoadConfig()");
 					return FALSE;
 				}
 			}
 
 			// Fill in the name.
 			token = ICF_ifstream::ExtractFirstToken(value, TRUE);
-			strcpy( spec->name, (LPCTSTR)token );
+			strcpy(spec->name, (LPCTSTR) token);
 
 			// Read the default assignment.
 			token = ICF_ifstream::ExtractFirstToken(value);
-			if ( token.CompareNoCase("NONE") == 0 )
+			if (token.CompareNoCase("NONE") == 0)
 				spec->default_assignment = AssignNone;
-			else if ( token.CompareNoCase("ALL") == 0 )
+			else if (token.CompareNoCase("ALL") == 0)
 				spec->default_assignment = AssignAll;
-			else if ( token.CompareNoCase("DISK") == 0 )
+			else if (token.CompareNoCase("DISK") == 0)
 				spec->default_assignment = AssignDisk;
-			else if ( token.CompareNoCase("NET") == 0 )
+			else if (token.CompareNoCase("NET") == 0)
 				spec->default_assignment = AssignNet;
 			else
-				spec->default_assignment = atoi( (LPCTSTR)token );
+				spec->default_assignment = atoi((LPCTSTR) token);
 
 			key = infile.GetNextLine();
-			if (key.GetAt(0) != '\'')
-			{
+			if (key.GetAt(0) != '\'') {
 				ErrorMessage("File is improperly formatted.  Expected a "
-					"comment line to follow the access specification name.");
+					     "comment line to follow the access specification name.");
 				return FALSE;
 			}
-
 			// Get the details of the access spec.
 
 			line_index = 0;
 			total_access = 0;
 
 			// Read lines until total percentage reaches 100.
-			while (infile.peek() != '\'')
-			{
+			while (infile.peek() != '\'') {
 				char comma;	// Used to throw commas away.
 
 				infile >> spec->access[line_index].size >> comma;
@@ -1030,16 +969,14 @@
 				infile.GetNextLine();
 
 				// Sanity check.
-				if ( spec->access[line_index].of_size > 100	|| 
-					 spec->access[line_index].reads > 100	|| 
-					 spec->access[line_index].random > 100	|| 
-					 spec->access[line_index].of_size < 0	|| 
-					 spec->access[line_index].reads < 0		|| 	
-					 spec->access[line_index].random < 0 )
-				{
-					Delete( spec );
-					ErrorMessage( "Error loading global access specifications.  "
-						"Invalid value encountered." );
+				if (spec->access[line_index].of_size > 100 ||
+				    spec->access[line_index].reads > 100 ||
+				    spec->access[line_index].random > 100 ||
+				    spec->access[line_index].of_size < 0 ||
+				    spec->access[line_index].reads < 0 || spec->access[line_index].random < 0) {
+					Delete(spec);
+					ErrorMessage("Error loading global access specifications.  "
+						     "Invalid value encountered.");
 					return FALSE;
 				}
 
@@ -1048,24 +985,20 @@
 			}
 
 			// Mark the end of the access spec.
-			if ( line_index <= MAX_ACCESS_SPECS )
+			if (line_index <= MAX_ACCESS_SPECS)
 				spec->access[line_index].of_size = IOERROR;
 
 			// Sanity check.
-			if ( total_access != 100 )
-			{
-				ErrorMessage( "Error loading global access specifications.  "
-					"Percentages don't add to 100." );
-				Delete( spec );
+			if (total_access != 100) {
+				ErrorMessage("Error loading global access specifications.  "
+					     "Percentages don't add to 100.");
+				Delete(spec);
 				return FALSE;
 			}
 
-		}
-		else
-		{
+		} else {
 			ErrorMessage("File is improperly formatted.  Global ACCESS "
-				"SPECIFICATION section contained an unrecognized \""
-				+ key + "\" comment.");
+				     "SPECIFICATION section contained an unrecognized \"" + key + "\" comment.");
 			return FALSE;
 		}
 	}
@@ -1073,92 +1006,79 @@
 	return TRUE;
 }
 
-
-
 //
 // Loads an old style access spec.
 //
-BOOL AccessSpecList::LoadConfigOld( ICF_ifstream& infile )
+BOOL AccessSpecList::LoadConfigOld(ICF_ifstream & infile)
 {
 	int total_access;
 	int line_index;
-	Test_Spec* spec;
+	Test_Spec *spec;
 	char comment[100];
 
 	// Read and discard initial comment line.
-	infile.getline( comment, 100 );
-	
+	infile.getline(comment, 100);
+
 	// Create new test spec.
 	spec = New();
 	line_index = 0;
 	total_access = 0;
 
 	// Get access specs from the file until an error occurs or all specs have been read in.
-	while ( !infile.rdstate() )
-	{
+	while (!infile.rdstate()) {
 		// Read in specifications until another comment is read in from the file.
 		// This signifies the end of the access spec portion.
-		if ( infile.peek() == '\'' || infile.peek() == EOF )
-		{
+		if (infile.peek() == '\'' || infile.peek() == EOF) {
 			// Delete the last spec created.
-			if ( spec )
-				Delete( spec );
-			
+			if (spec)
+				Delete(spec);
+
 			return TRUE;
 		}
-		
 		// Sanity check.
-		if ( !spec )
-		{
-			ErrorMessage( "Error allocating memory for access specification." );
+		if (!spec) {
+			ErrorMessage("Error allocating memory for access specification.");
 			return FALSE;
 		}
 
-		InitAccessSpecLine( &(spec->access[line_index]) );
+		InitAccessSpecLine(&(spec->access[line_index]));
 		infile >> spec->access[line_index].size;
 		infile >> spec->access[line_index].of_size;
 		infile >> spec->access[line_index].reads;
 		infile >> spec->access[line_index].random;
 		infile >> spec->access[line_index].delay;
 		infile >> spec->access[line_index].burst;
-		infile.ignore( 1, '\n' );
+		infile.ignore(1, '\n');
 
 		// Sanity check.
-		if ( spec->access[line_index].of_size > 100	|| 
-			 spec->access[line_index].reads > 100	|| 
-			 spec->access[line_index].random > 100	|| 
-			 spec->access[line_index].of_size < 0	|| 
-			 spec->access[line_index].reads < 0		|| 	
-			 spec->access[line_index].random < 0 )
-		{
+		if (spec->access[line_index].of_size > 100 ||
+		    spec->access[line_index].reads > 100 ||
+		    spec->access[line_index].random > 100 ||
+		    spec->access[line_index].of_size < 0 ||
+		    spec->access[line_index].reads < 0 || spec->access[line_index].random < 0) {
 			break;
 		}
-
 		// Skip lines that make up "0%" of the access.
-		if ( spec->access[line_index].of_size )
-		{
+		if (spec->access[line_index].of_size) {
 			total_access += spec->access[line_index].of_size;
 			line_index++;
+		} else {
+			ErrorMessage("Found an access specification line that makes up 0% of the test.  "
+				     "This line will be discarded.");
 		}
-		else
-		{
-			ErrorMessage( "Found an access specification line that makes up 0% of the test.  "
-						   "This line will be discarded." );
-		}
 
 		// Sanity check.
-		if ( total_access > 100 )
+		if (total_access > 100)
 			break;
-		
+
 		// Mark the end of the access spec if needed.
-		if ( total_access == 100 )
-		{
+		if (total_access == 100) {
 			spec->default_assignment = AssignAll;
-			if ( line_index <= MAX_ACCESS_SPECS )
+			if (line_index <= MAX_ACCESS_SPECS)
 				spec->access[line_index].of_size = IOERROR;
-	
+
 			// Try smart naming if possible.
-			SmartName( spec );
+			SmartName(spec);
 
 			// Create new test spec.
 			spec = New();
@@ -1170,19 +1090,17 @@
 	}
 
 	// Delete the last spec created.
-	if ( spec )
-		Delete( spec );
+	if (spec)
+		Delete(spec);
 
-	ErrorMessage( "Error loading access specification.  Invalid access specification." );
+	ErrorMessage("Error loading access specification.  Invalid access specification.");
 	return FALSE;
 }
 
-
-
 //
 // This function initializes a line of an access spec to the default values.
 //
-void AccessSpecList::InitAccessSpecLine(Access_Spec* spec_line)
+void AccessSpecList::InitAccessSpecLine(Access_Spec * spec_line)
 {
 	spec_line->size = 2048;
 	spec_line->of_size = 100;
@@ -1194,54 +1112,46 @@
 	spec_line->reply = 0;
 }
 
-
-
 //
 // This function will return an integer that will be the next sequential 
 // n for naming "Untitled n" access specs.
 //
-void AccessSpecList::NextUntitled( char *name )
+void AccessSpecList::NextUntitled(char *name)
 {
 	int next_number = 0;
 	CString current_name;
 
 	// Counting the number of "Untitled *" specs.
-	for ( int index = 0; index < spec_list.GetSize(); index++ )
-	{
+	for (int index = 0; index < spec_list.GetSize(); index++) {
 		current_name = Get(index)->name;
-		if (current_name.Find("Untitled") == 0)
-		{
+		if (current_name.Find("Untitled") == 0) {
 			++next_number;
 		}
 	}
 
 	// Ensure that names are not duplicated.
-	do
-	{
+	do {
 		// We have the current number, so we add 1 for the next number.
-		sprintf( name, "Untitled %d", ++next_number );
+		sprintf(name, "Untitled %d", ++next_number);
 	}
-	while ( RefByName( name ) );
+	while (RefByName(name));
 }
 
-
-
 //
 // Assigning a reasonable name to an older access spec that doesn't have one.
 //
-void AccessSpecList::SmartName( Test_Spec* spec )
+void AccessSpecList::SmartName(Test_Spec * spec)
 {
-	CString	name;
-	int		spec_number = 1;
-	int		name_size;
+	CString name;
+	int spec_number = 1;
+	int name_size;
 
 	// Verify that smart naming is possible.
-	if ( spec->access[1].of_size != IOERROR )
-		return;	// use existing name
+	if (spec->access[1].of_size != IOERROR)
+		return;		// use existing name
 
 	// Switch statement for size part of name
-	switch (spec->access[0].size)
-	{
+	switch (spec->access[0].size) {
 	case 512:
 		name = "512byte";
 		break;
@@ -1249,42 +1159,37 @@
 		name = "1MB";
 		break;
 	default:
-		name.Format("%dKB",(spec->access[0].size/KILOBYTE));
+		name.Format("%dKB", (spec->access[0].size / KILOBYTE));
 	}
-	
+
 	// Switch statement for random/sequential part of name
-	switch (spec->access[0].random )
-	{
+	switch (spec->access[0].random) {
 	case 0:
-		name +=" sequential";
+		name += " sequential";
 		break;
 	case 100:
 		name += " random";
 		break;
 	default:
-		name.Format("%s %d%% random", name.Left( name.GetLength() ),
-			spec->access[0].random);
+		name.Format("%s %d%% random", name.Left(name.GetLength()), spec->access[0].random);
 	}
 
 	// Switch statement for read/write part of name
-    switch (spec->access[0].reads)
-	{
+	switch (spec->access[0].reads) {
 	case 0:
-		name+=" writes";
+		name += " writes";
 		break;
 	case 100:
-		name+=" reads";
+		name += " reads";
 		break;
 	default:
-		name.Format("%s %d%% reads", name.Left( name.GetLength() ), 
-			spec->access[0].reads);
+		name.Format("%s %d%% reads", name.Left(name.GetLength()), spec->access[0].reads);
 	}
-	
+
 	// Test to ensure no duplicate names
 	name_size = name.GetLength();
-	while ( RefByName( (LPCTSTR) name ) )
-	{
-		name.Format("%s %d", name.Left( name_size ), ++spec_number);
-	}		
-	sprintf( spec->name, "%s", name );
+	while (RefByName((LPCTSTR) name)) {
+		name.Format("%s %d", name.Left(name_size), ++spec_number);
+	}
+	sprintf(spec->name, "%s", name);
 }

Modified: branches/IOMETER-restruct/iometer/src/AccessSpecList.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/AccessSpecList.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/AccessSpecList.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -62,64 +62,62 @@
 #ifndef ACCESS_LIST_DEFINED
 #define ACCESS_LIST_DEFINED
 
-
 #include "IOAccess.h"
 #include "IOTest.h"
 #include "ICF_ifstream.h"
 #include <afxtempl.h>
 
-#define IDLE_SPEC		0		// The index of the idle spec.
+#define IDLE_SPEC		0	// The index of the idle spec.
 #define	IDLE_NAME		"Idle"	// The name of the idle spec.
 
 // The AccessSpecList controls the addition and removal of the global access specs.
-class AccessSpecList
-{
-public:
-// Member Functions	
+class AccessSpecList {
+      public:
+// Member Functions     
 	AccessSpecList();
 	~AccessSpecList();
 
-	Test_Spec*	New();	// Creates a new Test_Spec in memory,
-						// and adds a pointer to it in the SpecList array.
-						// Returns the index to the entry in the pointer array
-						// if successful.
+	Test_Spec *New();	// Creates a new Test_Spec in memory,
+	// and adds a pointer to it in the SpecList array.
+	// Returns the index to the entry in the pointer array
+	// if successful.
 
-	Test_Spec*	Copy( Test_Spec *source_spec ); // Creates a copy of the 
-												// specified access spec.
-	
-	void	Delete( Test_Spec *spec );	// Removes the given pointer to a 
-										// Test_Spec from the SpecList array, 
-										// and removes the associated spec.
-										// Returns True if successful.
+	Test_Spec *Copy(Test_Spec * source_spec);	// Creates a copy of the 
+	// specified access spec.
 
-	Test_Spec*	Get(int index);	// Returns the pointer to the Test_Spec at the provided index.
+	void Delete(Test_Spec * spec);	// Removes the given pointer to a 
+	// Test_Spec from the SpecList array, 
+	// and removes the associated spec.
+	// Returns True if successful.
 
-	int		Count();			// Return the number of entries in the array.
+	Test_Spec *Get(int index);	// Returns the pointer to the Test_Spec at the provided index.
 
-	int		IndexByRef( const Test_Spec* spec );		// Returns the index of the given access spec.
-	Test_Spec*	RefByName( const char* check_name );	// Checks the access spec list for a spec of the given name.
+	int Count();		// Return the number of entries in the array.
 
-	BOOL	SaveResults( ostream& outfile );	// Saves only the currently active access specs to a result file.
+	int IndexByRef(const Test_Spec * spec);	// Returns the index of the given access spec.
+	Test_Spec *RefByName(const char *check_name);	// Checks the access spec list for a spec of the given name.
 
-	BOOL	SaveConfig( ostream& outfile );	// Saves all access specs to a config file.
-	BOOL	LoadConfig( const CString& infilename, BOOL replace );	// Gets the file version and calls the appropriate LoadConfigXXX function.
-	BOOL	LoadConfigNew( ICF_ifstream& infile );	// Loads the global access spec list from a current version's setup file.
-	BOOL	LoadConfigOld( ICF_ifstream& infile );	// Loads the global access spec list from a previous version's setup file.
+	BOOL SaveResults(ostream & outfile);	// Saves only the currently active access specs to a result file.
 
-protected:
+	BOOL SaveConfig(ostream & outfile);	// Saves all access specs to a config file.
+	BOOL LoadConfig(const CString & infilename, BOOL replace);	// Gets the file version and calls the appropriate LoadConfigXXX function.
+	BOOL LoadConfigNew(ICF_ifstream & infile);	// Loads the global access spec list from a current version's setup file.
+	BOOL LoadConfigOld(ICF_ifstream & infile);	// Loads the global access spec list from a previous version's setup file.
+
+      protected:
 // Private Functions
-	void	InsertIdleSpec();		// Creates the idle spec and inserts it's pointer into the poiter array.
-	void	InsertDefaultSpecs();	// Inserts the different default specifications.
+	void InsertIdleSpec();	// Creates the idle spec and inserts it's pointer into the poiter array.
+	void InsertDefaultSpecs();	// Inserts the different default specifications.
 
-	void	DeleteAll();		// Deletes all entries in the access spec list.
+	void DeleteAll();	// Deletes all entries in the access spec list.
 
-	void	InitAccessSpecLine( Access_Spec* spec_line); //Initializes a line of an access spec to the default values.
+	void InitAccessSpecLine(Access_Spec * spec_line);	//Initializes a line of an access spec to the default values.
 
-	void	SmartName( Test_Spec* spec); //Takes an access spec and assigns it a descriptive name
-	void	NextUntitled( char *name ); // Name an untitled access specs ("Untitled n").
+	void SmartName(Test_Spec * spec);	//Takes an access spec and assigns it a descriptive name
+	void NextUntitled(char *name);	// Name an untitled access specs ("Untitled n").
 
 // Private data structures
-	CTypedPtrArray<CPtrArray, Test_Spec*> spec_list;	// Pointer array to AccessSpecObjects
+	 CTypedPtrArray < CPtrArray, Test_Spec * >spec_list;	// Pointer array to AccessSpecObjects
 };
 
 #endif

Modified: branches/IOMETER-restruct/iometer/src/BigMeter.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/BigMeter.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/BigMeter.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,7 +60,6 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoApp.h"
 #include "GalileoView.h"
@@ -68,7 +67,6 @@
 #include "MeterCtrl.h"
 #include "TextDisplay.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -79,25 +77,23 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CBigMeter dialog
-CBigMeter::CBigMeter( CWnd* pParent ) : CDialog(CBigMeter::IDD, pParent)
+CBigMeter::CBigMeter(CWnd * pParent):CDialog(CBigMeter::IDD, pParent)
 {
 	is_displayed = FALSE;
-	SetButtonState( FALSE, FALSE, FALSE );
+	SetButtonState(FALSE, FALSE, FALSE);
 	max_range = 100;
 }
 
-
-void CBigMeter::DoDataExchange(CDataExchange* pDX)
+void CBigMeter::DoDataExchange(CDataExchange * pDX)
 {
 	CDialog::DoDataExchange(pDX);
 
@@ -109,21 +105,18 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CBigMeter, CDialog)
-	//{{AFX_MSG_MAP(CBigMeter)
-	ON_BN_CLICKED(BResultType, OnBResultType)
-	ON_BN_CLICKED(BNext, OnBNext)
-	ON_BN_CLICKED(BStop, OnBStop)
-	ON_EN_KILLFOCUS(EMaxRange, OnKillfocusEMaxRange)
-	ON_EN_CHANGE(EMaxRange, OnChangeEMaxRange)
-	ON_WM_PAINT()
-	ON_BN_CLICKED(CkWatermark, OnCkWatermark)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CBigMeter)
+    ON_BN_CLICKED(BResultType, OnBResultType)
+    ON_BN_CLICKED(BNext, OnBNext)
+    ON_BN_CLICKED(BStop, OnBStop)
+    ON_EN_KILLFOCUS(EMaxRange, OnKillfocusEMaxRange)
+    ON_EN_CHANGE(EMaxRange, OnChangeEMaxRange)
+    ON_WM_PAINT()
+ON_BN_CLICKED(CkWatermark, OnCkWatermark)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
 
-
-
 /////////////////////////////////////////////////////////////////////////////
 // Implementation
 //
@@ -133,26 +126,21 @@
 // big meter should replicate.  (It will show the same statistic for the same
 // worker as the bar whose number was passed in.)
 //
-BOOL CBigMeter::Create( int performance_bar, CString test_title, 
-	CString stat_title, CString worker_title )
+BOOL CBigMeter::Create(int performance_bar, CString test_title, CString stat_title, CString worker_title)
 {
 	CString text;
 
 	// If this dialog already exists, bring it to the foreground.
-	if ( is_displayed == TRUE )
-	{
+	if (is_displayed == TRUE) {
 		// If the window is minimized, restore it, otherwise just bring it forward
-		if ( IsIconic() )
-			VERIFY( ShowWindow( SW_RESTORE ) );
+		if (IsIconic())
+			VERIFY(ShowWindow(SW_RESTORE));
 		else
-			VERIFY( SetForegroundWindow() );
-	}
-	else
-	{
+			VERIFY(SetForegroundWindow());
+	} else {
 		// Create the dialog box
-		if ( !CDialog::Create( IDD_BIGMETER, (CWnd *) theApp.pView ) )
-		{
-			ErrorMessage( "Could not create dialog box to display results." );
+		if (!CDialog::Create(IDD_BIGMETER, (CWnd *) theApp.pView)) {
+			ErrorMessage("Could not create dialog box to display results.");
 			return FALSE;
 		}
 		is_displayed = TRUE;
@@ -168,34 +156,36 @@
 
 	// Set the buttons to their appropriate states
 	UpdateButtons();
-	m_BResultType.SetWindowText( result_name );
-	m_CkWatermark.SetCheck( 0 );
+	m_BResultType.SetWindowText(result_name);
+	m_CkWatermark.SetCheck(0);
 
 	// Set the text display boxes.
-	((CTextDisplay*)GetDlgItem(TDTestInfo))->SetAll( &test_title, "Arial", 22,
-		AlignLeft, FALSE, TRUE, FALSE, ::GetSysColor(COLOR_ACTIVECAPTION) );
+	((CTextDisplay *) GetDlgItem(TDTestInfo))->SetAll(&test_title, "Arial", 22,
+							  AlignLeft, FALSE, TRUE,
+							  FALSE,::GetSysColor(COLOR_ACTIVECAPTION));
 	text = worker_name + " - " + result_name;
-	((CTextDisplay*)GetDlgItem(TDWhichResult))->SetAll( &text, "Arial", 
-		22, AlignCenter, TRUE, FALSE, FALSE, ::GetSysColor(COLOR_ACTIVECAPTION) );
+	((CTextDisplay *) GetDlgItem(TDWhichResult))->SetAll(&text, "Arial",
+							     22, AlignCenter, TRUE, FALSE,
+							     FALSE,::GetSysColor(COLOR_ACTIVECAPTION));
 	text = "";
-	((CTextDisplay*)GetDlgItem(TDResult))->SetAll( &text, "Arial", 
-		54, AlignCenter, TRUE, FALSE, FALSE, ::GetSysColor(COLOR_ACTIVECAPTION) );
+	((CTextDisplay *) GetDlgItem(TDResult))->SetAll(&text, "Arial",
+							54, AlignCenter, TRUE, FALSE,
+							FALSE,::GetSysColor(COLOR_ACTIVECAPTION));
 
-	SetDlgItemInt( EMaxRange, max_range );
-	((CMeterCtrl*)GetDlgItem( MMeter ))->SetRange( 0, max_range );
+	SetDlgItemInt(EMaxRange, max_range);
+	((CMeterCtrl *) GetDlgItem(MMeter))->SetRange(0, max_range);
 
 	UpdateDisplay();
 
 	return TRUE;
 }
 
-
 //
 // Closes and destroys the window.
 //
 void CBigMeter::OnOK()
 {
-	ASSERT( is_displayed == TRUE );
+	ASSERT(is_displayed == TRUE);
 
 	// Hide the window from the display (CDialog does this for us)
 	CDialog::OnCancel();
@@ -205,7 +195,6 @@
 	is_displayed = FALSE;
 }
 
-
 //
 // Called in response to an Alt-F4 or a click on the X button.
 //
@@ -214,82 +203,70 @@
 	OnOK();
 }
 
-
 //
 // Displays the current results data.
 //
 void CBigMeter::UpdateDisplay()
 {
 	// Retrieve the formatted statistics from the CPageDisplay tab
-	theApp.pView->m_pPageDisplay->GetDisplayData( 
-		&(results[theApp.pView->m_pPageDisplay->GetWhichPerf()]), 
-		result_to_display, &result_value, &result_text );
+	theApp.pView->m_pPageDisplay->GetDisplayData(&(results[theApp.pView->m_pPageDisplay->GetWhichPerf()]),
+						     result_to_display, &result_value, &result_text);
 
 	// Set the meter's value
-	((CMeterCtrl*)GetDlgItem( MMeter ))->SetValue( result_value );
+	((CMeterCtrl *) GetDlgItem(MMeter))->SetValue(result_value);
 
 	// Display the result in the text display box.
-	((CTextDisplay*)GetDlgItem(TDResult))->SetText( &result_text );
+	((CTextDisplay *) GetDlgItem(TDResult))->SetText(&result_text);
 }
 
-
-
 //
 // Enables or disables the test control buttons as appropriate.
 //
 void CBigMeter::UpdateButtons()
 {
-	if ( !is_displayed )
+	if (!is_displayed)
 		return;
 
-	if ( button_state & BUTTON_START )
-	{
-		m_BNext.SetWindowText( "Start" );
-		m_BNext.EnableWindow( TRUE );
-		m_BStop.EnableWindow( FALSE );
-	}
-	else
-	{
-		if ( button_state & ( BUTTON_STOP | BUTTON_STOPALL ) )
-		{
-			m_BNext.SetWindowText( "Next >>" );
-			m_BNext.EnableWindow( button_state & BUTTON_STOPALL );
-			m_BStop.EnableWindow( TRUE );
+	if (button_state & BUTTON_START) {
+		m_BNext.SetWindowText("Start");
+		m_BNext.EnableWindow(TRUE);
+		m_BStop.EnableWindow(FALSE);
+	} else {
+		if (button_state & (BUTTON_STOP | BUTTON_STOPALL)) {
+			m_BNext.SetWindowText("Next >>");
+			m_BNext.EnableWindow(button_state & BUTTON_STOPALL);
+			m_BStop.EnableWindow(TRUE);
+		} else {
+			m_BNext.SetWindowText("Start");
+			m_BNext.EnableWindow(FALSE);
+			m_BStop.EnableWindow(FALSE);
 		}
-		else
-		{
-			m_BNext.SetWindowText( "Start" );
-			m_BNext.EnableWindow( FALSE );
-			m_BStop.EnableWindow( FALSE );
-		}
 	}
 }
 
-
 //
 // Handler which pops up a menu of results to monitor.
 //
 void CBigMeter::OnBResultType()
 {
-	CMenu	menu;
-	CRect	button_rect;
-	RECT	screen_rect;
-	int		menu_height, menu_x, menu_y;
+	CMenu menu;
+	CRect button_rect;
+	RECT screen_rect;
+	int menu_height, menu_x, menu_y;
 
 	// This prevents the menu from popping up if the user is "unchecking" the button.
-	if ( m_BResultType.GetCheck() ) 
-	{
-		m_BResultType.SetCheck( FALSE );
+	if (m_BResultType.GetCheck()) {
+		m_BResultType.SetCheck(FALSE);
 		return;
 	}
-
 	// Create the popup menu from the resource.
 	VERIFY(menu.LoadMenu(IDR_POPUP_DISPLAY_LIST));
-	CMenu* pPopup = menu.GetSubMenu(0);
+	CMenu *pPopup = menu.GetSubMenu(0);
+
 	ASSERT(pPopup != NULL);
 
 	// Get the screen coordinates of the button that was pressed.
-	m_BResultType.GetWindowRect( &button_rect );
+	m_BResultType.GetWindowRect(&button_rect);
 
 	// Position the menu with its upper left corner at the lower left corner of the button.
 	menu_x = button_rect.TopLeft().x;
@@ -297,49 +274,41 @@
 
 	// If the menu would go off the bottom of the screen, make it go *up* from the button instead.
 	menu_height = GetSystemMetrics(SM_CYMENUSIZE) * MDisplayNumSubmenus;
-	if ( SystemParametersInfo( SPI_GETWORKAREA, 0, &screen_rect, 0) && 
-		(menu_y + menu_height > screen_rect.bottom) )
-	{
+	if (SystemParametersInfo(SPI_GETWORKAREA, 0, &screen_rect, 0) && (menu_y + menu_height > screen_rect.bottom)) {
 		menu_y = button_rect.TopLeft().y - menu_height + 1;
 	}
-
 	// Set the button's visual state to "pressed" as long as the menu is popped up.
-	m_BResultType.SetCheck( TRUE );
+	m_BResultType.SetCheck(TRUE);
 
 	// Pop up the menu, giving the main frame (CGalileoView's parent) as the parent
-	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON, menu_x, menu_y, theApp.pView->GetParent() );
+	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON, menu_x, menu_y, theApp.pView->GetParent());
 
 	// The user's selection (if any) from the pop-up menu will result in a call to one of the 
 	// CGalileoView::OnMDisplay...() functions, which will in turn call CPageDisplay::OnMDisplay().
 
 	// Set the button's visual state to "not pressed" after the menu is dismissed.
-	m_BResultType.SetState( FALSE );
+	m_BResultType.SetState(FALSE);
 }
 
-
-
 //
 // Monitors a new result, as chosen from the popup menu in OnBResultType.
 // This is called by CGallileoView when the user chooses a value from that popup menu.
 //
-void CBigMeter::OnMDisplay( int submenu_id, int menu_item, int result_code )
+void CBigMeter::OnMDisplay(int submenu_id, int menu_item, int result_code)
 {
-	CString	which_result;
-	CMenu	menu, *popup, *sub_popup;
+	CString which_result;
+	CMenu menu, *popup, *sub_popup;
 
-	if ( (submenu_id < 0) || (submenu_id >= MDisplayNumSubmenus) )
-	{
+	if ((submenu_id < 0) || (submenu_id >= MDisplayNumSubmenus)) {
 		ErrorMessage("Invalid submenu_id value in CBigMeter::OnMDisplay()");
 		return;
 	}
-	if ( (result_code < 0) || (result_code >= NUM_RESULTS) )
-	{
+	if ((result_code < 0) || (result_code >= NUM_RESULTS)) {
 		ErrorMessage("Invalid result_code value in CBigMeter::OnMDisplay()");
 		return;
 	}
-
 	// If the user selected the same result, keep the same information.
-	if ( result_to_display == result_code )
+	if (result_to_display == result_code)
 		return;
 
 	// store the selected result for later use
@@ -353,51 +322,46 @@
 	popup = menu.GetSubMenu(0);
 	ASSERT(popup != NULL);
 
-	sub_popup = popup->GetSubMenu( submenu_id );
-	if ( sub_popup == NULL )
-	{
+	sub_popup = popup->GetSubMenu(submenu_id);
+	if (sub_popup == NULL) {
 		ErrorMessage("Could not get submenu in CBigMeter::OnMDisplay()");
 		return;
 	}
 
-	sub_popup->GetMenuString( menu_item, result_name, MF_BYCOMMAND );
+	sub_popup->GetMenuString(menu_item, result_name, MF_BYCOMMAND);
 
 	// Display the new monitored value on the button
-	m_BResultType.SetWindowText( result_name );
-	m_BResultType.SetCheck( FALSE );
+	m_BResultType.SetWindowText(result_name);
+	m_BResultType.SetCheck(FALSE);
 
 	// Update the edit box displaying which result is being shown.
 	which_result = worker_name + " - " + result_name;
-	((CTextDisplay*)GetDlgItem( TDWhichResult ))->SetText( &which_result ); 
+	((CTextDisplay *) GetDlgItem(TDWhichResult))->SetText(&which_result);
 
-	((CMeterCtrl*)GetDlgItem( MMeter ))->ResetWatermark();
+	((CMeterCtrl *) GetDlgItem(MMeter))->ResetWatermark();
 	UpdateDisplay();
 }
 
-
-
 //
 // This is called by CGalileoView whenever the main frame's toolbar button states
 // are set.  The three parameters here are the states of the "Start", "Stop",
 // and "Stop All" toolbar buttons.  These button states are used to determine the
 // states of CBigMeter's test control buttons.
 //
-void CBigMeter::SetButtonState( BOOL start, BOOL stop, BOOL stopall )
+void CBigMeter::SetButtonState(BOOL start, BOOL stop, BOOL stopall)
 {
 	button_state = 0;
 
-	if ( start )
+	if (start)
 		button_state |= BUTTON_START;
-	if ( stop )
+	if (stop)
 		button_state |= BUTTON_STOP;
-	if ( stopall )
+	if (stopall)
 		button_state |= BUTTON_STOPALL;
 
 	UpdateButtons();
 }
 
-
-
 //
 // Called when user clicks the "Next>>" (sometimes labeled "Start") button.
 //
@@ -405,37 +369,30 @@
 // If the tests have started, this button uses the main toolbar's STOP
 // button to continue to the next test, and it is therefore labeled "Next>>".
 //
-void CBigMeter::OnBNext() 
+void CBigMeter::OnBNext()
 {
-	if ( button_state & BUTTON_START )
-	{
-		((CMeterCtrl*)GetDlgItem( MMeter ))->ResetWatermark();
+	if (button_state & BUTTON_START) {
+		((CMeterCtrl *) GetDlgItem(MMeter))->ResetWatermark();
 		theApp.pView->Go();
+	} else {
+		theApp.pView->StopTest(ReturnSuccess);
 	}
-	else
-	{
-		theApp.pView->StopTest( ReturnSuccess );
-	}
 }
 
-
-
 //
 // Stops all tests.
 //
 // If tests remain after the current one, this is the same as clicking STOP ALL.
 // If only running one test, this is the same as clicking STOP.
 //
-void CBigMeter::OnBStop() 
+void CBigMeter::OnBStop()
 {
-	if ( button_state & BUTTON_STOPALL )
+	if (button_state & BUTTON_STOPALL)
 		theApp.pView->StopAll();
 	else
-		theApp.pView->StopTest( ReturnSuccess );
+		theApp.pView->StopTest(ReturnSuccess);
 }
 
-
-
 //
 // Prevents the user from leaving the max range edit box blank.
 //
@@ -444,46 +401,39 @@
 	int new_range;
 
 	// Update the maximum range, but disallow a blank or zero range.
-	if ( !(new_range = GetDlgItemInt( EMaxRange )) )
-	{
-		SetDlgItemInt( EMaxRange, max_range );
+	if (!(new_range = GetDlgItemInt(EMaxRange))) {
+		SetDlgItemInt(EMaxRange, max_range);
 		return;
 	}
 
-	SetMaxRange( new_range );
+	SetMaxRange(new_range);
 }
 
-
-
 //
 // Updates the meter's range as the user changes the max range edit box value.
 //
 void CBigMeter::OnChangeEMaxRange()
 {
-	int	new_range;
+	int new_range;
 
 	// Only set the range if the displayed value is not zero or blank.
-	if ( new_range = GetDlgItemInt( EMaxRange ) )
-		SetMaxRange( new_range );
+	if (new_range = GetDlgItemInt(EMaxRange))
+		SetMaxRange(new_range);
 }
 
-
-
 //
 // Sets a new maximum range for the display.
 //
-void CBigMeter::SetMaxRange( int new_range )
+void CBigMeter::SetMaxRange(int new_range)
 {
 	// If the range is the same as the old one, we don't need to update it.
-	if ( new_range == max_range )
+	if (new_range == max_range)
 		return;
 
 	max_range = new_range;
-	((CMeterCtrl*)GetDlgItem( MMeter ))->SetRange( 0, max_range );
+	((CMeterCtrl *) GetDlgItem(MMeter))->SetRange(0, max_range);
 }
 
-
-
 //
 // Called to uncheck the result selection button when the popup menu is dismissed.
 //
@@ -496,8 +446,8 @@
 	// not on the button that poped the popup up, Windows handles removing the
 	// menu.  We have to handle unchecking the button.
 
-	m_BResultType.GetWindowRect( &button_rect );
-	GetCursorPos( &point );
+	m_BResultType.GetWindowRect(&button_rect);
+	GetCursorPos(&point);
 
 	// Note that we only reset the state of the check button if the cursor is
 	// not within the button's bounding rectangle.  If the cursor is within
@@ -505,19 +455,16 @@
 	// Button handler will take care of unchecking the button, and will not
 	// display the menu.  This allows the button to toggle the menu.
 
-	if ( m_BResultType.GetCheck() && !button_rect.PtInRect( point ) )
-		m_BResultType.SetCheck( FALSE );
+	if (m_BResultType.GetCheck() && !button_rect.PtInRect(point))
+		m_BResultType.SetCheck(FALSE);
 }
 
-
-
 //
 // Called when the user clicks on the watermark check box.  This turns the
 // watermark off and on.
 //
-void CBigMeter::OnCkWatermark() 
+void CBigMeter::OnCkWatermark()
 {
-	((CMeterCtrl*)GetDlgItem( MMeter ))->show_watermark = 
-		m_CkWatermark.GetCheck();
-	((CMeterCtrl*)GetDlgItem( MMeter ))->ResetWatermark();
+	((CMeterCtrl *) GetDlgItem(MMeter))->show_watermark = m_CkWatermark.GetCheck();
+	((CMeterCtrl *) GetDlgItem(MMeter))->ResetWatermark();
 }

Modified: branches/IOMETER-restruct/iometer/src/BigMeter.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/BigMeter.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/BigMeter.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,92 +59,87 @@
 #ifndef BIGMETER_DEFINED
 #define BIGMETER_DEFINED
 
-
 #define BUTTON_START		0x01
 #define BUTTON_STOP		0x02
 #define BUTTON_STOPALL		0x04
 
-
-
 /////////////////////////////////////////////////////////////////////////////
 // CBigMeter dialog
 
-class CBigMeter : public CDialog
-{
+class CBigMeter:public CDialog {
 // Construction
-public:
-	CBigMeter( CWnd* pParent = NULL );   // standard constructor
+      public:
+	CBigMeter(CWnd * pParent = NULL);	// standard constructor
 
 	// Create the dialog
-	virtual BOOL	Create(	int performance_bar, CString test_title, 
-						CString result_title, CString worker_title );
-	
+	virtual BOOL Create(int performance_bar, CString test_title, CString result_title, CString worker_title);
+
 	// Tell the dialog which main frame toolbar
 	// buttons are enabled (of START, STOP, STOP ALL)
-	void		SetButtonState( BOOL start, BOOL stop, BOOL stopall );
+	void SetButtonState(BOOL start, BOOL stop, BOOL stopall);
 
 	// Called from CGalileoView when user selects a new result to display
-	void		OnMDisplay( int submenu_id, int menu_item, int result_code );
-	void		ClearCheckButton();
+	void OnMDisplay(int submenu_id, int menu_item, int result_code);
+	void ClearCheckButton();
 
-	void		UpdateDisplay();	// Call this when value has changed
+	void UpdateDisplay();	// Call this when value has changed
 
 	// Is the dialog visible?
-	BOOL		is_displayed;
+	BOOL is_displayed;
 
-protected:
+      protected:
 
 	// Update the "Next>>" and "Stop buttons.
-	void		UpdateButtons();
-	int			button_state;		// The state of CGalileoView's toolbar buttons
+	void UpdateButtons();
+	int button_state;	// The state of CGalileoView's toolbar buttons
 
 	// Controlling the maximum displayed value for the meter.
-	void		SetMaxRange( int new_range );
-	int			max_range;
+	void SetMaxRange(int new_range);
+	int max_range;
 
-	virtual void	OnOK();
-	virtual void	OnCancel();
+	virtual void OnOK();
+	virtual void OnCancel();
 
 	// Information needed to extract the result value being displayed.
-	Results		*results; // Pointer to base of results[MAX_UPDATE] array
-	int			result_to_display;
-	double		result_value;
-	CString		result_text;
+	Results *results;	// Pointer to base of results[MAX_UPDATE] array
+	int result_to_display;
+	double result_value;
+	CString result_text;
 
-	CString		result_name;
-	CString		worker_name;
+	CString result_name;
+	CString worker_name;
 
 // Dialog Data
 	//{{AFX_DATA(CBigMeter)
 	enum { IDD = IDD_BIGMETER };
-	CButton	m_CkWatermark;
-	CButton	m_BResultType;
-	CButton	m_BNext;
-	CButton	m_BStop;
+	CButton m_CkWatermark;
+	CButton m_BResultType;
+	CButton m_BNext;
+	CButton m_BStop;
 	//}}AFX_DATA
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CBigMeter)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 	// Generated message map functions
 	//{{AFX_MSG(CBigMeter)
-	afx_msg void OnBResultType();
+	 afx_msg void OnBResultType();
 	afx_msg void OnBNext();
 	afx_msg void OnBStop();
 	afx_msg void OnKillfocusEMaxRange();
 	afx_msg void OnChangeEMaxRange();
 	afx_msg void OnCkWatermark();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
 //{{AFX_INSERT_LOCATION}}
 // Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 
-#endif // !BIGMETER_DEFINED
+#endif				// !BIGMETER_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/ByteOrder.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/ByteOrder.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ByteOrder.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -72,23 +72,18 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOCommon.h"
 #include "IOTest.h"
 #include "IOMessage.h"
 
-
-
 inline void rotate(char *ptr, int size);
-template <class T> inline void reorder(T&);
-inline void reorder(CPU_Results&, int);
-inline void reorder(Net_Results&, int);
-inline void reorder(Raw_Result&);
-void reorder(Message&);
-void reorder(Data_Message&, int union_type, int send_recv);
+template < class T > inline void reorder(T &);
+inline void reorder(CPU_Results &, int);
+inline void reorder(Net_Results &, int);
+inline void reorder(Raw_Result &);
+void reorder(Message &);
+void reorder(Data_Message &, int union_type, int send_recv);
 
-
-
 #if defined(_DEBUG)
 void Dump_CPU_Results(struct CPU_Results *res)
 {
@@ -118,7 +113,7 @@
 {
 	if (!res)
 		return;
-	cout << "Dump manager result: "<< endl;
+	cout << "Dump manager result: " << endl;
 	cout << " time_counter = " << res->time_counter << endl;
 	Dump_CPU_Results(&(res->cpu_results));
 	Dump_Net_Results(&(res->net_results));
@@ -128,7 +123,7 @@
 {
 	if (!res)
 		return;
-	cout << "Dump raw result: "<< endl;
+	cout << "Dump raw result: " << endl;
 	cout << "   " << "bytes_read =" << res->bytes_read << endl;
 	cout << "   " << "bytes_written =" << res->bytes_written << endl;
 	cout << "   " << "read_count =" << res->read_count << endl;
@@ -146,15 +141,13 @@
 	cout << "   " << "transaction_latency_sum =" << res->transaction_latency_sum << endl;
 	cout << "   " << "connection_latency_sum =" << res->connection_latency_sum << endl;
 	cout << "   " << "counter_time =" << res->counter_time << endl;
-	cout << "Dump raw result end. "<< endl;
+	cout << "Dump raw result end. " << endl;
 }
 #endif
 
-
-
 #if defined(IOMTR_OS_LINUX) && defined(IOMTR_CPU_XSCALE)
 //
-//	This can be optimized definitely.
+//      This can be optimized definitely.
 //
 /* This is the standard way, leave here for understanding its purpose.
 void double_wordswap(double *d)
@@ -175,7 +168,7 @@
 void double_wordswap(double *d)
 {
 	unsigned long *c, t;
-	
+
 	c = (unsigned long *)d;
 	t = *c;
 	*c = *(c + 1);
@@ -201,7 +194,7 @@
 void CPU_Results_double_swap(struct CPU_Results *p)
 {
 	int i, j;
-	
+
 	for (i = 0; i < MAX_CPUS; i++)
 		for (j = 0; j < CPU_RESULTS; j++)
 			double_wordswap(&(p->CPU_utilization[i][j]));
@@ -210,7 +203,7 @@
 void Net_Results_double_swap(struct Net_Results *p)
 {
 	int i, j;
-	
+
 	for (i = 0; i < TCP_RESULTS; i++)
 		double_wordswap(&(p->tcp_stats[i]));
 	for (i = 0; i < MAX_NUM_INTERFACES; i++)
@@ -219,15 +212,12 @@
 }
 #endif
 
-
-
 inline void rotate(char *ptr, int size)
 {
 	int i;
 	int sz = size - 1;
 
-	for (i=0; i<(size/2); i++)
-	{
+	for (i = 0; i < (size / 2); i++) {
 		ptr[i] = ptr[i] ^ ptr[sz - i];
 		ptr[sz - i] = ptr[i] ^ ptr[sz - i];
 		ptr[i] = ptr[i] ^ ptr[sz - i];
@@ -235,21 +225,21 @@
 	return;
 }
 
-template <class T> inline void reorder(T& tref)
+template < class T > inline void reorder(T & tref)
 {
 	(void)rotate((char *)&tref, sizeof(T));
 	return;
 }
 
-inline void reorder(CPU_Results& var, int send_recv)
+inline void reorder(CPU_Results & var, int send_recv)
 {
 	int i, j;
 
 	if (send_recv == RECV)
 		reorder(var.count);
 
-	for (i=0; i<var.count; i++)
-		for (j=0; j<CPU_RESULTS; j++)
+	for (i = 0; i < var.count; i++)
+		for (j = 0; j < CPU_RESULTS; j++)
 			reorder(var.CPU_utilization[i][j]);
 
 	if (send_recv == SEND)
@@ -258,18 +248,18 @@
 	return;
 }
 
-inline void reorder(Net_Results& var, int send_recv)
+inline void reorder(Net_Results & var, int send_recv)
 {
-	int i,j;
+	int i, j;
 
 	if (send_recv == RECV)
 		reorder(var.ni_count);
 
-	for (i=0; i<TCP_RESULTS; i++)
+	for (i = 0; i < TCP_RESULTS; i++)
 		reorder(var.tcp_stats[i]);
 
-	for (i=0; i<var.ni_count; i++)
-		for (j=0; j<NI_RESULTS; j++)
+	for (i = 0; i < var.ni_count; i++)
+		for (j = 0; j < NI_RESULTS; j++)
 			reorder(var.ni_stats[i][j]);
 
 	if (send_recv == SEND)
@@ -278,7 +268,7 @@
 	return;
 }
 
-void reorder(Raw_Result& var)
+void reorder(Raw_Result & var)
 {
 	reorder(var.bytes_read);
 	reorder(var.bytes_written);
@@ -305,15 +295,14 @@
 	return;
 }
 
-
-void reorder(Message& var)
+void reorder(Message & var)
 {
 	(void)reorder(var.purpose);
 	(void)reorder(var.data);
 	return;
 }
 
-void reorder(Data_Message &var, int uniontype, int send_recv)
+void reorder(Data_Message & var, int uniontype, int send_recv)
 {
 	int i;
 
@@ -321,8 +310,7 @@
 	if (send_recv == RECV)
 		reorder(var.count);
 
-	switch(uniontype)
-	{
+	switch (uniontype) {
 	case 0:
 		return;
 		break;
@@ -342,40 +330,34 @@
 #ifdef _DEBUG
 		cout << "Target_Spec count: " << var.count << endl;
 #endif
-		for (i = 0; i < var.count; i++)
-		{
+		for (i = 0; i < var.count; i++) {
 			// must be first after recv.
 			if (send_recv == RECV)
 				reorder(var.data.targets[i].type);
 
 			// Is target Disk/Network/Vi type ?
-			if ( IsType(var.data.targets[i].type, GenericDiskType) )
-			{
+			if (IsType(var.data.targets[i].type, GenericDiskType)) {
 				reorder(var.data.targets[i].disk_info.sector_size);
 				reorder(var.data.targets[i].disk_info.maximum_size);
 				reorder(var.data.targets[i].disk_info.starting_sector);
 			}
 
-			if ( IsType(var.data.targets[i].type, GenericNetType) )
-			{
+			if (IsType(var.data.targets[i].type, GenericNetType)) {
 				reorder(var.data.targets[i].tcp_info.local_port);
 				reorder(var.data.targets[i].tcp_info.remote_port);
 			}
 
-			if ( IsType(var.data.targets[i].type, GenericVIType) )
-			{
+			if (IsType(var.data.targets[i].type, GenericVIType)) {
 #ifdef _DEBUG
 				cerr << "WARNING: VI data marshalling not supported yet." << endl;
 #endif
 			}
-
 			// Now re-order the other stuff.
 			reorder(var.data.targets[i].queue_depth);
 			reorder(var.data.targets[i].test_connection_rate);
 			reorder(var.data.targets[i].trans_per_conn);
 			reorder(var.data.targets[i].random);
 
-
 			// Must be last before send. Else Sparc Solaris will be confused.
 			if (send_recv == SEND)
 				reorder(var.data.targets[i].type);
@@ -388,8 +370,7 @@
 		cout << "Test_Spec count: " << var.count << endl;
 #endif
 		reorder(var.data.spec.default_assignment);
-		for (i = 0; i < MAX_ACCESS_SPECS; i++)
-		{
+		for (i = 0; i < MAX_ACCESS_SPECS; i++) {
 			reorder(var.data.spec.access[i].of_size);
 			reorder(var.data.spec.access[i].reads);
 			reorder(var.data.spec.access[i].random);
@@ -421,7 +402,7 @@
 		for (i = 0; i < MAX_SNAPSHOTS; i++)
 			reorder(var.data.worker_results.time[i]);
 
-		if (send_recv == RECV)					// never used as of now.
+		if (send_recv == RECV)	// never used as of now.
 			reorder(var.data.worker_results.target_results.count);
 
 		for (i = 0; i < var.data.worker_results.target_results.count; i++)
@@ -434,7 +415,7 @@
 	default:
 		return;
 		break;
-	} // end of switch(uniontype)....
+	}			// end of switch(uniontype)....
 
 	// Must be last before send. Else Sparc Solaris will be confused.
 	if (send_recv == SEND)
@@ -442,5 +423,3 @@
 
 	return;
 }
-
-

Modified: branches/IOMETER-restruct/iometer/src/GalileoApp.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoApp.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoApp.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -78,7 +78,6 @@
 #include "Legalbox.h"
 #include "IOPortTCP.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -89,32 +88,28 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
-
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoApp
 
 BEGIN_MESSAGE_MAP(CGalileoApp, CWinApp)
-	//{{AFX_MSG_MAP(CGalileoApp)
-	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
-	//}}AFX_MSG_MAP
-	// Standard file based document commands
-//	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
-//	ON_COMMAND(ID_FILE_OPEN, CPageAccess::OnFileOpen)
-END_MESSAGE_MAP()
-
+    //{{AFX_MSG_MAP(CGalileoApp)
+    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
+    //}}AFX_MSG_MAP
+    // Standard file based document commands
+//      ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
+//      ON_COMMAND(ID_FILE_OPEN, CPageAccess::OnFileOpen)
+    END_MESSAGE_MAP()
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoApp construction/destruction
-
-CGalileoApp::CGalileoApp()
- : m_pVersionString(NULL), m_pVersionStringWithDebug(NULL)
+    CGalileoApp::CGalileoApp()
+:  m_pVersionString(NULL), m_pVersionStringWithDebug(NULL)
 {
 	// TODO: add construction code here,
 	// Place all significant initialization in InitInstance
@@ -149,7 +144,7 @@
 	//  the specific initialization routines you do not need.
 #if _MSC_VER < 1300
 #ifdef _AFXDLL
-	Enable3dControls();			// Call this when using MFC in a shared DLL
+	Enable3dControls();	// Call this when using MFC in a shared DLL
 #else
 	Enable3dControlsStatic();	// Call this when linking to MFC statically
 #endif
@@ -158,23 +153,23 @@
 	//init file version strings
 	GetAppFileVersionString(&m_pVersionString, &m_pVersionStringWithDebug);
 
-	SetRegistryKey( "iometer.org" );	// Stores information in the registry under
-						// HKEY_CURRENT_USER\Software\iometer.org
-						// \Iometer\Settings\Version
+	SetRegistryKey("iometer.org");	// Stores information in the registry under
+	// HKEY_CURRENT_USER\Software\iometer.org
+	// \Iometer\Settings\Version
 
-	LoadStdProfileSettings();  // Load standard INI file options (including MRU)
+	LoadStdProfileSettings();	// Load standard INI file options (including MRU)
 
 	//
 	// Check to see if the end user license agreement should be displayed.
 	// If the current version is not stored in the registry, disply the EULA.
 	//
 #ifndef	_DEBUG
-	if ( GetProfileString( "Settings", "Version" ) != m_pVersionString )
-	{
-		CLegalBox legalDlg;					// Display EULA.
-		if ( legalDlg.DoModal() == IDOK )
+	if (GetProfileString("Settings", "Version") != m_pVersionString) {
+		CLegalBox legalDlg;	// Display EULA.
+
+		if (legalDlg.DoModal() == IDOK)
 			// User agrees to terms, so store the version in the registry.
-			WriteProfileString( "Settings", "Version", m_pVersionString );
+			WriteProfileString("Settings", "Version", m_pVersionString);
 		else
 			return FALSE;	// User does not agree to terms so exit.
 	}
@@ -183,12 +178,10 @@
 	// Register the application's document templates.  Document templates
 	//  serve as the connection between documents, frame windows and views.
 
-	CSingleDocTemplate* pDocTemplate;
-	pDocTemplate = new CSingleDocTemplate(
-		IDR_MAINFRAME,
-		RUNTIME_CLASS(CGalileoDoc),
-		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
-		RUNTIME_CLASS(CGalileoView));
+	CSingleDocTemplate *pDocTemplate;
+
+	pDocTemplate = new CSingleDocTemplate(IDR_MAINFRAME, RUNTIME_CLASS(CGalileoDoc), RUNTIME_CLASS(CMainFrame),	// main SDI frame window
+					      RUNTIME_CLASS(CGalileoView));
 	AddDocTemplate(pDocTemplate);
 
 	// Enable DDE Execute open
@@ -225,33 +218,30 @@
 	CWinApp::ParseCommandLine(cmdline);
 
 	// If the command line parser had any trouble, kill the program.
-	if ( cmdline.m_bFail )
+	if (cmdline.m_bFail)
 		return FALSE;
 
-	if ( !OnCmdMsg(ID_FILE_NEW, 0, NULL, NULL) )
-	{
+	if (!OnCmdMsg(ID_FILE_NEW, 0, NULL, NULL)) {
 		OnFileNew();
 	}
-	if (m_pMainWnd == NULL)
-	{
-		ErrorMessage("Error creating application's main frame.  "
-			"Please report this as an Iometer bug.");
+	if (m_pMainWnd == NULL) {
+		ErrorMessage("Error creating application's main frame.  " "Please report this as an Iometer bug.");
 		return FALSE;
 	}
-
 	// Fill in the local address strings.
 	IdentifyLocalAddresses();
 
 	// Set the status bar.
 	CRect rect;
-	m_wndStatusBar.GetWindowRect( &rect );
-	int* widths;
-	widths = (int*)malloc( sizeof(int) * 3 );
+
+	m_wndStatusBar.GetWindowRect(&rect);
+	int *widths;
+	widths = (int *)malloc(sizeof(int) * 3);
 	widths[0] = rect.Width() - 300;
 	widths[1] = rect.Width() - 150;
 	widths[2] = -1;
-	m_wndStatusBar.GetStatusBarCtrl().SetParts( 3, widths );
-	free( widths );
+	m_wndStatusBar.GetStatusBarCtrl().SetParts(3, widths);
+	free(widths);
 
 	// Set status bar text.
 	pView->ClearStatusBar();
@@ -260,92 +250,81 @@
 	pView->ButtonReset();
 
 	// make sure CGalileoApp::OnIdle() gets called at least once in a while
-	pView->SetTimer( IDLE_TIMER, IDLE_DELAY, NULL );
+	pView->SetTimer(IDLE_TIMER, IDLE_DELAY, NULL);
 
 	// Get the full pathname for Iometer.exe.
-	if ( !GetModuleFileName( NULL, iometer_path, sizeof( iometer_path ) ) )
-	{
-		ErrorMessage( "Could not get Iometer.exe pathname!" );
+	if (!GetModuleFileName(NULL, iometer_path, sizeof(iometer_path))) {
+		ErrorMessage("Could not get Iometer.exe pathname!");
 
 		// Set iometer_path to a null string; this will make NEW_WORKER_COMMAND
 		// search for Dynamo in the current directory and $PATH
 		iometer_path[0] = '\0';
 	}
-
 	// Find the last backslash in the pathname, if any
-	if ( p = strrchr( iometer_path, '\\' ) )
-	{
+	if (p = strrchr(iometer_path, '\\')) {
 		// Terminate the string right after the last backslash, leaving
 		// the full pathname of the directory containing Iometer.exe.
 		p++;
 		*p = '\0';
 	}
-
 	// Build the command line to launch Dynamo.  We must quote the pathname in case it 
 	// contains any spaces, but the "start" command (NEW_WORKER_COMMAND) assumes the
 	// first quoted argument is the window title, so we must provide it twice.
-	new_manager_command_line_format = (CString) NEW_WORKER_COMMAND 
-			+ "\"" + iometer_path + NEW_WORKER_EXECUTABLE + "%s\"" + " "
-			+ "\"" + iometer_path + NEW_WORKER_EXECUTABLE + "\"%s";
+	new_manager_command_line_format = (CString) NEW_WORKER_COMMAND
+	    + "\"" + iometer_path + NEW_WORKER_EXECUTABLE + "%s\"" + " "
+	    + "\"" + iometer_path + NEW_WORKER_EXECUTABLE + "\"%s";
 
-	if ( cmdline.GetConfigFile().IsEmpty() )
-	{
+	if (cmdline.GetConfigFile().IsEmpty()) {
 #ifndef	_DEBUG
 		// If the default config file exists, load it.
-		if ( ::GetFileAttributes(DEFAULT_CONFIG_FILE) != 0xFFFFFFFF )
-		{
+		if (::GetFileAttributes(DEFAULT_CONFIG_FILE) != 0xFFFFFFFF) {
 			OpenDocumentFile(DEFAULT_CONFIG_FILE);
-		}
-		else
-		{
+		} else {
 			// If no config file was specified on the command line
 			// and the default config file doesn't exist, start a
 			// local manager.with no command line options.
 			LaunchDynamo();
 		}
 #endif
-	}
-	else
-	{
+	} else {
 		// If a config file was specified on the command line, open it
-		OpenDocumentFile( cmdline.GetConfigFile() );
+		OpenDocumentFile(cmdline.GetConfigFile());
 	}
 
 	return TRUE;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
-//	Function Name:
-//		CGalileoApp::ExitInstance
+//      Function Name:
+//              CGalileoApp::ExitInstance
 //
-//	Syntax:
-//		int ExitInstance()
+//      Syntax:
+//              int ExitInstance()
 //
-//	Processing:
-//		Clean up instance data
+//      Processing:
+//              Clean up instance data
 ///////////////////////////////////////////////////////////////////////////////
 int CGalileoApp::ExitInstance()
 {
-	delete [] m_pVersionString;
-	delete [] m_pVersionStringWithDebug;
+	delete[]m_pVersionString;
+	delete[]m_pVersionStringWithDebug;
 
 	return CWinApp::ExitInstance();
 }
 
-
 ///////////////////////////////////////////////////////////////////////////////
-//	Function Name:
-//		CGalileoApp::GetVersionString
+//      Function Name:
+//              CGalileoApp::GetVersionString
 //
-//	Syntax:
-//		const char*		GetVersionString(BOOL fWithDebugIndicator = FALSE);
+//      Syntax:
+//              const char*             GetVersionString(BOOL fWithDebugIndicator = FALSE);
 //
-//	Processing:
-//		Return version string ptr (m_pVersionString or m_pVersionStringWithDebug).
+//      Processing:
+//              Return version string ptr (m_pVersionString or m_pVersionStringWithDebug).
 ///////////////////////////////////////////////////////////////////////////////
-const char*		CGalileoApp::GetVersionString(BOOL fWithDebugIndicator)
+const char *CGalileoApp::GetVersionString(BOOL fWithDebugIndicator)
 {
-	if (! fWithDebugIndicator)
+	if (!fWithDebugIndicator)
 		return m_pVersionString;
 	else
 		return m_pVersionStringWithDebug;
@@ -361,86 +340,75 @@
 //
 void CGalileoApp::IdentifyLocalAddresses()
 {
-	DWORD		namelength = MAX_NETWORK_NAME;
-	WSADATA		wd;
-	char		hostname[128];
-	hostent		*hostinfo;
-	sockaddr_in	sin;
+	DWORD namelength = MAX_NETWORK_NAME;
+	WSADATA wd;
+	char hostname[128];
+	hostent *hostinfo;
+	sockaddr_in sin;
 
 	////////////////////////////////////////////////////////////////////////////////////////
 	// Get the local machine's NetBIOS address.
 	////////////////////////////////////////////////////////////////////////////////////////
-	::GetComputerName( netbios_hostname.GetBuffer(MAX_NETWORK_NAME), &namelength );
+	::GetComputerName(netbios_hostname.GetBuffer(MAX_NETWORK_NAME), &namelength);
 	netbios_hostname.ReleaseBuffer();
 	netbios_hostname = "\\\\" + netbios_hostname + "\\";
 
 	////////////////////////////////////////////////////////////////////////////////////////
 	// Assemble a list of all local IP addresses (one for each NIC).
 	////////////////////////////////////////////////////////////////////////////////////////
-	if ( WSAStartup( MAKEWORD(2, 0), &wd ) )
-	{
-		ErrorMessage( "Error initializing WinSock in CGalileoApp::InitInstance()." );
+	if (WSAStartup(MAKEWORD(2, 0), &wd)) {
+		ErrorMessage("Error initializing WinSock in CGalileoApp::InitInstance().");
 		return;
 	}
 
-	if ( gethostname( hostname, sizeof(hostname) ) != SOCKET_ERROR )
-	{
-		hostinfo = gethostbyname( hostname );
-		if ( hostinfo != NULL )
-		{
-			for ( int counter=0; hostinfo->h_addr_list[counter] != NULL; counter++ )
-			{
-//				ip_addresses.Add(counter);
-				memcpy( &sin.sin_addr.s_addr, hostinfo->h_addr_list[counter], hostinfo->h_length );
-//				ip_addresses[counter] = inet_ntoa( sin.sin_addr );
-				ip_addresses.SetAtGrow(counter, inet_ntoa( sin.sin_addr ));
+	if (gethostname(hostname, sizeof(hostname)) != SOCKET_ERROR) {
+		hostinfo = gethostbyname(hostname);
+		if (hostinfo != NULL) {
+			for (int counter = 0; hostinfo->h_addr_list[counter] != NULL; counter++) {
+//                              ip_addresses.Add(counter);
+				memcpy(&sin.sin_addr.s_addr, hostinfo->h_addr_list[counter], hostinfo->h_length);
+//                              ip_addresses[counter] = inet_ntoa( sin.sin_addr );
+				ip_addresses.SetAtGrow(counter, inet_ntoa(sin.sin_addr));
 			}
-		}
-		else
-		{
+		} else {
 			// Non-fatal (might not recognize all local managers as being local, though)
-			ErrorMessage( "Error getting host info (HOSTENT) for \"" + (CString)hostname + "\"." );
+			ErrorMessage("Error getting host info (HOSTENT) for \"" + (CString) hostname + "\".");
 		}
-	}
-	else
-	{
+	} else {
 		// Non-fatal (might not recognize all local managers as being local, though)
-		ErrorMessage( "Error getting local host name in CGalileoApp::InitInstance()." );
+		ErrorMessage("Error getting local host name in CGalileoApp::InitInstance().");
 	}
 
 	WSACleanup();
 }
 
-
 //
 // Determines whether an address is local to the computer Iometer is running on.
 // This address can be a NetBIOS address (the NT name of the machine) or the IP
 // address of any NIC attached to the computer.
 //
-BOOL CGalileoApp::IsAddressLocal( const CString& addr )
+BOOL CGalileoApp::IsAddressLocal(const CString & addr)
 {
-	if ( netbios_hostname.CompareNoCase(addr) == 0 )
+	if (netbios_hostname.CompareNoCase(addr) == 0)
 		return TRUE;
 
-	for (int counter=0; counter<ip_addresses.GetSize(); counter++)
-	{
-		if ( ip_addresses[counter].CompareNoCase(addr) == 0 )
+	for (int counter = 0; counter < ip_addresses.GetSize(); counter++) {
+		if (ip_addresses[counter].CompareNoCase(addr) == 0)
 			return TRUE;
 	}
 
 	return FALSE;
 }
 
-
 //
 // Launch a local Dynamo with the given name.
 //
-void CGalileoApp::LaunchDynamo( const CString& mgr_name /* ="" */ )
+void CGalileoApp::LaunchDynamo(const CString & mgr_name /* ="" */ )
 {
 	CString cmd;
 
 	// Make sure the formatting string was initialized.
-	ASSERT( !theApp.new_manager_command_line_format.IsEmpty() );
+	ASSERT(!theApp.new_manager_command_line_format.IsEmpty());
 
 	// Create a string with the appropriate command line parameters.
 	cmd.Format(new_manager_command_line_format, mgr_name, mgr_name);
@@ -449,29 +417,27 @@
 	system(cmd);
 }
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CAboutDlg dialog used for App About
 
-class CAboutDlg : public CDialog
-{
-public:
+class CAboutDlg:public CDialog {
+      public:
 	CAboutDlg();
 
 // Dialog Data
 	//{{AFX_DATA(CAboutDlg)
 	enum { IDD = IDD_ABOUTBOX };
-	CStatic	m_TVersion;
+	CStatic m_TVersion;
 	//}}AFX_DATA
 
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CAboutDlg)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 	//{{AFX_MSG(CAboutDlg)
 	virtual BOOL OnInitDialog();
 	afx_msg void OnBViewEULA();
@@ -479,13 +445,13 @@
 	DECLARE_MESSAGE_MAP()
 };
 
-CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
+CAboutDlg::CAboutDlg():CDialog(CAboutDlg::IDD)
 {
 	//{{AFX_DATA_INIT(CAboutDlg)
 	//}}AFX_DATA_INIT
 }
 
-void CAboutDlg::DoDataExchange(CDataExchange* pDX)
+void CAboutDlg::DoDataExchange(CDataExchange * pDX)
 {
 	CDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CAboutDlg)
@@ -494,250 +460,222 @@
 }
 
 BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
-	//{{AFX_MSG_MAP(CAboutDlg)
-	ON_BN_CLICKED(BViewEULA, OnBViewEULA)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CAboutDlg)
+ON_BN_CLICKED(BViewEULA, OnBViewEULA)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 // App command to run the dialog
 void CGalileoApp::OnAppAbout()
 {
 	CAboutDlg aboutDlg;
+
 	aboutDlg.DoModal();
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoApp commands
 
-
-BOOL CAboutDlg::OnInitDialog() 
+BOOL CAboutDlg::OnInitDialog()
 {
 	CDialog::OnInitDialog();
 
 	// Display correct version information in about box dialog.
 	CString buffer = "Iometer ";
-	buffer += theApp.GetVersionString (TRUE);
-	m_TVersion.SetWindowText( buffer );
-	
-	return TRUE;  // return TRUE unless you set the focus to a control
-	              // EXCEPTION: OCX Property Pages should return FALSE
-}
 
+	buffer += theApp.GetVersionString(TRUE);
+	m_TVersion.SetWindowText(buffer);
 
+	return TRUE;		// return TRUE unless you set the focus to a control
+	// EXCEPTION: OCX Property Pages should return FALSE
+}
 
-void CAboutDlg::OnBViewEULA() 
+void CAboutDlg::OnBViewEULA()
 {
 	CLegalBox legal_dlg;
+
 	legal_dlg.running = TRUE;
 	legal_dlg.DoModal();
 }
 
-
-
 //
 // On Idle handler processes login requests from Dynamos.
 //
-BOOL CGalileoApp::OnIdle(LONG lCount) 
+BOOL CGalileoApp::OnIdle(LONG lCount)
 {
-	static Message		*login_msg;
-	static char			*login_msg_ptr;
-	static DWORD		login_msg_size;
-	static Data_Message	*login_data_msg;
-	static char			*login_data_msg_ptr;
-	static DWORD		login_data_msg_size;
-	DWORDLONG			result;
-	Message				reply_to_dynamo;
-	Manager				*manager;
+	static Message *login_msg;
+	static char *login_msg_ptr;
+	static DWORD login_msg_size;
+	static Data_Message *login_data_msg;
+	static char *login_data_msg_ptr;
+	static DWORD login_data_msg_size;
+	DWORDLONG result;
+	Message reply_to_dynamo;
+	Manager *manager;
 
 	if (CWinApp::OnIdle(lCount))
-		return TRUE;   	
+		return TRUE;
 
-	switch ( login_state )
-	{
+	switch (login_state) {
 	case closed:
 		// create and open the port
 
-		login_port = new PortTCP( FALSE );	// asynchronous port
-		if ( !login_port->Create( NULL, NULL, 0, WELL_KNOWN_TCP_PORT ) )
-		{
+		login_port = new PortTCP(FALSE);	// asynchronous port
+		if (!login_port->Create(NULL, NULL, 0, WELL_KNOWN_TCP_PORT)) {
 			ErrorMessage("Could not create TCP/IP port for Dynamo login!");
 			login_state = failed;
-			return FALSE; // go away and don't come back (for a while)
+			return FALSE;	// go away and don't come back (for a while)
 		}
 
 		login_state = open;
-		return TRUE; // go away and try again later
+		return TRUE;	// go away and try again later
 		break;
 
 	case open:
-		if ( !login_port->Accept() ) // begin accepting...
+		if (!login_port->Accept())	// begin accepting...
 		{
 			ErrorMessage("Accept() failed on Dynamo login port!");
 			login_port->Close();
 			login_state = failed;
-			return FALSE; // go away and don't come back (for a while)
+			return FALSE;	// go away and don't come back (for a while)
 		}
 		login_state = accepting;
-		return TRUE; // go away and try again later
+		return TRUE;	// go away and try again later
 		break;
 
 	case accepting:
 		// has Accept() completed?
-		if ( login_port->IsAcceptComplete() )
-		{
+		if (login_port->IsAcceptComplete()) {
 			// Yes!  Was it successful?
-			if ( login_port->GetAcceptResult() )
-			{
+			if (login_port->GetAcceptResult()) {
 				// Accept() succeeded
 				login_state = waiting;
-				return TRUE; // go away and try again later
-			}
-			else
-			{
+				return TRUE;	// go away and try again later
+			} else {
 				// Accept() failed!
 				ErrorMessage("GetAcceptResult() failed on Dynamo login port!");
 				login_port->Close();
 				login_state = failed;
-				return FALSE; // go away and don't come back (for a while)
+				return FALSE;	// go away and don't come back (for a while)
 			}
-		}
-		else
-		{
+		} else {
 			// Accept() has not yet completed
-			return FALSE; // go away and don't come back (for a while)
+			return FALSE;	// go away and don't come back (for a while)
 		}
 		break;
 
 	case waiting:
-		if ( login_port->Peek() )
-		{
+		if (login_port->Peek()) {
 			// There is data waiting for us!
 			login_msg = new Message;
-			login_msg_ptr = (char *) login_msg;
-			login_msg_size = sizeof( Message );
-			login_port->Receive( login_msg_ptr, login_msg_size ); // begin receiving...
+			login_msg_ptr = (char *)login_msg;
+			login_msg_size = sizeof(Message);
+			login_port->Receive(login_msg_ptr, login_msg_size);	// begin receiving...
 			login_state = receiving;
-			return TRUE; // go away and try again later
-		}
-		else
-		{
+			return TRUE;	// go away and try again later
+		} else {
 			// There is no data for us, go back to waiting
-			return FALSE; // go away and don't come back (for a while)
+			return FALSE;	// go away and don't come back (for a while)
 		}
 		break;
 
 	case receiving:
 		// has Receive() completed?
-		if ( login_port->IsReceiveComplete() )
-		{
+		if (login_port->IsReceiveComplete()) {
 			// Yes!  Have all requested bytes been received?
 			result = login_port->GetReceiveResult();
-			if ( result == login_msg_size )
-			{
+			if (result == login_msg_size) {
 				// All bytes received!  
-				
+
 				// Format our version number into an integer
 				int year, month, day, iometer_version;
 
-				sscanf( m_pVersionString, "%d.%d.%d", &year, &month, &day );
+				sscanf(m_pVersionString, "%d.%d.%d", &year, &month, &day);
 				iometer_version = (year * 10000) + (month * 100) + day;
 
 				// Compare it with Dynamo's version number (will be 0 or uninitialized for 
 				// versions before 1998.09.23)
-				if ( login_msg->data != iometer_version )
-				{
+				if (login_msg->data != iometer_version) {
 					// versions failed to match...  refuse connection
 
 					// tell Dynamo that the connection is being refused
 					reply_to_dynamo.purpose = LOGIN;
 					reply_to_dynamo.data = WRONG_VERSION;
-					login_port->Send( &reply_to_dynamo );
+					login_port->Send(&reply_to_dynamo);
 
 					login_port->Disconnect();
 
 					// give the user a message box explaining the problem
 					char errmsg[2 * MAX_VERSION_LENGTH + 100];
 
-					if ( login_msg->data > 19970101 && login_msg->data < 21001231 )
-					{
-						year = (int) (login_msg->data / 10000);
-						month = (int) (login_msg->data / 100) - (year * 100);
+					if (login_msg->data > 19970101 && login_msg->data < 21001231) {
+						year = (int)(login_msg->data / 10000);
+						month = (int)(login_msg->data / 100) - (year * 100);
 						day = login_msg->data - (month * 100) - (year * 10000);
 
-						sprintf( errmsg, "Iometer %s is not compatible with Dynamo %04d.%02d.%02d",
-							m_pVersionStringWithDebug, year, month, day );
+						sprintf(errmsg,
+							"Iometer %s is not compatible with Dynamo %04d.%02d.%02d",
+							m_pVersionStringWithDebug, year, month, day);
+					} else {
+						sprintf(errmsg,
+							"Iometer %s is not compatible with Dynamo (unknown version number)",
+							m_pVersionStringWithDebug);
 					}
-					else
-					{
-						sprintf( errmsg, "Iometer %s is not compatible with Dynamo (unknown version number)",
-							m_pVersionStringWithDebug );
-					}
 
 					ErrorMessage(errmsg);
 
 					// Receive() completed and processed, go back to Accept().
 					login_state = open;
 					delete login_msg;
+
 					return TRUE;	// go away and try again later
 				}
-
 				// we are through with login_msg
 				delete login_msg;
+
 				// Now wait for data message...
 				login_state = waiting_for_data;
-				return TRUE; // go away and try again later
-			}
-			else if ( result > 0 )
-			{
+				return TRUE;	// go away and try again later
+			} else if (result > 0) {
 				// Some bytes (but not all) received, post another receive for the rest of the message
 				login_msg_size -= (DWORD) result;
 				login_msg_ptr += result;
-				login_port->Receive( login_msg_ptr, login_msg_size ); // begin receiving...
+				login_port->Receive(login_msg_ptr, login_msg_size);	// begin receiving...
 				login_state = receiving;
-				return TRUE; // go away and try again later
-			}
-			else
-			{
+				return TRUE;	// go away and try again later
+			} else {
 				// Receive() failed!
 				ErrorMessage("GetReceiveResult() failed on Dynamo login port!");
 				login_port->Close();
 				login_state = failed;
-				return FALSE; // go away and don't come back (for a while)
+				return FALSE;	// go away and don't come back (for a while)
 			}
-		}
-		else
-		{
+		} else {
 			// Receive() has not yet completed
-			return TRUE; // go away and try again later
+			return TRUE;	// go away and try again later
 		}
 		break;
 
 	case waiting_for_data:
-		if ( login_port->Peek() )
-		{
+		if (login_port->Peek()) {
 			// There is data waiting for us!
 			login_data_msg = new Data_Message;
-			login_data_msg_ptr = (char *) login_data_msg;
-			login_data_msg_size = sizeof( Data_Message );
-			login_port->Receive( login_data_msg_ptr, login_data_msg_size ); // begin receiving...
+			login_data_msg_ptr = (char *)login_data_msg;
+			login_data_msg_size = sizeof(Data_Message);
+			login_port->Receive(login_data_msg_ptr, login_data_msg_size);	// begin receiving...
 			login_state = receiving_data;
-			return TRUE; // go away and try again later
-		}
-		else
-		{
+			return TRUE;	// go away and try again later
+		} else {
 			// There is no data for us, go back to waiting
-			return FALSE; // go away and don't come back (for a while)
+			return FALSE;	// go away and don't come back (for a while)
 		}
 		break;
 
 	case receiving_data:
 		// has Receive() completed?
-		if ( login_port->IsReceiveComplete() )
-		{
+		if (login_port->IsReceiveComplete()) {
 			// Yes!  Have all requested bytes been received?
 			result = login_port->GetReceiveResult();
-			if ( result == login_data_msg_size )
-			{
+			if (result == login_data_msg_size) {
 				// Keep track of whether this manager is logging in during
 				// a file restore operation.  Once the manager is added to
 				// the manager list, this state of this variable determines
@@ -753,29 +691,27 @@
 				// Tell Dynamo that the connection is being accepted
 				reply_to_dynamo.purpose = LOGIN;
 				reply_to_dynamo.data = LOGIN_OK;
-				login_port->Send( &reply_to_dynamo );
+				login_port->Send(&reply_to_dynamo);
 
 				// Receive succeeded, so contents of login_data_msg are valid...
-				manager = manager_list.AddManager( &(login_data_msg->data.manager_info) );
+				manager = manager_list.AddManager(&(login_data_msg->data.manager_info));
 
 				// We are all through with login_data_msg
 				delete login_data_msg;
 
 				// In certain situations, ::AddManager() may return a null, we have to at least 
 				// check for it.
-				if (manager == NULL)
-				{
+				if (manager == NULL) {
 					ErrorMessage("AddManager() failed to add manager to manager list!");
 					login_port->Close();
 					login_state = failed;
-					return FALSE; 
+					return FALSE;
 				}
-
 				// Get the manager's list of available targets.
 				manager->UpdateTargetLists();
 
 				// Add new manager to the end of the manager list.
-				pView->AddManager( manager );
+				pView->AddManager(manager);
 
 				// Add the default workers (specified in Test Setup page)
 				// ONLY if there is not a file restore operation happening.
@@ -784,44 +720,38 @@
 				// were added when merging a saved manager configuration, the
 				// default workers would never be deleted when the saved workers
 				// were restored.
-				if ( !wasWaitingList )
-					pView->AddDefaultWorkers( manager );
+				if (!wasWaitingList)
+					pView->AddDefaultWorkers(manager);
 
 				// Notify worker of successful login, then disconnect them.
 				login_port->Disconnect();
 
 				// Receive() completed and processed, go back to Accept().
 				login_state = open;
-				return TRUE; // go away and try again later
-			}
-			else if ( result > 0 )
-			{
+				return TRUE;	// go away and try again later
+			} else if (result > 0) {
 				// Some bytes (but not all) received, post another receive for the rest of the message
 				login_data_msg_size -= (DWORD) result;
 				login_data_msg_ptr += result;
-				login_port->Receive( login_data_msg_ptr, login_data_msg_size ); // begin receiving...
+				login_port->Receive(login_data_msg_ptr, login_data_msg_size);	// begin receiving...
 				login_state = receiving_data;
-				return TRUE; // go away and try again later
-			}
-			else
-			{
+				return TRUE;	// go away and try again later
+			} else {
 				// Receive() failed!
 				ErrorMessage("GetReceiveResult() failed on Dynamo login port!");
 				login_port->Close();
 				login_state = failed;
-				return FALSE; // go away and don't come back (for a while)
+				return FALSE;	// go away and don't come back (for a while)
 			}
-		}
-		else
-		{
+		} else {
 			// Receive() has not yet completed
-			return TRUE; // go away and try again later
+			return TRUE;	// go away and try again later
 		}
 		break;
 
 	case failed:
 		// we've suffered a fatal error, do nothing
-		return FALSE; // go away and don't come back (for a while)
+		return FALSE;	// go away and don't come back (for a while)
 		break;
 	}
 
@@ -829,11 +759,10 @@
 	return FALSE;
 }
 
-
 //
 // Handle an "open document" request (e.g. from a command line argument)
 //
-CDocument* CGalileoApp::OpenDocumentFile(LPCTSTR lpszFileName) 
+CDocument *CGalileoApp::OpenDocumentFile(LPCTSTR lpszFileName)
 {
 	CDocument *theDoc;
 	BOOL flags[NumICFFlags], replace;
@@ -848,11 +777,9 @@
 
 	// Create a CDocument object by calling the parent method
 	// (this also initializes the pView member)
-	if ( theDoc = CWinApp::OpenDocumentFile(lpszFileName) )
-	{
+	if (theDoc = CWinApp::OpenDocumentFile(lpszFileName)) {
 		// Attempt to open the file as a configuration file
-		if ( !pView->PrepareToOpenConfigFile( lpszFileName, flags, replace ) )
-		{
+		if (!pView->PrepareToOpenConfigFile(lpszFileName, flags, replace)) {
 			// The file could not be opened!  Indicate failure.
 			theDoc = NULL;
 		}
@@ -861,7 +788,6 @@
 	return theDoc;
 }
 
-
 //
 // See if Iometer is in batch mode.
 //
@@ -870,7 +796,6 @@
 	return cmdline.IsBatchMode();
 }
 
-
 //
 // Take the application out of batch mode.
 // No harm will be done if Iometer is already out of batch mode.

Modified: branches/IOMETER-restruct/iometer/src/GalileoApp.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoApp.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoApp.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,20 +61,19 @@
 #ifndef GALILEO_DEFINED
 #define GALILEO_DEFINED
 
-
 #include "GalileoDefs.h"
 #ifndef __AFXWIN_H__
-	#error include 'stdafx.h' before including this file for PCH
+#error include 'stdafx.h' before including this file for PCH
 #endif
 
-#include "resource.h"       // main symbols
+#include "resource.h"		// main symbols
 #include "IOCommon.h"
 #include "AccessSpecList.h"
 #include "ManagerList.h"
 #include "BigMeter.h"
 #include "GalileoCmdLine.h"
 
-class CGalileoView; // forward declaration
+class CGalileoView;		// forward declaration
 class ManagerList;
 
 /////////////////////////////////////////////////////////////////////////////
@@ -82,31 +81,30 @@
 // See GalileoApp.cpp for the implementation of this class
 //
 
-class CGalileoApp : public CWinApp
-{
-public:
+class CGalileoApp:public CWinApp {
+      public:
 	CGalileoApp();
 	~CGalileoApp();
 
-	const char* GetVersionString(BOOL fWithDebugIndicator = FALSE);
+	const char *GetVersionString(BOOL fWithDebugIndicator = FALSE);
 
 	// Is Iometer running in batch mode?
 	BOOL IsBatchMode();
 	// Turns off batch mode.  (Does no harm if Iometer isn't in batch mode.)
 	void OverrideBatchMode();
 	// Determines whether the given address is a local to this machine.
-	BOOL IsAddressLocal( const CString& addr );
+	BOOL IsAddressLocal(const CString & addr);
 	// Launch a local Dynamo with the given name.
-	void LaunchDynamo( const CString& mgr_name = "" );
+	void LaunchDynamo(const CString & mgr_name = "");
 
-	CGalileoView*	pView;
-	CToolBar		m_wndToolBar;
-	CStatusBar		m_wndStatusBar;
+	CGalileoView *pView;
+	CToolBar m_wndToolBar;
+	CStatusBar m_wndStatusBar;
 
-	AccessSpecList	access_spec_list;	// Global access spec list.
-	ManagerList		manager_list;		// Global manager list.
+	AccessSpecList access_spec_list;	// Global access spec list.
+	ManagerList manager_list;	// Global manager list.
 
-	Port			*login_port;
+	Port *login_port;
 
 	enum {
 		closed,
@@ -117,9 +115,9 @@
 		waiting_for_data,
 		receiving_data,
 		failed
-	}				login_state;
+	} login_state;
 
-	TestState		test_state;
+	TestState test_state;
 
 	// Command line parser.  (Also retains parameters.)
 	CGalileoCmdLine cmdline;
@@ -127,11 +125,11 @@
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CGalileoApp)
-public:
-	virtual BOOL InitInstance();
-	virtual	int	 ExitInstance();
+      public:
+	 virtual BOOL InitInstance();
+	virtual int ExitInstance();
 	virtual BOOL OnIdle(LONG lCount);
-	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);
+	virtual CDocument *OpenDocumentFile(LPCTSTR lpszFileName);
 	//}}AFX_VIRTUAL
 
 // Implementation
@@ -139,30 +137,25 @@
 	//{{AFX_MSG(CGalileoApp)
 	afx_msg void OnAppAbout();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 
-protected:
+      protected:
 	void IdentifyLocalAddresses();
 
-	CStringArray			ip_addresses;
-	CString					netbios_hostname;
+	CStringArray ip_addresses;
+	CString netbios_hostname;
 
 	// Formatting string for launching a new Dynamo.
 	// This is not the actual command line string.
 	// It is used by CGalileoApp::LaunchDynamo().
-	CString		new_manager_command_line_format;
-private:
-	char				   *m_pVersionString;
-	char				   *m_pVersionStringWithDebug;
+	CString new_manager_command_line_format;
+      private:
+	char *m_pVersionString;
+	char *m_pVersionStringWithDebug;
 };
 
 extern CGalileoApp theApp;
 
 /////////////////////////////////////////////////////////////////////////////
 
-
 #endif
-
-
-
-

Modified: branches/IOMETER-restruct/iometer/src/GalileoCmdLine.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoCmdLine.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoCmdLine.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,12 +60,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoApp.h"
 #include "GalileoCmdLine.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -76,14 +74,13 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -91,10 +88,8 @@
 const int CGalileoCmdLine::DefaultTimeout = 10;
 const char CGalileoCmdLine::DefaultConfigFile[] = "iometer.icf";
 
-
-CGalileoCmdLine::CGalileoCmdLine() :	m_bSwitches(FALSE), m_bFail(FALSE),
-										m_sConfigFile(""), m_sResultFile(""),
-										m_iTimeout(-1), m_bOverrideBatch(FALSE)
+CGalileoCmdLine::CGalileoCmdLine():m_bSwitches(FALSE), m_bFail(FALSE),
+m_sConfigFile(""), m_sResultFile(""), m_iTimeout(-1), m_bOverrideBatch(FALSE)
 {
 }
 
@@ -102,11 +97,10 @@
 {
 }
 
-
 //
 // See help text within for an explanation of the expected parameters.
 //
-void CGalileoCmdLine::ParseParam( const char* pszParam, BOOL bFlag, BOOL bLast )
+void CGalileoCmdLine::ParseParam(const char *pszParam, BOOL bFlag, BOOL bLast)
 {
 	static int param_count = 0;
 	static char last_switch = 0;
@@ -114,171 +108,140 @@
 
 	param_count++;
 
-	if ( m_bFail )
-	{
+	if (m_bFail) {
 		// If command line parsing has failed before, don't
 		// try to interpret the command line further.
 		return;
 	}
 
-	if ( bFlag && strlen(pszParam) != 1 )
-	{
-		Fail("Exactly one letter must follow a switch character.  "
-			"Switch characters are \"/\" and \"-\".");
+	if (bFlag && strlen(pszParam) != 1) {
+		Fail("Exactly one letter must follow a switch character.  " "Switch characters are \"/\" and \"-\".");
 		return;
 	}
 
-	if ( pszParam[0] == '?' )
-	{
+	if (pszParam[0] == '?') {
 		// get Syntax display string from resource file
 		CString version;
 		CString syntax;
-		version.Format( IDS_VERSION_OUTPUT, (LPCTSTR)theApp.GetVersionString (TRUE));
-		VERIFY( syntax.LoadString( IDS_CMDLINE_SYNTAX ) );
-		AfxMessageBox( version + "\n\n" + syntax );
 
+		version.Format(IDS_VERSION_OUTPUT, (LPCTSTR) theApp.GetVersionString(TRUE));
+		VERIFY(syntax.LoadString(IDS_CMDLINE_SYNTAX));
+		AfxMessageBox(version + "\n\n" + syntax);
+
 		m_bFail = TRUE;
 		return;
 	}
 
-	if ( last_switch )
-	{
+	if (last_switch) {
 		temp_switch = last_switch;
 		last_switch = 0;
 
 		// Previous switch expects another parameter.
-		switch ( temp_switch )
-		{
-		// Expecting the config file.
+		switch (temp_switch) {
+			// Expecting the config file.
 		case 'C':
-			if ( !m_sConfigFile.IsEmpty() )	// has it already been set?
+			if (!m_sConfigFile.IsEmpty())	// has it already been set?
 			{
 				Fail("Config file parameter was specified more than once.");
-			}
-			else if ( IsValidFilename(pszParam) )
-			{
-				if ( VerifyReadable(pszParam) )
+			} else if (IsValidFilename(pszParam)) {
+				if (VerifyReadable(pszParam))
 					m_sConfigFile = pszParam;
 				else
 					m_bFail = TRUE;
-			}
-			else
-			{
+			} else {
 				Fail("C switch should be followed by the name of a configuration file.");
 			}
 			return;
-		// Expecting the result file.
+			// Expecting the result file.
 		case 'R':
-			if ( !m_sResultFile.IsEmpty() )	// has it already been set?
+			if (!m_sResultFile.IsEmpty())	// has it already been set?
 			{
 				Fail("Result file parameter was specified more than once.");
-			}
-			else if ( IsValidFilename(pszParam) )
-			{
-				if ( VerifyWritable(pszParam) )
+			} else if (IsValidFilename(pszParam)) {
+				if (VerifyWritable(pszParam))
 					m_sResultFile = pszParam;
 				else
 					m_bFail = TRUE;
-			}
-			else
-			{
+			} else {
 				Fail("R switch should be followed by the name of the desired result file.");
 			}
 			return;
-		// Expecting the timeout value.
+			// Expecting the timeout value.
 		case 'T':
-			if ( m_iTimeout >= 0 )	// has it already been set?
+			if (m_iTimeout >= 0)	// has it already been set?
 			{
 				Fail("Timeout parameter was specified more than once.");
-			}
-			else if ( IsValidInteger(pszParam) )
-			{
+			} else if (IsValidInteger(pszParam)) {
 				m_iTimeout = atoi(pszParam);
-			}
-			else
-			{
+			} else {
 				Fail("T switch should be followed by an integer timeout value.");
 			}
 			return;
 		default:
 			{
-				char tmpary[2] = {last_switch, 0};
-				Fail("Unrecognized switch: " + (CString)tmpary + ".");
+				char tmpary[2] = { last_switch, 0 };
+				Fail("Unrecognized switch: " + (CString) tmpary + ".");
 			}
 			return;
 		}
 	}
 
-	if ( bFlag )
-	{
+	if (bFlag) {
 		m_bSwitches = TRUE;
-		last_switch = toupper( pszParam[0] );
+		last_switch = toupper(pszParam[0]);
 
-	//////////////////////////////////////////////////////////////////////
-	// This is an example of how to allow switches that have meaning on
-	// their own, without any additional parameters.
-	//
-	//	if ( last_switch == 'V' )	// spit out version number and exit
-	//	{
-	//		// Set BOOL member indicating that this switch was specified
-	//		// Make sure it's initialized in the constructor
-	//		m_bVersion = TRUE;
-	//
-	//		last_switch = 0;	// don't look for more parameters related to this switch
-	//		return;				// don't allow it to reach the bLast checking
-	//	}
-	//////////////////////////////////////////////////////////////////////
+		//////////////////////////////////////////////////////////////////////
+		// This is an example of how to allow switches that have meaning on
+		// their own, without any additional parameters.
+		//
+		//      if ( last_switch == 'V' )       // spit out version number and exit
+		//      {
+		//              // Set BOOL member indicating that this switch was specified
+		//              // Make sure it's initialized in the constructor
+		//              m_bVersion = TRUE;
+		//
+		//              last_switch = 0;        // don't look for more parameters related to this switch
+		//              return;                         // don't allow it to reach the bLast checking
+		//      }
+		//////////////////////////////////////////////////////////////////////
 
-		if ( bLast )
-		{
+		if (bLast) {
 			Fail("An additional parameter was expected after the last switch.");
 			return;
 		}
 
 		return;
 	}
-
 	// If switches haven't been used (so far)...
-	if ( !m_bSwitches )
-	{
-		switch (param_count)
-		{
-		// Expecting the config file.
+	if (!m_bSwitches) {
+		switch (param_count) {
+			// Expecting the config file.
 		case 1:
-			if ( IsValidFilename(pszParam) )
-			{
-				if ( VerifyReadable(pszParam) )
+			if (IsValidFilename(pszParam)) {
+				if (VerifyReadable(pszParam))
 					m_sConfigFile = pszParam;
 				else
 					m_bFail = TRUE;
-			}
-			else
-			{
+			} else {
 				Fail("First parameter should be the name of a valid config file.");
 			}
 			return;
-		// Expecting the result file.
+			// Expecting the result file.
 		case 2:
-			if ( IsValidFilename(pszParam) )
-			{
-				if ( VerifyWritable(pszParam) )
+			if (IsValidFilename(pszParam)) {
+				if (VerifyWritable(pszParam))
 					m_sResultFile = pszParam;
 				else
 					m_bFail = TRUE;
-			}
-			else
-			{
+			} else {
 				Fail("Second parameter should be the name of the result file.");
 			}
 			return;
-		// Expecting the timeout value.
+			// Expecting the timeout value.
 		case 3:
-			if ( IsValidInteger(pszParam) )
-			{
+			if (IsValidInteger(pszParam)) {
 				m_iTimeout = atoi(pszParam);
-			}
-			else
-			{
+			} else {
 				Fail("Third parameter should be an integer timeout value.");
 			}
 			return;
@@ -289,14 +252,13 @@
 	}
 
 	Fail("Didn't know what to do with this parameter:\n"
-		 + (CString)pszParam + "\nPlease report this as an Iometer bug.");
+	     + (CString) pszParam + "\nPlease report this as an Iometer bug.");
 }
 
-
 //
 // Set all member variables to the Fail state.
 //
-void CGalileoCmdLine::Fail( const CString& errmsg )
+void CGalileoCmdLine::Fail(const CString & errmsg)
 {
 	m_bFail = TRUE;
 	m_sConfigFile = "";
@@ -306,28 +268,24 @@
 	ErrorMessage("Error processing the command line.  " + errmsg);
 }
 
-
 CString CGalileoCmdLine::GetConfigFile()
 {
 	return m_sConfigFile;
 }
 
-
 CString CGalileoCmdLine::GetResultFile()
 {
 	return m_sResultFile;
 }
 
-
 int CGalileoCmdLine::GetTimeout()
 {
-	if ( m_iTimeout > 0 )
+	if (m_iTimeout > 0)
 		return m_iTimeout;
 	else
 		return CGalileoCmdLine::DefaultTimeout;
 }
 
-
 //
 // Is Iometer in batch mode?
 //
@@ -336,7 +294,6 @@
 	return !m_bOverrideBatch && !m_sConfigFile.IsEmpty() && !m_sResultFile.IsEmpty();
 }
 
-
 //
 // Take the application out of batch mode.
 // No harm will be done if Iometer is already out of batch mode.
@@ -347,23 +304,20 @@
 	m_bOverrideBatch = TRUE;
 }
 
-
 //
 // See if every character in the filename is valid as part of an integer.
 //
-BOOL CGalileoCmdLine::IsValidInteger( const CString& instring )
+BOOL CGalileoCmdLine::IsValidInteger(const CString & instring)
 {
 	const CString legal = "1234567890";
 
 	return instring.GetLength() == instring.SpanIncluding(legal).GetLength();
 }
 
-
-
 //
 // See if every character in the filename is a valid filename character.
 //
-BOOL CGalileoCmdLine::IsValidFilename( const CString& instring )
+BOOL CGalileoCmdLine::IsValidFilename(const CString & instring)
 {
 	const CString legal = "abcdefghijklmnopqrstuvwxyz1234567890_-=+!&%@#$.,;:'[]{}()\\ ";
 	CString teststring = instring;
@@ -373,50 +327,42 @@
 	return instring.GetLength() == teststring.SpanIncluding(legal).GetLength();
 }
 
-
 //
 // See if the specified string is the name of a writable file.
 // If it isn't, set it to an empty string, report error, and return FALSE.
 //
-BOOL CGalileoCmdLine::VerifyWritable( const CString& filename )
+BOOL CGalileoCmdLine::VerifyWritable(const CString & filename)
 {
-	ofstream outfile( filename, ios::app );
+	ofstream outfile(filename, ios::app);
 
-	if ( outfile.is_open() )
-	{
+	if (outfile.is_open()) {
 		// Good - file is open and writable.
 		outfile.close();
 		return TRUE;
-	}
-	else
-	{
+	} else {
 		// Bad - file is not writable.
 		outfile.close();
-		AfxMessageBox("Cannot write to file:\n" + filename );
+		AfxMessageBox("Cannot write to file:\n" + filename);
 		return FALSE;
 	}
 }
 
-
 //
 // See if the specified string is the name of a readable file.
 // If it isn't, set it to an empty string, report error, and return FALSE.
 //
-BOOL CGalileoCmdLine::VerifyReadable( const CString& filename )
+BOOL CGalileoCmdLine::VerifyReadable(const CString & filename)
 {
-	ifstream infile( filename );
+	ifstream infile(filename);
 
-	if ( infile.is_open() && !infile.rdstate() )
-	{
+	if (infile.is_open() && !infile.rdstate()) {
 		// Good - file is open and readable.
 		infile.close();
 		return TRUE;
-	}
-	else
-	{
+	} else {
 		// Bad - file is not readable.
 		infile.close();
-		AfxMessageBox("Cannot read from file:\n" + filename );
+		AfxMessageBox("Cannot read from file:\n" + filename);
 		return FALSE;
 	}
 }

Modified: branches/IOMETER-restruct/iometer/src/GalileoCmdLine.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoCmdLine.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoCmdLine.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,52 +59,50 @@
 #ifndef GALILEO_CMD_LINE_INCLUDED
 #define GALILEO_CMD_LINE_INCLUDED
 
-
-class CGalileoCmdLine : public CCommandLineInfo  
-{
-public:
+class CGalileoCmdLine:public CCommandLineInfo {
+      public:
 	CGalileoCmdLine();
-	virtual ~CGalileoCmdLine();
+	virtual ~ CGalileoCmdLine();
 
 	// see definitions in GalileoCmdLine.cpp
 	static const int DefaultTimeout;
 	static const char DefaultConfigFile[];
 
-	void ParseParam( const char* pszParam, BOOL bFlag, BOOL bLast );
+	void ParseParam(const char *pszParam, BOOL bFlag, BOOL bLast);
 
-	CString	GetConfigFile();
-	CString	GetResultFile();
-	int		GetTimeout();
+	CString GetConfigFile();
+	CString GetResultFile();
+	int GetTimeout();
 
 	// Interactive mode is the normal mode of operation for Iometer.
 	// If the user specifies both the config file and the results file
 	// on the command line, Iometer goes into batch mode, in which
 	// Iometer starts up, runs a test for its specified run time, writes
 	// the results file, and closes without user interaction.
-	//		TRUE = batch mode
-	//		FALSE = interactive mode
-	BOOL	IsBatchMode();
+	//              TRUE = batch mode
+	//              FALSE = interactive mode
+	BOOL IsBatchMode();
 
-	void	OverrideBatchMode();	// set m_bOverrideBatch (manually override batch mode)
+	void OverrideBatchMode();	// set m_bOverrideBatch (manually override batch mode)
 
-	BOOL	m_bFail;		// did the command line parser fail?
+	BOOL m_bFail;		// did the command line parser fail?
 
-protected:
-	void	Fail( const CString& errmsg );
-	BOOL	IsValidInteger( const CString& instring );
-	BOOL	IsValidFilename( const CString& instring );
+      protected:
+	void Fail(const CString & errmsg);
+	BOOL IsValidInteger(const CString & instring);
+	BOOL IsValidFilename(const CString & instring);
 
 	// See if the file is writable, otherwise clear the filename string.
-	BOOL	VerifyWritable( const CString& filename );
-	BOOL	VerifyReadable( const CString& filename );
+	BOOL VerifyWritable(const CString & filename);
+	BOOL VerifyReadable(const CString & filename);
 
-	BOOL	m_bSwitches;	// are switches being used
+	BOOL m_bSwitches;	// are switches being used
 
-	CString	m_sConfigFile;	// the specified config file
-	CString	m_sResultFile;	// the specified result file
-	int		m_iTimeout;		// the specified timeout value
+	CString m_sConfigFile;	// the specified config file
+	CString m_sResultFile;	// the specified result file
+	int m_iTimeout;		// the specified timeout value
 
-	BOOL	m_bOverrideBatch;	// if set, forces IsBatchMode to return FALSE
+	BOOL m_bOverrideBatch;	// if set, forces IsBatchMode to return FALSE
 };
 
-#endif	// GALILEO_CMD_LINE_INCLUDED
+#endif				// GALILEO_CMD_LINE_INCLUDED

Modified: branches/IOMETER-restruct/iometer/src/GalileoDefs.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoDefs.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoDefs.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,7 +59,6 @@
 #ifndef GALILEODEFS_DEFINED
 #define GALILEODEFS_DEFINED
 
-
 #include "stdafx.h"
 #include "resource.h"
 
@@ -83,7 +82,7 @@
 	AssignNet
 };
 
-extern void ErrorMessage( LPCTSTR errmsg );
+extern void ErrorMessage(LPCTSTR errmsg);
 
 #define DEFAULT_CONFIG_FILE		"iometer.icf"
 
@@ -91,9 +90,4 @@
 //that needs to be created.
 #define HOSTNAME_LOCAL			"(Local)"
 
-
-#endif // GALILEODEFS_DEFINED
-
-
-
-
+#endif				// GALILEODEFS_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/GalileoDoc.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoDoc.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoDoc.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,11 +60,9 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoDoc.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -75,31 +73,27 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
-
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoDoc
 
 IMPLEMENT_DYNCREATE(CGalileoDoc, CDocument)
 
-BEGIN_MESSAGE_MAP(CGalileoDoc, CDocument)
-	//{{AFX_MSG_MAP(CGalileoDoc)
-		// NOTE - the ClassWizard will add and remove mapping macros here.
-		//    DO NOT EDIT what you see in these blocks of generated code!
-	//}}AFX_MSG_MAP
-END_MESSAGE_MAP()
-
+    BEGIN_MESSAGE_MAP(CGalileoDoc, CDocument)
+    //{{AFX_MSG_MAP(CGalileoDoc)
+    // NOTE - the ClassWizard will add and remove mapping macros here.
+    //    DO NOT EDIT what you see in these blocks of generated code!
+    //}}AFX_MSG_MAP
+    END_MESSAGE_MAP()
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoDoc construction/destruction
-
-CGalileoDoc::CGalileoDoc()
+    CGalileoDoc::CGalileoDoc()
 {
 	// TODO: add one-time construction code here
 }
@@ -115,7 +109,7 @@
 
 	// TODO: add reinitialization code here
 	// (SDI documents will reuse this document)
-	SetTitle( NULL );
+	SetTitle(NULL);
 
 	return TRUE;
 }
@@ -123,14 +117,11 @@
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoDoc serialization
 
-void CGalileoDoc::Serialize(CArchive& ar)
+void CGalileoDoc::Serialize(CArchive & ar)
 {
-	if (ar.IsStoring())
-	{
+	if (ar.IsStoring()) {
 		// TODO: add storing code here
-	}
-	else
-	{
+	} else {
 		// TODO: add loading code here
 	}
 }
@@ -139,17 +130,16 @@
 // CGalileoDoc diagnostics
 
 #ifdef _DEBUG
-void CGalileoDoc::AssertValid() const
+void CGalileoDoc::AssertValid() const const
 {
 	CDocument::AssertValid();
 }
 
-void CGalileoDoc::Dump(CDumpContext& dc) const
+void CGalileoDoc::Dump(CDumpContext & dc) const const
 {
 	CDocument::Dump(dc);
 }
-#endif //_DEBUG
+#endif				//_DEBUG
 
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoDoc commands
-

Modified: branches/IOMETER-restruct/iometer/src/GalileoDoc.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoDoc.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoDoc.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,46 +59,41 @@
 #ifndef DOC_DEFINED
 #define DOC_DEFINED
 
-
 #include "GalileoApp.h"
 
-
-class CGalileoDoc : public CDocument
-{
-protected: // create from serialization only
+class CGalileoDoc:public CDocument {
+      protected:		// create from serialization only
 	CGalileoDoc();
 	DECLARE_DYNCREATE(CGalileoDoc)
-
 // Attributes
 // Operations
-public:
+      public:
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CGalileoDoc)
-	public:
+      public:
 	virtual BOOL OnNewDocument();
-	virtual void Serialize(CArchive& ar);
+	virtual void Serialize(CArchive & ar);
 	//}}AFX_VIRTUAL
 
 // Implementation
-public:
-	virtual ~CGalileoDoc();
+      public:
+	 virtual ~ CGalileoDoc();
 #ifdef _DEBUG
 	virtual void AssertValid() const;
-	virtual void Dump(CDumpContext& dc) const;
+	virtual void Dump(CDumpContext & dc) const;
 #endif
 
 // Generated message map functions
-protected:
+      protected:
 	//{{AFX_MSG(CGalileoDoc)
-		// NOTE - the ClassWizard will add and remove member functions here.
-		//    DO NOT EDIT what you see in these blocks of generated code !
+	// NOTE - the ClassWizard will add and remove member functions here.
+	//    DO NOT EDIT what you see in these blocks of generated code !
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
 /////////////////////////////////////////////////////////////////////////////
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/GalileoGlobals.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoGlobals.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoGlobals.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -71,13 +71,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoDefs.h"
 #include "GalileoApp.h"
 
-
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -88,50 +85,46 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
-
 UINT CDECL MessageBoxThread(LPVOID pErrorMessage);
 
 //
 // Reports error messages appropriately.
 // Make sure this is not called while the result file is open!
 //
-void ErrorMessage( LPCTSTR errmsg )
+void ErrorMessage(LPCTSTR errmsg)
 {
 	// If in batch mode, don't pop up error dialogs that require user intervention.
 
-	if ( theApp.IsBatchMode() )
-	{
+	if (theApp.IsBatchMode()) {
 		// Open the result file for appended output.
-		ofstream outfile( theApp.cmdline.GetResultFile(), ios::app );
+		ofstream outfile(theApp.cmdline.GetResultFile(), ios::app);
+
 		outfile << "\nERROR: " << errmsg << endl;
 		outfile.close();
-	}
-	else
-	{
+	} else {
 		//User-interactive mode: Display error message box.
 		//Must do so from a separate thread, in case the "waiting for managers"
 		//timeout dialog is present.  (Otherwise, the thread is blocked, and it
 		//continues to count down past 0, among other bad things.)  Bug #361.
 
 		//Create a copy of the error message string - thread must delete.
-		CString		*pErrorMessage = new CString(errmsg);
-		(void) AfxBeginThread(MessageBoxThread, (LPVOID) pErrorMessage);
+		CString *pErrorMessage = new CString(errmsg);
+
+		(void)AfxBeginThread(MessageBoxThread, (LPVOID) pErrorMessage);
 	}
 }
 
-
 //Called to display error message box in a separate thread (see ErrorMessage(), above).
 UINT CDECL MessageBoxThread(LPVOID pErrorMessage)
 {
-	AfxMessageBox(*(CString *)pErrorMessage);
-	delete (CString *)pErrorMessage;
+	AfxMessageBox(*(CString *) pErrorMessage);
+	delete(CString *) pErrorMessage;
 	return 0;
 }

Modified: branches/IOMETER-restruct/iometer/src/GalileoView.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoView.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoView.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -63,13 +63,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoView.h"
 #include "Mainfrm.h"
 #include "ManagerList.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -80,32 +78,28 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 void CGalileoView::SetButton(UINT nID, BOOL state)
 {
 	int i;
-	
+
 	// find the given button in toolbar_buttons array
-	for ( i = 0; i < NUM_TOOLBAR_BUTTONS; i++ )
-	{
-		if ( toolbar_buttons[i].nID == nID )
+	for (i = 0; i < NUM_TOOLBAR_BUTTONS; i++) {
+		if (toolbar_buttons[i].nID == nID)
 			break;
 	}
 
 	// did we find it?
-	if ( i == NUM_TOOLBAR_BUTTONS )
-	{
+	if (i == NUM_TOOLBAR_BUTTONS) {
 		// nID not found, do nothing
 		return;
 	}
-
 	// record new state
 	toolbar_buttons[i].enabled = state;
 
@@ -116,117 +110,110 @@
 //
 // Message handler for ON_UPDATE_COMMAND_UI for all toolbar buttons
 //
-void CGalileoView::OnUpdateToolbarButton(CCmdUI* pCmdUI) 
+void CGalileoView::OnUpdateToolbarButton(CCmdUI * pCmdUI)
 {
 	int i;
-	
+
 	// find the given button in toolbar_buttons array
-	for ( i = 0; i < NUM_TOOLBAR_BUTTONS; i++ )
-	{
-		if ( toolbar_buttons[i].nID == pCmdUI->m_nID )
-		{
+	for (i = 0; i < NUM_TOOLBAR_BUTTONS; i++) {
+		if (toolbar_buttons[i].nID == pCmdUI->m_nID) {
 			break;
 		}
 	}
 
 	// did we find it?
-	if ( i == NUM_TOOLBAR_BUTTONS )
-	{
+	if (i == NUM_TOOLBAR_BUTTONS) {
 		// nID not found, do nothing
 		return;
 	}
-
 	// set its state to match recorded state
-	pCmdUI->Enable( toolbar_buttons[i].enabled );	
+	pCmdUI->Enable(toolbar_buttons[i].enabled);
 }
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoView
 
 IMPLEMENT_DYNCREATE(CGalileoView, CView)
 
 BEGIN_MESSAGE_MAP(CGalileoView, CView)
-	//{{AFX_MSG_MAP(CGalileoView)
-	ON_WM_ERASEBKGND()
-	ON_COMMAND(BStart, OnBStart)
-	ON_COMMAND(BStop, OnBStop)
-	ON_WM_TIMER()
-	ON_COMMAND(BStopAll, OnBStopAll)
-	ON_COMMAND(BReset, OnBReset)
-	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
-	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
-	ON_COMMAND(BExitOne, OnBExitOne)
-	ON_COMMAND(BNewDynamo, OnBNewDynamo)
-	ON_COMMAND(BNewDiskWorker, OnBNewDiskWorker)
-	ON_COMMAND(BNewNetWorker, OnBNewNetWorker)
-	ON_COMMAND(BCopyWorker, OnBCopyWorker)
-	ON_COMMAND(MRefresh, OnMRefresh)
-	ON_WM_SETCURSOR()
-	ON_UPDATE_COMMAND_UI(BExitOne, OnUpdateToolbarButton)
-	ON_WM_DESTROY()
-	ON_COMMAND(MDisplayCPUDPC, OnMDisplayCPUDPC)
-	ON_COMMAND(MDisplayCPUEffectiveness, OnMDisplayCPUEffectiveness)
-	ON_COMMAND(MDisplayCPUInterruptsPS, OnMDisplayCPUInterruptsPS)
-	ON_COMMAND(MDisplayCPUInterruptTime, OnMDisplayCPUInterruptTime)
-	ON_COMMAND(MDisplayCPUPrivileged, OnMDisplayCPUPrivileged)
-	ON_COMMAND(MDisplayCPUUser, OnMDisplayCPUUser)
-	ON_COMMAND(MDisplayCPUUtilization, OnMDisplayCPUUtilization)
-	ON_COMMAND(MDisplayErrIO, OnMDisplayErrIO)
-	ON_COMMAND(MDisplayErrRIO, OnMDisplayErrRIO)
-	ON_COMMAND(MDisplayErrWIO, OnMDisplayErrWIO)
-	ON_COMMAND(MDisplayAvgCon, OnMDisplayAvgCon)
-	ON_COMMAND(MDisplayAvgIO, OnMDisplayAvgIO)
-	ON_COMMAND(MDisplayAvgRIO, OnMDisplayAvgRIO)
-	ON_COMMAND(MDisplayAvgTrans, OnMDisplayAvgTrans)
-	ON_COMMAND(MDisplayAvgWIO, OnMDisplayAvgWIO)
-	ON_COMMAND(MDisplayMaxCon, OnMDisplayMaxCon)
-	ON_COMMAND(MDisplayMaxIO, OnMDisplayMaxIO)
-	ON_COMMAND(MDisplayMaxRIO, OnMDisplayMaxRIO)
-	ON_COMMAND(MDisplayMaxTrans, OnMDisplayMaxTrans)
-	ON_COMMAND(MDisplayMaxWIO, OnMDisplayMaxWIO)
-	ON_COMMAND(MDisplayMBsMBPS, OnMDisplayMBsMBPS)
-	ON_COMMAND(MDisplayMBsRMBPS, OnMDisplayMBsRMBPS)
-	ON_COMMAND(MDisplayMBsWMBPS, OnMDisplayMBsWMBPS)
-	ON_COMMAND(MDisplayNetPacketErrors, OnMDisplayNetPacketErrors)
-	ON_COMMAND(MDisplayNetPacketsPS, OnMDisplayNetPacketsPS)
-	ON_COMMAND(MDisplayNetRetransPS, OnMDisplayNetRetransPS)
-	ON_COMMAND(MDisplayOpsConPS, OnMDisplayOpsConPS)
-	ON_COMMAND(MDisplayOpsIOPS, OnMDisplayOpsIOPS)
-	ON_COMMAND(MDisplayOpsRIOPS, OnMDisplayOpsRIOPS)
-	ON_COMMAND(MDisplayOpsTransPS, OnMDisplayOpsTransPS)
-	ON_COMMAND(MDisplayOpsWIOPS, OnMDisplayOpsWIOPS)
-	ON_UPDATE_COMMAND_UI(BNewDynamo, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(BNewDiskWorker, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(BNewNetWorker, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(BCopyWorker, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(BReset, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(BStart, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(BStop, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(BStopAll, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(ID_APP_ABOUT, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(ID_APP_EXIT, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(ID_FILE_OPEN, OnUpdateToolbarButton)
-	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateToolbarButton)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CGalileoView)
+    ON_WM_ERASEBKGND()
+    ON_COMMAND(BStart, OnBStart)
+    ON_COMMAND(BStop, OnBStop)
+    ON_WM_TIMER()
+    ON_COMMAND(BStopAll, OnBStopAll)
+    ON_COMMAND(BReset, OnBReset)
+    ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
+    ON_COMMAND(ID_FILE_SAVE, OnFileSave)
+    ON_COMMAND(BExitOne, OnBExitOne)
+    ON_COMMAND(BNewDynamo, OnBNewDynamo)
+    ON_COMMAND(BNewDiskWorker, OnBNewDiskWorker)
+    ON_COMMAND(BNewNetWorker, OnBNewNetWorker)
+    ON_COMMAND(BCopyWorker, OnBCopyWorker)
+    ON_COMMAND(MRefresh, OnMRefresh)
+    ON_WM_SETCURSOR()
+    ON_UPDATE_COMMAND_UI(BExitOne, OnUpdateToolbarButton)
+    ON_WM_DESTROY()
+    ON_COMMAND(MDisplayCPUDPC, OnMDisplayCPUDPC)
+    ON_COMMAND(MDisplayCPUEffectiveness, OnMDisplayCPUEffectiveness)
+    ON_COMMAND(MDisplayCPUInterruptsPS, OnMDisplayCPUInterruptsPS)
+    ON_COMMAND(MDisplayCPUInterruptTime, OnMDisplayCPUInterruptTime)
+    ON_COMMAND(MDisplayCPUPrivileged, OnMDisplayCPUPrivileged)
+    ON_COMMAND(MDisplayCPUUser, OnMDisplayCPUUser)
+    ON_COMMAND(MDisplayCPUUtilization, OnMDisplayCPUUtilization)
+    ON_COMMAND(MDisplayErrIO, OnMDisplayErrIO)
+    ON_COMMAND(MDisplayErrRIO, OnMDisplayErrRIO)
+    ON_COMMAND(MDisplayErrWIO, OnMDisplayErrWIO)
+    ON_COMMAND(MDisplayAvgCon, OnMDisplayAvgCon)
+    ON_COMMAND(MDisplayAvgIO, OnMDisplayAvgIO)
+    ON_COMMAND(MDisplayAvgRIO, OnMDisplayAvgRIO)
+    ON_COMMAND(MDisplayAvgTrans, OnMDisplayAvgTrans)
+    ON_COMMAND(MDisplayAvgWIO, OnMDisplayAvgWIO)
+    ON_COMMAND(MDisplayMaxCon, OnMDisplayMaxCon)
+    ON_COMMAND(MDisplayMaxIO, OnMDisplayMaxIO)
+    ON_COMMAND(MDisplayMaxRIO, OnMDisplayMaxRIO)
+    ON_COMMAND(MDisplayMaxTrans, OnMDisplayMaxTrans)
+    ON_COMMAND(MDisplayMaxWIO, OnMDisplayMaxWIO)
+    ON_COMMAND(MDisplayMBsMBPS, OnMDisplayMBsMBPS)
+    ON_COMMAND(MDisplayMBsRMBPS, OnMDisplayMBsRMBPS)
+    ON_COMMAND(MDisplayMBsWMBPS, OnMDisplayMBsWMBPS)
+    ON_COMMAND(MDisplayNetPacketErrors, OnMDisplayNetPacketErrors)
+    ON_COMMAND(MDisplayNetPacketsPS, OnMDisplayNetPacketsPS)
+    ON_COMMAND(MDisplayNetRetransPS, OnMDisplayNetRetransPS)
+    ON_COMMAND(MDisplayOpsConPS, OnMDisplayOpsConPS)
+    ON_COMMAND(MDisplayOpsIOPS, OnMDisplayOpsIOPS)
+    ON_COMMAND(MDisplayOpsRIOPS, OnMDisplayOpsRIOPS)
+    ON_COMMAND(MDisplayOpsTransPS, OnMDisplayOpsTransPS)
+    ON_COMMAND(MDisplayOpsWIOPS, OnMDisplayOpsWIOPS)
+    ON_UPDATE_COMMAND_UI(BNewDynamo, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(BNewDiskWorker, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(BNewNetWorker, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(BCopyWorker, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(BReset, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(BStart, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(BStop, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(BStopAll, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(ID_APP_ABOUT, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(ID_APP_EXIT, OnUpdateToolbarButton)
+    ON_UPDATE_COMMAND_UI(ID_FILE_OPEN, OnUpdateToolbarButton)
+ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateToolbarButton)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoView construction/destruction
-
-CGalileoView::CGalileoView()
+    CGalileoView::CGalileoView()
 {
 	// set pointers to pages and sheets to NULL
 	m_bSizedBefore = FALSE;
-	m_pPropSheet=NULL;
-	m_pPageDisk=NULL;
-	m_pPageAccess=NULL;
-	m_pPageDisplay=NULL;
-	m_pPageSetup=NULL;
+	m_pPropSheet = NULL;
+	m_pPageDisk = NULL;
+	m_pPageAccess = NULL;
+	m_pPageDisplay = NULL;
+	m_pPageSetup = NULL;
 	m_pWorkerView = NULL;
 	p_DragImage = NULL;
 	dragging = FALSE;
-	
+
 	run_count = 0;
 	run_index = 0;
 	access_count = 0;
@@ -239,6 +226,7 @@
 	save_queue_depth = NULL;
 
 	int i = 0;
+
 	toolbar_buttons[i].nID = ID_FILE_OPEN;
 	toolbar_buttons[i].enabled = FALSE;
 	i++;
@@ -278,7 +266,7 @@
 	toolbar_buttons[i].nID = ID_APP_ABOUT;
 	toolbar_buttons[i].enabled = TRUE;
 	i++;
-	ASSERT( i == NUM_TOOLBAR_BUTTONS );
+	ASSERT(i == NUM_TOOLBAR_BUTTONS);
 }
 
 CGalileoView::~CGalileoView()
@@ -293,11 +281,10 @@
 	delete m_pWorkerView;
 }
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoView drawing
 
-void CGalileoView::OnDraw(CDC* pDC)
+void CGalileoView::OnDraw(CDC * pDC)
 {
 // we don't draw because the child window will do it all
 }
@@ -306,47 +293,42 @@
 // CGalileoView diagnostics
 
 #ifdef _DEBUG
-void CGalileoView::AssertValid() const
+void CGalileoView::AssertValid() const const
 {
 	CView::AssertValid();
 }
 
-void CGalileoView::Dump(CDumpContext& dc) const
+void CGalileoView::Dump(CDumpContext & dc) const const
 {
 	CView::Dump(dc);
 }
 
-CGalileoDoc* CGalileoView::GetDocument() // non-debug version is inline
+CGalileoDoc *CGalileoView::GetDocument()	// non-debug version is inline
 {
 	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CGalileoDoc)));
-	return (CGalileoDoc*)m_pDocument;
+	return (CGalileoDoc *) m_pDocument;
 }
-#endif //_DEBUG
+#endif				//_DEBUG
 
 /////////////////////////////////////////////////////////////////////////////
 // CGalileoView message handlers
 
 BOOL CGalileoView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
-						  DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
-						  UINT nID, CCreateContext* pContext) 
+			  DWORD dwStyle, const RECT & rect, CWnd * pParentWnd, UINT nID, CCreateContext * pContext)
 {
 	ASSERT(pParentWnd != NULL);
 	ASSERT_KINDOF(CFrameWnd, pParentWnd);
 
 	theApp.pView = this;
 
-	if (!CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd,
-		nID, pContext))
-	{
+	if (!CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext)) {
 		return FALSE;
 	}
 	m_pWorkerView = new CWorkerView;
-	if ( !m_pWorkerView->Create( IDD_MANAGER_VIEW, this ) )
-	{
+	if (!m_pWorkerView->Create(IDD_MANAGER_VIEW, this)) {
 		DestroyWindow();
 		return FALSE;
 	}
-
 	// Adding tab sheet pages to the display.
 	m_pPageDisk = new CPageDisk;
 	m_pPageNetwork = new CPageNetwork;
@@ -359,16 +341,13 @@
 	// Add the first page, so that the call to create will succeed.
 	m_pPropSheet->AddPage(m_pPageDisk);
 	// create a modeless property page
-	if (!m_pPropSheet->Create( this,
-			DS_CONTEXTHELP | DS_SETFONT | WS_CHILD | WS_VISIBLE))
-	{
+	if (!m_pPropSheet->Create(this, DS_CONTEXTHELP | DS_SETFONT | WS_CHILD | WS_VISIBLE)) {
 		DestroyWindow();
 		return FALSE;
 	}
-
 	// Change the style of the underlying tab control so that 
 	// all tabs are on the same line.
-	m_pPropSheet->GetTabControl()->ModifyStyle( TCS_MULTILINE, NULL );
+	m_pPropSheet->GetTabControl()->ModifyStyle(TCS_MULTILINE, NULL);
 
 	// Add the remaining pages.
 	m_pPropSheet->AddPage(m_pPageNetwork);
@@ -378,81 +357,81 @@
 
 	// Activate all pages to enable dialog item access 
 	// from last to first, so that the first one remains visible.
-	for ( int i = SETUP_PAGE; i >= 0; i-- ) 
-	{
+	for (int i = SETUP_PAGE; i >= 0; i--) {
 		m_pPropSheet->SetActivePage(i);
 	}
-	
+
 	///////////////////////////////////////////////////////////////////
 	//
 	// Arrange the topology window and property sheets in the frame.
 	//
 	///////////////////////////////////////////////////////////////////
-	CFrameWnd* pParentFrame = GetParentFrame();
+	CFrameWnd *pParentFrame = GetParentFrame();
 	CRect rect_size, tab_sheet_size;
 
 	// set the property sheet in the upper left corner of the view window
-	m_pWorkerView->GetWindowRect( &rect_size );
+	m_pWorkerView->GetWindowRect(&rect_size);
 
 	// Moving the worker view window for a pleasing look.
-	m_pWorkerView->SetWindowPos(NULL, 5, 8, 0, 0, 
-		SWP_NOZORDER | SWP_NOSIZE);
+	m_pWorkerView->SetWindowPos(NULL, 5, 8, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
 
 	// Move the property sheet next to the topology window.
-	m_pPropSheet->SetWindowPos(NULL, rect_size.Width() + 5, 1, 0, 0, 
-		SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
+	m_pPropSheet->SetWindowPos(NULL, rect_size.Width() + 5, 1, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
 
 	// Size the frame window to fit the topology window and the property sheets.
-	m_pPropSheet->GetWindowRect( &tab_sheet_size );
+	m_pPropSheet->GetWindowRect(&tab_sheet_size);
 
-	rect_size.InflateRect( 0, 0, tab_sheet_size.Width() + 18, 112 );
+	rect_size.InflateRect(0, 0, tab_sheet_size.Width() + 18, 112);
 
-	CFrameWnd* pFrame = GetParentFrame();
-	pFrame->MoveWindow( &rect_size );
+	CFrameWnd *pFrame = GetParentFrame();
 
+	pFrame->MoveWindow(&rect_size);
+
 	//////////////////////////////////////////////////////////
 	//
 	// Center the window.
 	//
 	//////////////////////////////////////////////////////////
-	pFrame->GetWindowRect( &rect_size );
+	pFrame->GetWindowRect(&rect_size);
 
 	// Calculate the desired upper left point of the window.
-    int y = ::GetSystemMetrics(SM_CYSCREEN) / 2; 
-    int x = ::GetSystemMetrics(SM_CXSCREEN) / 2;
+	int y =::GetSystemMetrics(SM_CYSCREEN) / 2;
+	int x =::GetSystemMetrics(SM_CXSCREEN) / 2;
 
 	// Get the current center point of the window.
 	CPoint app_center;
+
 	app_center = rect_size.CenterPoint();
 
 	// Move the window by the differnce of the desired and actual.
-	rect_size.OffsetRect( x - app_center.x, y - app_center.y );
-	pFrame->MoveWindow( &rect_size );
+	rect_size.OffsetRect(x - app_center.x, y - app_center.y);
+	pFrame->MoveWindow(&rect_size);
 
 	// Insert the all managers item in the GUI.
 	m_pWorkerView->Initialize();
 
-	theApp.manager_list.ResetResults( WHOLE_TEST_PERF );
-	theApp.manager_list.ResetResults( LAST_UPDATE_PERF );
-	
+	theApp.manager_list.ResetResults(WHOLE_TEST_PERF);
+	theApp.manager_list.ResetResults(LAST_UPDATE_PERF);
+
 	return TRUE;
 }
 
-void CGalileoView::DoDataExchange(CDataExchange* pDX) 
+void CGalileoView::DoDataExchange(CDataExchange * pDX)
 {
 	CView::DoDataExchange(pDX);
 }
 
-
-BOOL CGalileoView::OnEraseBkgnd(CDC* pDC) 
+BOOL CGalileoView::OnEraseBkgnd(CDC * pDC)
 {
-	CBrush* pOldBrush;
+	CBrush *pOldBrush;
 
 	CBrush backBrush;
-	backBrush.CreateSolidBrush(::GetSysColor(COLOR_3DFACE));//COLOR_3DLIGHT
+
+	backBrush.CreateSolidBrush(::GetSysColor(COLOR_3DFACE));	//COLOR_3DLIGHT
 	backBrush.UnrealizeObject();
 
 	CRect rectClient;
+
 	GetClientRect(rectClient);
 
 	pOldBrush = pDC->SelectObject(&backBrush);
@@ -462,24 +441,21 @@
 	return TRUE;
 }
 
-
 //
 // Enabling the display parts for user access.
 //
-void CGalileoView::EnableWindow( BOOL enable )
+void CGalileoView::EnableWindow(BOOL enable)
 {
 	// Do not enable the display when we are testing.
-	if ( enable && theApp.test_state != TestIdle )
+	if (enable && theApp.test_state != TestIdle)
 		return;
 
-	m_pPageDisk->EnableWindow( enable );
-	m_pPageNetwork->EnableWindow( enable );
-	m_pPageAccess->EnableWindow( enable );
-	m_pPageSetup->EnableWindow( enable );
+	m_pPageDisk->EnableWindow(enable);
+	m_pPageNetwork->EnableWindow(enable);
+	m_pPageAccess->EnableWindow(enable);
+	m_pPageSetup->EnableWindow(enable);
 }
 
-
-
 //
 // Resetting display to initial start-up state.
 //
@@ -504,7 +480,7 @@
 	m_pPageNetwork->Reset();
 	m_pPageDisplay->Reset();
 
-	m_pPageSetup->UpdateData( TRUE );
+	m_pPageSetup->UpdateData(TRUE);
 
 	ButtonReset();
 
@@ -512,8 +488,6 @@
 	UnlockWindowUpdate();
 }
 
-
-
 //
 // Resetting display as needed.  Not all items are reset.
 //
@@ -523,31 +497,27 @@
 	m_pPageAccess->Reset();
 }
 
-
-
 //
 // Adds a manager to the display.
 //
-void CGalileoView::AddManager( Manager *manager )
+void CGalileoView::AddManager(Manager * manager)
 {
 	// Lock the GUI while we change it's contents.
 	LockWindowUpdate();
-	m_pWorkerView->AddManager( manager );
-	if ( theApp.manager_list.ManagerCount() == 1 )
+	m_pWorkerView->AddManager(manager);
+	if (theApp.manager_list.ManagerCount() == 1)
 		ButtonReady();
 	m_pPageDisk->ShowData();
 	m_pPageNetwork->ShowData();
-	EnableWindow( TRUE );
+	EnableWindow(TRUE);
 	// Unlock the GUI, we are done changing the contents.
 	UnlockWindowUpdate();
 }
 
-
 //
 // Adds a worker to the display.
 //
-Worker *CGalileoView::AddWorker( TargetType worker_type,
-								 Manager *manager, const CString& name )
+Worker *CGalileoView::AddWorker(TargetType worker_type, Manager * manager, const CString & name)
 {
 	Worker *worker;
 
@@ -555,35 +525,31 @@
 	LockWindowUpdate();
 
 	// Add a worker to the manager.
-	if ( name.IsEmpty() )
-		worker = manager->AddWorker( worker_type );
+	if (name.IsEmpty())
+		worker = manager->AddWorker(worker_type);
 	else
-		worker = manager->AddWorker( worker_type, NULL, name );
+		worker = manager->AddWorker(worker_type, NULL, name);
 
 	// Pass the new worker into the worker view
-	if ( worker )
-	{
-		m_pWorkerView->AddWorker( worker );
+	if (worker) {
+		m_pWorkerView->AddWorker(worker);
 		m_pPageDisk->ShowData();
 		m_pPageNetwork->ShowData();
 	}
 
-	EnableWindow( TRUE );
+	EnableWindow(TRUE);
 	// Unlock the GUI, we are done changing the contents.
 	UnlockWindowUpdate();
 
 	return worker;
 }
 
-
-
 void CGalileoView::OnBStart()
 {
 	Go();
 }
 
-
-void CGalileoView::Go() 
+void CGalileoView::Go()
 {
 	BOOL invalidSpecOK;
 
@@ -592,80 +558,72 @@
 
 	// Remove the focus from whoever has it.  This sends the KILLFOCUS message
 	// to whoever has the focus, possibly causing an update of the GUI data.
-	::SetFocus( NULL );
+	::SetFocus(NULL);
 
 	// If in batch mode, assume the user knows what specs are
 	// running and that they are setup properly.
-	if ( theApp.IsBatchMode() ) {
+	if (theApp.IsBatchMode()) {
 		invalidSpecOK = TRUE;
-	}
-	else {
+	} else {
 		invalidSpecOK = FALSE;
 	}
 
 	// Verify that all tests were defined correctly.
-	if ( theApp.manager_list.InvalidSetup( invalidSpecOK ) ) {
+	if (theApp.manager_list.InvalidSetup(invalidSpecOK)) {
 		return;
 	}
-
 	// Disable displays to prevent user access.
-	EnableWindow( FALSE );
+	EnableWindow(FALSE);
 	ButtonOff();
 
 	// Updating the data from the setup page
-	m_pPageSetup->UpdateData( TRUE );
+	m_pPageSetup->UpdateData(TRUE);
 
 	// Reset access specification display.
 	m_pPageAccess->Reset();
 
 	// Figure out the name of the result file.
-	if ( !theApp.cmdline.GetResultFile().IsEmpty() )
-	{
+	if (!theApp.cmdline.GetResultFile().IsEmpty()) {
 		// The result file was specified on the command line.
 		result_file = theApp.cmdline.GetResultFile();
 
 		// If the test setup indicates that results are not to be recorded,
 		// record ALL results anyway.  (It makes no sense to specify a result
 		// file and not have the test record results.)
-		if ( m_pPageSetup->result_type == RecordNone )
+		if (m_pPageSetup->result_type == RecordNone)
 			m_pPageSetup->result_type = RecordAll;
-	}
-	else if ( m_pPageSetup->result_type != RecordNone )
-	{
+	} else if (m_pPageSetup->result_type != RecordNone) {
 		// The user wants to save the results to a file,
 		// but no filename was specified on the command line.
-		CFileDialog	file_box(FALSE, "csv", "results",
-			OFN_HIDEREADONLY | OFN_NOTESTFILECREATE, 
-			"CSV Files (*.csv)|*.csv|Text Files (*.txt)|*.txt|All Files (*.*)|*.*||" );
+		CFileDialog file_box(FALSE, "csv", "results",
+				     OFN_HIDEREADONLY | OFN_NOTESTFILECREATE,
+				     "CSV Files (*.csv)|*.csv|Text Files (*.txt)|*.txt|All Files (*.*)|*.*||");
 		file_box.m_ofn.lpstrTitle = "Save Results";
 
-		if ( file_box.DoModal() == IDOK )
+		if (file_box.DoModal() == IDOK)
 			result_file = file_box.GetPathName();
 		else
 			result_file.Empty();
 	}
-
 	// If a result file is being used, 
-	if ( !result_file.IsEmpty() )
-	{
+	if (!result_file.IsEmpty()) {
 		// Opening result file.
-		ofstream file( result_file, ios::app );
+		ofstream file(result_file, ios::app);
 
-		file << setiosflags( ios::fixed ) << setprecision( 2 );
+		file << setiosflags(ios::fixed) << setprecision(2);
 
 		// Saving test configuration
-		m_pPageSetup->SaveResults( &file );
+		m_pPageSetup->SaveResults(&file);
 
 		file.close();
 	}
-
 	// Save any settings that may change during the test, so they can be reset
 	// after the test runs.
 	SaveSettings();
 
 	// Determine how many total tests runs there will be.
 	CalcRunCount();
-	
+
 	// Initialize information for first test run.
 	access_index = 0;
 	run_index = 0;
@@ -676,7 +634,7 @@
 	// they complete.
 	worker_to_prepare = 0;
 	manager_to_prepare = 0;
-	if ( DisksNotPrepared() )
+	if (DisksNotPrepared())
 		return;
 
 	// Start running the tests.
@@ -685,46 +643,40 @@
 	StartTest();
 }
 
-
-
 //
 // Mark assigned targets as active based on selected cycling option.
 //
 BOOL CGalileoView::SetActiveTargets()
 {
 	// Check for test cycling.
-	switch ( m_pPageSetup->test_type )
-	{
-	// Add disk_step drives for all workers to all managers at a time.
+	switch (m_pPageSetup->test_type) {
+		// Add disk_step drives for all workers to all managers at a time.
 	case CyclingTargets:
 		return CycleTargets();
-	// Add worker_step workers, with all selected drives, to all managers.
+		// Add worker_step workers, with all selected drives, to all managers.
 	case CyclingWorkers:
 		return CycleWorkers();
-	// Add disk_step drives to worker_step workers.
+		// Add disk_step drives to worker_step workers.
 	case CyclingWorkersTargets:
 		return CycleWorkersTargets();
-	// Add disk_step drives, down each worker, at a time for all managers.
+		// Add disk_step drives, down each worker, at a time for all managers.
 	case CyclingIncTargetsParallel:
 		return IncrementTargets();
-	// Add disk_step drives, down each worker, one manager at a time.
+		// Add disk_step drives, down each worker, one manager at a time.
 	case CyclingIncTargetsSerial:
 		return IncrementTargetsSerial();
-	// Add disk_step drives, down each worker, one manager at a time.
+		// Add disk_step drives, down each worker, one manager at a time.
 	case CyclingQueue:
 		return CycleQueue();
-	// Add disk_step drives, down each worker, one manager at a time.
+		// Add disk_step drives, down each worker, one manager at a time.
 	case CyclingQueueTargets:
 		return CycleTargetsQueue();
-	// Normal test run.  Run selected targets for all workers.
+		// Normal test run.  Run selected targets for all workers.
 	default:
 		return Normal();
 	}
 }
 
-
-
-
 //
 // Set targets for all workers according to the current test and cycling mode.
 // Returns TRUE for success, or FALSE if any error occurs.
@@ -739,17 +691,14 @@
 	return theApp.manager_list.SetTargets();
 }
 
-
-
 //
 // Set the access specifications for all managers and workers.
 //
 BOOL CGalileoView::SetAccess()
 {
-	return theApp.manager_list.SetAccess( access_index );
+	return theApp.manager_list.SetAccess(access_index);
 }
 
-
 //
 // Returns the currently running access spec's index.
 //
@@ -758,8 +707,6 @@
 	return access_index;
 }
 
-
-
 //
 // Initialize all test cycling control variables for the next set of tests
 // on the current access spec.
@@ -777,86 +724,71 @@
 	theApp.manager_list.ClearActiveTargets();
 }
 
-
-
 //
 // Saves and configuration settings that may be changed during testing, so
 // they may be restored after testing completes.
 //
 void CGalileoView::SaveSettings()
 {
-	int		i = 0, m, w, mgr_count, wkr_count;
-	Manager	*mgr;
+	int i = 0, m, w, mgr_count, wkr_count;
+	Manager *mgr;
 
 	// See if queue depth will change during testing.
-	if ( m_pPageSetup->test_type != CyclingQueue &&
-		m_pPageSetup->test_type != CyclingQueueTargets )
-	{
+	if (m_pPageSetup->test_type != CyclingQueue && m_pPageSetup->test_type != CyclingQueueTargets) {
 		return;
 	}
-
 	// Save queue depth settings.  Allocate an array large enough.
-	save_queue_depth = (int*)malloc( theApp.manager_list.WorkerCount() 
-		* sizeof( int ) );
-	if ( !save_queue_depth )
-	{
-		ErrorMessage( "Could not allocate memory to save current worker "
-			"settings.  Current values will be lost." );
+	save_queue_depth = (int *)malloc(theApp.manager_list.WorkerCount()
+					 * sizeof(int));
+	if (!save_queue_depth) {
+		ErrorMessage("Could not allocate memory to save current worker "
+			     "settings.  Current values will be lost.");
 		return;
 	}
 
 	mgr_count = theApp.manager_list.ManagerCount();
-	for ( m = 0; m < mgr_count; m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < mgr_count; m++) {
+		mgr = theApp.manager_list.GetManager(m);
 		wkr_count = mgr->WorkerCount();
-		for ( w = 0; w < wkr_count; w++ )
-		{
+		for (w = 0; w < wkr_count; w++) {
 			// Assumes all targets for a worker have the same queue depth.
-			save_queue_depth[i++] = mgr->GetWorker( w )->GetQueueDepth( 
-				GenericType );
+			save_queue_depth[i++] = mgr->GetWorker(w)->GetQueueDepth(GenericType);
 		}
 	}
 }
 
-
-
 //
 // Restores all previously saved test configuration settings.
 //
 void CGalileoView::RestoreSettings()
 {
-	int		i = 0, m, w, mgr_count, wkr_count;
-	Manager	*mgr;
+	int i = 0, m, w, mgr_count, wkr_count;
+	Manager *mgr;
 
-	if ( !save_queue_depth )
+	if (!save_queue_depth)
 		return;
 
 	// Restore saved queue depth settings.
 	mgr_count = theApp.manager_list.ManagerCount();
-	for ( m = 0; m < mgr_count; m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < mgr_count; m++) {
+		mgr = theApp.manager_list.GetManager(m);
 		wkr_count = mgr->WorkerCount();
-		for ( w = 0; w < wkr_count; w++ )
-			mgr->GetWorker( w )->SetQueueDepth( save_queue_depth[i++] );
+		for (w = 0; w < wkr_count; w++)
+			mgr->GetWorker(w)->SetQueueDepth(save_queue_depth[i++]);
 	}
 
 	// Free memory used to save configuration.
-	free( save_queue_depth );
+	free(save_queue_depth);
 	save_queue_depth = NULL;
 }
 
-
-
 //
 // Starting all testing.  This signals all Dynamos to begin performing I/Os.
 //
 void CGalileoView::StartTest()
 {
-	if ( !SetAccess() || !SetTargets() )
-	{
-		TestDone( ReturnError );
+	if (!SetAccess() || !SetTargets()) {
+		TestDone(ReturnError);
 		return;
 	}
 
@@ -869,33 +801,27 @@
 	UpdateTestStatus();
 
 	// Signal Dynamo to start the next test.
-	if ( !theApp.manager_list.SendActiveManagers( START ) ||
-		!theApp.manager_list.SendActiveManagers( BEGIN_IO ) )
-	{
+	if (!theApp.manager_list.SendActiveManagers(START) || !theApp.manager_list.SendActiveManagers(BEGIN_IO)) {
 		// Testing failed to successfully start.
-		StopTest( ReturnError );
+		StopTest(ReturnError);
 		return;
 	}
-
 	// Waiting ramping up period or signaling to start recording results.
-	if ( m_pPageSetup->ramp_time )
-		SetTimer( RAMP_TIMER, m_pPageSetup->ramp_time * 1000, NULL );
+	if (m_pPageSetup->ramp_time)
+		SetTimer(RAMP_TIMER, m_pPageSetup->ramp_time * 1000, NULL);
 	else
 		StartRecording();
 
 	// enable Stop and Stop All buttons
 	ButtonTest();
-	if ( run_index < run_count )
-	{
-		m_pPageDisplay->m_dlgBigMeter.SetButtonState( FALSE, TRUE, TRUE );
+	if (run_index < run_count) {
+		m_pPageDisplay->m_dlgBigMeter.SetButtonState(FALSE, TRUE, TRUE);
 		SetButton(BStopAll, TRUE);
 	}
 
 	theApp.m_wndToolBar.RedrawWindow();
 }
 
-
-
 //
 // Starting to record results.  We are through ramping up.
 //
@@ -906,103 +832,90 @@
 	theApp.test_state = TestRecording;
 
 	// Get amount of time to run test.
-	if ( timer_delay = m_pPageSetup->GetRunTime() )
-		SetTimer( TEST_TIMER, timer_delay, NULL );
+	if (timer_delay = m_pPageSetup->GetRunTime())
+		SetTimer(TEST_TIMER, timer_delay, NULL);
 
 	// Signal Dynamo to start recording.
-	theApp.manager_list.SendActiveManagers( RECORD_ON );
+	theApp.manager_list.SendActiveManagers(RECORD_ON);
 
 	// Get update frequency of results display.
-	if ( timer_delay = m_pPageDisplay->GetUpdateDelay() )
-		SetTimer( DISPLAY_TIMER, timer_delay, NULL ); 
+	if (timer_delay = m_pPageDisplay->GetUpdateDelay())
+		SetTimer(DISPLAY_TIMER, timer_delay, NULL);
 }
 
-
-
 //
 // Prepare drives that need to be prepared.
 //
 BOOL CGalileoView::DisksNotPrepared()
 {
-	Manager	*manager;
-	int		wkr_count;
+	Manager *manager;
+	int wkr_count;
 
 	// Loop through managers.
-	while ( manager_to_prepare < theApp.manager_list.ManagerCount())
-	{
-		manager = theApp.manager_list.GetManager( manager_to_prepare );
+	while (manager_to_prepare < theApp.manager_list.ManagerCount()) {
+		manager = theApp.manager_list.GetManager(manager_to_prepare);
 
 		// Loop through each manager's workers.
 		wkr_count = manager->WorkerCount();
-		for ( worker_to_prepare = 0; worker_to_prepare < wkr_count; 
-			worker_to_prepare++ )
-		{
+		for (worker_to_prepare = 0; worker_to_prepare < wkr_count; worker_to_prepare++) {
 			// Does the worker need to prepare its targets?
-			if ( !manager->GetWorker( worker_to_prepare )->ReadyToRunTests() )
-			{
+			if (!manager->GetWorker(worker_to_prepare)->ReadyToRunTests()) {
 				// enable StopAll button
-				manager->SetTargetsToPrepare( worker_to_prepare );
+				manager->SetTargetsToPrepare(worker_to_prepare);
 				ButtonPrepare();
-				SetTimer( PREPARE_TIMER, LONG_DELAY, NULL );
-				SetStatusBarText( m_pPageSetup->test_name, 
-					"Preparing Drives" );
- 				return TRUE;	// preparing
+				SetTimer(PREPARE_TIMER, LONG_DELAY, NULL);
+				SetStatusBarText(m_pPageSetup->test_name, "Preparing Drives");
+				return TRUE;	// preparing
 			}
 		}
 		manager_to_prepare++;
 	}
-	return FALSE;	// all drives prepared
+	return FALSE;		// all drives prepared
 }
 
-
-
-void CGalileoView::OnTimer(UINT nIDEvent) 
+void CGalileoView::OnTimer(UINT nIDEvent)
 {
 	int timer_delay;
 
-	switch (nIDEvent)
-	{
-	// Display timer has expired.  Get result update.
+	switch (nIDEvent) {
+		// Display timer has expired.  Get result update.
 	case DISPLAY_TIMER:
-		KillTimer( nIDEvent );
+		KillTimer(nIDEvent);
 
 		// Get a results update from Dynamo and update the display.
-	
+
 		// Always get results for the whole test so far.
-		theApp.manager_list.UpdateResults( WHOLE_TEST_PERF );
+		theApp.manager_list.UpdateResults(WHOLE_TEST_PERF);
 		// Also get results since the last update, if requested.
-		if ( m_pPageDisplay->GetWhichPerf() == LAST_UPDATE_PERF )
-			theApp.manager_list.UpdateResults( LAST_UPDATE_PERF );
+		if (m_pPageDisplay->GetWhichPerf() == LAST_UPDATE_PERF)
+			theApp.manager_list.UpdateResults(LAST_UPDATE_PERF);
 		// Update the display, using whole test or last update results as appropriate.
 		m_pPageDisplay->Update();
 
 		// Reset the result update timer
-		if ( timer_delay = m_pPageDisplay->GetUpdateDelay() )
-			SetTimer( DISPLAY_TIMER, timer_delay, NULL );
+		if (timer_delay = m_pPageDisplay->GetUpdateDelay())
+			SetTimer(DISPLAY_TIMER, timer_delay, NULL);
 		return;
 
-	// Ramp-up timer has expired.  Beginning testing.
+		// Ramp-up timer has expired.  Beginning testing.
 	case RAMP_TIMER:
-		KillTimer( nIDEvent );
+		KillTimer(nIDEvent);
 		StartRecording();
 		return;
 
 	case PREPARE_TIMER:
 		// See if Dynamo has responded that the drive is prepared.
-		if ( !theApp.manager_list.GetManager( manager_to_prepare )->Peek( worker_to_prepare ) )
-			return;			// not done yet - keep waiting
+		if (!theApp.manager_list.GetManager(manager_to_prepare)->Peek(worker_to_prepare))
+			return;	// not done yet - keep waiting
 
 		// Completion message has arrived.  Stop waiting and get response.
 		KillTimer(nIDEvent);
-		if ( !theApp.manager_list.GetManager( 
-			manager_to_prepare )->PreparedAnswer( worker_to_prepare ) )
-		{
-			ErrorMessage( "Failed to prepare targets for testing." );
-			TestDone( ReturnError );
+		if (!theApp.manager_list.GetManager(manager_to_prepare)->PreparedAnswer(worker_to_prepare)) {
+			ErrorMessage("Failed to prepare targets for testing.");
+			TestDone(ReturnError);
 		}
-
 		// See if anymore drives need to be prepared on other systems.
-		if ( DisksNotPrepared() )
+		if (DisksNotPrepared())
 			return;
 
 		ButtonOff();
@@ -1016,7 +929,7 @@
 		return;
 
 	case TEST_TIMER:
-		StopTest( ReturnSuccess );
+		StopTest(ReturnSuccess);
 		return;
 
 	case IDLE_TIMER:
@@ -1027,70 +940,60 @@
 	}
 }
 
-
 void CGalileoView::OnBStop()
 {
 	theApp.cmdline.OverrideBatchMode();	// abort batch mode
-	StopTest( ReturnSuccess );
+	StopTest(ReturnSuccess);
 }
 
-
-void CGalileoView::StopTest( ReturnVal test_successful )
+void CGalileoView::StopTest(ReturnVal test_successful)
 {
-	bool		recording;
+	bool recording;
 	CWaitCursor wait;
+
 	ButtonOff();
 
 	// Signal all workers to stop recording if they currently are.
-	if ( recording = (theApp.test_state == TestRecording) )
-	{
+	if (recording = (theApp.test_state == TestRecording)) {
 		theApp.test_state = TestRampingDown;
-		theApp.manager_list.SendActiveManagers( RECORD_OFF );
+		theApp.manager_list.SendActiveManagers(RECORD_OFF);
 	}
-
 	// Stop all timers and tell all workers to stop test
-	KillTimer( RAMP_TIMER );
-	KillTimer( TEST_TIMER );
-	KillTimer( DISPLAY_TIMER );
+	KillTimer(RAMP_TIMER);
+	KillTimer(TEST_TIMER);
+	KillTimer(DISPLAY_TIMER);
 	theApp.test_state = TestIdle;
-	theApp.manager_list.SendActiveManagers( STOP );
+	theApp.manager_list.SendActiveManagers(STOP);
 
 	// If we were recording results when we stopped.  Update the results.
-	if ( recording )
-	{
+	if (recording) {
 		// Always get results for the whole test and since the last update.
-		theApp.manager_list.UpdateResults( WHOLE_TEST_PERF );
-		theApp.manager_list.UpdateResults( LAST_UPDATE_PERF );
+		theApp.manager_list.UpdateResults(WHOLE_TEST_PERF);
+		theApp.manager_list.UpdateResults(LAST_UPDATE_PERF);
 		// Update the display, using whole test or last update results as appropriate.
 		m_pPageDisplay->Update();
 		// Save them to a file if user requested it.
 		SaveResults();
 	}
-
 	// See if the testing ended abnormally or was aborted.
-	if ( test_successful != ReturnSuccess )
-	{
+	if (test_successful != ReturnSuccess) {
 		// If saving results, write an abort message into the result file.
-		if ( (m_pPageSetup->result_type != RecordNone) && !result_file.IsEmpty() )
-		{
-			ofstream file( result_file, ios::app );
+		if ((m_pPageSetup->result_type != RecordNone) && !result_file.IsEmpty()) {
+			ofstream file(result_file, ios::app);
+
 			file << "Aborted test" << endl;
 			file.close();
 		}
-		TestDone( test_successful );
+		TestDone(test_successful);
 		return;
 	}
-
 	// See if we need to run another test.
-	if ( run_index >= run_count )
-	{
-		TestDone( ReturnSuccess );
+	if (run_index >= run_count) {
+		TestDone(ReturnSuccess);
 		return;
 	}
-
 	// See if there are more tests to run for the current access spec.
-	if ( !SetActiveTargets() )
-	{
+	if (!SetActiveTargets()) {
 		// Continue running on the next access spec.  First find a spec
 		// that will run.  This is necessary in case an Idle spec has been set
 		// after all real access specs.
@@ -1101,101 +1004,89 @@
 			// Call Normal() to set all targets as active, then see if
 			// anyone will run for the current access spec.
 			Normal();
-		} while ( !theApp.manager_list.ActiveInCurrentTest() );
+		} while (!theApp.manager_list.ActiveInCurrentTest());
 		InitAccessSpecRun();
 		SetActiveTargets();
 		SaveAccessSpecs();
 	}
-
 	// Start the next test.
 	StartTest();
 }
 
-
-
 void CGalileoView::OnBStopAll()
 {
 	theApp.cmdline.OverrideBatchMode();	// abort batch mode
 	StopAll();
 }
 
-
 //
 // Stopping testing or disk preparation.
 //
-void CGalileoView::StopAll() 
+void CGalileoView::StopAll()
 {
-	switch ( theApp.test_state )
-	{
+	switch (theApp.test_state) {
 	case TestPreparing:
 		// We are aborting disk preparation.  Signal workers to stop.
 		theApp.test_state = TestIdle;
-		KillTimer( PREPARE_TIMER );
-		theApp.manager_list.Send( manager_to_prepare, STOP_PREPARE, worker_to_prepare );
-		theApp.manager_list.GetManager( manager_to_prepare )->Receive();
+		KillTimer(PREPARE_TIMER);
+		theApp.manager_list.Send(manager_to_prepare, STOP_PREPARE, worker_to_prepare);
+		theApp.manager_list.GetManager(manager_to_prepare)->Receive();
 
 		// Notify user of the abort and re-enable the GUI.
-		SetStatusBarText( m_pPageSetup->test_name, "Preparation Aborted" );
-		EnableWindow( TRUE );
+		SetStatusBarText(m_pPageSetup->test_name, "Preparation Aborted");
+		EnableWindow(TRUE);
 		ButtonReady();
 		break;
 	case TestRampingUp:
 	case TestRecording:
 		// Abort testing.
-		StopTest( ReturnAbort );
+		StopTest(ReturnAbort);
 		break;
 	default:
 		ErrorMessage("Unexpected test state in CGalileoView::OnBStopAll().");
 	}
 }
 
-
-
 //
 // All testing has completed.
 //
-void CGalileoView::TestDone( ReturnVal test_successful )
+void CGalileoView::TestDone(ReturnVal test_successful)
 {
 	// If Iometer is in batch mode and the test finishes, close Iometer.
-	if ( theApp.IsBatchMode() )
+	if (theApp.IsBatchMode())
 		::PostQuitMessage(0);
 
 	// Re-enable the GUI.
-	EnableWindow( TRUE );
+	EnableWindow(TRUE);
 	ButtonReady();
 
-	switch ( test_successful )
-	{
+	switch (test_successful) {
 	case ReturnSuccess:
-		m_pPageAccess->MarkAccesses( access_index );
-		SetStatusBarText( "Test Completed Successfully" );
+		m_pPageAccess->MarkAccesses(access_index);
+		SetStatusBarText("Test Completed Successfully");
 		break;
 	case ReturnError:
-		ErrorMessage( "Testing encountered an error and is unable to continue."
-			"  See Dynamo output for additional error messages." );
+		ErrorMessage("Testing encountered an error and is unable to continue."
+			     "  See Dynamo output for additional error messages.");
 	case ReturnAbort:
 		theApp.test_state = TestIdle;
-		SetStatusBarText( "Test Aborted" );
+		SetStatusBarText("Test Aborted");
 	}
 
 	// Restore any previously saved test values.
 	RestoreSettings();
 }
 
-
-
 //
 // User wishes to reset the program.
 //
-void CGalileoView::OnBReset() 
+void CGalileoView::OnBReset()
 {
-	::SetFocus( NULL );
+	::SetFocus(NULL);
 
 	Reset();
 }
 
-
-
 //
 // Saving results from test into a file.  Open the file here and have each manager, worker, etc. 
 // save their own results.
@@ -1204,19 +1095,17 @@
 {
 	// Don't do anything unless the user has specified some results to be saved
 	// and a file to save them to
-	if ( (m_pPageSetup->result_type == RecordNone) || result_file.IsEmpty() )
+	if ((m_pPageSetup->result_type == RecordNone) || result_file.IsEmpty())
 		return;
 
-	ofstream file( result_file, ios::app );
+	ofstream file(result_file, ios::app);
 
 	// Save results for workers and their managers.
-	file << setiosflags( ios::fixed ) << setprecision( 6 );
-	theApp.manager_list.SaveResults( &file, access_index, m_pPageSetup->result_type );
+	file << setiosflags(ios::fixed) << setprecision(6);
+	theApp.manager_list.SaveResults(&file, access_index, m_pPageSetup->result_type);
 	file.close();
 }
 
-
-
 //
 // Saving all active access specs for the current access_index to the result_file.
 //
@@ -1224,16 +1113,15 @@
 {
 	// Don't do anything unless the user has specified some results to be saved
 	// and a file to save them to
-	if ( (m_pPageSetup->result_type == RecordNone) || result_file.IsEmpty() )
+	if ((m_pPageSetup->result_type == RecordNone) || result_file.IsEmpty())
 		return;
 
-	ofstream file( result_file, ios::app );
-	theApp.access_spec_list.SaveResults( file );
+	ofstream file(result_file, ios::app);
+
+	theApp.access_spec_list.SaveResults(file);
 	file.close();
 }
 
-
-
 //
 // Open a file to load test specifications.
 //
@@ -1242,7 +1130,7 @@
 	BOOL flags[NumICFFlags];
 
 	// Show the custom file open dialog.
-	if ( file_open_box.DoModal() == IDCANCEL )
+	if (file_open_box.DoModal() == IDCANCEL)
 		return;
 
 	flags[ICFTestSetupFlag] = file_open_box.isCkTestSetup;
@@ -1253,20 +1141,18 @@
 	flags[ICFAssignedTargetFlag] = file_open_box.isCkAssignTargets;
 
 	// Could optionally test return value to see if file was restored without errors.
-	(void) PrepareToOpenConfigFile( file_open_box.GetPathName(), flags, file_open_box.isROverwrite );
+	(void)PrepareToOpenConfigFile(file_open_box.GetPathName(), flags, file_open_box.isROverwrite);
 }
 
-
-
 //
 // Saving current test setup information.
 //
-void CGalileoView::OnFileSave() 
+void CGalileoView::OnFileSave()
 {
 	BOOL flags[NumICFFlags];
 
 	// Show the custom file save dialog.
-	if ( file_save_box.DoModal() == IDCANCEL )
+	if (file_save_box.DoModal() == IDCANCEL)
 		return;
 
 	flags[ICFTestSetupFlag] = file_save_box.isCkTestSetup;
@@ -1277,11 +1163,9 @@
 	flags[ICFAssignedTargetFlag] = file_save_box.isCkAssignTargets;
 
 	// Could optionally test return value to see if file was saved without errors.
-	(void) SaveConfigFile( file_save_box.GetPathName(), flags );
+	(void)SaveConfigFile(file_save_box.GetPathName(), flags);
 }
 
-
-
 //
 // Preprocesses the config file and makes sure all managers specified in
 // the file are available (or waits on them), then calls OpenConfigFile.
@@ -1291,9 +1175,7 @@
 // or that managers are being waited on.  (In the latter case, no indication will be
 // given about the success of the eventual call to OpenConfigFile.)
 //
-BOOL CGalileoView::PrepareToOpenConfigFile(	const CString& infilename,
-											BOOL* flags,
-											BOOL replace )
+BOOL CGalileoView::PrepareToOpenConfigFile(const CString & infilename, BOOL * flags, BOOL replace)
 {
 	// Do some preliminary checking on the file before we toss
 	// the filename off to the other LoadConfig routines.
@@ -1301,41 +1183,35 @@
 	ICF_ifstream infile(infilename);
 
 	// Was the file opened successfully?
-	if ( !infile.is_open() )
-	{
-		ErrorMessage( "Could not open \"" + infilename + "\"" );
+	if (!infile.is_open()) {
+		ErrorMessage("Could not open \"" + infilename + "\"");
 		return FALSE;
 	}
-
 	// Verify that the file can be read.
-	if ( infile.rdstate() )
-	{
-		ErrorMessage( "Error reading from \"" + infilename + "\"" );
+	if (infile.rdstate()) {
+		ErrorMessage("Error reading from \"" + infilename + "\"");
 		infile.close();
 		return FALSE;
 	}
 
 	infile.close();
 
-	if ( flags[ICFManagerWorkerFlag] )
-	{
+	if (flags[ICFManagerWorkerFlag]) {
 		// Manager configuration is being restored,
 
 		// Prepare a map of which saved managers should
 		// be restored to which managers logged into Iometer.
 		theApp.manager_list.loadmap.Reset();
 
-		if ( !theApp.manager_list.LoadConfigPreprocess( infilename, flags, replace ) )
-		{
+		if (!theApp.manager_list.LoadConfigPreprocess(infilename, flags, replace)) {
 			return FALSE;
 		}
 
-		if ( theApp.manager_list.loadmap.IsWaitingList() )
-		{
+		if (theApp.manager_list.loadmap.IsWaitingList()) {
 			// The ManagerMap is in a waiting state.
 
 			// Display the waiting list dialog.
-			theApp.manager_list.loadmap.ShowWaitingList( infilename, flags, replace );
+			theApp.manager_list.loadmap.ShowWaitingList(infilename, flags, replace);
 
 			// Control will immediately return to Iometer so new Dynamos can log in.
 			// The user will not be allowed to interfere with Iometer while
@@ -1344,13 +1220,11 @@
 			return TRUE;
 		}
 	}
-
 	// Either the loadmap has been set up or it is not needed.
 	// Go ahead and start loading the config file.
 	return OpenConfigFile(infilename, flags, replace);
 }
 
-
 //
 // Perform load of Iometer Configuration File (.icf).
 // This function assumes that the ManagerMap has been created and all
@@ -1359,18 +1233,15 @@
 // This should only be called by OpenConfigFileWrapper or as the callback
 // function for the CWaitingForManagers dialog box.
 //
-BOOL CGalileoView::OpenConfigFile(	const CString& infilename,
-									BOOL* flags,
-									BOOL replace )
+BOOL CGalileoView::OpenConfigFile(const CString & infilename, BOOL * flags, BOOL replace)
 {
 	CWaitCursor wait;
 	BOOL retval;
 
-	if (flags[ICFTestSetupFlag])
-	{
+	if (flags[ICFTestSetupFlag]) {
 		// Restore test setup tab settings.
 
-		retval = m_pPageSetup->LoadConfig( infilename );
+		retval = m_pPageSetup->LoadConfig(infilename);
 
 		m_pPageSetup->UpdateData(FALSE);	// copy variables to GUI
 
@@ -1378,10 +1249,9 @@
 			return FALSE;
 	}
 
-	if (flags[ICFGlobalAspecFlag])
-	{
+	if (flags[ICFGlobalAspecFlag]) {
 		// Restore global access specification list.
-		retval = theApp.access_spec_list.LoadConfig( infilename, replace );
+		retval = theApp.access_spec_list.LoadConfig(infilename, replace);
 
 		// Update the Access Spec page.
 		m_pPageAccess->ShowGlobalAccess();
@@ -1389,22 +1259,20 @@
 
 		// Did we fail?  (Have to check for this AFTER the update
 		// in case some modifications were made before the error.)
-		if ( !retval )
+		if (!retval)
 			return FALSE;
 	}
 
-	if (flags[ICFManagerWorkerFlag])
-	{
+	if (flags[ICFManagerWorkerFlag]) {
 		// Restore manager/worker configuration.
 
 		// Prevent the worker view from updating until
 		// all updates have taken place.
 		LockWindowUpdate();
 
-		retval = theApp.manager_list.LoadConfig( infilename,
-												flags[ICFAssignedAspecFlag],
-												flags[ICFAssignedTargetFlag],
-												replace );
+		retval = theApp.manager_list.LoadConfig(infilename,
+							flags[ICFAssignedAspecFlag],
+							flags[ICFAssignedTargetFlag], replace);
 
 		UnlockWindowUpdate();
 
@@ -1417,20 +1285,17 @@
 			return FALSE;
 	}
 
-	if (flags[ICFResultsDisplayFlag])
-	{
+	if (flags[ICFResultsDisplayFlag]) {
 		// Restore results display tab settings.
 		// This must be done AFTER restoring workers/managers!
 
-		retval = m_pPageDisplay->LoadConfig( infilename );
+		retval = m_pPageDisplay->LoadConfig(infilename);
 
 		m_pPageDisplay->UpdateData(FALSE);	// copy variables to GUI
 
-		if ( !retval )
+		if (!retval)
 			return FALSE;
-	}
-	else
-	{
+	} else {
 		// If results display settings is not being restored
 		// from the file, reset the results display tab.
 		theApp.pView->m_pPageDisplay->Reset();
@@ -1439,38 +1304,35 @@
 	return TRUE;
 }
 
-
 //
 // Saving current test setup information.
 //
-BOOL CGalileoView::SaveConfigFile( const CString& outfilename, BOOL* flags )
+BOOL CGalileoView::SaveConfigFile(const CString & outfilename, BOOL * flags)
 {
 	CWaitCursor wait;
 
 	CString cstrVersion;
-	cstrVersion.Format( IDS_VERSION_OUTPUT, (LPCTSTR)theApp.GetVersionString (TRUE));
+
+	cstrVersion.Format(IDS_VERSION_OUTPUT, (LPCTSTR) theApp.GetVersionString(TRUE));
 	char *pVersion = cstrVersion.GetBuffer(cstrVersion.GetLength());
 
 	// Open the specified file for output and save the test setup.
-	ofstream outfile( outfilename );
+	ofstream outfile(outfilename);
 
 	// Was the file opened successfully?
-	if ( !outfile.is_open() )
-	{
-		ErrorMessage( "Could not open \"" + outfilename + "\" for writing." );
+	if (!outfile.is_open()) {
+		ErrorMessage("Could not open \"" + outfilename + "\" for writing.");
 		return FALSE;
 	}
 
 	outfile << pVersion << endl;
 
-	if (flags[ICFTestSetupFlag])
-	{
+	if (flags[ICFTestSetupFlag]) {
 		// Save test setup tab settings.
 
 		m_pPageSetup->UpdateData(TRUE);	// copy GUI data to variables
 
-		if (!m_pPageSetup->SaveConfig( outfile ))
-		{
+		if (!m_pPageSetup->SaveConfig(outfile)) {
 			outfile << pVersion << endl;
 			outfile << "Error while writing test setup" << endl;
 			outfile.close();
@@ -1478,14 +1340,12 @@
 		}
 	}
 
-	if (flags[ICFResultsDisplayFlag])
-	{
+	if (flags[ICFResultsDisplayFlag]) {
 		// Save results display tab settings.
 
 		m_pPageDisplay->UpdateData(TRUE);	// copy GUI data to variables
 
-		if (!m_pPageDisplay->SaveConfig( outfile ))
-		{
+		if (!m_pPageDisplay->SaveConfig(outfile)) {
 			outfile << pVersion << endl;
 			outfile << "Error while writing results display" << endl;
 			outfile.close();
@@ -1493,12 +1353,10 @@
 		}
 	}
 
-	if (flags[ICFGlobalAspecFlag])
-	{
+	if (flags[ICFGlobalAspecFlag]) {
 		// Save global access specification list.
 
-		if (!theApp.access_spec_list.SaveConfig( outfile ))
-		{
+		if (!theApp.access_spec_list.SaveConfig(outfile)) {
 			outfile << pVersion << endl;
 			outfile << "Error while writing global access spec list" << endl;
 			outfile.close();
@@ -1506,14 +1364,10 @@
 		}
 	}
 
-	if (flags[ICFManagerWorkerFlag])
-	{
+	if (flags[ICFManagerWorkerFlag]) {
 		// Save manager/worker configuration.
 
-		if ( !theApp.manager_list.SaveConfig( outfile,
-											flags[ICFAssignedAspecFlag],
-											flags[ICFAssignedTargetFlag]) )
-		{
+		if (!theApp.manager_list.SaveConfig(outfile, flags[ICFAssignedAspecFlag], flags[ICFAssignedTargetFlag])) {
 			outfile << pVersion << endl;
 			outfile << "Error while writing manager/worker configuration" << endl;
 			outfile.close();
@@ -1527,12 +1381,10 @@
 	return TRUE;
 }
 
-
-
-void CGalileoView::OnBExitOne() 
+void CGalileoView::OnBExitOne()
 {
 	// Forcing update to target selection information in case one is needed.
-	::SetFocus( NULL );
+	::SetFocus(NULL);
 
 	// Lock the GUI while we change it's contents.
 	LockWindowUpdate();
@@ -1547,19 +1399,15 @@
 	UnlockWindowUpdate();
 }
 
-
-
 //
 // Processing request to spawn a new manager.
 //
-void CGalileoView::OnBNewDynamo() 
+void CGalileoView::OnBNewDynamo()
 {
 	// Spawn a Dynamo with no command line options.
 	theApp.LaunchDynamo();
 }
 
-
-
 //
 // The worker selection has changed.  Processing the update.
 //
@@ -1568,54 +1416,44 @@
 	CWaitCursor wait;
 
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
 
 	// Lock the GUI while we change it's contents.
 	LockWindowUpdate();
 	// Set the new worker/manager buttons if the test is idle and the
 	// toolbar window exists.
-	if ( theApp.test_state == TestIdle &&
-		::IsWindow( theApp.m_wndToolBar.GetToolBarCtrl().m_hWnd) )
-	{
+	if (theApp.test_state == TestIdle &&::IsWindow(theApp.m_wndToolBar.GetToolBarCtrl().m_hWnd)) {
 		manager = m_pWorkerView->GetSelectedManager();
-		
+
 		// Enable the new worker buttons
-		SetButton( BNewDiskWorker, manager && manager->InterfaceCount( 
-			GenericDiskType ) );
-		SetButton( BNewNetWorker, manager && manager->InterfaceCount( 
-			GenericNetType ) );
-		
+		SetButton(BNewDiskWorker, manager && manager->InterfaceCount(GenericDiskType));
+		SetButton(BNewNetWorker, manager && manager->InterfaceCount(GenericNetType));
+
 		// Don't allow copies of network clients.  Will be very confusing when
 		// we allow multiple clients per server.
 		worker = m_pWorkerView->GetSelectedWorker();
-		SetButton( BCopyWorker, worker && 
-			!IsType( worker->Type(), GenericClientType ) );
+		SetButton(BCopyWorker, worker && !IsType(worker->Type(), GenericClientType));
 	}
-
 	// Display and enable the target pages, if appropriate.
 	m_pPageNetwork->ShowData();
 	m_pPageDisk->ShowData();
 
 	// Update the access spec page to reflect the change in selection.
 	m_pPageAccess->ShowAssignedAccess();
-	m_pPageAccess->MarkAccesses( access_index );
+	m_pPageAccess->MarkAccesses(access_index);
 
 	// Unlock the GUI, we are done changing the contents.
 	UnlockWindowUpdate();
 }
 
-
-
 //
 // The worker selection is changing.  Processing the update.
 void CGalileoView::ChangingSelection()
 {
 	// Update the target selections before changing.
-	::SetFocus( m_pWorkerView->m_TWorkers );
+	::SetFocus(m_pWorkerView->m_TWorkers);
 }
 
-
-
 //
 // Setting specified number of targets active for all workers on all managers 
 // at one time.
@@ -1626,56 +1464,47 @@
 //
 BOOL CGalileoView::CycleTargets()
 {
-	Manager		*mgr;
-	Worker		*wkr;
-	int			m, w;
-	int			old_count;		// targets currently active
-	int			new_count = 0;	// targets set active
+	Manager *mgr;
+	Worker *wkr;
+	int m, w;
+	int old_count;		// targets currently active
+	int new_count = 0;	// targets set active
 
 	// Record the number of targets currently active.
-	old_count = theApp.manager_list.TargetCount( ActiveType );
+	old_count = theApp.manager_list.TargetCount(ActiveType);
 
 	// Count total # of targets that will run (sum of targets on all workers & mgrs).
 	// (TBD: Make this code a separate method, and call from CycleTargetsQueue(), if
 	// possible.  It would require some way of determining when cycling is complete,
 	// since that's the other reason CycleTargetsQueue() is calling this method.
 	// If it can be done, it would help to de-couple the 2 methods.)
-	for ( m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		mgr = theApp.manager_list.GetManager(m);
 
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( IsType( wkr->Type(), GenericClientType ) )
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
+			if (IsType(wkr->Type(), GenericClientType))
 				continue;
 
 			// Only include workers who could be active for the current test.
-			if ( wkr->HasActiveCurrentSpec() && wkr->TargetCount() )
-				new_count += wkr->SetActiveTargets( targets_to_run );
+			if (wkr->HasActiveCurrentSpec() && wkr->TargetCount())
+				new_count += wkr->SetActiveTargets(targets_to_run);
 		}
 	}
 
 	// Determine how many targets should run with the next iteration based on
 	// the cycling type.
-	if ( m_pPageSetup->target_cycling.step_type == StepLinear || 
-		m_pPageSetup->target_cycling.step == 1 )
-	{
+	if (m_pPageSetup->target_cycling.step_type == StepLinear || m_pPageSetup->target_cycling.step == 1) {
 		targets_to_run += m_pPageSetup->target_cycling.step;
-	}
-	else
-	{
+	} else {
 		targets_to_run = m_pPageSetup->target_cycling.start *
-			(int)pow ( (double)m_pPageSetup->target_cycling.step, 
-			(double)target_exponent++ );
+		    (int)pow((double)m_pPageSetup->target_cycling.step, (double)target_exponent++);
 	}
 
 	// Return TRUE if new targets are now active.
-	return ( new_count > old_count );
+	return (new_count > old_count);
 }
 
-
-
 //
 // Add worker_step workers, with all selected targets, to all managers at a time.
 //
@@ -1685,36 +1514,33 @@
 //
 BOOL CGalileoView::CycleWorkers()
 {
-	Manager		*mgr;
-	Worker		*wkr;
-	int			m, w;
-	int			workers_remaining;
-	int			old_count;		// targets currently active
-	int			new_count = 0;	// targets set active
+	Manager *mgr;
+	Worker *wkr;
+	int m, w;
+	int workers_remaining;
+	int old_count;		// targets currently active
+	int new_count = 0;	// targets set active
 
 	// Record the number of targets currently active.
-	old_count = theApp.manager_list.TargetCount( ActiveType );
+	old_count = theApp.manager_list.TargetCount(ActiveType);
 
-	for ( m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		mgr = theApp.manager_list.GetManager(m);
 
 		// Each manager will run with workers_to_run workers, (if the
 		// manager has that many workers).
 		workers_remaining = workers_to_run;
 
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( IsType( wkr->Type(), GenericClientType ) )
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
+			if (IsType(wkr->Type(), GenericClientType))
 				continue;
 
 			// Only include workers who could be active for the current test.
-			if ( wkr->HasActiveCurrentSpec() && wkr->TargetCount() )
-			{
-				new_count += wkr->SetActiveTargets( wkr->TargetCount() );
+			if (wkr->HasActiveCurrentSpec() && wkr->TargetCount()) {
+				new_count += wkr->SetActiveTargets(wkr->TargetCount());
 
-				if ( !--workers_remaining )
+				if (!--workers_remaining)
 					break;
 			}
 		}
@@ -1722,24 +1548,17 @@
 
 	// Determine how many workers should run with the next iteration based on
 	// the cycling type.
-	if ( m_pPageSetup->worker_cycling.step_type == StepLinear || 
-		m_pPageSetup->worker_cycling.step == 1 )
-	{
+	if (m_pPageSetup->worker_cycling.step_type == StepLinear || m_pPageSetup->worker_cycling.step == 1) {
 		workers_to_run += m_pPageSetup->worker_cycling.step;
-	}
-	else
-	{
+	} else {
 		workers_to_run = m_pPageSetup->worker_cycling.start *
-			(int)pow ( (double)m_pPageSetup->worker_cycling.step, 
-			(double)worker_exponent++ );
+		    (int)pow((double)m_pPageSetup->worker_cycling.step, (double)worker_exponent++);
 	}
 
 	// Return TRUE if new targets are now active.
-	return ( new_count > old_count );
+	return (new_count > old_count);
 }
 
-
-
 //
 // Add target_step targets to worker_step workers.
 //
@@ -1749,38 +1568,35 @@
 //
 int CGalileoView::CycleWorkersTargets()
 {
-	Manager		*mgr;
-	Worker		*wkr;
-	int			m, w;
-	int			workers_remaining;
-	int			max_targets = 0, max_workers = 0;
-	int			old_target_count;
-	int			new_target_count = 0, worker_count = 0;
+	Manager *mgr;
+	Worker *wkr;
+	int m, w;
+	int workers_remaining;
+	int max_targets = 0, max_workers = 0;
+	int old_target_count;
+	int new_target_count = 0, worker_count = 0;
 
 	// Record the number of targets currently active.
-	old_target_count = theApp.manager_list.TargetCount( ActiveType );
+	old_target_count = theApp.manager_list.TargetCount(ActiveType);
 
-	for ( m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		mgr = theApp.manager_list.GetManager(m);
 
 		// Each manager will run with workers_to_run workers, (if the
 		// manager has that many workers).
 		workers_remaining = workers_to_run;
 
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( IsType( wkr->Type(), GenericClientType ) )
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
+			if (IsType(wkr->Type(), GenericClientType))
 				continue;
 
 			// Only include workers who could be active for the current test.
-			if ( wkr->HasActiveCurrentSpec() && wkr->TargetCount() )
-			{
-				new_target_count += wkr->SetActiveTargets( targets_to_run );
+			if (wkr->HasActiveCurrentSpec() && wkr->TargetCount()) {
+				new_target_count += wkr->SetActiveTargets(targets_to_run);
 				worker_count++;
 
-				if ( !--workers_remaining )
+				if (!--workers_remaining)
 					break;
 			}
 		}
@@ -1788,39 +1604,33 @@
 
 	// Determine how many workers and targets should run with the next 
 	// iteration based on the cycling type.
-	if ( !new_target_count )
-	{
+	if (!new_target_count) {
 		// No targets were set, everyone's idle.
 		return 0;
-	}
-	else if ( new_target_count > old_target_count )
-	{
+	} else if (new_target_count > old_target_count) {
 		// Add additional targets to the same workers
-		if ( m_pPageSetup->target_cycling.step_type == StepLinear || m_pPageSetup->worker_cycling.step == 1 )
+		if (m_pPageSetup->target_cycling.step_type == StepLinear || m_pPageSetup->worker_cycling.step == 1)
 			targets_to_run += m_pPageSetup->target_cycling.step;
 		else
 			targets_to_run = m_pPageSetup->target_cycling.start *
-				(int)pow ( (double)m_pPageSetup->target_cycling.step, (double)target_exponent++ );
+			    (int)pow((double)m_pPageSetup->target_cycling.step, (double)target_exponent++);
 		return worker_count;
 	}
-
 	// Reset the number of targets to run and add additional workers.
 	theApp.manager_list.ClearActiveTargets();
 	targets_to_run = m_pPageSetup->target_cycling.start;
 	target_exponent = 1;
-	if ( m_pPageSetup->worker_cycling.step_type == StepLinear || m_pPageSetup->worker_cycling.step == 1 )
+	if (m_pPageSetup->worker_cycling.step_type == StepLinear || m_pPageSetup->worker_cycling.step == 1)
 		workers_to_run += m_pPageSetup->worker_cycling.step;
 	else
 		workers_to_run = m_pPageSetup->worker_cycling.start *
-			(int)pow ( (double)m_pPageSetup->worker_cycling.step, (double)worker_exponent++ );
+		    (int)pow((double)m_pPageSetup->worker_cycling.step, (double)worker_exponent++);
 
 	// Try running with the next set of workers.  If no new workers were set
 	// running, we're done.
-	return ( CycleWorkersTargets() > worker_count );
+	return (CycleWorkersTargets() > worker_count);
 }
 
-
-
 //
 // Add a single drive, down each worker, at a time for all managers.
 //
@@ -1830,31 +1640,28 @@
 //
 BOOL CGalileoView::IncrementTargets()
 {
-	Manager		*mgr;
-	Worker		*wkr;
-	int			m, w;
-	int			targets_remaining;
-	int			old_count;					// targets currently active
-	int			set_count, new_count = 0;	// targets set active
+	Manager *mgr;
+	Worker *wkr;
+	int m, w;
+	int targets_remaining;
+	int old_count;		// targets currently active
+	int set_count, new_count = 0;	// targets set active
 
 	// Record the number of targets currently active.
-	old_count = theApp.manager_list.TargetCount( ActiveType );
+	old_count = theApp.manager_list.TargetCount(ActiveType);
 
-	for ( m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		mgr = theApp.manager_list.GetManager(m);
 		targets_remaining = targets_to_run;
 
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( IsType( wkr->Type(), GenericClientType ) )
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
+			if (IsType(wkr->Type(), GenericClientType))
 				continue;
 
 			// Only include workers who could be active for the current test.
-			if ( wkr->HasActiveCurrentSpec() && wkr->TargetCount() )
-			{
-				set_count = wkr->SetActiveTargets( targets_remaining );
+			if (wkr->HasActiveCurrentSpec() && wkr->TargetCount()) {
+				set_count = wkr->SetActiveTargets(targets_remaining);
 				new_count += set_count;
 				targets_remaining -= set_count;
 			}
@@ -1863,24 +1670,17 @@
 
 	// Determine how many targets should run with the next iteration based on
 	// the cycling type.
-	if ( m_pPageSetup->target_cycling.step_type == StepLinear || 
-		m_pPageSetup->target_cycling.step == 1 )
-	{
+	if (m_pPageSetup->target_cycling.step_type == StepLinear || m_pPageSetup->target_cycling.step == 1) {
 		targets_to_run += m_pPageSetup->target_cycling.step;
-	}
-	else
-	{
+	} else {
 		targets_to_run = m_pPageSetup->target_cycling.start *
-			(int)pow ( (double)m_pPageSetup->target_cycling.step, 
-			(double)target_exponent++ );
+		    (int)pow((double)m_pPageSetup->target_cycling.step, (double)target_exponent++);
 	}
 
 	// Return TRUE if new targets are now active.
-	return ( new_count > old_count );
+	return (new_count > old_count);
 }
 
-
-
 //
 // Add a single drive, down each worker, for one manager at a time.
 //
@@ -1890,31 +1690,28 @@
 //
 BOOL CGalileoView::IncrementTargetsSerial()
 {
-	Manager		*mgr;
-	Worker		*wkr;
-	int			m, w;
-	int			targets_remaining;
-	int			old_count;					// targets currently active
-	int			set_count, new_count = 0;	// targets set active
+	Manager *mgr;
+	Worker *wkr;
+	int m, w;
+	int targets_remaining;
+	int old_count;		// targets currently active
+	int set_count, new_count = 0;	// targets set active
 
 	// Record the number of targets currently active.
-	old_count = theApp.manager_list.TargetCount( ActiveType );
+	old_count = theApp.manager_list.TargetCount(ActiveType);
 	targets_remaining = targets_to_run;
 
-	for ( m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		mgr = theApp.manager_list.GetManager(m);
 
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( IsType( wkr->Type(), GenericClientType ) )
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
+			if (IsType(wkr->Type(), GenericClientType))
 				continue;
 
 			// Only include workers who could be active for the current test.
-			if ( wkr->HasActiveCurrentSpec() && wkr->TargetCount() )
-			{
-				set_count = wkr->SetActiveTargets( targets_remaining );
+			if (wkr->HasActiveCurrentSpec() && wkr->TargetCount()) {
+				set_count = wkr->SetActiveTargets(targets_remaining);
 				new_count += set_count;
 				targets_remaining -= set_count;
 			}
@@ -1923,24 +1720,17 @@
 
 	// Determine how many targets should run with the next iteration based on
 	// the cycling type.
-	if ( m_pPageSetup->target_cycling.step_type == StepLinear || 
-		m_pPageSetup->target_cycling.step == 1 )
-	{
+	if (m_pPageSetup->target_cycling.step_type == StepLinear || m_pPageSetup->target_cycling.step == 1) {
 		targets_to_run += m_pPageSetup->target_cycling.step;
-	}
-	else
-	{
+	} else {
 		targets_to_run = m_pPageSetup->target_cycling.start *
-			(int)pow ( (double)m_pPageSetup->target_cycling.step, 
-			(double)target_exponent++ );
+		    (int)pow((double)m_pPageSetup->target_cycling.step, (double)target_exponent++);
 	}
 
 	// Return TRUE if new targets are now active.
-	return ( new_count > old_count );
+	return (new_count > old_count);
 }
 
-
-
 //
 // Run selected drives cycling the queue depth for all workers.
 //
@@ -1950,61 +1740,54 @@
 //
 BOOL CGalileoView::CycleQueue()
 {
-	Manager	*mgr;
-	Worker	*wkr;
-	int		m, w;
-	BOOL	workers_running = FALSE;
-	BOOL	disk_workers = FALSE;
+	Manager *mgr;
+	Worker *wkr;
+	int m, w;
+	BOOL workers_running = FALSE;
+	BOOL disk_workers = FALSE;
 
 	// Stop cycling when our queue depth to run is greater than the last
 	// queue depth to run.
-	if ( queue_depth_to_run > m_pPageSetup->queue_cycling.end )
+	if (queue_depth_to_run > m_pPageSetup->queue_cycling.end)
 		return FALSE;
 
-	for ( m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
+	for (m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		mgr = theApp.manager_list.GetManager(m);
 
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( IsType( wkr->Type(), GenericClientType ) )
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
+			if (IsType(wkr->Type(), GenericClientType))
 				continue;
 
 			// Only include workers who could be active for the current test.
-			if ( wkr->HasActiveCurrentSpec() && wkr->TargetCount() )
-			{
-				wkr->SetQueueDepth( queue_depth_to_run );
-				wkr->SetActiveTargets( wkr->TargetCount() );
+			if (wkr->HasActiveCurrentSpec() && wkr->TargetCount()) {
+				wkr->SetQueueDepth(queue_depth_to_run);
+				wkr->SetActiveTargets(wkr->TargetCount());
 				workers_running = TRUE;
 
 				// Record if any disk workers are running.
-				if ( IsType( wkr->Type(), GenericDiskType ) )
+				if (IsType(wkr->Type(), GenericDiskType))
 					disk_workers = TRUE;
 			}
 		}
 	}
 
 	// Continue cycling queue depth only if there are disk workers running.
-	if ( !disk_workers )
-	{
+	if (!disk_workers) {
 		// No disk workers running, but we might have idle network workers.
 		// Let them run, but set the queue depth past the last value to stop
 		// cycling queue depth for these workers.
 		queue_depth_to_run = m_pPageSetup->queue_cycling.end + 1;
-	}
-	else if ( m_pPageSetup->queue_cycling.step_type == StepLinear || m_pPageSetup->queue_cycling.step == 1 )
+	} else if (m_pPageSetup->queue_cycling.step_type == StepLinear || m_pPageSetup->queue_cycling.step == 1)
 		queue_depth_to_run += m_pPageSetup->queue_cycling.step;
 	else
 		queue_depth_to_run = m_pPageSetup->queue_cycling.start *
-			(int)pow ( (double)m_pPageSetup->queue_cycling.step, (double)queue_exponent++ );
+		    (int)pow((double)m_pPageSetup->queue_cycling.step, (double)queue_exponent++);
 
 	// Continue to cycle queue depth as long as all workers are not idle.
 	return workers_running;
 }
 
-
-
 //
 // Cycle through queue depth while cycling through targets.
 //
@@ -2014,13 +1797,11 @@
 //
 BOOL CGalileoView::CycleTargetsQueue()
 {
-	int	save_targets_to_run;
-	int	save_target_exponent;
+	int save_targets_to_run;
+	int save_target_exponent;
 
-
 	// Cycle through all queue depths for the selected number of targets.
-	if ( CycleQueue() )
-	{
+	if (CycleQueue()) {
 		// Set the appropriate number of targets.
 		theApp.manager_list.ClearActiveTargets();
 		save_targets_to_run = targets_to_run;
@@ -2031,9 +1812,7 @@
 		// until we're done cycling queue depth.
 		targets_to_run = save_targets_to_run;
 		target_exponent = save_target_exponent;
-	}
-	else
-	{
+	} else {
 		// See if we're through cycling targets as well.  Call CycleTargets()
 		// to update the number of targets that we need to run.
 		// targets_to_run was set back to a saved value above, so we know that
@@ -2044,7 +1823,7 @@
 
 		// Now try to cycle with more targets.  This check determines if we're
 		// through cycling targets.
-		if ( !CycleTargets() )
+		if (!CycleTargets())
 			return FALSE;
 		targets_to_run = save_targets_to_run;
 		target_exponent = save_target_exponent;
@@ -2053,7 +1832,7 @@
 		queue_exponent = 1;
 		queue_depth_to_run = m_pPageSetup->queue_cycling.start;
 		CycleQueue();
-		
+
 		// Reset the targets that need to run, CycleQueue() will have cleared
 		// the settings.
 		theApp.manager_list.ClearActiveTargets();
@@ -2065,8 +1844,6 @@
 	return TRUE;
 }
 
-
-
 //
 // Prepares all worker targets for a normal test run.  All assigned targets
 // are listed as active.
@@ -2077,186 +1854,170 @@
 //
 BOOL CGalileoView::Normal()
 {
-	Manager		*mgr;
-	Worker		*wkr;
-	int			m, w;
-	int			old_count;		// targets currently active
-	int			new_count = 0;	// targets set active
+	Manager *mgr;
+	Worker *wkr;
+	int m, w;
+	int old_count;		// targets currently active
+	int new_count = 0;	// targets set active
 
 	// Record the number of targets currently active.
-	old_count = theApp.manager_list.TargetCount( ActiveType );
+	old_count = theApp.manager_list.TargetCount(ActiveType);
 
 	// Mark all assigned targets as active.
-	for ( m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		mgr = theApp.manager_list.GetManager( m );
-		
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( IsType( wkr->Type(), GenericClientType ) )
+	for (m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		mgr = theApp.manager_list.GetManager(m);
+
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
+			if (IsType(wkr->Type(), GenericClientType))
 				continue;
 
 			// Only include workers who could be active for the current test.
-			if ( wkr->HasActiveCurrentSpec() && wkr->TargetCount() )
-				new_count += mgr->SetActiveTargets( w, wkr->TargetCount() );
+			if (wkr->HasActiveCurrentSpec() && wkr->TargetCount())
+				new_count += mgr->SetActiveTargets(w, wkr->TargetCount());
 		}
 	}
 
 	// Return TRUE if new targets are now active.
-	return ( new_count > old_count );
+	return (new_count > old_count);
 }
 
-
-
-void CGalileoView::OnMRefresh() 
+void CGalileoView::OnMRefresh()
 {
-	Manager *manager = (Manager *) m_pWorkerView->m_TWorkers.GetItemData( right_clicked_item );
-	
+	Manager *manager = (Manager *) m_pWorkerView->m_TWorkers.GetItemData(right_clicked_item);
+
 	// Updates the target lists when the user right clicks on a manager.
 	manager->UpdateTargetLists();
 	m_pPageDisk->ShowData();
 	m_pPageNetwork->ShowData();
 }
 
-
-
 void CGalileoView::ButtonReset()
 {
-	SetButton( ID_FILE_OPEN, TRUE );
-	SetButton( ID_FILE_SAVE, TRUE );
-	SetButton( BNewDynamo, TRUE );
-	SetButton( BNewDiskWorker, FALSE );
-	SetButton( BNewNetWorker, FALSE );
-	SetButton( BCopyWorker, FALSE );
-	SetButton( BReset, FALSE );
-	SetButton( BExitOne, FALSE );
-	SetButton( ID_APP_EXIT, TRUE );
+	SetButton(ID_FILE_OPEN, TRUE);
+	SetButton(ID_FILE_SAVE, TRUE);
+	SetButton(BNewDynamo, TRUE);
+	SetButton(BNewDiskWorker, FALSE);
+	SetButton(BNewNetWorker, FALSE);
+	SetButton(BCopyWorker, FALSE);
+	SetButton(BReset, FALSE);
+	SetButton(BExitOne, FALSE);
+	SetButton(ID_APP_EXIT, TRUE);
 
-	m_pPageDisplay->m_dlgBigMeter.SetButtonState( FALSE, FALSE, FALSE );
-	SetButton( BStart, FALSE );
-	SetButton( BStop, FALSE );
-	SetButton( BStopAll, FALSE );
-	
+	m_pPageDisplay->m_dlgBigMeter.SetButtonState(FALSE, FALSE, FALSE);
+	SetButton(BStart, FALSE);
+	SetButton(BStop, FALSE);
+	SetButton(BStopAll, FALSE);
+
 	theApp.m_wndToolBar.RedrawWindow();
 }
 
-
 //
 // Set buttons to indicate that we're ready to run the next test.
 //
 void CGalileoView::ButtonReady()
 {
-	Manager	*manager = m_pWorkerView->GetSelectedManager();
-	BOOL	new_disk_worker_ok;
-	BOOL	new_net_worker_ok;
+	Manager *manager = m_pWorkerView->GetSelectedManager();
+	BOOL new_disk_worker_ok;
+	BOOL new_net_worker_ok;
 
-	SetButton( ID_FILE_OPEN, TRUE );
-	SetButton( ID_FILE_SAVE, TRUE );
-	SetButton( BNewDynamo, TRUE );
+	SetButton(ID_FILE_OPEN, TRUE);
+	SetButton(ID_FILE_SAVE, TRUE);
+	SetButton(BNewDynamo, TRUE);
 
 	// Only enable the new worker buttons if creating a worker of that kind
 	// is allowed on the given manager or worker's manager.
-	if ( manager )
-	{
-		new_disk_worker_ok = manager->InterfaceCount( GenericDiskType );
-		new_net_worker_ok = manager->InterfaceCount( GenericNetType );
-	}
-	else
-	{
+	if (manager) {
+		new_disk_worker_ok = manager->InterfaceCount(GenericDiskType);
+		new_net_worker_ok = manager->InterfaceCount(GenericNetType);
+	} else {
 		new_disk_worker_ok = FALSE;
 		new_net_worker_ok = FALSE;
 	}
-	SetButton( BNewDiskWorker, new_disk_worker_ok );
-	SetButton( BNewNetWorker, new_net_worker_ok );
+	SetButton(BNewDiskWorker, new_disk_worker_ok);
+	SetButton(BNewNetWorker, new_net_worker_ok);
 
 	// Enable worker copy button if a worker is selected.
-	SetButton( BCopyWorker, (BOOL) (PtrToLong(m_pWorkerView->GetSelectedWorker())) );
-	SetButton( BReset, TRUE );
-	SetButton( BExitOne, TRUE );
-	SetButton( ID_APP_EXIT, TRUE );
+	SetButton(BCopyWorker, (BOOL) (PtrToLong(m_pWorkerView->GetSelectedWorker())));
+	SetButton(BReset, TRUE);
+	SetButton(BExitOne, TRUE);
+	SetButton(ID_APP_EXIT, TRUE);
 
-	m_pPageDisplay->m_dlgBigMeter.SetButtonState( TRUE, FALSE, FALSE );
-	SetButton( BStart, TRUE );
-	SetButton( BStop, FALSE );
-	SetButton( BStopAll, FALSE );
+	m_pPageDisplay->m_dlgBigMeter.SetButtonState(TRUE, FALSE, FALSE);
+	SetButton(BStart, TRUE);
+	SetButton(BStop, FALSE);
+	SetButton(BStopAll, FALSE);
 
 	theApp.m_wndToolBar.RedrawWindow();
 }
 
-
 //
 // Set buttons to indicate that we're preparing a drive.
 //
 void CGalileoView::ButtonPrepare()
 {
-	SetButton( ID_FILE_OPEN, FALSE );
-	SetButton( ID_FILE_SAVE, FALSE );
-	SetButton( BNewDynamo, FALSE );
-	SetButton( BNewDiskWorker, FALSE );
-	SetButton( BNewNetWorker, FALSE );
-	SetButton( BCopyWorker, FALSE );
-	SetButton( BReset, FALSE );
-	SetButton( BExitOne, FALSE );
-	SetButton( ID_APP_EXIT, TRUE );
+	SetButton(ID_FILE_OPEN, FALSE);
+	SetButton(ID_FILE_SAVE, FALSE);
+	SetButton(BNewDynamo, FALSE);
+	SetButton(BNewDiskWorker, FALSE);
+	SetButton(BNewNetWorker, FALSE);
+	SetButton(BCopyWorker, FALSE);
+	SetButton(BReset, FALSE);
+	SetButton(BExitOne, FALSE);
+	SetButton(ID_APP_EXIT, TRUE);
 
-	m_pPageDisplay->m_dlgBigMeter.SetButtonState( FALSE, FALSE, TRUE );
-	SetButton( BStart, FALSE );
-	SetButton( BStop, FALSE );
-	SetButton( BStopAll, TRUE );
-	
+	m_pPageDisplay->m_dlgBigMeter.SetButtonState(FALSE, FALSE, TRUE);
+	SetButton(BStart, FALSE);
+	SetButton(BStop, FALSE);
+	SetButton(BStopAll, TRUE);
+
 	theApp.m_wndToolBar.RedrawWindow();
 }
 
-
 //
 // Set buttons to indicate that we're running a test.
 //
 void CGalileoView::ButtonTest()
 {
-	SetButton( ID_FILE_OPEN, FALSE );
-	SetButton( ID_FILE_SAVE, FALSE );
-	SetButton( BNewDynamo, FALSE );
-	SetButton( BNewDiskWorker, FALSE );
-	SetButton( BNewNetWorker, FALSE );
-	SetButton( BCopyWorker, FALSE );
-	SetButton( BReset, FALSE );
-	SetButton( BExitOne, FALSE );
-	SetButton( ID_APP_EXIT, TRUE );
+	SetButton(ID_FILE_OPEN, FALSE);
+	SetButton(ID_FILE_SAVE, FALSE);
+	SetButton(BNewDynamo, FALSE);
+	SetButton(BNewDiskWorker, FALSE);
+	SetButton(BNewNetWorker, FALSE);
+	SetButton(BCopyWorker, FALSE);
+	SetButton(BReset, FALSE);
+	SetButton(BExitOne, FALSE);
+	SetButton(ID_APP_EXIT, TRUE);
 
-	m_pPageDisplay->m_dlgBigMeter.SetButtonState( FALSE, TRUE, FALSE );
-	SetButton( BStart, FALSE );
-	SetButton( BStop, TRUE );
-	SetButton( BStopAll, FALSE );
+	m_pPageDisplay->m_dlgBigMeter.SetButtonState(FALSE, TRUE, FALSE);
+	SetButton(BStart, FALSE);
+	SetButton(BStop, TRUE);
+	SetButton(BStopAll, FALSE);
 }
 
-
-
 //
 // Disable most buttons on the GUI to prevent user access.
 //
 void CGalileoView::ButtonOff()
 {
-	SetButton( ID_FILE_OPEN, FALSE );
-	SetButton( ID_FILE_SAVE, FALSE );
-	SetButton( BNewDynamo, FALSE );
-	SetButton( BNewDiskWorker, FALSE );
-	SetButton( BNewNetWorker, FALSE );
-	SetButton( BCopyWorker, FALSE );
-	SetButton( BReset, FALSE );
-	SetButton( BExitOne, FALSE );
-	SetButton( ID_APP_EXIT, TRUE );
+	SetButton(ID_FILE_OPEN, FALSE);
+	SetButton(ID_FILE_SAVE, FALSE);
+	SetButton(BNewDynamo, FALSE);
+	SetButton(BNewDiskWorker, FALSE);
+	SetButton(BNewNetWorker, FALSE);
+	SetButton(BCopyWorker, FALSE);
+	SetButton(BReset, FALSE);
+	SetButton(BExitOne, FALSE);
+	SetButton(ID_APP_EXIT, TRUE);
 
-	m_pPageDisplay->m_dlgBigMeter.SetButtonState( FALSE, FALSE, FALSE );
-	SetButton( BStart, FALSE );
-	SetButton( BStop, FALSE );
-	SetButton( BStopAll, FALSE );
-	
+	m_pPageDisplay->m_dlgBigMeter.SetButtonState(FALSE, FALSE, FALSE);
+	SetButton(BStart, FALSE);
+	SetButton(BStop, FALSE);
+	SetButton(BStopAll, FALSE);
+
 	theApp.m_wndToolBar.RedrawWindow();
 }
 
-
-
 //
 // Setting the text in the status bar to inform the user to the status of which test
 // is running and how many are runs are left.
@@ -2266,32 +2027,27 @@
 	CString blank, run;
 
 	// Mark the currently running access spec.
-	m_pPageAccess->MarkAccesses( access_index );
+	m_pPageAccess->MarkAccesses(access_index);
 
 	// Display access specification and run numbers.
 	blank = "";
-	run.Format( "Run %d of %d", run_index, run_count );
+	run.Format("Run %d of %d", run_index, run_count);
 
-	SetStatusBarText( m_pPageSetup->test_name, blank, run );
+	SetStatusBarText(m_pPageSetup->test_name, blank, run);
 }
 
-
-
 //
 // Updating the status bar with a single notification message.
 //
-void CGalileoView::SetStatusBarText( CString text1, CString text2, CString text3 )
+void CGalileoView::SetStatusBarText(CString text1, CString text2, CString text3)
 {
-	if ( theApp.m_wndStatusBar )
-	{
-		theApp.m_wndStatusBar.GetStatusBarCtrl().SetText( text1, 0, 0 );
-		theApp.m_wndStatusBar.GetStatusBarCtrl().SetText( text2, 1, 0 );
-		theApp.m_wndStatusBar.GetStatusBarCtrl().SetText( text3, 2, 0 );
+	if (theApp.m_wndStatusBar) {
+		theApp.m_wndStatusBar.GetStatusBarCtrl().SetText(text1, 0, 0);
+		theApp.m_wndStatusBar.GetStatusBarCtrl().SetText(text2, 1, 0);
+		theApp.m_wndStatusBar.GetStatusBarCtrl().SetText(text3, 2, 0);
 	}
 }
 
-
-
 //
 // Clearing all information displayed in the status bar.
 //
@@ -2300,8 +2056,6 @@
 	SetStatusBarText();
 }
 
-
-
 //
 // Calculates the total number of runs for all testing.
 //
@@ -2313,86 +2067,78 @@
 
 	// Determine the total number of runs for each access spec.
 	max_spec_count = theApp.manager_list.GetMaxAccessSpecCount();
-	for ( access_index = 0; access_index < max_spec_count; access_index++ )
-	{
+	for (access_index = 0; access_index < max_spec_count; access_index++) {
 		InitAccessSpecRun();
 
 		// Ensure that we do at least one run per access spec.  This is
 		// necessary in case all workers have been set idle.
 		old_count = run_count;
 
-		switch ( m_pPageSetup->test_type )
-		{
+		switch (m_pPageSetup->test_type) {
 		case CyclingTargets:
-			while ( CycleTargets() )
+			while (CycleTargets())
 				run_count++;
 			break;
 		case CyclingWorkers:
-			while ( CycleWorkers() )
+			while (CycleWorkers())
 				run_count++;
 			break;
 		case CyclingIncTargetsParallel:
-			while ( IncrementTargets() )
+			while (IncrementTargets())
 				run_count++;
 			break;
 		case CyclingIncTargetsSerial:
-			while ( IncrementTargetsSerial() )
+			while (IncrementTargetsSerial())
 				run_count++;
 			break;
 		case CyclingWorkersTargets:
-			while ( CycleWorkersTargets() )
+			while (CycleWorkersTargets())
 				run_count++;
 			break;
 		case CyclingQueue:
-			while ( CycleQueue() )
+			while (CycleQueue())
 				run_count++;
 			break;
 		case CyclingQueueTargets:
-			while ( CycleTargetsQueue() )
+			while (CycleTargetsQueue())
 				run_count++;
 			break;
 		default:
-			if ( Normal() )
+			if (Normal())
 				run_count++;
 		}
 
 		// If old_count = run_count, then all workers were marked as idle and
 		// no new targets were set.  If the user specified that someone should 
 		// actually be idle, increment the run count.
-		if ( old_count == run_count && 
-			theApp.manager_list.HasIdleCurrentSpec() )
-		{
+		if (old_count == run_count && theApp.manager_list.HasIdleCurrentSpec()) {
 			run_count++;
 		}
 	}
 }
 
-
-BOOL CGalileoView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
+BOOL CGalileoView::OnSetCursor(CWnd * pWnd, UINT nHitTest, UINT message)
 {
 	// Check to see if the mouse is moved during a drag event.
-	if ( message == WM_MOUSEMOVE && dragging )
-	{
+	if (message == WM_MOUSEMOVE && dragging) {
 		CPoint point;
-		GetCursorPos( &point );
-		p_DragImage->DragShowNolock( TRUE );
-		p_DragImage->DragMove( point );
+
+		GetCursorPos(&point);
+		p_DragImage->DragShowNolock(TRUE);
+		p_DragImage->DragMove(point);
 		return TRUE;
 	}
-
 	// Check to see if the button up event happened after a drag event.
-	if ( message == WM_LBUTTONUP && dragging )
-	{
+	if (message == WM_LBUTTONUP && dragging) {
 		p_DragImage->EndDrag();
 		delete p_DragImage;
 
 		CPoint point;
-		GetCursorPos( &point );
 
-		m_pPageDisplay->SetResultSource( 
-			m_pWorkerView->GetSelectedManagerIndex(),
-			m_pWorkerView->GetSelectedWorkerIndex(),
-			point );
+		GetCursorPos(&point);
+
+		m_pPageDisplay->SetResultSource(m_pWorkerView->GetSelectedManagerIndex(),
+						m_pWorkerView->GetSelectedWorkerIndex(), point);
 		dragging = FALSE;	// Reset dragging flag.
 		return TRUE;
 	}
@@ -2400,130 +2146,105 @@
 	return CView::OnSetCursor(pWnd, nHitTest, message);
 }
 
-
-
-
-TargetType CGalileoView::GetSelectedTargetType() 
+TargetType CGalileoView::GetSelectedTargetType()
 {
 	Worker *worker;
 
 	// See if a worker was selected.
-	if ( worker = m_pWorkerView->GetSelectedWorker() )
+	if (worker = m_pWorkerView->GetSelectedWorker())
 		// Return selected worker's type
 		return worker->Type();
 
 	return InvalidType;
 }
 
-
-
 //
 // called as the CGalileoView window is being destroyed (i.e. on application exit)
 //
 void CGalileoView::OnDestroy()
 {
 	// If a test is running, stop it!
-	if ( theApp.test_state != TestIdle )
-	{
+	if (theApp.test_state != TestIdle) {
 		// Test was running or drives were being prepared, abort.
 		StopAll();
 	}
-
 	// Remove all manager and worker information.
 	theApp.manager_list.RemoveAllManagers();
 
 	CView::OnDestroy();
 }
 
-
-
 //
 // Processing request to spawn a new worker thread.
 // This is called by the OnBNewDiskWorker() and OnBNewNetWorker() handlers.
 // It is BYPASSED by AddDefaultWorkers().
 //
-void CGalileoView::OnNewWorker( TargetType worker_type )
+void CGalileoView::OnNewWorker(TargetType worker_type)
 {
 	Manager *manager;
 
 	// Forcing update to target selection information in case one is needed.
-	::SetFocus( NULL );
+	::SetFocus(NULL);
 
 	// Updating the data from the setup page
-	m_pPageSetup->UpdateData( TRUE );
+	m_pPageSetup->UpdateData(TRUE);
 	ResetDisplayforNewTest();
 
 	// Seeing if there is a manager who's selected to receive the new worker.
 	manager = m_pWorkerView->GetSelectedManager();
 
-	if ( manager )
-	{
-		AddWorker( worker_type, manager );
-	}
-	else
-	{
+	if (manager) {
+		AddWorker(worker_type, manager);
+	} else {
 		// Shouldn't ever get to this code.  (Button should be disabled.)
-		ErrorMessage( "You must first highlight the manager you wish to start a worker on."
-						"  This should not have been allowed by Iometer." );
+		ErrorMessage("You must first highlight the manager you wish to start a worker on."
+			     "  This should not have been allowed by Iometer.");
 	}
 }
 
-
 void CGalileoView::OnBNewDiskWorker()
 {
-	OnNewWorker( GenericDiskType );
+	OnNewWorker(GenericDiskType);
 }
 
-
 void CGalileoView::OnBNewNetWorker()
 {
-	OnNewWorker( GenericServerType );
+	OnNewWorker(GenericServerType);
 }
 
-
 //
 // Adds the number of disk and network workers specified in Test Setup to a manager.
 //
-void CGalileoView::AddDefaultWorkers( Manager *manager )
+void CGalileoView::AddDefaultWorkers(Manager * manager)
 {
 	int i;
-	int	number_of_workers;
+	int number_of_workers;
 
-	if ( manager->InterfaceCount( GenericDiskType ) )
-	{
+	if (manager->InterfaceCount(GenericDiskType)) {
 		// Get default number of disk workers.
 		number_of_workers = m_pPageSetup->disk_worker_count;
 
-		if ( number_of_workers == -1 )
-		{
-			number_of_workers =
-				manager->processors;
+		if (number_of_workers == -1) {
+			number_of_workers = manager->processors;
 		}
-
 		// Add default number of disk workers.
-		for ( i = 0; i < number_of_workers; i++ )
-			AddWorker( GenericDiskType, manager );
+		for (i = 0; i < number_of_workers; i++)
+			AddWorker(GenericDiskType, manager);
 	}
 
-	if ( manager->InterfaceCount( GenericNetType ) )
-	{
+	if (manager->InterfaceCount(GenericNetType)) {
 		// Get default number of net workers.
 		number_of_workers = m_pPageSetup->net_worker_count;
 
-		if ( number_of_workers == -1 )
-		{
-			number_of_workers =
-				manager->processors;
+		if (number_of_workers == -1) {
+			number_of_workers = manager->processors;
 		}
-
 		// Add default number of net workers.
-		for ( i = 0; i < number_of_workers; i++ )
-			AddWorker( GenericServerType, manager );
+		for (i = 0; i < number_of_workers; i++)
+			AddWorker(GenericServerType, manager);
 	}
 }
 
-
-
 //
 // Adds a worker to the display.
 //
@@ -2533,33 +2254,28 @@
 	Worker *src_worker, *new_worker;
 
 	// Forcing update to target selection information in case one is needed.
-	::SetFocus( NULL );
+	::SetFocus(NULL);
 
 	// Updating the data from the setup page.
-	m_pPageSetup->UpdateData( TRUE );
+	m_pPageSetup->UpdateData(TRUE);
 	ResetDisplayforNewTest();
 
 	src_manager = m_pWorkerView->GetSelectedManager();
 	src_worker = m_pWorkerView->GetSelectedWorker();
 
-	if ( !src_worker )
-	{
-		ErrorMessage( "No worker was selected.  "
-						"This should not have been allowed by Iometer." );
+	if (!src_worker) {
+		ErrorMessage("No worker was selected.  " "This should not have been allowed by Iometer.");
 		return;
 	}
-
 	// Add the new worker to the manager and retrieve its pointer.
-	new_worker = src_manager->AddWorker( src_worker->Type(), src_worker );
+	new_worker = src_manager->AddWorker(src_worker->Type(), src_worker);
 
-	if ( new_worker )
-		m_pWorkerView->AddWorker( new_worker );
+	if (new_worker)
+		m_pWorkerView->AddWorker(new_worker);
 
-	EnableWindow( TRUE );
+	EnableWindow(TRUE);
 }
 
-
-
 //
 // The OnMDisplay...() functions are called in response to a selection from the 
 // IDR_POPUP_DISPLAY_LIST menu, which is popped up by the function CPageDisplay::OnBResultType(). 
@@ -2595,159 +2311,159 @@
 // changes its resource ID, moves to a different submenu, or changes its functionality
 // (different *_RESULT constant).
 //
-void CGalileoView::OnMDisplayCPUDPC() 
+void CGalileoView::OnMDisplayCPUDPC()
 {
-	OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUDPC );
+	OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUDPC);
 }
 
-void CGalileoView::OnMDisplayCPUEffectiveness() 
+void CGalileoView::OnMDisplayCPUEffectiveness()
 {
-	OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUEffectiveness );
+	OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUEffectiveness);
 }
 
-void CGalileoView::OnMDisplayCPUInterruptsPS() 
+void CGalileoView::OnMDisplayCPUInterruptsPS()
 {
-	OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUInterruptsPS );
+	OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUInterruptsPS);
 }
 
-void CGalileoView::OnMDisplayCPUInterruptTime() 
+void CGalileoView::OnMDisplayCPUInterruptTime()
 {
-	OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUInterruptTime );
+	OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUInterruptTime);
 }
 
-void CGalileoView::OnMDisplayCPUPrivileged() 
+void CGalileoView::OnMDisplayCPUPrivileged()
 {
-	OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUPrivileged );
+	OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUPrivileged);
 }
 
-void CGalileoView::OnMDisplayCPUUser() 
+void CGalileoView::OnMDisplayCPUUser()
 {
-	OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUUser );
+	OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUUser);
 }
 
-void CGalileoView::OnMDisplayCPUUtilization() 
+void CGalileoView::OnMDisplayCPUUtilization()
 {
-	OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUUtilization );
+	OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUUtilization);
 }
 
-void CGalileoView::OnMDisplayErrIO() 
+void CGalileoView::OnMDisplayErrIO()
 {
-	OnMDisplay( MDisplayErrSubmenuID, MDisplayErrIO );
+	OnMDisplay(MDisplayErrSubmenuID, MDisplayErrIO);
 }
 
-void CGalileoView::OnMDisplayErrRIO() 
+void CGalileoView::OnMDisplayErrRIO()
 {
-	OnMDisplay( MDisplayErrSubmenuID, MDisplayErrRIO );
+	OnMDisplay(MDisplayErrSubmenuID, MDisplayErrRIO);
 }
 
-void CGalileoView::OnMDisplayErrWIO() 
+void CGalileoView::OnMDisplayErrWIO()
 {
-	OnMDisplay( MDisplayErrSubmenuID, MDisplayErrWIO );
+	OnMDisplay(MDisplayErrSubmenuID, MDisplayErrWIO);
 }
 
-void CGalileoView::OnMDisplayAvgCon() 
+void CGalileoView::OnMDisplayAvgCon()
 {
-	OnMDisplay( MDisplayAvgSubmenuID, MDisplayAvgCon );
+	OnMDisplay(MDisplayAvgSubmenuID, MDisplayAvgCon);
 }
 
-void CGalileoView::OnMDisplayAvgIO() 
+void CGalileoView::OnMDisplayAvgIO()
 {
-	OnMDisplay( MDisplayAvgSubmenuID, MDisplayAvgIO );
+	OnMDisplay(MDisplayAvgSubmenuID, MDisplayAvgIO);
 }
 
-void CGalileoView::OnMDisplayAvgRIO() 
+void CGalileoView::OnMDisplayAvgRIO()
 {
-	OnMDisplay( MDisplayAvgSubmenuID, MDisplayAvgRIO );
+	OnMDisplay(MDisplayAvgSubmenuID, MDisplayAvgRIO);
 }
 
-void CGalileoView::OnMDisplayAvgTrans() 
+void CGalileoView::OnMDisplayAvgTrans()
 {
-	OnMDisplay( MDisplayAvgSubmenuID, MDisplayAvgTrans );
+	OnMDisplay(MDisplayAvgSubmenuID, MDisplayAvgTrans);
 }
 
-void CGalileoView::OnMDisplayAvgWIO() 
+void CGalileoView::OnMDisplayAvgWIO()
 {
-	OnMDisplay( MDisplayAvgSubmenuID, MDisplayAvgWIO );
+	OnMDisplay(MDisplayAvgSubmenuID, MDisplayAvgWIO);
 }
 
-void CGalileoView::OnMDisplayMaxCon() 
+void CGalileoView::OnMDisplayMaxCon()
 {
-	OnMDisplay( MDisplayMaxSubmenuID, MDisplayMaxCon );
+	OnMDisplay(MDisplayMaxSubmenuID, MDisplayMaxCon);
 }
 
-void CGalileoView::OnMDisplayMaxIO() 
+void CGalileoView::OnMDisplayMaxIO()
 {
-	OnMDisplay( MDisplayMaxSubmenuID, MDisplayMaxIO );
+	OnMDisplay(MDisplayMaxSubmenuID, MDisplayMaxIO);
 }
 
-void CGalileoView::OnMDisplayMaxRIO() 
+void CGalileoView::OnMDisplayMaxRIO()
 {
-	OnMDisplay( MDisplayMaxSubmenuID, MDisplayMaxRIO );
+	OnMDisplay(MDisplayMaxSubmenuID, MDisplayMaxRIO);
 }
 
-void CGalileoView::OnMDisplayMaxTrans() 
+void CGalileoView::OnMDisplayMaxTrans()
 {
-	OnMDisplay( MDisplayMaxSubmenuID, MDisplayMaxTrans );
+	OnMDisplay(MDisplayMaxSubmenuID, MDisplayMaxTrans);
 }
 
-void CGalileoView::OnMDisplayMaxWIO() 
+void CGalileoView::OnMDisplayMaxWIO()
 {
-	OnMDisplay( MDisplayMaxSubmenuID, MDisplayMaxWIO );
+	OnMDisplay(MDisplayMaxSubmenuID, MDisplayMaxWIO);
 }
 
-void CGalileoView::OnMDisplayMBsMBPS() 
+void CGalileoView::OnMDisplayMBsMBPS()
 {
-	OnMDisplay( MDisplayMBsSubmenuID, MDisplayMBsMBPS );
+	OnMDisplay(MDisplayMBsSubmenuID, MDisplayMBsMBPS);
 }
 
-void CGalileoView::OnMDisplayMBsRMBPS() 
+void CGalileoView::OnMDisplayMBsRMBPS()
 {
-	OnMDisplay( MDisplayMBsSubmenuID, MDisplayMBsRMBPS );
+	OnMDisplay(MDisplayMBsSubmenuID, MDisplayMBsRMBPS);
 }
 
-void CGalileoView::OnMDisplayMBsWMBPS() 
+void CGalileoView::OnMDisplayMBsWMBPS()
 {
-	OnMDisplay( MDisplayMBsSubmenuID, MDisplayMBsWMBPS );
+	OnMDisplay(MDisplayMBsSubmenuID, MDisplayMBsWMBPS);
 }
 
-void CGalileoView::OnMDisplayNetPacketErrors() 
+void CGalileoView::OnMDisplayNetPacketErrors()
 {
-	OnMDisplay( MDisplayNetSubmenuID, MDisplayNetPacketErrors );
+	OnMDisplay(MDisplayNetSubmenuID, MDisplayNetPacketErrors);
 }
 
-void CGalileoView::OnMDisplayNetPacketsPS() 
+void CGalileoView::OnMDisplayNetPacketsPS()
 {
-	OnMDisplay( MDisplayNetSubmenuID, MDisplayNetPacketsPS );
+	OnMDisplay(MDisplayNetSubmenuID, MDisplayNetPacketsPS);
 }
 
-void CGalileoView::OnMDisplayNetRetransPS() 
+void CGalileoView::OnMDisplayNetRetransPS()
 {
-	OnMDisplay( MDisplayNetSubmenuID, MDisplayNetRetransPS );
+	OnMDisplay(MDisplayNetSubmenuID, MDisplayNetRetransPS);
 }
 
-void CGalileoView::OnMDisplayOpsConPS() 
+void CGalileoView::OnMDisplayOpsConPS()
 {
-	OnMDisplay( MDisplayOpsSubmenuID, MDisplayOpsConPS );
+	OnMDisplay(MDisplayOpsSubmenuID, MDisplayOpsConPS);
 }
 
-void CGalileoView::OnMDisplayOpsIOPS() 
+void CGalileoView::OnMDisplayOpsIOPS()
 {
-	OnMDisplay( MDisplayOpsSubmenuID, MDisplayOpsIOPS );
+	OnMDisplay(MDisplayOpsSubmenuID, MDisplayOpsIOPS);
 }
 
-void CGalileoView::OnMDisplayOpsRIOPS() 
+void CGalileoView::OnMDisplayOpsRIOPS()
 {
-	OnMDisplay( MDisplayOpsSubmenuID, MDisplayOpsRIOPS );
+	OnMDisplay(MDisplayOpsSubmenuID, MDisplayOpsRIOPS);
 }
 
-void CGalileoView::OnMDisplayOpsTransPS() 
+void CGalileoView::OnMDisplayOpsTransPS()
 {
-	OnMDisplay( MDisplayOpsSubmenuID, MDisplayOpsTransPS );
+	OnMDisplay(MDisplayOpsSubmenuID, MDisplayOpsTransPS);
 }
 
-void CGalileoView::OnMDisplayOpsWIOPS() 
+void CGalileoView::OnMDisplayOpsWIOPS()
 {
-	OnMDisplay( MDisplayOpsSubmenuID, MDisplayOpsWIOPS );
+	OnMDisplay(MDisplayOpsSubmenuID, MDisplayOpsWIOPS);
 }
 
 //
@@ -2755,115 +2471,114 @@
 // passes the word along to the appropriate display dialog.  (See the explanation
 // just above the OnMDisplay...() functions.)
 //
-void CGalileoView::OnMDisplay( int submenu_id, int menu_item )
+void CGalileoView::OnMDisplay(int submenu_id, int menu_item)
 {
 	int result_code;
 
 	// Determine result code associated with selected menu item.
-	switch ( menu_item )
-	{
-		case MDisplayCPUDPC:
-			result_code = DPC_UTILIZATION_RESULT;
-			break;
-		case MDisplayCPUEffectiveness:
-			result_code = CPU_EFFECTIVENESS_RESULT;
-			break;
-		case MDisplayCPUInterruptsPS:
-			result_code = CPU_INTERRUPT_RESULT;
-			break;
-		case MDisplayCPUInterruptTime:
-			result_code = IRQ_UTILIZATION_RESULT;
-			break;
-		case MDisplayCPUPrivileged:
-			result_code = PRIVILEGED_UTILIZATION_RESULT;
-			break;
-		case MDisplayCPUUser:
-			result_code = USER_UTILIZATION_RESULT;
-			break;
-		case MDisplayCPUUtilization:
-			result_code = CPU_UTILIZATION_RESULT;
-			break;
-		case MDisplayErrIO:
-			result_code = ERROR_RESULT;
-			break;
-		case MDisplayErrRIO:
-			result_code = READ_ERROR_RESULT;
-			break;
-		case MDisplayErrWIO:
-			result_code = WRITE_ERROR_RESULT;
-			break;
-		case MDisplayAvgCon:
-			result_code = AVG_CONNECTION_LATENCY_RESULT;
-			break;
-		case MDisplayAvgIO:
-			result_code = AVG_LATENCY_RESULT;
-			break;
-		case MDisplayAvgRIO:
-			result_code = AVG_READ_LATENCY_RESULT;
-			break;
-		case MDisplayAvgTrans:
-			result_code = AVG_TRANSACTION_LATENCY_RESULT;
-			break;
-		case MDisplayAvgWIO:
-			result_code = AVG_WRITE_LATENCY_RESULT;
-			break;
-		case MDisplayMaxCon:
-			result_code = MAX_CONNECTION_LATENCY_RESULT;
-			break;
-		case MDisplayMaxIO:
-			result_code = MAX_LATENCY_RESULT;
-			break;
-		case MDisplayMaxRIO:
-			result_code = MAX_READ_LATENCY_RESULT;
-			break;
-		case MDisplayMaxTrans:
-			result_code = MAX_TRANSACTION_LATENCY_RESULT;
-			break;
-		case MDisplayMaxWIO:
-			result_code = MAX_WRITE_LATENCY_RESULT;
-			break;
-		case MDisplayMBsMBPS:
-			result_code = MBPS_RESULT;
-			break;
-		case MDisplayMBsRMBPS:
-			result_code = READ_MBPS_RESULT;
-			break;
-		case MDisplayMBsWMBPS:
-			result_code = WRITE_MBPS_RESULT;
-			break;
-		case MDisplayNetPacketErrors:
-			result_code = NI_ERROR_RESULT;
-			break;
-		case MDisplayNetPacketsPS:
-			result_code = NI_PACKET_RESULT;
-			break;
-		case MDisplayNetRetransPS:
-			result_code = TCP_SEGMENT_RESULT;
-			break;
-		case MDisplayOpsConPS:
-			result_code = CONNECTION_PER_SEC_RESULT;
-			break;
-		case MDisplayOpsIOPS:
-			result_code = IOPS_RESULT;
-			break;
-		case MDisplayOpsRIOPS:
-			result_code = READ_IOPS_RESULT;
-			break;
-		case MDisplayOpsTransPS:
-			result_code = TRANSACTION_PER_SEC_RESULT;
-			break;
-		case MDisplayOpsWIOPS:
-			result_code = WRITE_IOPS_RESULT;
-			break;
-		default:
-			ErrorMessage("Invalid menu_item value in CGalileoView::OnMDisplay()");
-			return;
+	switch (menu_item) {
+	case MDisplayCPUDPC:
+		result_code = DPC_UTILIZATION_RESULT;
+		break;
+	case MDisplayCPUEffectiveness:
+		result_code = CPU_EFFECTIVENESS_RESULT;
+		break;
+	case MDisplayCPUInterruptsPS:
+		result_code = CPU_INTERRUPT_RESULT;
+		break;
+	case MDisplayCPUInterruptTime:
+		result_code = IRQ_UTILIZATION_RESULT;
+		break;
+	case MDisplayCPUPrivileged:
+		result_code = PRIVILEGED_UTILIZATION_RESULT;
+		break;
+	case MDisplayCPUUser:
+		result_code = USER_UTILIZATION_RESULT;
+		break;
+	case MDisplayCPUUtilization:
+		result_code = CPU_UTILIZATION_RESULT;
+		break;
+	case MDisplayErrIO:
+		result_code = ERROR_RESULT;
+		break;
+	case MDisplayErrRIO:
+		result_code = READ_ERROR_RESULT;
+		break;
+	case MDisplayErrWIO:
+		result_code = WRITE_ERROR_RESULT;
+		break;
+	case MDisplayAvgCon:
+		result_code = AVG_CONNECTION_LATENCY_RESULT;
+		break;
+	case MDisplayAvgIO:
+		result_code = AVG_LATENCY_RESULT;
+		break;
+	case MDisplayAvgRIO:
+		result_code = AVG_READ_LATENCY_RESULT;
+		break;
+	case MDisplayAvgTrans:
+		result_code = AVG_TRANSACTION_LATENCY_RESULT;
+		break;
+	case MDisplayAvgWIO:
+		result_code = AVG_WRITE_LATENCY_RESULT;
+		break;
+	case MDisplayMaxCon:
+		result_code = MAX_CONNECTION_LATENCY_RESULT;
+		break;
+	case MDisplayMaxIO:
+		result_code = MAX_LATENCY_RESULT;
+		break;
+	case MDisplayMaxRIO:
+		result_code = MAX_READ_LATENCY_RESULT;
+		break;
+	case MDisplayMaxTrans:
+		result_code = MAX_TRANSACTION_LATENCY_RESULT;
+		break;
+	case MDisplayMaxWIO:
+		result_code = MAX_WRITE_LATENCY_RESULT;
+		break;
+	case MDisplayMBsMBPS:
+		result_code = MBPS_RESULT;
+		break;
+	case MDisplayMBsRMBPS:
+		result_code = READ_MBPS_RESULT;
+		break;
+	case MDisplayMBsWMBPS:
+		result_code = WRITE_MBPS_RESULT;
+		break;
+	case MDisplayNetPacketErrors:
+		result_code = NI_ERROR_RESULT;
+		break;
+	case MDisplayNetPacketsPS:
+		result_code = NI_PACKET_RESULT;
+		break;
+	case MDisplayNetRetransPS:
+		result_code = TCP_SEGMENT_RESULT;
+		break;
+	case MDisplayOpsConPS:
+		result_code = CONNECTION_PER_SEC_RESULT;
+		break;
+	case MDisplayOpsIOPS:
+		result_code = IOPS_RESULT;
+		break;
+	case MDisplayOpsRIOPS:
+		result_code = READ_IOPS_RESULT;
+		break;
+	case MDisplayOpsTransPS:
+		result_code = TRANSACTION_PER_SEC_RESULT;
+		break;
+	case MDisplayOpsWIOPS:
+		result_code = WRITE_IOPS_RESULT;
+		break;
+	default:
+		ErrorMessage("Invalid menu_item value in CGalileoView::OnMDisplay()");
+		return;
 	}
 
 	// If the big meter dialog is open, dispatch this message to it.
 	// Otherwise, send it to CPageDisplay to figure out which button will be updated.
-	if ( m_pPageDisplay->m_dlgBigMeter.is_displayed )
-		m_pPageDisplay->m_dlgBigMeter.OnMDisplay( submenu_id, menu_item, result_code );
+	if (m_pPageDisplay->m_dlgBigMeter.is_displayed)
+		m_pPageDisplay->m_dlgBigMeter.OnMDisplay(submenu_id, menu_item, result_code);
 	else
-		m_pPageDisplay->OnMDisplay( submenu_id, menu_item, result_code );
+		m_pPageDisplay->OnMDisplay(submenu_id, menu_item, result_code);
 }

Modified: branches/IOMETER-restruct/iometer/src/GalileoView.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/GalileoView.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/GalileoView.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,7 +59,6 @@
 #ifndef	VIEW_DEFINED
 #define VIEW_DEFINED
 
-
 #define	TEST_TIMER		1
 #define PREPARE_TIMER		2
 #define RAMP_TIMER		3
@@ -73,7 +72,6 @@
 
 #define NUM_TOOLBAR_BUTTONS	13
 
-
 #include "GalileoDoc.h"
 #include "WorkerView.h"
 #include "ManagerList.h"
@@ -86,195 +84,185 @@
 #include "ICFOpenDialog.h"
 #include "ICFSaveDialog.h"
 
-class CGalileoView : public CView
-{
-protected: // create from serialization only
+class CGalileoView:public CView {
+      protected:		// create from serialization only
 	CGalileoView();
 	DECLARE_DYNCREATE(CGalileoView)
-
 // Attributes
-public:
-	CGalileoDoc*	GetDocument();
+      public:
+	CGalileoDoc * GetDocument();
 
 // Operations
-public:
+      public:
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CGalileoView)
-	public:
-	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
-	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);
+      public:
+	virtual void OnDraw(CDC * pDC);	// overridden to draw this view
+	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT & rect,
+			    CWnd * pParentWnd, UINT nID, CCreateContext * pContext = NULL);
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);
 	//}}AFX_VIRTUAL
 
 // Implementation
-public:
-	virtual			~CGalileoView();
+      public:
+	 virtual ~ CGalileoView();
 #ifdef _DEBUG
 	virtual void AssertValid() const;
-	virtual void Dump(CDumpContext& dc) const;
+	virtual void Dump(CDumpContext & dc) const;
 #endif
-	void			AddManager( Manager *manager );
-	Worker*			AddWorker( TargetType worker_type, Manager *manager,
-						const CString& name = "" );
-	void			OnNewWorker( TargetType worker_type );
-	void			AddDefaultWorkers( Manager *manager );
-	BOOL			DisksNotPrepared();
-	void			ChangedSelection();
-	void			ChangingSelection();
-	TargetType		GetSelectedTargetType();
+	void AddManager(Manager * manager);
+	Worker *AddWorker(TargetType worker_type, Manager * manager, const CString & name = "");
+	void OnNewWorker(TargetType worker_type);
+	void AddDefaultWorkers(Manager * manager);
+	BOOL DisksNotPrepared();
+	void ChangedSelection();
+	void ChangingSelection();
+	TargetType GetSelectedTargetType();
 
 	// Functions to set button states.
-	void			ButtonReset();
+	void ButtonReset();
 
 	// Called by the button handlers for the toolbar and for the big meter dialog
-	void			Go();
-	void			StopAll();
+	void Go();
+	void StopAll();
 
 	//////////////////////////////////////////////////////
 	// Saves/loads an Iometer Configuration File (.icf) //
 	//////////////////////////////////////////////////////
 	// Preprocesses the config file and makes sure all managers specified in
 	// the file are available (or waits on them), then calls OpenConfigFile.
-	BOOL			PrepareToOpenConfigFile(
-									const CString& infilename,
-									BOOL* flags,
-									BOOL replace );
+	BOOL PrepareToOpenConfigFile(const CString & infilename, BOOL * flags, BOOL replace);
 	// Restores configuration from specified file.
-	BOOL			OpenConfigFile( const CString& infilename,	// DO NOT CALL DIRECTLY!
-									BOOL* flags,				// Use OpenConfigFileWrapper!
-									BOOL replace );
+	BOOL OpenConfigFile(const CString & infilename,	// DO NOT CALL DIRECTLY!
+			    BOOL * flags,	// Use OpenConfigFileWrapper!
+			    BOOL replace);
 	// Saves configuration to specified file.
-	BOOL			SaveConfigFile( const CString& outfilename,
-									BOOL* flags );
+	BOOL SaveConfigFile(const CString & outfilename, BOOL * flags);
 
 	// Resets display as needed.
-	void			ResetDisplayforNewTest();
+	void ResetDisplayforNewTest();
 
 	// Function to set text in the status bar.
-	void			SetStatusBarText( CString text1 = "", CString text2 = "", CString text3 = "" );
-	void			ClearStatusBar();
-	void			UpdateTestStatus();
+	void SetStatusBarText(CString text1 = "", CString text2 = "", CString text3 = "");
+	void ClearStatusBar();
+	void UpdateTestStatus();
 
 	// Returns the currently running access spec's index.
-	int				GetCurrentAccessIndex();
+	int GetCurrentAccessIndex();
 
-	void			CalcRunCount();
+	void CalcRunCount();
 
 	// Tells the results display dialogs which result was selected to be monitored.
-	void			OnMDisplay( int submenu_id, int menu_item );
+	void OnMDisplay(int submenu_id, int menu_item);
 
-	void			Reset();
+	void Reset();
 
 	///////////////////////////////////////////////////////////////////////////
 	// Tab sheets.
 	//
-	CWorkerView*	m_pWorkerView;
-	CPageDisk*		m_pPageDisk;
-	CPageNetwork*	m_pPageNetwork;
-	CPageDisplay*	m_pPageDisplay;
-	CPageSetup*		m_pPageSetup;
-	CPageAccess*	m_pPageAccess;
+	CWorkerView *m_pWorkerView;
+	CPageDisk *m_pPageDisk;
+	CPageNetwork *m_pPageNetwork;
+	CPageDisplay *m_pPageDisplay;
+	CPageSetup *m_pPageSetup;
+	CPageAccess *m_pPageAccess;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
+	HTREEITEM right_clicked_item;
+	CImageList *p_DragImage;
+	BOOL dragging;
 
-	HTREEITEM		right_clicked_item;
-	CImageList*		p_DragImage;
-	BOOL			dragging;
-
 	// property sheet is wired to MDI child frame and is not displayed
-	CPropertySheet* m_pPropSheet;
+	CPropertySheet *m_pPropSheet;
 
-protected:
-	CICFOpenDialog file_open_box;	// open config file dialog box
+      protected:
+	 CICFOpenDialog file_open_box;	// open config file dialog box
 	CICFSaveDialog file_save_box;	// save config file dialog box
 
 	// tracks whether parent frame has already been sized.
-	BOOL			m_bSizedBefore;
+	BOOL m_bSizedBefore;
 
-	int				manager_to_prepare;
-	int				worker_to_prepare;
-	CString			result_file;
+	int manager_to_prepare;
+	int worker_to_prepare;
+	CString result_file;
 
-	struct
-	{ 
+	struct {
 		UINT nID;
 		BOOL enabled;
-	}				toolbar_buttons[NUM_TOOLBAR_BUTTONS];
+	} toolbar_buttons[NUM_TOOLBAR_BUTTONS];
 
 	///////////////////////////////////////////////////////////////////////////
 	// Information needed to save configuration settings before testing and
 	// restore them afterwards.
 	//
-	void			SaveSettings();
-	void			RestoreSettings();
+	void SaveSettings();
+	void RestoreSettings();
 	//
-	int				*save_queue_depth;
+	int *save_queue_depth;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-	void			InitAccessSpecRun();
-	BOOL			SetAccess();
-	void			SaveAccessSpecs();
-	void			StartTest();
-	void			StartRecording();
-public:
-	void			StopTest( ReturnVal test_successful );
-protected:
-	void			TestDone( ReturnVal test_successful );
-	void			SaveResults();
-	BOOL			SetActiveTargets();
-	BOOL			SetTargets();
+	void InitAccessSpecRun();
+	BOOL SetAccess();
+	void SaveAccessSpecs();
+	void StartTest();
+	void StartRecording();
+      public:
+	void StopTest(ReturnVal test_successful);
+      protected:
+	void TestDone(ReturnVal test_successful);
+	void SaveResults();
+	BOOL SetActiveTargets();
+	BOOL SetTargets();
 
-	void			EnableWindow( BOOL enable = TRUE );
+	void EnableWindow(BOOL enable = TRUE);
 
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to set button states.
 	//
-	void			SetButton(UINT nID, BOOL state); 
-	void			ButtonReady();
-	void			ButtonTest();
-	void			ButtonPrepare();
-	void			ButtonOff();
+	void SetButton(UINT nID, BOOL state);
+	void ButtonReady();
+	void ButtonTest();
+	void ButtonPrepare();
+	void ButtonOff();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Information used to manage cycling through targets, workers, queue
 	// depth, access specs, etc.
 	//
-	int				run_count;
-	int				run_index;
-	int				access_count;
-	int				access_index;
+	int run_count;
+	int run_index;
+	int access_count;
+	int access_index;
 	//
-	BOOL			CycleTargets();
-	BOOL			CycleWorkers();
-	BOOL			IncrementTargets();
-	BOOL			IncrementTargetsSerial();
-	BOOL			Normal();
-	int				CycleWorkersTargets();
-	BOOL			CycleQueue();
-	BOOL			CycleTargetsQueue();
+	BOOL CycleTargets();
+	BOOL CycleWorkers();
+	BOOL IncrementTargets();
+	BOOL IncrementTargetsSerial();
+	BOOL Normal();
+	int CycleWorkersTargets();
+	BOOL CycleQueue();
+	BOOL CycleTargetsQueue();
 	//
-	int				workers_to_run;
-	int				targets_to_run;
-	int				queue_depth_to_run;
-	int				worker_exponent;
-	int				target_exponent;
-	int				queue_exponent;
+	int workers_to_run;
+	int targets_to_run;
+	int queue_depth_to_run;
+	int worker_exponent;
+	int target_exponent;
+	int queue_exponent;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 // Generated message map functions
-protected:
+      protected:
 	//{{AFX_MSG(CGalileoView)
-	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
+	 afx_msg BOOL OnEraseBkgnd(CDC * pDC);
 	afx_msg void OnTimer(UINT nIDEvent);
 	afx_msg void OnBReset();
 	afx_msg void OnFileOpen();
@@ -288,8 +276,8 @@
 	afx_msg void OnBStart();
 	afx_msg void OnBStop();
 	afx_msg void OnBStopAll();
-	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
-	afx_msg void OnUpdateToolbarButton(CCmdUI* pCmdUI);
+	afx_msg BOOL OnSetCursor(CWnd * pWnd, UINT nHitTest, UINT message);
+	afx_msg void OnUpdateToolbarButton(CCmdUI * pCmdUI);
 	afx_msg void OnDestroy();
 	afx_msg void OnMDisplayCPUDPC();
 	afx_msg void OnMDisplayCPUEffectiveness();
@@ -323,12 +311,14 @@
 	afx_msg void OnMDisplayOpsTransPS();
 	afx_msg void OnMDisplayOpsWIOPS();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
-#ifndef _DEBUG  // debug version in GalileoView.cpp
-inline CGalileoDoc* CGalileoView::GetDocument()
-   { return (CGalileoDoc*)m_pDocument; }
+#ifndef _DEBUG			// debug version in GalileoView.cpp
+inline CGalileoDoc *CGalileoView::GetDocument()
+{
+	return (CGalileoDoc *) m_pDocument;
+}
 #endif
 
 /////////////////////////////////////////////////////////////////////////////

Modified: branches/IOMETER-restruct/iometer/src/ICFOpenDialog.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/ICFOpenDialog.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ICFOpenDialog.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -62,12 +62,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoApp.h"
 #include "ICFOpenDialog.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -78,35 +76,31 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 IMPLEMENT_DYNAMIC(CICFOpenDialog, CFileDialog)
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CICFOpenDialog dialog
-
-CICFOpenDialog::CICFOpenDialog()
-					: CFileDialog(	TRUE, "icf", "", NULL,
-									"Iometer Configuration Files (*.icf)|*.icf|"
-									"Text Files (*.txt)|*.txt|All Files (*.*)|*.*||" )
+    CICFOpenDialog::CICFOpenDialog()
+:  CFileDialog(TRUE, "icf", "", NULL,
+	    "Iometer Configuration Files (*.icf)|*.icf|" "Text Files (*.txt)|*.txt|All Files (*.*)|*.*||")
 {
 	CString title;
 	char *buf;
 
-	VERIFY( title.LoadString( IDS_OPEN_DIALOG_TITLE ) );	// get frame title from resource file
-	buf = new char[ title.GetLength() + 1 ];
-	strcpy( buf, title );
+	VERIFY(title.LoadString(IDS_OPEN_DIALOG_TITLE));	// get frame title from resource file
+	buf = new char[title.GetLength() + 1];
+
+	strcpy(buf, title);
 	m_ofn.lpstrTitle = buf;
 
-	m_ofn.Flags |= OFN_ENABLETEMPLATE | OFN_PATHMUSTEXIST
-				| OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
+	m_ofn.Flags |= OFN_ENABLETEMPLATE | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
 
 	m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPEN_OPTS);
 	//{{AFX_DATA_INIT(CICFOpenDialog)
@@ -124,8 +118,7 @@
 	wasCkAssignTargets = TRUE;
 }
 
-
-void CICFOpenDialog::DoDataExchange(CDataExchange* pDX)
+void CICFOpenDialog::DoDataExchange(CDataExchange * pDX)
 {
 	CFileDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CICFOpenDialog)
@@ -146,52 +139,44 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CICFOpenDialog, CFileDialog)
-	//{{AFX_MSG_MAP(CICFOpenDialog)
-	ON_BN_CLICKED(CkManagerWorker, OnCkManagerWorker)
-	ON_BN_CLICKED(CkTestSetup, OnAnyCheck)
-	ON_BN_CLICKED(ROverwrite, OnROverwrite)
-	ON_BN_CLICKED(RMerge, OnRMerge)
-	ON_WM_HELPINFO()
-	ON_BN_CLICKED(CkResultsDisplay, OnAnyCheck)
-	ON_BN_CLICKED(CkGlobalAccessSpec, OnAnyCheck)
-	ON_BN_CLICKED(CkAssignAccessSpec, OnAnyCheck)
-	ON_BN_CLICKED(CkAssignTargets, OnAnyCheck)
-	ON_WM_PAINT()
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CICFOpenDialog)
+    ON_BN_CLICKED(CkManagerWorker, OnCkManagerWorker)
+    ON_BN_CLICKED(CkTestSetup, OnAnyCheck)
+    ON_BN_CLICKED(ROverwrite, OnROverwrite)
+    ON_BN_CLICKED(RMerge, OnRMerge)
+    ON_WM_HELPINFO()
+    ON_BN_CLICKED(CkResultsDisplay, OnAnyCheck)
+    ON_BN_CLICKED(CkGlobalAccessSpec, OnAnyCheck)
+    ON_BN_CLICKED(CkAssignAccessSpec, OnAnyCheck)
+    ON_BN_CLICKED(CkAssignTargets, OnAnyCheck)
+ON_WM_PAINT()
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CICFOpenDialog message handlers
-
-void CICFOpenDialog::OnCkManagerWorker() 
+void CICFOpenDialog::OnCkManagerWorker()
 {
 	UpdateData(TRUE);	// copy the GUI state to the variables
 
-	if ( isCkManagerWorker )
-	{
+	if (isCkManagerWorker) {
 		// The box was checked
-		m_CkAssignAccessSpec.EnableWindow( TRUE );
+		m_CkAssignAccessSpec.EnableWindow(TRUE);
 		isCkAssignAccessSpec = wasCkAssignAccessSpec;
 
-		m_CkAssignTargets.EnableWindow( TRUE );
+		m_CkAssignTargets.EnableWindow(TRUE);
 		isCkAssignTargets = wasCkAssignTargets;
-	}
-	else
-	{
+	} else {
 		// The box was unchecked
-		if ( m_CkAssignAccessSpec.IsWindowEnabled() )
-		{
-			m_CkAssignAccessSpec.EnableWindow( FALSE );
+		if (m_CkAssignAccessSpec.IsWindowEnabled()) {
+			m_CkAssignAccessSpec.EnableWindow(FALSE);
 			wasCkAssignAccessSpec = isCkAssignAccessSpec;
 			isCkAssignAccessSpec = FALSE;
 		}
 
-		if ( m_CkAssignTargets.IsWindowEnabled() )
-		{
-			m_CkAssignTargets.EnableWindow( FALSE );
+		if (m_CkAssignTargets.IsWindowEnabled()) {
+			m_CkAssignTargets.EnableWindow(FALSE);
 			wasCkAssignTargets = isCkAssignTargets;
 			isCkAssignTargets = FALSE;
 		}
@@ -202,52 +187,49 @@
 	OnAnyCheck();
 }
 
-void CICFOpenDialog::OnAnyCheck() 
+void CICFOpenDialog::OnAnyCheck()
 {
 	UpdateData(TRUE);	// copy the GUI state to the variables
 
 	// Disable OK button if no boxes are checked
-	if ( isCkTestSetup || isCkResultsDisplay
-			|| isCkGlobalAccessSpec || isCkManagerWorker
-			|| isCkAssignAccessSpec || isCkAssignTargets )
+	if (isCkTestSetup || isCkResultsDisplay
+	    || isCkGlobalAccessSpec || isCkManagerWorker || isCkAssignAccessSpec || isCkAssignTargets)
 		CWnd::GetOwner()->GetDlgItem(IDOK)->EnableWindow(TRUE);
 	else
 		CWnd::GetOwner()->GetDlgItem(IDOK)->EnableWindow(FALSE);
 }
 
-void CICFOpenDialog::OnROverwrite() 
+void CICFOpenDialog::OnROverwrite()
 {
 	isROverwrite = TRUE;
 }
 
-void CICFOpenDialog::OnRMerge() 
+void CICFOpenDialog::OnRMerge()
 {
 	isROverwrite = FALSE;
 }
 
-BOOL CICFOpenDialog::OnInitDialog() 
+BOOL CICFOpenDialog::OnInitDialog()
 {
 	CFileDialog::OnInitDialog();
 
-	m_ROverwrite.SetCheck( isROverwrite );
-	m_RMerge.SetCheck( !isROverwrite );
+	m_ROverwrite.SetCheck(isROverwrite);
+	m_RMerge.SetCheck(!isROverwrite);
 
 	UpdateData(FALSE);	// copy the variable states to the GUI
 
-	if ( !isCkManagerWorker )
-	{
-		m_CkAssignAccessSpec.EnableWindow( FALSE );
-		m_CkAssignTargets.EnableWindow( FALSE );
+	if (!isCkManagerWorker) {
+		m_CkAssignAccessSpec.EnableWindow(FALSE);
+		m_CkAssignTargets.EnableWindow(FALSE);
 	}
 
-	return TRUE;  // return TRUE unless you set the focus to a control
+	return TRUE;		// return TRUE unless you set the focus to a control
 }
 
-BOOL CICFOpenDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
+BOOL CICFOpenDialog::OnHelpInfo(HELPINFO * pHelpInfo)
 {
-	switch ( pHelpInfo->iCtrlId )
-	{
-	// When we figure out the help, put it here...
+	switch (pHelpInfo->iCtrlId) {
+		// When we figure out the help, put it here...
 	case CkTestSetup:
 		break;
 	case CkResultsDisplay:
@@ -269,7 +251,6 @@
 	return CFileDialog::OnHelpInfo(pHelpInfo);
 }
 
-
 //
 // Draw the lines that show the relation between the Manager/Worker
 // checkbox and the access spec and target assignment checkboxes.
@@ -277,9 +258,9 @@
 // message, since this is an extension to the file open/save common
 // dialog.
 //
-void CICFOpenDialog::OnPaint() 
+void CICFOpenDialog::OnPaint()
 {
-	CPaintDC dc(this); // device context for painting
+	CPaintDC dc(this);	// device context for painting
 
 	CRect MgrWkr;
 	CRect AsgnAspec;
@@ -303,7 +284,7 @@
 
 	x1 = MgrWkr.left + centerer - 1;
 	x2 = AsgnAspec.left;
-	
+
 	y1 = MgrWkr.bottom;
 	y2 = AsgnAspec.top + centerer;
 	y3 = AsgnTargets.top + centerer;

Modified: branches/IOMETER-restruct/iometer/src/ICFOpenDialog.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/ICFOpenDialog.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ICFOpenDialog.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,66 +61,63 @@
 #ifndef ICFOPENDIALOG_DEFINED
 #define ICFOPENDIALOG_DEFINED
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CICFOpenDialog dialog
 
-class CICFOpenDialog : public CFileDialog
-{
+class CICFOpenDialog:public CFileDialog {
 	DECLARE_DYNAMIC(CICFOpenDialog)
-
 // Construction
-public:
+      public:
 	CICFOpenDialog();
 
 // Dialog Data
 	//{{AFX_DATA(CICFOpenDialog)
 	enum { IDD = IDD_FILEOPEN_OPTS };
-	CButton	m_CkTestSetup;
-	CButton	m_CkResultsDisplay;
-	CButton	m_CkGlobalAccessSpec;
-	CButton	m_CkManagerWorker;
-	CButton	m_CkAssignAccessSpec;
-	CButton	m_CkAssignTargets;
-	CButton	m_RMerge;
-	CButton	m_ROverwrite;
-	BOOL	isCkAssignAccessSpec;
-	BOOL	isCkTestSetup;
-	BOOL	isCkResultsDisplay;
-	BOOL	isCkManagerWorker;
-	BOOL	isCkGlobalAccessSpec;
-	BOOL	isCkAssignTargets;
+	CButton m_CkTestSetup;
+	CButton m_CkResultsDisplay;
+	CButton m_CkGlobalAccessSpec;
+	CButton m_CkManagerWorker;
+	CButton m_CkAssignAccessSpec;
+	CButton m_CkAssignTargets;
+	CButton m_RMerge;
+	CButton m_ROverwrite;
+	BOOL isCkAssignAccessSpec;
+	BOOL isCkTestSetup;
+	BOOL isCkResultsDisplay;
+	BOOL isCkManagerWorker;
+	BOOL isCkGlobalAccessSpec;
+	BOOL isCkAssignTargets;
 	//}}AFX_DATA
 
 	// Once checkboxes are cleared and disabled in response to the
 	// deselection of other checkboxes, their old states are maintained here.
-	BOOL	wasCkAssignAccessSpec;
-	BOOL	wasCkAssignTargets;
+	BOOL wasCkAssignAccessSpec;
+	BOOL wasCkAssignTargets;
 
 	// Tracks radio button state.  (Can't make a radio button state variable?)
-	BOOL	isROverwrite;
+	BOOL isROverwrite;
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CICFOpenDialog)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 
 	// Generated message map functions
 	//{{AFX_MSG(CICFOpenDialog)
-	afx_msg void OnCkManagerWorker();
+	 afx_msg void OnCkManagerWorker();
 	virtual BOOL OnInitDialog();
 	afx_msg void OnAnyCheck();
 	afx_msg void OnROverwrite();
 	afx_msg void OnRMerge();
-	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
+	afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
 	afx_msg void OnPaint();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
 //{{AFX_INSERT_LOCATION}}

Modified: branches/IOMETER-restruct/iometer/src/ICFSaveDialog.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/ICFSaveDialog.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ICFSaveDialog.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -62,12 +62,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoApp.h"
 #include "ICFSaveDialog.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -78,35 +76,31 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 IMPLEMENT_DYNAMIC(CICFSaveDialog, CFileDialog)
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CICFSaveDialog dialog
-
-CICFSaveDialog::CICFSaveDialog()
-					: CFileDialog(	FALSE, "icf", "iometer", NULL,
-									"Iometer Configuration Files (*.icf)|*.icf|"
-									"Text Files (*.txt)|*.txt|All Files (*.*)|*.*||" )
+    CICFSaveDialog::CICFSaveDialog()
+:  CFileDialog(FALSE, "icf", "iometer", NULL,
+	    "Iometer Configuration Files (*.icf)|*.icf|" "Text Files (*.txt)|*.txt|All Files (*.*)|*.*||")
 {
 	CString title;
 	char *buf;
 
-	VERIFY( title.LoadString( IDS_SAVE_DIALOG_TITLE ) );	// get frame title from resource file
-	buf = new char[ title.GetLength() + 1 ];
-	strcpy( buf, title );
+	VERIFY(title.LoadString(IDS_SAVE_DIALOG_TITLE));	// get frame title from resource file
+	buf = new char[title.GetLength() + 1];
+
+	strcpy(buf, title);
 	m_ofn.lpstrTitle = buf;
 
-	m_ofn.Flags |= OFN_ENABLETEMPLATE | OFN_PATHMUSTEXIST
-				| OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
+	m_ofn.Flags |= OFN_ENABLETEMPLATE | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
 
 	m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILESAVE_OPTS);
 	//{{AFX_DATA_INIT(CICFSaveDialog)
@@ -122,8 +116,7 @@
 	wasCkAssignTargets = TRUE;
 }
 
-
-void CICFSaveDialog::DoDataExchange(CDataExchange* pDX)
+void CICFSaveDialog::DoDataExchange(CDataExchange * pDX)
 {
 	CDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CICFSaveDialog)
@@ -142,49 +135,41 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CICFSaveDialog, CDialog)
-	//{{AFX_MSG_MAP(CICFSaveDialog)
-	ON_BN_CLICKED(CkManagerWorker, OnCkManagerWorker)
-	ON_BN_CLICKED(CkTestSetup, OnAnyCheck)
-	ON_WM_HELPINFO()
-	ON_BN_CLICKED(CkResultsDisplay, OnAnyCheck)
-	ON_BN_CLICKED(CkGlobalAccessSpec, OnAnyCheck)
-	ON_BN_CLICKED(CkAssignAccessSpec, OnAnyCheck)
-	ON_BN_CLICKED(CkAssignTargets, OnAnyCheck)
-	ON_WM_PAINT()
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CICFSaveDialog)
+    ON_BN_CLICKED(CkManagerWorker, OnCkManagerWorker)
+    ON_BN_CLICKED(CkTestSetup, OnAnyCheck)
+    ON_WM_HELPINFO()
+    ON_BN_CLICKED(CkResultsDisplay, OnAnyCheck)
+    ON_BN_CLICKED(CkGlobalAccessSpec, OnAnyCheck)
+    ON_BN_CLICKED(CkAssignAccessSpec, OnAnyCheck)
+    ON_BN_CLICKED(CkAssignTargets, OnAnyCheck)
+ON_WM_PAINT()
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CICFSaveDialog message handlers
-
-void CICFSaveDialog::OnCkManagerWorker() 
+void CICFSaveDialog::OnCkManagerWorker()
 {
 	UpdateData(TRUE);	// copy the GUI state to the variables
 
-	if ( isCkManagerWorker )
-	{
+	if (isCkManagerWorker) {
 		// The box was checked
-		m_CkAssignAccessSpec.EnableWindow( TRUE );
+		m_CkAssignAccessSpec.EnableWindow(TRUE);
 		isCkAssignAccessSpec = wasCkAssignAccessSpec;
 
-		m_CkAssignTargets.EnableWindow( TRUE );
+		m_CkAssignTargets.EnableWindow(TRUE);
 		isCkAssignTargets = wasCkAssignTargets;
-	}
-	else
-	{
+	} else {
 		// The box was unchecked
-		if ( m_CkAssignAccessSpec.IsWindowEnabled() )
-		{
-			m_CkAssignAccessSpec.EnableWindow( FALSE );
+		if (m_CkAssignAccessSpec.IsWindowEnabled()) {
+			m_CkAssignAccessSpec.EnableWindow(FALSE);
 			wasCkAssignAccessSpec = isCkAssignAccessSpec;
 			isCkAssignAccessSpec = FALSE;
 		}
 
-		if ( m_CkAssignTargets.IsWindowEnabled() )
-		{
-			m_CkAssignTargets.EnableWindow( FALSE );
+		if (m_CkAssignTargets.IsWindowEnabled()) {
+			m_CkAssignTargets.EnableWindow(FALSE);
 			wasCkAssignTargets = isCkAssignTargets;
 			isCkAssignTargets = FALSE;
 		}
@@ -195,39 +180,36 @@
 	OnAnyCheck();
 }
 
-void CICFSaveDialog::OnAnyCheck() 
+void CICFSaveDialog::OnAnyCheck()
 {
 	UpdateData(TRUE);	// copy the GUI state to the variables
 
 	// Disable OK button if no boxes are checked
-	if ( isCkTestSetup || isCkResultsDisplay
-			|| isCkGlobalAccessSpec || isCkManagerWorker
-			|| isCkAssignAccessSpec || isCkAssignTargets )
+	if (isCkTestSetup || isCkResultsDisplay
+	    || isCkGlobalAccessSpec || isCkManagerWorker || isCkAssignAccessSpec || isCkAssignTargets)
 		CWnd::GetOwner()->GetDlgItem(IDOK)->EnableWindow(TRUE);
 	else
 		CWnd::GetOwner()->GetDlgItem(IDOK)->EnableWindow(FALSE);
 }
 
-BOOL CICFSaveDialog::OnInitDialog() 
+BOOL CICFSaveDialog::OnInitDialog()
 {
 	CDialog::OnInitDialog();
 
 	UpdateData(FALSE);	// copy the variable states to the GUI
 
-	if ( !isCkManagerWorker )
-	{
-		m_CkAssignAccessSpec.EnableWindow( FALSE );
-		m_CkAssignTargets.EnableWindow( FALSE );
+	if (!isCkManagerWorker) {
+		m_CkAssignAccessSpec.EnableWindow(FALSE);
+		m_CkAssignTargets.EnableWindow(FALSE);
 	}
 
-	return TRUE;  // return TRUE unless you set the focus to a control
+	return TRUE;		// return TRUE unless you set the focus to a control
 }
 
-BOOL CICFSaveDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
+BOOL CICFSaveDialog::OnHelpInfo(HELPINFO * pHelpInfo)
 {
-	switch ( pHelpInfo->iCtrlId )
-	{
-	// When we figure out the help, put it here...
+	switch (pHelpInfo->iCtrlId) {
+		// When we figure out the help, put it here...
 	case CkTestSetup:
 		break;
 	case CkResultsDisplay:
@@ -245,7 +227,6 @@
 	return CDialog::OnHelpInfo(pHelpInfo);
 }
 
-
 //
 // Draw the lines that show the relation between the Manager/Worker
 // checkbox and the access spec and target assignment checkboxes.
@@ -253,9 +234,9 @@
 // message, since this is an extension to the file open/save common
 // dialog.
 //
-void CICFSaveDialog::OnPaint() 
+void CICFSaveDialog::OnPaint()
 {
-	CPaintDC dc(this); // device context for painting
+	CPaintDC dc(this);	// device context for painting
 
 	CRect MgrWkr;
 	CRect AsgnAspec;
@@ -279,7 +260,7 @@
 
 	x1 = MgrWkr.left + centerer - 1;
 	x2 = AsgnAspec.left;
-	
+
 	y1 = MgrWkr.bottom;
 	y2 = AsgnAspec.top + centerer;
 	y3 = AsgnTargets.top + centerer;

Modified: branches/IOMETER-restruct/iometer/src/ICFSaveDialog.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/ICFSaveDialog.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ICFSaveDialog.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,59 +61,56 @@
 #ifndef ICFSAVEDIALOG_DEFINED
 #define ICFSAVEDIALOG_DEFINED
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CICFSaveDialog dialog
 
-class CICFSaveDialog : public CFileDialog
-{
+class CICFSaveDialog:public CFileDialog {
 	DECLARE_DYNAMIC(CICFSaveDialog)
-
 // Construction
-public:
+      public:
 	CICFSaveDialog();
 
 // Dialog Data
 	//{{AFX_DATA(CICFSaveDialog)
 	enum { IDD = IDD_FILESAVE_OPTS };
-	CButton	m_CkTestSetup;
-	CButton	m_CkResultsDisplay;
-	CButton	m_CkGlobalAccessSpec;
-	CButton	m_CkManagerWorker;
-	CButton	m_CkAssignAccessSpec;
-	CButton	m_CkAssignTargets;
-	BOOL	isCkTestSetup;
-	BOOL	isCkResultsDisplay;
-	BOOL	isCkGlobalAccessSpec;
-	BOOL	isCkManagerWorker;
-	BOOL	isCkAssignAccessSpec;
-	BOOL	isCkAssignTargets;
+	CButton m_CkTestSetup;
+	CButton m_CkResultsDisplay;
+	CButton m_CkGlobalAccessSpec;
+	CButton m_CkManagerWorker;
+	CButton m_CkAssignAccessSpec;
+	CButton m_CkAssignTargets;
+	BOOL isCkTestSetup;
+	BOOL isCkResultsDisplay;
+	BOOL isCkGlobalAccessSpec;
+	BOOL isCkManagerWorker;
+	BOOL isCkAssignAccessSpec;
+	BOOL isCkAssignTargets;
 	//}}AFX_DATA
 
 	// Once checkboxes are cleared and disabled in response to the
 	// deselection of other checkboxes, their old states are maintained here.
-	BOOL	wasCkAssignAccessSpec;
-	BOOL	wasCkAssignTargets;
+	BOOL wasCkAssignAccessSpec;
+	BOOL wasCkAssignTargets;
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CICFSaveDialog)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 
 	// Generated message map functions
 	//{{AFX_MSG(CICFSaveDialog)
-	afx_msg void OnCkManagerWorker();
+	 afx_msg void OnCkManagerWorker();
 	virtual BOOL OnInitDialog();
 	afx_msg void OnAnyCheck();
-	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
+	afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
 	afx_msg void OnPaint();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
 //{{AFX_INSERT_LOCATION}}

Modified: branches/IOMETER-restruct/iometer/src/ICF_ifstream.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/ICF_ifstream.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ICF_ifstream.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -67,12 +67,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoApp.h"
 #include "ICF_ifstream.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -83,14 +81,13 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 //
 // Reads the version header from the file,
 // returns the version number as a long integer.
@@ -107,41 +104,35 @@
 	long version;
 
 	version_string = GetNextLine();
-	if (version_string.IsEmpty())
-	{
+	if (version_string.IsEmpty()) {
 		ErrorMessage("File is improperly formatted.  Empty line found "
-			"where file version information was expected.");
+			     "where file version information was expected.");
 		return -1;
 	}
 
 	if (!ExtractFirstIntVersion(version_string, major)
-		|| !ExtractFirstIntVersion(version_string, middle)
-		|| !ExtractFirstIntVersion(version_string, minor))
-	{
-		ErrorMessage("File is improperly formatted.  "
-			"Error retrieving file version information.");
+	    || !ExtractFirstIntVersion(version_string, middle)
+	    || !ExtractFirstIntVersion(version_string, minor)) {
+		ErrorMessage("File is improperly formatted.  " "Error retrieving file version information.");
 		return -1;
 	}
 
-	version = (long) major * 10000 + middle * 100 + minor;
+	version = (long)major *10000 + middle * 100 + minor;
 
 	// Special case test for ancient version "3.26.97" OLTP.txt
 	// file distributed with 1998.01.05.
-	if ( version == 32697 )
+	if (version == 32697)
 		version = 19980105;
 
-	if ( version < 19980105 )
-	{
-		ErrorMessage( "Error restoring file.  "
-			"Version number earlier than 1998.01.05 or incorrectly formatted." );
+	if (version < 19980105) {
+		ErrorMessage("Error restoring file.  "
+			     "Version number earlier than 1998.01.05 or incorrectly formatted.");
 		return -1;
 	}
 
 	return version;
 }
 
-
-
 //
 // Looks through the whole stream for the given identifier on a line
 // by itself, puts the fstream file pointer at the beginning of the
@@ -161,9 +152,8 @@
 
 	identifier.TrimLeft();
 	identifier.TrimRight();
-	
-	do
-	{
+
+	do {
 		if (eof())
 			return FALSE;
 
@@ -172,15 +162,13 @@
 		curline.TrimLeft();
 		curline.TrimRight();
 	}
-	while ( identifier.CompareNoCase(curline.Left(identifier.GetLength())) != 0 );
+	while (identifier.CompareNoCase(curline.Left(identifier.GetLength())) != 0);
 	// Loop until the identifier is matched.  (Ignore the rest of the line when
 	// comparing.)
 
 	return TRUE;
 }
 
-
-
 //
 // Duplicates the functionality of istream's getline(), but does so using
 // CStrings.  This hides all the "buffer" code required to get a char*
@@ -194,11 +182,10 @@
 {
 	CString curline;
 
-	if (!is_open())
-	{
+	if (!is_open()) {
 		// This should never happen.  This indicates an Iometer bug.
 		ErrorMessage("A call was made to ICF_ifstream::GetNextLine() "
-			"with a closed file!  Please report this as an Iometer bug.");
+			     "with a closed file!  Please report this as an Iometer bug.");
 		curline.Empty();
 		return curline;
 	}
@@ -212,8 +199,6 @@
 	return curline;
 }
 
-
-
 //
 // Use GetPair retrieve the next comment and corresponding value from the
 // Iometer config file.  (They are returned by reference in key and value.)
@@ -228,19 +213,17 @@
 // Return value of FALSE indicates an error.  The calling function
 // should report a specific error.
 //
-BOOL ICF_ifstream::GetPair(CString& key, CString& value)
+BOOL ICF_ifstream::GetPair(CString & key, CString & value)
 {
 	streampos placeholder;
 	CString tempstring;
 
-	if (!is_open())
-	{
+	if (!is_open()) {
 		// This should never happen.  This indicates an Iometer bug.
 		ErrorMessage("A call was made to ICF_ifstream::GetPair() "
-			"with a closed file!  Please report this as an Iometer bug.");
+			     "with a closed file!  Please report this as an Iometer bug.");
 		return FALSE;
 	}
-
 	// If EOF, let the caller report an error.
 	if (rdstate())
 		return FALSE;
@@ -258,50 +241,42 @@
 	// Note that strlen is used (instead of a constant) to make the
 	// connection between the string and its length obvious to someone
 	// making changes to the code.
-	if ( key.Left((int)(strlen("'End"))).CompareNoCase("'End") == 0
-		|| key.Left((int)(strlen("'Version"))).CompareNoCase("'Version") == 0)
-	{
+	if (key.Left((int)(strlen("'End"))).CompareNoCase("'End") == 0
+	    || key.Left((int)(strlen("'Version"))).CompareNoCase("'Version") == 0) {
 		value.Empty();
 		return TRUE;
 	}
-
 	// Skip any extra comment lines before the data.
-	while (peek() == '\'')
-	{
+	while (peek() == '\'') {
 		placeholder = tellg();
 		tempstring = GetNextLine();
 
-		if ( tempstring.Left((int)(strlen("'End"))).CompareNoCase("'End") == 0
-			|| tempstring.Left((int)(strlen("'Version"))).CompareNoCase("'Version") == 0)
-		{
+		if (tempstring.Left((int)(strlen("'End"))).CompareNoCase("'End") == 0
+		    || tempstring.Left((int)(strlen("'Version"))).CompareNoCase("'Version") == 0) {
 			// This only happens when there is an empty section, like:
-			//	'Worker
-			//	'End worker
+			//      'Worker
+			//      'End worker
 			// Worker name is normally expected after the "'Worker" header,
 			// but in this case, it's only an "'End worker" header.  The
 			// "'End..." header must be returned in the NEXT call to GetPair.
 
-			seekg( placeholder );	// back up the file pointer
+			seekg(placeholder);	// back up the file pointer
 			value.Empty();
-			return TRUE;			// NOT an error condition
+			return TRUE;	// NOT an error condition
 		}
 	}
 
 	// If EOF, let the caller report an error.
-	if (rdstate())
-	{
+	if (rdstate()) {
 		value.Empty();
 		return FALSE;
 	}
-
 	// Get the data corresponding to the above key.
 	value = GetNextLine();
 
 	return TRUE;
 }
 
-
-
 //
 // Extract the first integer in a CString and remove it from the CString.
 // Both the string and the number parameters are modified.  Finds the
@@ -312,7 +287,7 @@
 // Return value of FALSE indicates an error.  The calling function
 // should report a specific error.
 //
-BOOL ICF_ifstream::ExtractFirstInt(CString& string, int& number)
+BOOL ICF_ifstream::ExtractFirstInt(CString & string, int &number)
 {
 	const CString backup_string = string;
 	CString substring;
@@ -320,29 +295,25 @@
 
 	number = 0;
 
-	if ((pos = string.FindOneOf("-1234567890")) == -1)
-	{
-		ErrorMessage("File is improperly formatted.  Expected an "
-			"integer value.");
+	if ((pos = string.FindOneOf("-1234567890")) == -1) {
+		ErrorMessage("File is improperly formatted.  Expected an " "integer value.");
 		return FALSE;
 	}
-
 	// Cleave off everything before the first number.
 	string = string.Right(string.GetLength() - pos);
 
-	substring = string.SpanIncluding("-1234567890"); // get the int as a string
+	substring = string.SpanIncluding("-1234567890");	// get the int as a string
 	string = string.Right(string.GetLength() - substring.GetLength());
 
 	// If there are any negative signs after the first character, fail.
-	if (substring.Right(substring.GetLength() - 1).Find('-') != -1)
-	{
+	if (substring.Right(substring.GetLength() - 1).Find('-') != -1) {
 		ErrorMessage("File is improperly formatted.  An integer value "
-			"has a negative sign in the middle or on the end of it.");
+			     "has a negative sign in the middle or on the end of it.");
 		string = backup_string;	// restore string's old value
 		return FALSE;
 	}
 
-	number = atoi( (LPCTSTR)substring );
+	number = atoi((LPCTSTR) substring);
 
 	// Prepare string for further processing.  Eat whitespace.
 	string.TrimLeft();
@@ -357,7 +328,7 @@
 	return TRUE;
 }
 
-BOOL ICF_ifstream::ExtractFirstIntVersion(CString& string, int& number)
+BOOL ICF_ifstream::ExtractFirstIntVersion(CString & string, int &number)
 {
 	const CString backup_string = string;
 	CString substring;
@@ -365,20 +336,17 @@
 
 	number = 0;
 
-	if ((pos = string.FindOneOf("1234567890")) == -1)
-	{
-		ErrorMessage("File is improperly formatted.  Expected an "
-			"integer value.");
+	if ((pos = string.FindOneOf("1234567890")) == -1) {
+		ErrorMessage("File is improperly formatted.  Expected an " "integer value.");
 		return FALSE;
 	}
-
 	// Cleave off everything before the first number.
 	string = string.Right(string.GetLength() - pos);
 
-	substring = string.SpanIncluding("1234567890"); // get the int as a string
+	substring = string.SpanIncluding("1234567890");	// get the int as a string
 	string = string.Right(string.GetLength() - substring.GetLength());
 
-	number = atoi( (LPCTSTR)substring );
+	number = atoi((LPCTSTR) substring);
 
 	// Prepare string for further processing.  Eat whitespace.
 	string.TrimLeft();
@@ -393,8 +361,6 @@
 	return TRUE;
 }
 
-
-
 //
 // Extracts the first solid series of letters, numbers, underscores, and
 // hyphens in a string.  Returns the substring, removes the token from the
@@ -406,21 +372,17 @@
 // Error condition is not reported.  If returned string is empty (IsEmpty)
 // and an empty string is not expected, the caller should report an error.
 //
-CString ICF_ifstream::ExtractFirstToken(CString& string, BOOL spaces/*=FALSE*/)
+CString ICF_ifstream::ExtractFirstToken(CString & string, BOOL spaces /*=FALSE*/ )
 {
 	CString substring;
 	int pos;
 	CString token_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-							"abcdefghijklmnopqrstuvwxyz"
-							"1234567890"
-							"`~!@#$%^&*()-_=+[]{}\\:;\"'./<>?";
+	    "abcdefghijklmnopqrstuvwxyz" "1234567890" "`~!@#$%^&*()-_=+[]{}\\:;\"'./<>?";
 
-
 	if (spaces)
 		token_chars += " ";
 
-	if ((pos = string.FindOneOf(token_chars)) == -1)
-	{
+	if ((pos = string.FindOneOf(token_chars)) == -1) {
 		substring.Empty();
 		return substring;
 	}

Modified: branches/IOMETER-restruct/iometer/src/ICF_ifstream.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/ICF_ifstream.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ICF_ifstream.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -84,28 +84,25 @@
 #ifndef ICF_IFSTREAM_DEFINED
 #define ICF_IFSTREAM_DEFINED
 
-
 #include <fstream>
 using namespace std;
 
-
 #define MAX_ICF_LINE 200
 
+class ICF_ifstream:public ifstream {
+      public:
+	ICF_ifstream():ifstream() {
+	} ICF_ifstream(const CString & infilename):ifstream(infilename) {
+	}
 
-class ICF_ifstream : public ifstream
-{
-public:
-	ICF_ifstream()							: ifstream() { }
-	ICF_ifstream(const CString& infilename)	: ifstream(infilename) { }
+	long GetVersion();
+	BOOL SkipTo(CString identifier);
+	CString GetNextLine();
+	BOOL GetPair(CString & key, CString & value);
 
-	long	GetVersion();
-	BOOL	SkipTo(CString identifier);
-	CString	GetNextLine();
-	BOOL	GetPair(CString& key, CString& value);
-
-	static BOOL		ExtractFirstInt(CString& string, int& number);
-	static BOOL		ExtractFirstIntVersion(CString& string, int& number);
-	static CString	ExtractFirstToken(CString& string, BOOL spaces=FALSE);
+	static BOOL ExtractFirstInt(CString & string, int &number);
+	static BOOL ExtractFirstIntVersion(CString & string, int &number);
+	static CString ExtractFirstToken(CString & string, BOOL spaces = FALSE);
 };
 
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOAccess.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOAccess.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOAccess.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -62,47 +62,39 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
-
 #include "IOAccess.h"
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- pthread_mutex_t lock_mt;
+pthread_mutex_t lock_mt;
 #endif
 
-
-
 //
 // Setting the access specifications based on the given input.  This will also
 // record the maximum requested transfer size.
 //
-void Access::Initialize( const Access_Specs specs )
+void Access::Initialize(const Access_Specs specs)
 {
-	int		i, temp_value, start_percent = 0, spec_no = 0;
+	int i, temp_value, start_percent = 0, spec_no = 0;
+
 	max_transfer = 0;
 
-	do
-	{
-		for ( i = start_percent; ( i < ( start_percent + specs[spec_no].of_size ) &&
-			( i < MAX_ACCESS_SPECS )); i++ )
-		{
-			access_grid[i].size	= specs[spec_no].size;
-			access_grid[i].read	= specs[spec_no].reads;
-			access_grid[i].random	= specs[spec_no].random;
-			access_grid[i].delay	= specs[spec_no].delay;
-			access_grid[i].burst	= specs[spec_no].burst;
-			access_grid[i].align	= specs[spec_no].align;
-			access_grid[i].reply	= specs[spec_no].reply;
+	do {
+		for (i = start_percent; (i < (start_percent + specs[spec_no].of_size) && (i < MAX_ACCESS_SPECS)); i++) {
+			access_grid[i].size = specs[spec_no].size;
+			access_grid[i].read = specs[spec_no].reads;
+			access_grid[i].random = specs[spec_no].random;
+			access_grid[i].delay = specs[spec_no].delay;
+			access_grid[i].burst = specs[spec_no].burst;
+			access_grid[i].align = specs[spec_no].align;
+			access_grid[i].reply = specs[spec_no].reply;
 
 			temp_value = access_grid[i].align;
 
-			if ( temp_value != 0 )
-			{
+			if (temp_value != 0) {
 				// See if alignment value is a power of two by repeatedly
 				// dividing it in half (right shifting by 1 bit) and checking
 				// to see if the result is odd at any stage.
-				while ( temp_value > 1 )
-				{
-					if ( temp_value % 2 )
+				while (temp_value > 1) {
+					if (temp_value % 2)
 						break;
 
 					temp_value >>= 1;
@@ -114,9 +106,9 @@
 				// (access_grid[i].align is abbreviated "align" in examples)
 				//
 				// "& ~((DWORDLONG)align - 1)" masks off lower bits to force
-				//			sector alignment.  sector_size is cast to a
-				//			DWORDLONG to force the result to be a 64-bit
-				//			quantity.
+				//                      sector alignment.  sector_size is cast to a
+				//                      DWORDLONG to force the result to be a 64-bit
+				//                      quantity.
 				//
 				//     For example, if alignment = 512 (0x00000200):
 				//           (DWORDLONG)align      = 0x0000000000000200
@@ -124,44 +116,34 @@
 				//         ~((DWORDLONG)align - 1) = 0xFFFFFFFFFFFFFE00
 
 				if (temp_value == 1)
-					access_grid[i].align_mask = ~( (DWORDLONG)access_grid[i].align - 1 );
+					access_grid[i].align_mask = ~((DWORDLONG) access_grid[i].align - 1);
 				else
 					access_grid[i].align_mask = NOT_POWER_OF_TWO;
-			}
-			else
-			{
+			} else {
 				// assuming sector alignment (mask value is ignored, setting it anyway)
 				access_grid[i].align_mask = 0;
 			}
 		}
 		// Checking for new maximum transfer size (request or reply).
-		if ( i > start_percent )
-		{
-			if ( specs[spec_no].size > (DWORD) max_transfer )
-				max_transfer = (int) specs[spec_no].size;
-			if ( specs[spec_no].reply > (DWORD) max_transfer )
-				max_transfer = (int) specs[spec_no].reply;
+		if (i > start_percent) {
+			if (specs[spec_no].size > (DWORD) max_transfer)
+				max_transfer = (int)specs[spec_no].size;
+			if (specs[spec_no].reply > (DWORD) max_transfer)
+				max_transfer = (int)specs[spec_no].reply;
 		}
-		
-		start_percent = i;		// Begin again where we left off.
+
+		start_percent = i;	// Begin again where we left off.
 		spec_no++;
-	}	while ( i < MAX_ACCESS_SPECS );
+	} while (i < MAX_ACCESS_SPECS);
 	cout << "Access specifications for test defined." << endl << flush;
 }
 
-
-
 //
 // Gets information from the access spec to prepare the next burst.
 // Doesn't retrieve ALL data from the access spec.
 //
-void Access::GetNextBurst(	int			access_percent,
-							int			*burst,
-							DWORD		*size,
-							int			*delay,
-							DWORD		*align,
-							DWORDLONG	*align_mask,
-							DWORD		*reply )
+void Access::GetNextBurst(int access_percent,
+			  int *burst, DWORD * size, int *delay, DWORD * align, DWORDLONG * align_mask, DWORD * reply)
 {
 	*burst = access_grid[access_percent].burst;
 	*size = access_grid[access_percent].size;
@@ -171,22 +153,18 @@
 	*reply = access_grid[access_percent].reply;
 }
 
-
-
 //
 // Determines if an access is to be a read.
 //
-BOOL Access::Read( int access_percent, int read_percent )
+BOOL Access::Read(int access_percent, int read_percent)
 {
-	return ( read_percent < access_grid[access_percent].read );
+	return (read_percent < access_grid[access_percent].read);
 }
 
-
-
 //
 // Determines is an access is to be random.
 //
-BOOL Access::Random( int access_percent, int random_percent )
+BOOL Access::Random(int access_percent, int random_percent)
 {
-	return ( random_percent < access_grid[access_percent].random );
+	return (random_percent < access_grid[access_percent].random);
 }

Modified: branches/IOMETER-restruct/iometer/src/IOAccess.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOAccess.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOAccess.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -57,32 +57,27 @@
 #ifndef ACCESS_DEFINED
 #define ACCESS_DEFINED
 
-
 #include "IOCommon.h"
-#define NOT_POWER_OF_TWO   (DWORDLONG) -1   // a mask is set to this if it cannot be used for
+#define NOT_POWER_OF_TWO   (DWORDLONG) -1	// a mask is set to this if it cannot be used for
 					    // byte alignment (because the alignment isn't a
 					    // power of two)
 
-typedef struct
-{
+typedef struct {
 	int random;
 	int read;
 	DWORD size;
-	int	delay;
+	int delay;
 	int burst;
 	DWORD align;
 	DWORD reply;
 	DWORDLONG align_mask;
-}	ACCESS;
+} ACCESS;
 
-
-
-struct Access_Spec
-{
-	int of_size;	// Indicates how many percent this Access_Spec
-	                // acquires in AccessSpecList (so the sum of
-					// all Access_Spec's of_size fields has to be
-					// 100 in total)
+struct Access_Spec {
+	int of_size;		// Indicates how many percent this Access_Spec
+	// acquires in AccessSpecList (so the sum of
+	// all Access_Spec's of_size fields has to be
+	// 100 in total)
 	int reads;
 	int random;
 	int delay;
@@ -91,38 +86,31 @@
 	DWORD reply;
 	DWORD size;
 };
+
 #define Access_Specs Access_Spec*
-#define MAX_ACCESS_SPECS	100		// Maximum number of specs in a total specification.
+#define MAX_ACCESS_SPECS	100	// Maximum number of specs in a total specification.
 
+class Access {
+      public:
 
+	Access() {
+		max_transfer = 0;
+	} ~Access() {
+	}
 
-class Access
-{
-public:
+	void Initialize(const Access_Specs specs);
 
-	Access() { max_transfer = 0; }
-	~Access() { }
+	void GetNextBurst(int access_percent,
+			  int *burst, DWORD * size, int *delay, DWORD * align, DWORDLONG * align_mask, DWORD * reply);
 
-	void	Initialize( const Access_Specs specs );
+	BOOL Read(int access_percent, int read_percent);
+	BOOL Random(int access_percent, int random_percent);
 
-	void	GetNextBurst(	int			access_percent,
-							int			*burst,
-							DWORD		*size,
-							int			*delay,
-							DWORD		*align,
-							DWORDLONG	*align_mask,
-							DWORD		*reply );
+	int max_transfer;	// Maximum size of a transfer request for a test.
 
-	BOOL	Read( int access_percent, int read_percent );
-	BOOL	Random( int access_percent, int random_percent );
+      private:
 
-	int		max_transfer;				// Maximum size of a transfer request for a test.
-
-private:
-
 	ACCESS access_grid[MAX_ACCESS_SPECS];
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOCQ.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCQ.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOCQ.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -4,10 +4,10 @@
 /* ##                                                                     ## */
 /* ## ------------------------------------------------------------------- ## */
 /* ##                                                                     ## */
-/* ##  Job .......: Interface for the abstract class CQ (Completion       ## */ 
-/* ##               Queue), which is used to manage completions.          ## */ 
-/* ##               Inherited subclasses can be blocking or non-blocking, ## */ 
-/* ##               allowing the use of completion polling or waiting.    ## */ 
+/* ##  Job .......: Interface for the abstract class CQ (Completion       ## */
+/* ##               Queue), which is used to manage completions.          ## */
+/* ##               Inherited subclasses can be blocking or non-blocking, ## */
+/* ##               allowing the use of completion polling or waiting.    ## */
 /* ##                                                                     ## */
 /* ## ------------------------------------------------------------------- ## */
 /* ##                                                                     ## */
@@ -67,26 +67,21 @@
 #ifndef	CQ_DEFINED
 #define	CQ_DEFINED
 
-
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <afxwin.h>
+#include <afxwin.h>
 #endif
 #include "IOTransfers.h"
 #include "IOCommon.h"
 
+class CQ {
+      public:
 
-
-class CQ
-{
-public:
-
-	virtual	ReturnVal	GetStatus( int *bytes, int *data, int delay ) = 0;
+	virtual ReturnVal GetStatus(int *bytes, int *data, int delay) = 0;
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	virtual BOOL		SetQueueSize(int size) { return FALSE; };
+	virtual BOOL SetQueueSize(int size) {
+		return FALSE;
+	};
 #endif
 };
 
-
-
-#endif // CQ_DEFINED
+#endif				// CQ_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/IOCQAIO.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCQAIO.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOCQAIO.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -71,119 +71,100 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOCQAIO.h"
 
-
-
 CQAIO::CQAIO()
 {
-	completion_queue = CreateIoCompletionPort( INVALID_HANDLE_VALUE, 
-		NULL, 0, 1 );
+	completion_queue = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
 
-	if ( completion_queue == INVALID_HANDLE_VALUE )
-	{
-		cout << "*** Unable to create I/O completion port for asynchronous "
-			<< "I/O operations." << endl;
+	if (completion_queue == INVALID_HANDLE_VALUE) {
+		cout << "*** Unable to create I/O completion port for asynchronous " << "I/O operations." << endl;
 	}
 }
 
-
-
 //
 // Getting and returning that status of any completed I/O calls.
 //
-ReturnVal CQAIO::GetStatus( int *bytes, int *data, int delay )
+ReturnVal CQAIO::GetStatus(int *bytes, int *data, int delay)
 {
-	Transaction	*transaction = NULL;
+	Transaction *transaction = NULL;
+
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-	ULONG_PTR	temp;
+	ULONG_PTR temp;
 #elif defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	DWORD		temp;
+	DWORD temp;
 #else
-	#error ===> ERROR: You have to do some coding here to get the port done!
+#error ===> ERROR: You have to do some coding here to get the port done!
 #endif
-	BOOL		result;
-	DWORD		error_no;
+	BOOL result;
+	DWORD error_no;
 
-	result = GetQueuedCompletionStatus( completion_queue, (DWORD*) bytes, 
-		&temp, (LPOVERLAPPED*) &transaction, delay );
+	result = GetQueuedCompletionStatus(completion_queue, (DWORD *) bytes,
+					   &temp, (LPOVERLAPPED *) & transaction, delay);
 
 	// Set the return data to the transaction id that completed or failed.
-	if ( result )
-	{
+	if (result) {
 		// I/O completed successfully.
 		*data = transaction->request_number;
 		return ReturnSuccess;
 	}
-
 	// See if the request timed out - i.e. nothing completed to the queue 
 	// within the specified time.
-	if ( (error_no = GetLastError()) == WAIT_TIMEOUT )
+	if ((error_no = GetLastError()) == WAIT_TIMEOUT)
 		return ReturnTimeout;
 
 	// If an I/O failed, but we know which one, abort.
-	if ( transaction )
-	{
+	if (transaction) {
 		*data = transaction->request_number;
 		return ReturnAbort;
 	}
-
 	// Unknown error occurred.
-	cout << "*** Error " << error_no << " occurred while getting queued "
-		<< "completion status." << endl;
+	cout << "*** Error " << error_no << " occurred while getting queued " << "completion status." << endl;
 	return ReturnError;
 }
 
-
-
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 BOOL CQAIO::SetQueueSize(int size)
 {
-    struct IOCQ *this_cqid = (struct IOCQ *)completion_queue;
+	struct IOCQ *this_cqid = (struct IOCQ *)completion_queue;
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-    this_cqid->element_list = (struct CQ_Element *)malloc(sizeof(CQ_Element) * size);
+	this_cqid->element_list = (struct CQ_Element *)malloc(sizeof(CQ_Element) * size);
 #elif defined(IOMTR_OS_NETWARE)
-    this_cqid->element_list = (struct CQ_Element *)NXMemAlloc(sizeof(CQ_Element) * size, 1);
+	this_cqid->element_list = (struct CQ_Element *)NXMemAlloc(sizeof(CQ_Element) * size, 1);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-    if (this_cqid->element_list == NULL)
-    {
-        cout << "memory allocation failed." << endl;
-        return(FALSE);
-    }
+	if (this_cqid->element_list == NULL) {
+		cout << "memory allocation failed." << endl;
+		return (FALSE);
+	}
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-    this_cqid->aiocb_list = (struct aiocb64 **)malloc(sizeof(struct aiocb64 *) * size);
+	this_cqid->aiocb_list = (struct aiocb64 **)malloc(sizeof(struct aiocb64 *) * size);
 #elif defined(IOMTR_OS_NETWARE)
-    this_cqid->aiocb_list = (struct aiocb64 **)NXMemAlloc(sizeof(struct aiocb64 *) * size, 1);
+	this_cqid->aiocb_list = (struct aiocb64 **)NXMemAlloc(sizeof(struct aiocb64 *) * size, 1);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-    if (this_cqid->aiocb_list == NULL)
-    {
-        cout << "memory allocation failed." << endl;
+	if (this_cqid->aiocb_list == NULL) {
+		cout << "memory allocation failed." << endl;
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-        free(this_cqid->element_list);
+		free(this_cqid->element_list);
 #elif defined(IOMTR_OS_NETWARE)
-        NXMemFree(this_cqid->element_list);
+		NXMemFree(this_cqid->element_list);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-		return(FALSE);
-    }
+		return (FALSE);
+	}
 
-    this_cqid->size = size;
-    memset(this_cqid->aiocb_list, 0, sizeof(struct aiocb64 *) * size);
+	this_cqid->size = size;
+	memset(this_cqid->aiocb_list, 0, sizeof(struct aiocb64 *) * size);
 	memset(this_cqid->element_list, 0, sizeof(struct CQ_Element) * size);
 
-    #ifdef _DEBUG
-    cout << "allocated a completion queue of size " << size << " for handle : "
-        << this_cqid << endl;
-    #endif
-    return(TRUE);
+#ifdef _DEBUG
+	cout << "allocated a completion queue of size " << size << " for handle : " << this_cqid << endl;
+#endif
+	return (TRUE);
 }
 #endif
-
-

Modified: branches/IOMETER-restruct/iometer/src/IOCQAIO.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCQAIO.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOCQAIO.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -7,7 +7,7 @@
 /* ##  Job .......: Interface for the class CQAIO, which provides a       ## */
 /* ##               Completion Queue for asynchronous access to           ## */
 /* ##               TargetDisk and TargetTCP objects. CQAIO is an         ## */
-/* ##               implementation of the abstract class CQ.              ## */ 
+/* ##               implementation of the abstract class CQ.              ## */
 /* ##                                                                     ## */
 /* ## ------------------------------------------------------------------- ## */
 /* ##                                                                     ## */
@@ -65,41 +65,29 @@
 #ifndef	CQAIO_DEFINED
 #define	CQAIO_DEFINED
 
-
-
 #include "IOCQ.h"
 
-
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // Completion queues used by asynchronous I/O targets.  This includes NT
 // and Solaris disk and TCP targets.
 // 
 ///////////////////////////////////////////////////////////////////////////////
-class CQAIO : public CQ
-{
-public:
+class CQAIO:public CQ {
+      public:
 
 	CQAIO();
 
 	///////////////////////////////////////////////////////////////////////////
 	// Attach asynchronous I/O objects with this completion queue.
 	//
-	ReturnVal	GetStatus( int *bytes, int *data, int delay );
+	ReturnVal GetStatus(int *bytes, int *data, int delay);
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	BOOL        SetQueueSize(int);
+	BOOL SetQueueSize(int);
 #endif
-	HANDLE		completion_queue;
+	HANDLE completion_queue;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
 };
 
-
-
-#endif // CQAIO_DEFINED
-
-
-
-
+#endif				// CQAIO_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/IOCQVI.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCQVI.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOCQVI.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,20 +64,16 @@
 #include "IOTargetVI.h"
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <iostream>
- using namespace std;
+#include <iostream>
+using namespace std;
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
- #include <iostream.h>
+#include <iostream.h>
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
+#define CQVI_DETAILS 0		// Set to 1 for additional debug messages.
 
-#define CQVI_DETAILS 0 // Set to 1 for additional debug messages.
-
-
-
-
 //
 // Initializing VI completion queue.
 //
@@ -87,36 +83,29 @@
 	vi_target = NULL;
 }
 
-
-
 //
 // Creating the CQ on the given VI NIC.
 //
-BOOL CQVI::Create( VINic *vi_nic, TargetVI *target )
+BOOL CQVI::Create(VINic * vi_nic, TargetVI * target)
 {
 	VIP_RETURN result;
-	#if CQVI_DETAILS
-		cout << "Creating VI CQ for VI NIC " 
-			<< vi_nic->nic_attributes.Name << endl;
-	#endif
 
+#if CQVI_DETAILS
+	cout << "Creating VI CQ for VI NIC " << vi_nic->nic_attributes.Name << endl;
+#endif
+
 	// Create a completion queue for the NIC.  The completion queue must be
 	// able to handle the specified number of oustanding I/Os.
-	if ( (result = vipl.VipCreateCQ( vi_nic->nic, target->outstanding_ios,
-		&completion_queue )) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to create VI completion queue: " << vipl.Error( result ) << endl;
+	if ((result = vipl.VipCreateCQ(vi_nic->nic, target->outstanding_ios, &completion_queue)) != VIP_SUCCESS) {
+		cout << "*** Unable to create VI completion queue: " << vipl.Error(result) << endl;
 		return FALSE;
 	}
-
 	// Record which target this completion is associated with.
 	vi_target = target;
 
 	return TRUE;
 }
 
-
-
 //
 // Destroying the CQ.
 // 
@@ -124,16 +113,15 @@
 {
 	VIP_RETURN result;
 
-	#if CQVI_DETAILS
-		cout << "Destroying VI CQ." << endl;
-	#endif
+#if CQVI_DETAILS
+	cout << "Destroying VI CQ." << endl;
+#endif
 
 	// Destroy the completion queue.
-	result = vipl.VipDestroyCQ( completion_queue );
+	result = vipl.VipDestroyCQ(completion_queue);
 
-	if ( result != VIP_SUCCESS )
-	{
-		cout << "*** Unable to VI completion queue: " << vipl.Error( result ) << endl; 
+	if (result != VIP_SUCCESS) {
+		cout << "*** Unable to VI completion queue: " << vipl.Error(result) << endl;
 		return FALSE;
 	}
 
@@ -142,72 +130,65 @@
 	return TRUE;
 }
 
-
-
 //
 // Getting and returning that status of any completed I/O calls.
 //
-ReturnVal CQVI::GetStatus( int *bytes, int *data, int delay )
+ReturnVal CQVI::GetStatus(int *bytes, int *data, int delay)
 {
-	VIP_VI_HANDLE	vi;
-	VIP_BOOLEAN		receive_done;
-	VIP_DESCRIPTOR	*descriptor;
-	VIP_RETURN		result;
+	VIP_VI_HANDLE vi;
+	VIP_BOOLEAN receive_done;
+	VIP_DESCRIPTOR *descriptor;
+	VIP_RETURN result;
 
-	#if CQVI_DETAILS
-		cout << "Checking VI completion queue." << endl;
-	#endif
+#if CQVI_DETAILS
+	cout << "Checking VI completion queue." << endl;
+#endif
 
 	// Verify that completion queue exists.  If not, it needs to be created
 	// and then it can be retried.  This happens when testing connection rate.
-	if ( !completion_queue )
+	if (!completion_queue)
 		return ReturnRetry;
 
 	// Check completion queue for completed I/Os.
-	if ( delay )
-		result = vipl.VipCQWait( completion_queue, delay, &vi, &receive_done );
+	if (delay)
+		result = vipl.VipCQWait(completion_queue, delay, &vi, &receive_done);
 	else
-		result = vipl.VipCQDone( completion_queue, &vi, &receive_done );
+		result = vipl.VipCQDone(completion_queue, &vi, &receive_done);
 
-	switch( result )
-	{
-	// An I/O has completed, process it.
+	switch (result) {
+		// An I/O has completed, process it.
 	case VIP_SUCCESS:
-		#if CQVI_DETAILS
-			cout << "   I/O has been posted to VI completion queue." << endl;
-		#endif
+#if CQVI_DETAILS
+		cout << "   I/O has been posted to VI completion queue." << endl;
+#endif
 
-		if ( receive_done == VIP_TRUE )
-		{
+		if (receive_done == VIP_TRUE) {
 			// Getting the completed receive.
-			if ( vipl.VipRecvDone( vi, &descriptor ) != VIP_SUCCESS )
-			{
+			if (vipl.VipRecvDone(vi, &descriptor) != VIP_SUCCESS) {
 				cout << "*** Unable to successfully complete receive." << endl;
 				return ReturnError;
 			}
-		}
-		else
-		{
+		} else {
 			// Getting the completed send.
-			if ( vipl.VipSendDone( vi, &descriptor ) != VIP_SUCCESS )
-			{
+			if (vipl.VipSendDone(vi, &descriptor) != VIP_SUCCESS) {
 				cout << "*** Unable to successfully complete send." << endl;
 				return ReturnError;
 			}
 		}
 		break;
 
-	// No I/O is done yet.
-	case VIP_NOT_DONE: case VIP_TIMEOUT:
-		#if CQVI_DETAILS
-			cout << "   no completions posted within the timeout period." << endl;
-		#endif
+		// No I/O is done yet.
+	case VIP_NOT_DONE:
+	case VIP_TIMEOUT:
+#if CQVI_DETAILS
+		cout << "   no completions posted within the timeout period." << endl;
+#endif
 		return ReturnTimeout;
 
 	default:
-		#if CQVI_DETAILS
-			cout << "   error checking completion queue: " << vipl.Error( result ) << endl;
-		#endif
+#if CQVI_DETAILS
+		cout << "   error checking completion queue: " << vipl.Error(result) << endl;
+#endif
 		return ReturnError;
 	}
 
@@ -216,17 +197,15 @@
 	*data = descriptor->CS.ImmediateData;
 
 	// See if the completion was for an I/O request or control data.
-	if ( *data != CONTROL_MESSAGE )
-	{
+	if (*data != CONTROL_MESSAGE) {
 		// It was for an I/O request.
-		#if CQVI_DETAILS
-			cout << "   completed " << (receive_done ? "receive":"send") 
-				<< " for transaction " << *data << endl;
-		#endif
+#if CQVI_DETAILS
+		cout << "   completed " << (receive_done ? "receive" : "send")
+		    << " for transaction " << *data << endl;
+#endif
 
 		// Perform additional processing on completed receives.
-		if ( receive_done == VIP_TRUE )
-		{
+		if (receive_done == VIP_TRUE) {
 			// Increment the number of available receives.
 			vi_target->available_receives++;
 
@@ -236,29 +215,27 @@
 			// because the receives are pre-posted.)  In this case, signal a
 			// retry to indicate that the I/O should not be processed as
 			// complete until after it's been requested.
-			if ( vi_target->requested_receives-- <= 0 )
-			{
-				#if CQVI_DETAILS
-					cout << "   receive has not been requested yet." << endl;
-				#endif
+			if (vi_target->requested_receives-- <= 0) {
+#if CQVI_DETAILS
+				cout << "   receive has not been requested yet." << endl;
+#endif
 				return ReturnRetry;
 			}
 		}
 
 		return ReturnSuccess;
 	}
-
 	//
 	// Message contains information needed to maintain pre-posting receive
 	// requirements.  Intercept these and update the VI connection management
 	// information.
 	//
-	#if CQVI_DETAILS
-		cout << "   completion is for maintaining flow control." << endl;
-	#endif
+#if CQVI_DETAILS
+	cout << "   completion is for maintaining flow control." << endl;
+#endif
 
 	// If we received a control message, update that more sends are available.
-	if ( receive_done != VIP_FALSE )
+	if (receive_done != VIP_FALSE)
 		vi_target->more_sends_available = TRUE;
 
 	// Return that no data messages completed, but we may not have waited

Modified: branches/IOMETER-restruct/iometer/src/IOCQVI.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCQVI.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOCQVI.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,15 +61,11 @@
 #ifndef	CQVI_DEFINED
 #define	CQVI_DEFINED
 
-
-
 #include "IOCQ.h"
 #include "VINic.h"
 
-class TargetVI;		// forward declaration
+class TargetVI;			// forward declaration
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // Completion queues used by VI targets.  Note that although a VI completion 
 // queue can be used by multiple VI connections, it can only be associated 
@@ -79,36 +75,33 @@
 // this class.
 //
 ///////////////////////////////////////////////////////////////////////////////
-class CQVI : public CQ
-{
-public:
+class CQVI:public CQ {
+      public:
 
 	CQVI();
-	virtual ~CQVI() {}
+	virtual ~ CQVI() {
+	}
+	///////////////////////////////////////////////////////////////////////////// Each completion queue is directly associated with a single VI NIC.
+	    BOOL Create(VINic * vi_nic, TargetVI * target);
+	BOOL Destroy();
 
-	///////////////////////////////////////////////////////////////////////////
-	// Each completion queue is directly associated with a single VI NIC.
-	BOOL		Create( VINic *vi_nic, TargetVI *target );
-	BOOL		Destroy();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Attach VI connections with this completion queue.
-	ReturnVal		GetStatus( int *bytes, int *data, int delay );
-	VIP_CQ_HANDLE	completion_queue;
+	ReturnVal GetStatus(int *bytes, int *data, int delay);
+	VIP_CQ_HANDLE completion_queue;
+
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-private:
+      private:
 
 	// Pointer to data use to manage and maintain the VI connection.
-	TargetVI	*vi_target;
+	TargetVI * vi_target;
 
-	VIPL	vipl;
+	VIPL vipl;
 };
 
-
-
-#endif // CQVI_DEFINED
+#endif				// CQVI_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/IOCommon.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -155,8 +155,6 @@
 #ifndef	___IOCOMMON_H_DEFINED___
 #define ___IOCOMMON_H_DEFINED___
 
-
-
 // Check and map the different global defines for Operating
 // System family, Operating System and CPU (see README).
 // ----------------------------------------------------------------------------
@@ -165,8 +163,8 @@
     (!defined(IOMTR_OSFAMILY_NETWARE) &&  defined(IOMTR_OSFAMILY_UNIX) && !defined(IOMTR_OSFAMILY_WINDOWS)) || \
     (!defined(IOMTR_OSFAMILY_NETWARE) && !defined(IOMTR_OSFAMILY_UNIX) &&  defined(IOMTR_OSFAMILY_WINDOWS))
  // nop
-#else    
- #error ===> ERROR: Check the Operating System to Operating System family mapping!
+#else
+#error ===> ERROR: Check the Operating System to Operating System family mapping!
 #endif
 // ----------------------------------------------------------------------------
 // Check the Operating System mapping
@@ -177,8 +175,8 @@
     (!defined(IOMTR_OS_LINUX) && !defined(IOMTR_OS_NETWARE) && !defined(IOMTR_OS_OSX) && !defined(IOMTR_OS_SOLARIS) &&  defined(IOMTR_OS_WIN32) && !defined(IOMTR_OS_WIN64)) || \
     (!defined(IOMTR_OS_LINUX) && !defined(IOMTR_OS_NETWARE) && !defined(IOMTR_OS_OSX) && !defined(IOMTR_OS_SOLARIS) && !defined(IOMTR_OS_WIN32) &&  defined(IOMTR_OS_WIN64))
  // nop
-#else    
- #error ===> ERROR: You have to define exactly one IOMTR_OS_* global define!
+#else
+#error ===> ERROR: You have to define exactly one IOMTR_OS_* global define!
 #endif
 // ----------------------------------------------------------------------------
 // Check the Processor mapping
@@ -191,31 +189,29 @@
     (!defined(IOMTR_CPU_ALPHA) && !defined(IOMTR_CPU_I386) && !defined(IOMTR_CPU_IA64) && !defined(IOMTR_CPU_MIPS) && !defined(IOMTR_CPU_PPC) && !defined(IOMTR_CPU_SPARC) &&  defined(IOMTR_CPU_X86_64) && !defined(IOMTR_CPU_XSCALE)) || \
     (!defined(IOMTR_CPU_ALPHA) && !defined(IOMTR_CPU_I386) && !defined(IOMTR_CPU_IA64) && !defined(IOMTR_CPU_MIPS) && !defined(IOMTR_CPU_PPC) && !defined(IOMTR_CPU_SPARC) && !defined(IOMTR_CPU_X86_64) &&  defined(IOMTR_CPU_XSCALE))
  // nop
-#else    
- #error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
+#else
+#error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
 #endif
 // ----------------------------------------------------------------------------
 
-
-
 // Include the different header files
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
-#if defined(IOMTR_OSFAMILY_WINDOWS)   // Only first, because it is needed here!
- #define VC_EXTRALEAN
- #pragma warning (disable: 4242)
- #include <process.h>
- #include <io.h>
- #include <direct.h>
- #include <afxwin.h>
- #include <afxext.h>
- #include <afxcmn.h>
- #include <winioctl.h>
- #include <iomanip>
- #include <winperf.h>
- #include <winreg.h>
- #include <afxmt.h>
- #include <malloc.h>
+#if defined(IOMTR_OSFAMILY_WINDOWS)	// Only first, because it is needed here!
+#define VC_EXTRALEAN
+#pragma warning (disable: 4242)
+#include <process.h>
+#include <io.h>
+#include <direct.h>
+#include <afxwin.h>
+#include <afxext.h>
+#include <afxcmn.h>
+#include <winioctl.h>
+#include <iomanip>
+#include <winperf.h>
+#include <winreg.h>
+#include <afxmt.h>
+#include <malloc.h>
 #endif
 // ----------------------------------------------------------------------------
 #include <stdio.h>
@@ -232,193 +228,192 @@
 #include <iostream>
 #include <fstream>
 using namespace std;
+
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE)
- #include <sys/timeval.h>
- #include <sys/time.h>
- #include <sys/socket.h>
- #include <unistd.h>
- #include <signal.h>
- #include <netinet/in.h>   // in_addr_t
- #include <nks/memory.h>
- #include <nks/fsio.h>
- #include <pthread.h>
- #include <mmpublic.h>
- #include <malloc.h>
+#include <sys/timeval.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <signal.h>
+#include <netinet/in.h>		// in_addr_t
+#include <nks/memory.h>
+#include <nks/fsio.h>
+#include <pthread.h>
+#include <mmpublic.h>
+#include <malloc.h>
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX)
- #include <sys/timeb.h>
- #include <unistd.h>
- #include <pthread.h>
- #include <signal.h>
- #include <netinet/in.h>   // in_addr_t
+#include <sys/timeb.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <signal.h>
+#include <netinet/in.h>		// in_addr_t
 
- #if defined(IOMTR_OS_OSX)
-  #include <sys/aio.h>
- #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-  #include <malloc.h>
-  #include <aio.h>
- #else
-  #error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
- #endif
+#if defined(IOMTR_OS_OSX)
+#include <sys/aio.h>
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+#include <malloc.h>
+#include <aio.h>
+#else
+#error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
+#endif
 
- #if defined(IOMTR_OS_LINUX)
-  #include <sys/ioctl.h>
- #endif
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-  #include <syslog.h>
- #endif
+#if defined(IOMTR_OS_LINUX)
+#include <sys/ioctl.h>
 #endif
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
+#include <syslog.h>
+#endif
+#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_WINDOWS)
- #include <sys/timeb.h>
- #if (_MSC_VER < 1300) || defined(USING_DDK)
-  #include "ostream64.h"
- #endif
+#include <sys/timeb.h>
+#if (_MSC_VER < 1300) || defined(USING_DDK)
+#include "ostream64.h"
 #endif
+#endif
 // ----------------------------------------------------------------------------
-#include "IOVersion.h"   // version info definitions
+#include "IOVersion.h"		// version info definitions
 // ----------------------------------------------------------------------------
 
-
-
-
 // Define the different data types
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- #define __int64   long long
- #define __int32   long
- #define __int16   short
- #define __int8    char
+#define __int64   long long
+#define __int32   long
+#define __int16   short
+#define __int8    char
 
- #if defined(IOMTR_SETTING_GCC_M64)
+#if defined(IOMTR_SETTING_GCC_M64)
   // in the gcc on x86_64 environment long is 64 bits
-  #undef __int32
-  #define __int32 int
- #endif
+#undef __int32
+#define __int32 int
+#endif
 
- typedef long long	       _int64;
- //typedef long long	       LARGE_INTEGER; 
- typedef unsigned long long    DWORDLONG;
+typedef long long _int64;
 
- #if defined(IOMTR_OSFAMILY_NETWARE)
-  #ifndef LONG
-   #define LONG	unsigned long
-  #endif
-  #ifndef WORD
-   #define WORD	unsigned short
-  #endif
- #elif defined(IOMTR_OSFAMILY_UNIX)
+ //typedef long long           LARGE_INTEGER; 
+typedef unsigned long long DWORDLONG;
+
+#if defined(IOMTR_OSFAMILY_NETWARE)
+#ifndef LONG
+#define LONG	unsigned long
+#endif
+#ifndef WORD
+#define WORD	unsigned short
+#endif
+#elif defined(IOMTR_OSFAMILY_UNIX)
   // This is OK for x86-64 processors because LONG is only used in Netware or
   // in MeterCtrl.cpp.or safely internally in IOTargetDisk.cpp.
   // It could cause problems because in the x86-64 environment long is 64 bits.
-  typedef long		       LONG;
-  #if defined(IOMTR_OS_OSX)
-   #define off64_t	off_t  
-  #endif 
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif
- 
- #if defined(IOMTR_SETTING_GCC_M64)
+typedef long LONG;
+
+#if defined(IOMTR_OS_OSX)
+#define off64_t	off_t
+#endif
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
+
+#if defined(IOMTR_SETTING_GCC_M64)
   // DWORD is supposed to be an unsigned 32 bit number.
-  typedef unsigned int	       DWORD;
- #else
-  typedef unsigned long	       DWORD;
- #endif
- 
- typedef int		       INT;
- typedef int		       BOOL;
- typedef int		       BOOLEAN;
- typedef unsigned int	       UINT;
- typedef unsigned int	      *PUINT;
+typedef unsigned int DWORD;
+#else
+typedef unsigned long DWORD;
+#endif
 
- typedef unsigned short	       WCHAR;
- typedef unsigned short	      *LPWSTR;
+typedef int INT;
+typedef int BOOL;
+typedef int BOOLEAN;
+typedef unsigned int UINT;
+typedef unsigned int *PUINT;
 
- typedef char		      *LPSTR;
- typedef unsigned char	       BYTE;
- typedef const char	      *LPCSTR;
+typedef unsigned short WCHAR;
+typedef unsigned short *LPWSTR;
 
- typedef void		      *HANDLE;
- typedef void		      *LPVOID;
+typedef char *LPSTR;
+typedef unsigned char BYTE;
+typedef const char *LPCSTR;
 
+typedef void *HANDLE;
+typedef void *LPVOID;
+
  //  The places in the Iometer code that now use CONNECTION used to use
  //  SOCKET. But SOCKET is a defined type in winsock2.h used for network
  //  access. Iometer defined a type called SOCKET used in NetTCP.cpp but 
  //  the original winsock SOCKET was used in IOPortTCP.cpp. Defining
  //  a new CONNECTION type allows me to separate the two different concepts
  //  cleanly.
- typedef void                 *CONNECTION;
- 
- typedef int		       SOCKET;
- typedef const void	      *LPCVOID;
+typedef void *CONNECTION;
 
- typedef DWORD		      *LPDWORD;
- typedef BYTE		      *LPBYTE;
- typedef LPCSTR		       LPCTSTR;
+typedef int SOCKET;
+typedef const void *LPCVOID;
 
- typedef unsigned long         ULONG_PTR, *PULONG_PTR;
- typedef ULONG_PTR             DWORD_PTR;
-#endif 
+typedef DWORD *LPDWORD;
+typedef BYTE *LPBYTE;
+typedef LPCSTR LPCTSTR;
+
+typedef unsigned long ULONG_PTR, *PULONG_PTR;
+typedef ULONG_PTR DWORD_PTR;
+#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_WINDOWS)
- #ifndef USING_DDK
-  #if defined(IOMTR_OS_WIN32)
+#ifndef USING_DDK
+#if defined(IOMTR_OS_WIN32)
    // dps: Was __int32 in before, but conflicts while conversion
    //      from unsigned __int32 to unsigned long for instance
    //      (using Microsoft Visual C++).
-   typedef long LONG_PTR, *PLONG_PTR;
-   typedef unsigned long  ULONG_PTR, *PULONG_PTR;
-   typedef ULONG_PTR      DWORD_PTR;
-  #endif
-  #if defined(IOMTR_OS_WIN64)
-   typedef __int64 LONG_PTR, *PLONG_PTR;
-   typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
-   typedef ULONG_PTR        DWORD_PTR;
-  #endif
- #endif // USING_DDK
+typedef long LONG_PTR, *PLONG_PTR;
+typedef unsigned long ULONG_PTR, *PULONG_PTR;
+typedef ULONG_PTR DWORD_PTR;
+#endif
+#if defined(IOMTR_OS_WIN64)
+typedef __int64 LONG_PTR, *PLONG_PTR;
+typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
+typedef ULONG_PTR DWORD_PTR;
+#endif
+#endif				// USING_DDK
  //  The places in the Iometer code that now use CONNECTION used to use
  //  SOCKET. But SOCKET is a defined type in winsock2.h used for network
  //  access. Iometer defined a type called SOCKET used in NetTCP.cpp but 
  //  the original winsock SOCKET was used in IOPortTCP.cpp. Defining
  //  a new CONNECTION type allows me to separate the two different concepts
  //  cleanly.
- typedef ULONG_PTR CONNECTION;
-#endif 
+typedef ULONG_PTR CONNECTION;
+#endif
 // ----------------------------------------------------------------------------
 
 // Because of some of the memory over writing issues in the 64 bit environment
 // and the typing required by the windows environment, variables need to be cast
 // differently depending on OSFAMILY. this gets the job done... 
 #if defined(IOMTR_OSFAMILY_WINDOWS)
- #define IOMTR_MACRO_INTERLOCK_CAST(a) (long *)
+#define IOMTR_MACRO_INTERLOCK_CAST(a) (long *)
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
- #define IOMTR_MACRO_INTERLOCK_CAST(a) (a *)
+#define IOMTR_MACRO_INTERLOCK_CAST(a) (a *)
 #else
- #error ===> ERROR: You have to do some coding here to get the port done!
+#error ===> ERROR: You have to do some coding here to get the port done!
 #endif
 
 // ----------------------------------------------------------------------------
 
-
 // Definition of the defines itself
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 // Different return values for the Iometer and Dynamo function calls.
-#define IOERROR	-1   // keep negative
+#define IOERROR	-1		// keep negative
 
-#define RETRY_DELAY   200    // msec. to wait before reattempting an action
-#define LONG_DELAY    3000   // msec. to wait before reattempting an action
-#define IDLE_DELAY    1000   // max msec to wait between calls to CGalileoApp::OnIdle()
+#define RETRY_DELAY   200	// msec. to wait before reattempting an action
+#define LONG_DELAY    3000	// msec. to wait before reattempting an action
+#define IDLE_DELAY    1000	// max msec to wait between calls to CGalileoApp::OnIdle()
 
 #define KILOBYTE   1024
 #define MEGABYTE   1048576
 
-#define MAX_NAME	      80   // xca1019: Was 64 - changed according to
-                                   // the Solaris 2.6 man page for swapctl(2)
+#define MAX_NAME	      80	// xca1019: Was 64 - changed according to
+				   // the Solaris 2.6 man page for swapctl(2)
 #define	MAX_CPUS	      32
 #define	MAX_WORKERS	      100
 #define MAX_TARGETS	      512
@@ -445,22 +440,22 @@
 #define CPU_IRQ			     5
 
 // Definitions for network tcp results
-#define TCP_RESULTS           1   // total number of network results
+#define TCP_RESULTS           1	// total number of network results
 // List all specific performance results that are desired.
 #define TCP_SEGMENTS_RESENT   0
 
 // Definitions for network interface results
-#define NI_RESULTS	     3   // total number of network interface results reported
-#define NI_COMBINE_RESULTS   2   // combine some reported results together
+#define NI_RESULTS	     3	// total number of network interface results reported
+#define NI_COMBINE_RESULTS   2	// combine some reported results together
 // List all specific performance results that are desired.
 #define NI_PACKETS	     0
 #define NI_OUT_ERRORS	     1
 #define NI_IN_ERRORS	     2
-#define NI_ERRORS	     1   // combine in and out errors together when saving
+#define NI_ERRORS	     1	// combine in and out errors together when saving
 
 // Initialization parameters for CArray and related classes.
-#define INITIAL_ARRAY_SIZE   0    // Sets the size of the array.
-#define ARRAY_GROW_STEP	     10   // Sets the amount of memory to allocate when the array is grown.
+#define INITIAL_ARRAY_SIZE   0	// Sets the size of the array.
+#define ARRAY_GROW_STEP	     10	// Sets the amount of memory to allocate when the array is grown.
 
 // To record performance statistics, two snapshots of specific counters are needed.
 #define FIRST_SNAPSHOT	 0
@@ -479,65 +474,65 @@
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
  //param does not contain a valid internet address
  // (For Win32 || _WIN64, INADDR_NONE is defined as 0xffffffff)
- #ifndef INADDR_NONE
-  #define INADDR_NONE   (in_addr_t)-1
- #endif
+#ifndef INADDR_NONE
+#define INADDR_NONE   (in_addr_t)-1
+#endif
 
  // Needed to get the CDECL stuff thru (under non Windows platforms)
- #define CDECL
+#define CDECL
 
- #define FALSE			0
- #define TRUE			1
- #define INVALID_HANDLE_VALUE   (HANDLE)-1
- #define INVALID_SOCKET		(~0L)
- #define PERF_NO_INSTANCES	-1
- #define SOCKET_ERROR		-1
- #define SD_BOTH		2
- #define INFINITE		(unsigned)~0
- #define ERROR_IO_PENDING	501
- #define WAIT_TIMEOUT		ERROR_IO_PENDING
- #define ERROR_IO_INCOMPLETE	ERROR_IO_PENDING
+#define FALSE			0
+#define TRUE			1
+#define INVALID_HANDLE_VALUE   (HANDLE)-1
+#define INVALID_SOCKET		(~0L)
+#define PERF_NO_INSTANCES	-1
+#define SOCKET_ERROR		-1
+#define SD_BOTH		2
+#define INFINITE		(unsigned)~0
+#define ERROR_IO_PENDING	501
+#define WAIT_TIMEOUT		ERROR_IO_PENDING
+#define ERROR_IO_INCOMPLETE	ERROR_IO_PENDING
 
- #define FILE_ELEMENT		1
- #define CQ_ELEMENT		0
+#define FILE_ELEMENT		1
+#define CQ_ELEMENT		0
 
- #if defined(IOMTR_OSFAMILY_NETWARE)
-  #define SIGEV_NONE		0
-  #define AIO_NOTCANCELED	1
- #endif
+#if defined(IOMTR_OSFAMILY_NETWARE)
+#define SIGEV_NONE		0
+#define AIO_NOTCANCELED	1
+#endif
 
- #if defined(IOMTR_OS_LINUX)
+#if defined(IOMTR_OS_LINUX)
   // different Linux kernel has different /proc/stat style.
   // Currently we only support vanilla 2.4 and 2.6 alike
-  #define PROCSTATUNKNOWN	0x00
-  #define PROCSTAT24STYLE	0x01
-  #define PROCSTAT26STYLE	0x02
- #endif
+#define PROCSTATUNKNOWN	0x00
+#define PROCSTAT24STYLE	0x01
+#define PROCSTAT26STYLE	0x02
 #endif
+#endif
 // ----------------------------------------------------------------------------
 
-
-
 // Define the enumerations, structures etc.
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 enum ReturnVal {
-	ReturnError   = IOERROR,   // catch all unexpected errors
-	ReturnSuccess = 0,	   // Normal completion
-	ReturnTimeout,		   // Operation timed out
-	ReturnPending,		   // Request has been queued
-	ReturnAbort,		   // Operation aborted
-	ReturnRetry	   	   // Operation was interrupted and can be retried
+	ReturnError = IOERROR,	// catch all unexpected errors
+	ReturnSuccess = 0,	// Normal completion
+	ReturnTimeout,		// Operation timed out
+	ReturnPending,		// Request has been queued
+	ReturnAbort,		// Operation aborted
+	ReturnRetry		// Operation was interrupted and can be retried
 };
+
 // Testing states that Iometer and worker threads go through
 enum TestState {
-	TestIdle,	  // before Start_Test() and after Stop_Test()
+	TestIdle,		// before Start_Test() and after Stop_Test()
 	TestPreparing,
-	TestOpening,	  // after Start_Test()
-	TestRampingUp,	  // after Begin_IO()
-	TestRecording,	  // after Record_On()
-	TestRampingDown	  // after Record_Off()
+	TestOpening,		// after Start_Test()
+	TestRampingUp,		// after Begin_IO()
+	TestRecording,		// after Record_On()
+	TestRampingDown		// after Record_Off()
 };
+
 // Specified on the Test Setup tab: which test results to record.
 // (In IOCommon.h because Dynamo uses these as parameters.)
 enum {
@@ -547,126 +542,127 @@
 	RecordNoManagers,
 	RecordNone
 };
+
 // ----------------------------------------------------------------------------
-struct Manager_Info
-{
-	char	       version[MAX_VERSION_LENGTH];
-	char	       names[2][MAX_NETWORK_NAME];
-	unsigned short port_number;   // used only with TCP/IP.
-#if defined(IOMTR_OSFAMILY_NETWARE)	
+struct Manager_Info {
+	char version[MAX_VERSION_LENGTH];
+	char names[2][MAX_NETWORK_NAME];
+	unsigned short port_number;	// used only with TCP/IP.
+#if defined(IOMTR_OSFAMILY_NETWARE)
 	char pad[2];
-#endif	
-	int	       	   processors;
-	double	       processor_speed;
+#endif
+	int processors;
+	double processor_speed;
 };
+
 // Basic result information stored by worker threads.
-struct Raw_Result
-{
-	DWORDLONG    bytes_read;   	       // Number of bytes transferred.
-	DWORDLONG    bytes_written;
-	DWORDLONG    read_count;	       // Number of I/Os completed.
-	DWORDLONG    write_count;
-	DWORDLONG    transaction_count;	       // Number of transactions completed.
-	DWORDLONG    connection_count;
-	unsigned int read_errors;	       // Number of errors seen.
+struct Raw_Result {
+	DWORDLONG bytes_read;	// Number of bytes transferred.
+	DWORDLONG bytes_written;
+	DWORDLONG read_count;	// Number of I/Os completed.
+	DWORDLONG write_count;
+	DWORDLONG transaction_count;	// Number of transactions completed.
+	DWORDLONG connection_count;
+	unsigned int read_errors;	// Number of errors seen.
 	unsigned int write_errors;
-	DWORDLONG    max_raw_read_latency;     // Application latencies for an I/O to complete, recorded
-	DWORDLONG    read_latency_sum;	       // using the processor counter clock.
-	DWORDLONG    max_raw_write_latency;
-	DWORDLONG    write_latency_sum;
-	DWORDLONG    max_raw_transaction_latency;
-	DWORDLONG    max_raw_connection_latency;
-	DWORDLONG    transaction_latency_sum;
-	DWORDLONG    connection_latency_sum;   // Application latencies for a Connection.
-	__int64	     counter_time;	       // Difference between ending and starting counter time stamps.
+	DWORDLONG max_raw_read_latency;	// Application latencies for an I/O to complete, recorded
+	DWORDLONG read_latency_sum;	// using the processor counter clock.
+	DWORDLONG max_raw_write_latency;
+	DWORDLONG write_latency_sum;
+	DWORDLONG max_raw_transaction_latency;
+	DWORDLONG max_raw_connection_latency;
+	DWORDLONG transaction_latency_sum;
+	DWORDLONG connection_latency_sum;	// Application latencies for a Connection.
+	__int64 counter_time;	// Difference between ending and starting counter time stamps.
 };
+
 // Storing results for all targets in a single structure.
-struct Target_Results
-{
-	int	   count;    // Number of targets.
-	char	   pad[4];   // padding
+struct Target_Results {
+	int count;		// Number of targets.
+	char pad[4];		// padding
 	Raw_Result result[MAX_TARGETS];
 };
+
 // Storing results for a worker.  This includes the worker's target results.
-struct Worker_Results
-{
-	DWORDLONG      time[MAX_SNAPSHOTS];   // Processor based counters to provide time stamps.
+struct Worker_Results {
+	DWORDLONG time[MAX_SNAPSHOTS];	// Processor based counters to provide time stamps.
 	Target_Results target_results;
 };
+
 // All CPU related results are stored in a single structure.
-struct CPU_Results
-{
-	int    count;	 // Number of processors.
-	char   pad[4];   // padding
+struct CPU_Results {
+	int count;		// Number of processors.
+	char pad[4];		// padding
 	double CPU_utilization[MAX_CPUS][CPU_RESULTS];
 };
+
 // All network related results are stored in a single structure.
-struct Net_Results
-{
+struct Net_Results {
 	double tcp_stats[TCP_RESULTS];
-	int    ni_count;   // Number of NICs.
-	char   pad[4];     // padding
+	int ni_count;		// Number of NICs.
+	char pad[4];		// padding
 	double ni_stats[MAX_NUM_INTERFACES][NI_RESULTS];
 };
+
 // Results SPECIFIC to a single system.  This is NOT compiled system results.
-struct Manager_Results
-{
-	__int64	    time_counter[MAX_SNAPSHOTS];
+struct Manager_Results {
+	__int64 time_counter[MAX_SNAPSHOTS];
 	CPU_Results cpu_results;
 	Net_Results net_results;
 };
+
 // Result structure used by the manager list, managers, and workers to store
 // results that will be saved.
-struct Results
-{
-	Raw_Result   raw;
-	double	     IOps;
-	double	     read_IOps;
-	double	     write_IOps;
-	double	     MBps;
-	double	     read_MBps;
-	double	     write_MBps;
-	double	     ave_latency;
-	double	     max_latency;
-	double	     ave_read_latency;
-	double	     max_read_latency;
-	double	     ave_write_latency;
-	double	     max_write_latency;
-	double	     transactions_per_second;
-	double	     ave_transaction_latency;
-	double	     max_transaction_latency;
+struct Results {
+	Raw_Result raw;
+	double IOps;
+	double read_IOps;
+	double write_IOps;
+	double MBps;
+	double read_MBps;
+	double write_MBps;
+	double ave_latency;
+	double max_latency;
+	double ave_read_latency;
+	double max_read_latency;
+	double ave_write_latency;
+	double max_write_latency;
+	double transactions_per_second;
+	double ave_transaction_latency;
+	double max_transaction_latency;
 	unsigned int total_errors;
-	double	     CPU_utilization[CPU_RESULTS];
-	double	     CPU_effectiveness;
-	double	     individual_CPU_utilization[MAX_CPUS][CPU_RESULTS];
-	double	     tcp_statistics[TCP_RESULTS];
-	double	     ni_statistics[NI_COMBINE_RESULTS];
-	double	     connections_per_second;
-	double	     ave_connection_latency;
-	double	     max_connection_latency;
+	double CPU_utilization[CPU_RESULTS];
+	double CPU_effectiveness;
+	double individual_CPU_utilization[MAX_CPUS][CPU_RESULTS];
+	double tcp_statistics[TCP_RESULTS];
+	double ni_statistics[NI_COMBINE_RESULTS];
+	double connections_per_second;
+	double ave_connection_latency;
+	double max_connection_latency;
 };
+
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
  // This LPOVERLAPPED typedef is from WINBASE.H
- #if defined(IOMTR_OSFAMILY_NETWARE)
- struct  aiocb64 {
- 	int		aio_fildes;
- 	void		*aio_buf;
- 	size_t		aio_nbytes;
- 	off_t		aio_offset;
- 	int		aio_flag;
- 	int		error;
- 	int		returnval;
+#if defined(IOMTR_OSFAMILY_NETWARE)
+struct aiocb64 {
+	int aio_fildes;
+	void *aio_buf;
+	size_t aio_nbytes;
+	off_t aio_offset;
+	int aio_flag;
+	int error;
+	int returnval;
 #if defined(IOMTR_SETTING_GCC_M64)
- 	unsigned int	completion_key;
+	unsigned int completion_key;
 #else
- 	unsigned long	completion_key;
+	unsigned long completion_key;
 #endif
- 	struct {
- 		int sigev_notify;
- 		}	aio_sigevent;
-	};
- struct timeb {
+	struct {
+		int sigev_notify;
+	} aio_sigevent;
+};
+struct timeb {
 #if defined(IOMTR_SETTING_GCC_M64)
 	int time;
 #else
@@ -675,304 +671,299 @@
 	unsigned short millitm;
 	short timezone;
 	short dstflag;
-	};
- #endif
- typedef struct _OVERLAPPED {   
-	DWORD  Internal;
-       	DWORD  InternalHigh;
-	DWORD  Offset;
-	DWORD  OffsetHigh;
+};
+#endif
+typedef struct _OVERLAPPED {
+	DWORD Internal;
+	DWORD InternalHigh;
+	DWORD Offset;
+	DWORD OffsetHigh;
 	HANDLE hEvent;
- } OVERLAPPED, *LPOVERLAPPED;
- typedef struct _LARGE_INTEGER {
+} OVERLAPPED, *LPOVERLAPPED;
+typedef struct _LARGE_INTEGER {
 	long LowPart;
 	long HighPart;
- } LARGE_INTEGER;
- struct CQ_Element {
-	struct  aiocb64 aiocbp;
-	void   *data;
-	int	done;
-	int	error;
-	int	completion_key;
+} LARGE_INTEGER;
+struct CQ_Element {
+	struct aiocb64 aiocbp;
+	void *data;
+	int done;
+	int error;
+	int completion_key;
 #if defined(IOMTR_SETTING_GCC_M64)
-	long	bytes_transferred;
+	long bytes_transferred;
 #else
-	int	bytes_transferred;
+	int bytes_transferred;
 #endif
- };
- struct IOCQ {
-	CQ_Element      *element_list;
+};
+struct IOCQ {
+	CQ_Element *element_list;
 	struct aiocb64 **aiocb_list;
-	int	         size;
-	int	         last_freed;
-	int	         position;
- };
- struct File {
-	int   fd;
-	int   completion_key;
+	int size;
+	int last_freed;
+	int position;
+};
+struct File {
+	int fd;
+	int completion_key;
 	IOCQ *iocq;
- #if defined(IOMTR_OSFAMILY_NETWARE)
+#if defined(IOMTR_OSFAMILY_NETWARE)
 	int type;
- #endif
- };
-#endif 
+#endif
+};
+#endif
 // ----------------------------------------------------------------------------
 
-
-
 // Define the global variables
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
-const char NEW_WORKER_COMMAND[]    = "start /MIN ";
+const char NEW_WORKER_COMMAND[] = "start /MIN ";
 const char NEW_WORKER_EXECUTABLE[] = "dynamo";
+
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
- extern pthread_mutex_t lock_mt;   // we use one global locking mutex
+extern pthread_mutex_t lock_mt;	// we use one global locking mutex
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_CPU_SPARC) || defined(IOMTR_CPU_PPC)
- extern double processor_speed_to_nsecs;
+extern double processor_speed_to_nsecs;
 #endif
 // ----------------------------------------------------------------------------
 
-
-
 // Define the different function prototypes and macros for
 // global functions - including the Strip() and IsBigEndian()
 // function (both, OS family based and common)
 // ----------------------------------------------------------------------------
-extern void GetAppFileVersionString( char **ppStrStandard, char **ppStrWithDebug );
+extern void GetAppFileVersionString(char **ppStrStandard, char **ppStrWithDebug);
 
 inline void rotate(char *ptr, int size);
-template <class T> inline void reorder(T&);
-inline void reorder(CPU_Results&, int);
-inline void reorder(Net_Results&, int);
-inline void reorder(Raw_Result&);
+template < class T > inline void reorder(T &);
+inline void reorder(CPU_Results &, int);
+inline void reorder(Net_Results &, int);
+inline void reorder(Raw_Result &);
 
-inline char *Strip( char *pcString )
+inline char *Strip(char *pcString)
 {
- unsigned int uiLength = strlen(pcString);
- int          I;
- int          iIndex = 0;
- int          iPos1, iPos2; 
- 
- for( iPos1 = 0;            ( (iPos1<(int)uiLength) && (pcString[iPos1]==(int)' ') ); iPos1++ ) { /* NOP */ }
- for( iPos2 = uiLength - 1; ( (iPos2>=0)            && (pcString[iPos2]==(int)' ') ); iPos2-- ) { /* NOP */ }
- 
- if( (iPos1 != 0) || (iPos2 != ((int)uiLength - 1)) )
- {    
-  for( I = iPos1; I <= iPos2; I++ )
-  {
-   pcString[iIndex] = pcString[I];
-   iIndex++;
-  }
-  pcString[iIndex] = '\0';
- }
- 
- return(pcString);
+	unsigned int uiLength = strlen(pcString);
+	int I;
+	int iIndex = 0;
+	int iPos1, iPos2;
+
+	for (iPos1 = 0; ((iPos1 < (int)uiLength) && (pcString[iPos1] == (int)' ')); iPos1++) {	/* NOP */
+	}
+	for (iPos2 = uiLength - 1; ((iPos2 >= 0) && (pcString[iPos2] == (int)' ')); iPos2--) {	/* NOP */
+	}
+
+	if ((iPos1 != 0) || (iPos2 != ((int)uiLength - 1))) {
+		for (I = iPos1; I <= iPos2; I++) {
+			pcString[iIndex] = pcString[I];
+			iIndex++;
+		}
+		pcString[iIndex] = '\0';
+	}
+
+	return (pcString);
 }
 
-inline int IsBigEndian( void )
+inline int IsBigEndian(void)
 {
- union EndianUnion
- {
-  struct EndianStruct
-  {
-   unsigned ubBit1 :1;
-   unsigned ubBit2 :1;
-   unsigned ubBit3 :1;
-   unsigned ubBit4 :1;
-   unsigned ubBit5 :1;
-   unsigned ubBit6 :1;
-   unsigned ubBit7 :1;
-   unsigned ubBit8 :1;
-   unsigned ubBitN :8;
-  } sStruct;
-  unsigned char ucNumber;
- } sUnion;
- sUnion.sStruct.ubBit1 = 0;
- sUnion.sStruct.ubBit2 = 0;
- sUnion.sStruct.ubBit3 = 0;
- sUnion.sStruct.ubBit4 = 0;
- sUnion.sStruct.ubBit5 = 0;
- sUnion.sStruct.ubBit6 = 0;
- sUnion.sStruct.ubBit7 = 0;
- sUnion.sStruct.ubBit8 = 0;
- sUnion.sStruct.ubBitN = 0;
- sUnion.ucNumber       = 5;
+	union EndianUnion {
+		struct EndianStruct {
+			unsigned ubBit1:1;
+			unsigned ubBit2:1;
+			unsigned ubBit3:1;
+			unsigned ubBit4:1;
+			unsigned ubBit5:1;
+			unsigned ubBit6:1;
+			unsigned ubBit7:1;
+			unsigned ubBit8:1;
+			unsigned ubBitN:8;
+		} sStruct;
+		unsigned char ucNumber;
+	} sUnion;
 
- if( (sUnion.sStruct.ubBit1 == 1) && (sUnion.sStruct.ubBit3 == 1) )
- { return(0); }      /* ##### Little Endian */
- else
- {
-  if( (sUnion.sStruct.ubBit6 == 1) && (sUnion.sStruct.ubBit8 == 1) )
-  { return(1); }     /* ##### Big Endian    */
-  else
-  { return(-42); }   /* ##### Unknown       */
- }
+	sUnion.sStruct.ubBit1 = 0;
+	sUnion.sStruct.ubBit2 = 0;
+	sUnion.sStruct.ubBit3 = 0;
+	sUnion.sStruct.ubBit4 = 0;
+	sUnion.sStruct.ubBit5 = 0;
+	sUnion.sStruct.ubBit6 = 0;
+	sUnion.sStruct.ubBit7 = 0;
+	sUnion.sStruct.ubBit8 = 0;
+	sUnion.sStruct.ubBitN = 0;
+	sUnion.ucNumber = 5;
+
+	if ((sUnion.sStruct.ubBit1 == 1) && (sUnion.sStruct.ubBit3 == 1)) {
+		return (0);
+	} /* ##### Little Endian */
+	else {
+		if ((sUnion.sStruct.ubBit6 == 1) && (sUnion.sStruct.ubBit8 == 1)) {
+			return (1);
+		} /* ##### Big Endian    */
+		else {
+			return (-42);
+		}		/* ##### Unknown       */
+	}
 }
 
 #if defined(_DEBUG)
- void	Dump_Raw_Result(struct Raw_Result *res);
- void	Dump_Manager_Results(struct Manager_Results *res);
- void	Dump_CPU_Results(struct CPU_Results *res);
- void	Dump_Net_Results(struct Net_Results *res);
+void Dump_Raw_Result(struct Raw_Result *res);
+void Dump_Manager_Results(struct Manager_Results *res);
+void Dump_CPU_Results(struct CPU_Results *res);
+void Dump_Net_Results(struct Net_Results *res);
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- BOOL    SetQueueSize(HANDLE, int);
- HANDLE  CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);
- BOOL    GetQueuedCompletionStatus(HANDLE, LPDWORD, LPDWORD, LPOVERLAPPED *, DWORD);
+BOOL SetQueueSize(HANDLE, int);
+HANDLE CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);
+BOOL GetQueuedCompletionStatus(HANDLE, LPDWORD, LPDWORD, LPOVERLAPPED *, DWORD);
 
- BOOL    ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
- BOOL    WriteFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
- HANDLE  CreateEvent(void *, BOOL, BOOL, LPCSTR);
- BOOL    GetOverlappedResult( HANDLE, LPOVERLAPPED, LPDWORD, BOOL );
+BOOL ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
+BOOL WriteFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
+HANDLE CreateEvent(void *, BOOL, BOOL, LPCSTR);
+BOOL GetOverlappedResult(HANDLE, LPOVERLAPPED, LPDWORD, BOOL);
 
- void    SetLastError(DWORD);
- DWORD   GetLastError(void);
- int     WSAGetLastError(void);
- void    WSASetLastError(DWORD);
+void SetLastError(DWORD);
+DWORD GetLastError(void);
+int WSAGetLastError(void);
+void WSASetLastError(DWORD);
 
- BOOL    CloseHandle(HANDLE, int object_type = 0);
- char   *_itoa(int, char *, int);
- DWORD   WaitForSingleObject(HANDLE h, DWORD milliSecs);
+BOOL CloseHandle(HANDLE, int object_type = 0);
+char *_itoa(int, char *, int);
+DWORD WaitForSingleObject(HANDLE h, DWORD milliSecs);
 
- #ifndef NOMINMAX
-  #ifndef max
-   #define max(a,b)             (((a) > (b)) ? (a) : (b))
-  #endif
-  #ifndef min
-   #define min(a,b)             (((a) < (b)) ? (a) : (b))
-  #endif
- #endif 
- #ifndef __max
-  #define __max(a,b)            (((a) < (b)) ? (b) : (a))
- #endif
+#ifndef NOMINMAX
+#ifndef max
+#define max(a,b)             (((a) > (b)) ? (a) : (b))
+#endif
+#ifndef min
+#define min(a,b)             (((a) < (b)) ? (a) : (b))
+#endif
+#endif
+#ifndef __max
+#define __max(a,b)            (((a) < (b)) ? (b) : (a))
+#endif
 
- #if defined(IOMTR_OSFAMILY_NETWARE)
-  #define _timeb		timeb
-  #define _ftime		nwtime
-  #define _time			time
-  #define _millitm		millitm
-  #define Sleep(x)		delay((x))
- #elif defined(IOMTR_OSFAMILY_UNIX)
-  #if defined(IOMTR_OS_OSX)
-   #define aiocb64 		aiocb
-   #define aio_suspend64	aio_suspend
-   #define aio_error64		aio_error
-   #define aio_cancel64		aio_cancel
-   #define aio_read64		aio_read
-   #define aio_write64		aio_write
-   #define aio_return64		aio_return
+#if defined(IOMTR_OSFAMILY_NETWARE)
+#define _timeb		timeb
+#define _ftime		nwtime
+#define _time			time
+#define _millitm		millitm
+#define Sleep(x)		delay((x))
+#elif defined(IOMTR_OSFAMILY_UNIX)
+#if defined(IOMTR_OS_OSX)
+#define aiocb64 		aiocb
+#define aio_suspend64	aio_suspend
+#define aio_error64		aio_error
+#define aio_cancel64		aio_cancel
+#define aio_read64		aio_read
+#define aio_write64		aio_write
+#define aio_return64		aio_return
 
-   #define _timeb		timeval
-   #define _ftime(x)		gettimeofday(x,NULL)
-   #define _time		tv_sec
-   #define _millitm		tv_usec
-   #define Sleep(x) 		usleep((x) * 1000)
-  #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-   #define _timeb		timeb
-   #define _ftime		ftime
-   #define _time			time
-   #define _millitm		millitm
-   #define Sleep(x) 		usleep((x) * 1000)
-  #else
-   #error ===> ERROR: You have to do some coding here to get the port done!
-  #endif
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif
+#define _timeb		timeval
+#define _ftime(x)		gettimeofday(x,NULL)
+#define _time		tv_sec
+#define _millitm		tv_usec
+#define Sleep(x) 		usleep((x) * 1000)
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+#define _timeb		timeb
+#define _ftime		ftime
+#define _time			time
+#define _millitm		millitm
+#define Sleep(x) 		usleep((x) * 1000)
+#else
+#error ===> ERROR: You have to do some coding here to get the port done!
+#endif
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 
- #define LOCK					    \
+#define LOCK					    \
 	 if (pthread_mutex_lock(&lock_mt))          \
 	 {					    \
 		cout << "unable to lock" << endl;   \
 		exit(1);			    \
 	 }
- #define UNLOCK					      \
+#define UNLOCK					      \
 	 if (pthread_mutex_unlock(&lock_mt))	      \
 	 {					      \
 		cout << "unable to unlock" << endl;   \
 		exit(1);			      \
 	 }
 
- #define InterlockedExchange(a,b)   \
+#define InterlockedExchange(a,b)   \
 	 LOCK;			    \
 	 *(a) = (b);		    \
 	 UNLOCK;
- #define InterlockedDecrement(a)   \
+#define InterlockedDecrement(a)   \
 	 LOCK;			   \
 	 --*(a);		   \
 	 UNLOCK;
- #define InterlockedIncrement(a)   \
+#define InterlockedIncrement(a)   \
 	 LOCK;			   \
 	 ++*(a);		   \
 	 UNLOCK;
-#endif 
+#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_LINUX)
- extern DWORDLONG jiffies(void);
- extern DWORDLONG rdtsc(void);
+extern DWORDLONG jiffies(void);
+extern DWORDLONG rdtsc(void);
 
- #if defined(IOMTR_CPU_PPC)
-  extern DWORD get_tbl();
-  extern DWORD get_tbu();
- #endif
+#if defined(IOMTR_CPU_PPC)
+extern DWORD get_tbl();
+extern DWORD get_tbu();
+#endif
 
- #if defined(IOMTR_CPU_XSCALE)
-  extern void double_wordswap(double *d);
-  extern void Manager_Info_double_swap(struct Manager_Info *p);
-  extern void Manager_Results_double_swap(struct Manager_Results *p);
-  extern void CPU_Results_double_swap(struct CPU_Results *p);
-  extern void Net_Results_double_swap(struct Net_Results *p);
- #endif
- 
- #if defined(_IO)  && !defined(BLKSSZGET)
-  #define BLKSSZGET    _IO(0x12,104)
- #endif
- #if defined(_IOR) && !defined(BLKBSZGET)
-  #define BLKBSZGET    _IOR(0x12,112,size_t)
- #endif
- #if defined(_IO)  && !defined(BLKGETSIZE)
-  #define BLKGETSIZE   _IO(0x12,96)
- #endif
- #if defined(_IO)  && !defined(BLKGETSIZE64)
-  #define BLKGETSIZE64 _IOR(0x12,114, size_t)
- #endif
-#endif 
+#if defined(IOMTR_CPU_XSCALE)
+extern void double_wordswap(double *d);
+extern void Manager_Info_double_swap(struct Manager_Info *p);
+extern void Manager_Results_double_swap(struct Manager_Results *p);
+extern void CPU_Results_double_swap(struct CPU_Results *p);
+extern void Net_Results_double_swap(struct Net_Results *p);
+#endif
+
+#if defined(_IO)  && !defined(BLKSSZGET)
+#define BLKSSZGET    _IO(0x12,104)
+#endif
+#if defined(_IOR) && !defined(BLKBSZGET)
+#define BLKBSZGET    _IOR(0x12,112,size_t)
+#endif
+#if defined(_IO)  && !defined(BLKGETSIZE)
+#define BLKGETSIZE   _IO(0x12,96)
+#endif
+#if defined(_IO)  && !defined(BLKGETSIZE64)
+#define BLKGETSIZE64 _IOR(0x12,114, size_t)
+#endif
+#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_NETWARE)
- int aio_suspend64(struct aiocb64 **cb, int a, struct timespec *);
- int aio_error64(struct aiocb64 *cb);
- int aio_return64(struct aiocb64 *cb);
- int aio_read64(struct aiocb64 *cb, int type);
- int aio_write64(struct aiocb64 *cb, int type);
- int aio_cancel64(int a, struct aiocb64 *cb);
+int aio_suspend64(struct aiocb64 **cb, int a, struct timespec *);
+int aio_error64(struct aiocb64 *cb);
+int aio_return64(struct aiocb64 *cb);
+int aio_read64(struct aiocb64 *cb, int type);
+int aio_write64(struct aiocb64 *cb, int type);
+int aio_cancel64(int a, struct aiocb64 *cb);
 
- #ifdef __cplusplus
- extern "C"
- {
- #endif
- extern LONG  GetTimerMinorTicksPerSecond(void);
- extern unsigned long kGetProcessorInterruptCount(unsigned int, unsigned int *);
- extern void  EnterDebugger();
- extern LONG SSGetLANCommonCounters(unsigned long, unsigned long, unsigned char *, unsigned int);
- #ifdef __cplusplus
- }
- #endif
-
- extern DWORDLONG rdtsc(void); 
+#ifdef __cplusplus
+extern "C" {
 #endif
+	extern LONG GetTimerMinorTicksPerSecond(void);
+	extern unsigned long kGetProcessorInterruptCount(unsigned int, unsigned int *);
+	extern void EnterDebugger();
+	extern LONG SSGetLANCommonCounters(unsigned long, unsigned long, unsigned char *, unsigned int);
+#ifdef __cplusplus
+}
+#endif
+extern DWORDLONG rdtsc(void);
+#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
- extern "C" DWORDLONG rdtsc();
+extern "C" DWORDLONG rdtsc();
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- extern DWORDLONG rdtsc();
+extern DWORDLONG rdtsc();
 #endif
 // ----------------------------------------------------------------------------
 
-
-#endif	// ___IOCOMMON_H_DEFINED___
+#endif				// ___IOCOMMON_H_DEFINED___

Modified: branches/IOMETER-restruct/iometer/src/IOCompletionQ.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCompletionQ.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOCompletionQ.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -81,7 +81,6 @@
  // nop
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 
-
 #include "IOCommon.h"
 #include <assert.h>
 
@@ -89,49 +88,45 @@
 #include "IOTest.h"
 #endif
 
-
-
-
 BOOL SetQueueSize(HANDLE cqid, int size)
 {
 	// Allocate memory for size elements in the completion queue.
 	// and also for the parallel array of struct aiocb pointers.
 	struct IOCQ *this_cqid;
+
 	this_cqid = (struct IOCQ *)cqid;
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	this_cqid->element_list = (struct CQ_Element *)malloc(sizeof(CQ_Element) * size);
 #elif defined(IOMTR_OS_NETWARE)
 	this_cqid->element_list = (struct CQ_Element *)NXMemAlloc(sizeof(CQ_Element) * size, 1);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	if (this_cqid->element_list == NULL)
-	{
+	if (this_cqid->element_list == NULL) {
 		cout << "memory allocation failed" << endl;
-		return(FALSE);
+		return (FALSE);
 	}
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	this_cqid->aiocb_list = (struct aiocb64 **)malloc(sizeof(struct aiocb64 *) * size);
 #elif defined(IOMTR_OS_NETWARE)
 	this_cqid->aiocb_list = (struct aiocb64 **)NXMemAlloc(sizeof(struct aiocb64 *) * size, 1);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	if (this_cqid->aiocb_list == NULL)
-	{
+	if (this_cqid->aiocb_list == NULL) {
 		cout << "memory allocation failed" << endl;
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		free(this_cqid->element_list);
 #elif defined(IOMTR_OS_NETWARE)
 		NXMemFree(this_cqid->element_list);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-		return(FALSE);
+		return (FALSE);
 	}
 
 	memset(this_cqid->element_list, 0, sizeof(struct CQ_Element) * size);
-	memset(this_cqid->aiocb_list, 0, sizeof(struct aiocb64 *) * size );
+	memset(this_cqid->aiocb_list, 0, sizeof(struct aiocb64 *) * size);
 	this_cqid->size = size;
 	this_cqid->last_freed = -1;
 	this_cqid->position = 0;
@@ -139,13 +134,9 @@
 #ifdef _DEBUG
 	cout << "allocated a completion queue of size " << size << " for handle : " << this_cqid << endl;
 #endif
-	return(TRUE);
+	return (TRUE);
 }
 
-
-
-
-
 //
 // This function is the UNIX equivalent of the NT call to create a IO Completion Port.
 // The behavior is similar to the NT call wherein a Completion Queue is created and
@@ -158,22 +149,20 @@
 //
 HANDLE CreateIoCompletionPort(HANDLE file_handle, HANDLE cq, DWORD completion_key, DWORD num_threads)
 {
-	struct File		*filep;
-	struct IOCQ		*cqid;
+	struct File *filep;
+	struct IOCQ *cqid;
 
 	cqid = (struct IOCQ *)cq;
-	if (cqid == NULL)
-	{
+	if (cqid == NULL) {
 		// cqid is NULL. We assign a new completion queue.
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-		cqid = (struct IOCQ *) malloc(sizeof(struct IOCQ));
+		cqid = (struct IOCQ *)malloc(sizeof(struct IOCQ));
 #elif defined(IOMTR_OS_NETWARE)
-		cqid = (struct IOCQ *) NXMemAlloc(sizeof(struct IOCQ), 1);
+		cqid = (struct IOCQ *)NXMemAlloc(sizeof(struct IOCQ), 1);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-		if (cqid == NULL)
-		{
+		if (cqid == NULL) {
 			cout << "memory allocation failed. Exiting...." << endl;
 			exit(1);
 		}
@@ -188,19 +177,14 @@
 	// If file_handle is INVALID then do nothing. 
 	// We are required to create the comp queue only.
 	filep = (struct File *)file_handle;
-	if (filep != INVALID_HANDLE_VALUE)
-	{
-		filep->iocq	= cqid;
+	if (filep != INVALID_HANDLE_VALUE) {
+		filep->iocq = cqid;
 		filep->completion_key = completion_key;
 	}
 
-	return((HANDLE)cqid);
+	return ((HANDLE) cqid);
 }
 
-
-
-
-
 //
 // This is the UNIX equivalent of the NT call CreateEvent() which creates an Event Queue.
 // It is similar to a Completion Queue and works in the same way. The only difference is
@@ -217,16 +201,15 @@
 	IOCQ *eventqid;
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	eventqid = (struct IOCQ *) malloc(sizeof(struct IOCQ));
+	eventqid = (struct IOCQ *)malloc(sizeof(struct IOCQ));
 #elif defined(IOMTR_OS_NETWARE)
-	eventqid = (struct IOCQ *) NXMemAlloc(sizeof(struct IOCQ), 1);
+	eventqid = (struct IOCQ *)NXMemAlloc(sizeof(struct IOCQ), 1);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	if (eventqid == NULL)
-	{
+	if (eventqid == NULL) {
 		cout << "memory allocation failed. Exiting...." << endl;
-		return(NULL);
+		return (NULL);
 	}
 	eventqid->element_list = NULL;
 	eventqid->aiocb_list = NULL;
@@ -234,13 +217,9 @@
 	eventqid->last_freed = -1;
 	eventqid->position = 0;
 
-	return((HANDLE)eventqid);
+	return ((HANDLE) eventqid);
 }
 
-
-
-
-
 //
 // Again, another NT-like call.
 //
@@ -257,13 +236,13 @@
 // the file handle and a pointer to void data.
 //
 BOOL GetQueuedCompletionStatus(HANDLE cq, LPDWORD bytes_transferred, LPDWORD completion_key,
-							   LPOVERLAPPED *lpOverlapped, DWORD tmout)
+			       LPOVERLAPPED * lpOverlapped, DWORD tmout)
 {
-	struct timespec	*timeoutp;
-	struct timespec	timeout;
-	struct IOCQ	*cqid;
-	int		i, j;
-	int		aio_error_return;
+	struct timespec *timeoutp;
+	struct timespec timeout;
+	struct IOCQ *cqid;
+	int i, j;
+	int aio_error_return;
 
 	cqid = (struct IOCQ *)cq;
 
@@ -298,35 +277,35 @@
 	// IO Return Loop - return one AIO completion.
 
 	i = cqid->position;
-	
-	for( j = 0; j < cqid->size; j++ ) {
-	
-		if( i == cqid->size ) {
+
+	for (j = 0; j < cqid->size; j++) {
+
+		if (i == cqid->size) {
 			i = 0;
 		}
-		
-		if( cqid->element_list[i].done == TRUE ) {
-		
+
+		if (cqid->element_list[i].done == TRUE) {
+
 			// IO operation completed with either success or failure.
 
-			*completion_key            = cqid->element_list[i].completion_key;
-			
+			*completion_key = cqid->element_list[i].completion_key;
+
 			// Always set completion key
-			
-			*lpOverlapped          	   = (LPOVERLAPPED)cqid->element_list[i].data;
 
+			*lpOverlapped = (LPOVERLAPPED) cqid->element_list[i].data;
+
 			// Always set overlap data
-			
+
 			cqid->element_list[i].done = FALSE;
-			cqid->last_freed 	   = i;
-			cqid->position             = i + 1;
-			*bytes_transferred         = cqid->element_list[i].bytes_transferred;
-			
+			cqid->last_freed = i;
+			cqid->position = i + 1;
+			*bytes_transferred = cqid->element_list[i].bytes_transferred;
+
 			// We are returning the status of this aio. Set it to NULL to free the slot.
-			
+
 			cqid->aiocb_list[i] = 0;
 
-			if( (DWORD )*bytes_transferred < (DWORD)0 ) {
+			if ((DWORD) * bytes_transferred < (DWORD) 0) {
 				*bytes_transferred = 0;
 				// TODO: Here - and in the other locations where SetLastError()
 				// is called in this method - we have the problem, that it is
@@ -339,15 +318,14 @@
 				// As this method is called by CQAIO::GetStatus() (only?), we
 				// have to considere changes there as well.
 				SetLastError(cqid->element_list[i].error);
-				return( FALSE );
+				return (FALSE);
+			} else {
+				return (TRUE);
 			}
-			else {
-				return( TRUE );
-			}
 		}
-		
+
 		i++;
-	} // end of IO Return loop.
+	}			// end of IO Return loop.
 
 	//
 	// Beyond this point return FALSE. No I/O has completed yet.
@@ -356,19 +334,17 @@
 	// 
 	if (tmout == INFINITE)
 		timeoutp = NULL;
-	else
-	{
-		timeout.tv_sec  = tmout/1000;
+	else {
+		timeout.tv_sec = tmout / 1000;
 		timeout.tv_nsec = (tmout % 1000) * 1000000;
-		timeoutp        = &timeout;
+		timeoutp = &timeout;
 	}
 
-	if (aio_suspend64(cqid->aiocb_list, cqid->size, timeoutp) < 0)
-	{
-		*lpOverlapped      = NULL;
+	if (aio_suspend64(cqid->aiocb_list, cqid->size, timeoutp) < 0) {
+		*lpOverlapped = NULL;
 		*bytes_transferred = 0;
-		*completion_key    = 0;
-		if ( (errno == EAGAIN) || (errno == EINVAL) ) {
+		*completion_key = 0;
+		if ((errno == EAGAIN) || (errno == EINVAL)) {
 #if defined(IOMTR_OS_LINUX)
 			assert(errno == EAGAIN);
 #endif
@@ -376,17 +352,15 @@
 		} else {
 			SetLastError(errno);
 		}
-		
-		return(FALSE);
-	}
 
+		return (FALSE);
+	}
 	// Tagging loop - to tag completed AIOs.
-	for( j = 0; j < cqid->size; j++ ) {
+	for (j = 0; j < cqid->size; j++) {
 		errno = 0;
-		if( cqid->aiocb_list[j] ) {
-			if( ( aio_error_return = aio_error64( cqid->aiocb_list[j] ) ) != EINPROGRESS ) {
-				cqid->element_list[j].bytes_transferred =
-					aio_return64(cqid->aiocb_list[j]);
+		if (cqid->aiocb_list[j]) {
+			if ((aio_error_return = aio_error64(cqid->aiocb_list[j])) != EINPROGRESS) {
+				cqid->element_list[j].bytes_transferred = aio_return64(cqid->aiocb_list[j]);
 				//
 				// We have done an aio_return() on this element. Anull it.
 				// The slot will be picked up by the next request.
@@ -405,13 +379,9 @@
 		}
 	}
 	SetLastError(WAIT_TIMEOUT);
-	return(FALSE);
+	return (FALSE);
 }
 
-
-
-
-
 //
 // This call is very similar to GetQueuedCompletionStatus().
 //
@@ -421,16 +391,15 @@
 // Depending on a wait value being TRUE or FALSE, the call either blocks indefinitely
 // scans the event queue just once waiting for an I/O completion.
 //
-BOOL GetOverlappedResult(HANDLE file_handle, LPOVERLAPPED lpOverlapped, LPDWORD bytes_transferred,
-						 BOOL wait)
+BOOL GetOverlappedResult(HANDLE file_handle, LPOVERLAPPED lpOverlapped, LPDWORD bytes_transferred, BOOL wait)
 {
-	struct timespec	*timeoutp;
-	struct timespec	timeout;
-	struct File	*filep;
-	int		this_fd;
-	int		i, j;
-	int		aio_error_return;
-	IOCQ		*eventqid;
+	struct timespec *timeoutp;
+	struct timespec timeout;
+	struct File *filep;
+	int this_fd;
+	int i, j;
+	int aio_error_return;
+	IOCQ *eventqid;
 
 	//
 	// This function either blocks for ever or scans the AIO list just once for completions.
@@ -438,8 +407,7 @@
 	filep = (struct File *)file_handle;
 	if (wait == TRUE)
 		timeoutp = NULL;
-	else
-	{
+	else {
 		timeout.tv_sec = 0;
 		timeout.tv_nsec = 0;
 		timeoutp = &timeout;
@@ -452,45 +420,39 @@
 	// function.
 	//
 	// get a handle to the current event queue.
-	eventqid = (IOCQ *)((ULONG_PTR)lpOverlapped->hEvent ^ 0x1);
+	eventqid = (IOCQ *) ((ULONG_PTR) lpOverlapped->hEvent ^ 0x1);
 
 	// Call aio_suspend() now.
-	if (aio_suspend64(eventqid->aiocb_list, eventqid->size, timeoutp) < 0)
-	{
-		if ( (errno == EAGAIN) || (errno == EINVAL) )
-		{
+	if (aio_suspend64(eventqid->aiocb_list, eventqid->size, timeoutp) < 0) {
+		if ((errno == EAGAIN) || (errno == EINVAL)) {
 			// No operations completed in the given timeout.
 			// Note that changing lpOverlapped has no effect. Its a local copy.
 			lpOverlapped = NULL;
 			*bytes_transferred = 0;
 			SetLastError(WAIT_TIMEOUT);
-			return(FALSE);
+			return (FALSE);
 		}
 #ifdef _DEBUG
 		cout << "aio_suspend returned error " << errno << endl;
 #endif
 		SetLastError(errno);
-		return(FALSE);
+		return (FALSE);
 	}
 	// aio_suspend() returned successfully. Check if atleast one of the
 	// I/Os completed. must have!.
 	i = eventqid->position;
-	for (j = 0; j < eventqid->size; j++)
-	{
+	for (j = 0; j < eventqid->size; j++) {
 		if (i == eventqid->size)
 			i = 0;
 
 		errno = 0;
-		if (eventqid->aiocb_list[i])
-		{
-			if ((aio_error_return = aio_error64(eventqid->aiocb_list[i])) != EINPROGRESS)
-			{
+		if (eventqid->aiocb_list[i]) {
+			if ((aio_error_return = aio_error64(eventqid->aiocb_list[i])) != EINPROGRESS) {
 				this_fd = eventqid->element_list[i].aiocbp.aio_fildes;
-				if (this_fd == filep->fd)
-				{
+				if (this_fd == filep->fd) {
 					DWORD bytes_expected;
 
-					*bytes_transferred = (DWORD)aio_return64(eventqid->aiocb_list[i]);
+					*bytes_transferred = (DWORD) aio_return64(eventqid->aiocb_list[i]);
 
 					bytes_expected = eventqid->aiocb_list[i]->aio_nbytes;
 
@@ -502,43 +464,35 @@
 
 					// Note that changing lpOverlapped has no effect. Its a local copy.
 
-					lpOverlapped = (LPOVERLAPPED)eventqid->element_list[i].data;
+					lpOverlapped = (LPOVERLAPPED) eventqid->element_list[i].data;
 
-					if (*bytes_transferred != bytes_expected)
-					{
-						if ( aio_error_return == ENOSPC )
-						{
-							SetLastError( aio_error_return );
-							return( FALSE );
+					if (*bytes_transferred != bytes_expected) {
+						if (aio_error_return == ENOSPC) {
+							SetLastError(aio_error_return);
+							return (FALSE);
 						}
 					}
 
-					if ((DWORD)*bytes_transferred < 0)
-					{
+					if ((DWORD) * bytes_transferred < 0) {
 						*bytes_transferred = 0;
 						if (aio_error_return)
 							SetLastError(aio_error_return);
-						else if (errno) 
+						else if (errno)
 							SetLastError(errno);
-						
-						return(FALSE);
-					}
-					else
-						return(TRUE);
+
+						return (FALSE);
+					} else
+						return (TRUE);
 				}
 			}
 		}
 		i++;
-	} // end of for() loop
+	}			// end of for() loop
 	// At this point NO I/O has completed. Return WAIT_TIMEOUT and FALSE.
 	SetLastError(WAIT_TIMEOUT);
-	return(FALSE);
+	return (FALSE);
 }
 
-
-
-
-
 //
 // ReadFile() reads "bytes_to_read" bytes from the file_handle into the buffer.
 // The call uses asynch I/O routine aio_read().
@@ -547,49 +501,40 @@
 // It also determines from the Overlapped structure if the I/O completion status should be 
 // posted on the event queue or the completion queue associated with the file handle.
 //
-BOOL ReadFile(HANDLE file_handle, void *buffer, DWORD bytes_to_read, LPDWORD bytes_read, LPOVERLAPPED
-			  lpOverlapped)
+BOOL ReadFile(HANDLE file_handle, void *buffer, DWORD bytes_to_read, LPDWORD bytes_read, LPOVERLAPPED lpOverlapped)
 {
-	struct File	*filep;
-	struct IOCQ	*this_cq;
-	struct aiocb64	*aiocbp;
-	int		i, free_index = -1;
+	struct File *filep;
+	struct IOCQ *this_cq;
+	struct aiocb64 *aiocbp;
+	int i, free_index = -1;
+
 #ifdef IMMEDIATE_AIO_COMPLETION
-	int		aio_error_return;
+	int aio_error_return;
 #endif
 
 	filep = (struct File *)file_handle;
 	//
 	// At this point we have to decide whether to place this in the Completion queue
 	// or the event queue.
-	if ((ULONG_PTR)lpOverlapped->hEvent & 0x00000001)
-	{
+	if ((ULONG_PTR) lpOverlapped->hEvent & 0x00000001) {
 		// forcibly place this on the event queue even though a completion queue is associated
 		// with the file. Well, thats what you asked for.
-		this_cq = (IOCQ *)((ULONG_PTR)lpOverlapped->hEvent ^ 0x1);
-	}
-	else
+		this_cq = (IOCQ *) ((ULONG_PTR) lpOverlapped->hEvent ^ 0x1);
+	} else
 		this_cq = filep->iocq;
 
-	if (this_cq == NULL)
-	{
+	if (this_cq == NULL) {
 		cout << "event or completion queue not allocated " << endl;
-		return(FALSE);
+		return (FALSE);
 	}
-
 	// First locate an empty slot in the queue.
-	if (this_cq->last_freed != -1)
-	{
+	if (this_cq->last_freed != -1) {
 		free_index = this_cq->last_freed;
-		this_cq->last_freed = -1;  // the slot is taken. Thanks
-	}
-	else
-	{
+		this_cq->last_freed = -1;	// the slot is taken. Thanks
+	} else {
 		// search for a free index. 
-		for (i = 0; i < this_cq->size; i++)
-		{
-			if (this_cq->aiocb_list[i] == NULL)
-			{
+		for (i = 0; i < this_cq->size; i++) {
+			if (this_cq->aiocb_list[i] == NULL) {
 				free_index = i;
 				break;
 			}
@@ -598,7 +543,7 @@
 
 	// either free_index holds the free index or there is no free space in the Q.
 	if (free_index == -1)
-		return(FALSE);
+		return (FALSE);
 
 	aiocbp = &this_cq->element_list[free_index].aiocbp;
 
@@ -619,50 +564,42 @@
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	if (aio_read64(&this_cq->element_list[free_index].aiocbp) < 0)
 #elif defined(IOMTR_OS_NETWARE)
-	if (aio_read64(&this_cq->element_list[free_index].aiocbp,filep->type) < 0)
+	if (aio_read64(&this_cq->element_list[free_index].aiocbp, filep->type) < 0)
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		cout << "queuing for read failed with error " << errno << endl;
 		// Note that we have not set aiocb_list[] with the correct pointers.
 		// So, this slot will get grabbed in the next loop.
 		SetLastError(errno);
-		return(FALSE);
+		return (FALSE);
 	}
 #ifdef IMMEDIATE_AIO_COMPLETION
 	// Check if the aio_read completed successfully.
-	if ((aio_error_return = aio_error64(&this_cq->element_list[free_index].aiocbp)) != EINPROGRESS)
-	{
-		*bytes_read = (DWORD)aio_return64(&this_cq->element_list[free_index].aiocbp);
-		if ((long)*bytes_read < 0)
-		{
+	if ((aio_error_return = aio_error64(&this_cq->element_list[free_index].aiocbp)) != EINPROGRESS) {
+		*bytes_read = (DWORD) aio_return64(&this_cq->element_list[free_index].aiocbp);
+		if ((long)*bytes_read < 0) {
 			*bytes_read = 0;
 			if (aio_error_return)
 				SetLastError(aio_error_return);
 			else if (errno)
 				SetLastError(errno);
-			return(FALSE);
-		}
-		else
-		{
+			return (FALSE);
+		} else {
 			SetLastError(0);
-			return(TRUE);
+			return (TRUE);
 		}
 	}
 #endif
 	else
 		// aio_read is in progress. We have to set the aiocb_list[] to point correctly.
 		this_cq->aiocb_list[free_index] = aiocbp;
-	
+
 	SetLastError(ERROR_IO_PENDING);
-	return(FALSE);
+	return (FALSE);
 }
 
-
-
-
-
 //
 // WriteFile() writes "bytes_to_write" bytes from the buffer into the file pointed to by
 // the file handle.
@@ -672,56 +609,48 @@
 // It also determines from the Overlapped structure if the I/O completion status should be 
 // posted on the event queue or the completion queue associated with the file handle.
 //
-BOOL WriteFile(HANDLE file_handle, void *buffer, DWORD bytes_to_write, LPDWORD bytes_written,
-			   LPOVERLAPPED lpOverlapped)
+BOOL WriteFile(HANDLE file_handle, void *buffer, DWORD bytes_to_write, LPDWORD bytes_written, LPOVERLAPPED lpOverlapped)
 {
-	struct File	*filep;
-	struct IOCQ	*this_cq;
-	struct aiocb64	*aiocbp;
-	int		i, free_index = -1;
+	struct File *filep;
+	struct IOCQ *this_cq;
+	struct aiocb64 *aiocbp;
+	int i, free_index = -1;
+
 #ifdef IMMEDIATE_AIO_COMPLETION
-	int		aio_error_return;
+	int aio_error_return;
 #endif
 
 	filep = (struct File *)file_handle;
 	//
 	// At this point we have to decide whether to place this in the Completion queue
 	// or the event queue.
-	if ((ULONG_PTR)lpOverlapped->hEvent & 0x00000001)
-	{
+	if ((ULONG_PTR) lpOverlapped->hEvent & 0x00000001) {
 		// forcibly place this on the event queue even though a completion queue is associated
 		// with the file. Well, thats what you asked for.
-		this_cq = (IOCQ *)((ULONG_PTR)lpOverlapped->hEvent ^ 0x1);
-	}
-	else
+		this_cq = (IOCQ *) ((ULONG_PTR) lpOverlapped->hEvent ^ 0x1);
+	} else
 		this_cq = filep->iocq;
 
-	if (this_cq == NULL)
-	{
+	if (this_cq == NULL) {
 		cout << "event or completion queue not allocated " << endl;
-		return(FALSE);
+		return (FALSE);
 	}
-
 	// First locate an empty slot in the queue.
-	if (this_cq->last_freed != -1)
-	{
+	if (this_cq->last_freed != -1) {
 		free_index = this_cq->last_freed;
-		this_cq->last_freed = -1;  // the slot is taken. Thanks
-	}
-	else
+		this_cq->last_freed = -1;	// the slot is taken. Thanks
+	} else
 		// search for a free index. 
-		for (i = 0; i < this_cq->size; i++)
-		{
-			if (this_cq->aiocb_list[i] == NULL)
-			{
+		for (i = 0; i < this_cq->size; i++) {
+			if (this_cq->aiocb_list[i] == NULL) {
 				free_index = i;
 				break;
 			}
 		}
-		
+
 	// either free_index holds the free index or there is no free space in the Q.
 	if (free_index == -1)
-		return(FALSE);
+		return (FALSE);
 
 	aiocbp = &this_cq->element_list[free_index].aiocbp;
 
@@ -742,50 +671,42 @@
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	if (aio_write64(&this_cq->element_list[free_index].aiocbp) < 0)
 #elif defined(IOMTR_OS_NETWARE)
-	if (aio_write64(&this_cq->element_list[free_index].aiocbp,filep->type) < 0)
+	if (aio_write64(&this_cq->element_list[free_index].aiocbp, filep->type) < 0)
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		cout << "queuing for write failed with error " << errno << endl;
 		// Note that we have not set aiocb_list[] with the correct pointers.
 		// So, this slot will get grabbed in the next loop.
 		SetLastError(errno);
-		return(FALSE);
+		return (FALSE);
 	}
 #ifdef IMMEDIATE_AIO_COMPLETION
 	// Check if the aio_write completed successfully.
-	if ((aio_error_return = aio_error64(&this_cq->element_list[free_index].aiocbp)) != EINPROGRESS)
-	{
-		*bytes_written = (DWORD)aio_return64(&this_cq->element_list[free_index].aiocbp);
-		if ((long)*bytes_written < 0)
-		{
+	if ((aio_error_return = aio_error64(&this_cq->element_list[free_index].aiocbp)) != EINPROGRESS) {
+		*bytes_written = (DWORD) aio_return64(&this_cq->element_list[free_index].aiocbp);
+		if ((long)*bytes_written < 0) {
 			*bytes_written = 0;
 			if (aio_error_return)
 				SetLastError(aio_error_return);
 			else if (errno)
 				SetLastError(errno);
-			return(FALSE);
-		}
-		else
-		{
+			return (FALSE);
+		} else {
 			SetLastError(0);
-			return(TRUE);
+			return (TRUE);
 		}
 	}
 #endif
 	else
 		// aio_write is in progress. We have to set the aiocb_list[] to point correctly.
 		this_cq->aiocb_list[free_index] = aiocbp;
-	
+
 	SetLastError(ERROR_IO_PENDING);
-	return(FALSE);
+	return (FALSE);
 }
 
-
-
-
-
 //
 // CloseHandle() has a slightly different interface from the NT call. It takes an
 // additional input parameter to determine the object type. The object can be either
@@ -801,34 +722,29 @@
 // 
 BOOL CloseHandle(HANDLE object, int object_type)
 {
-	struct File	*filep;
-	struct IOCQ	*cqid;
-	int		retval, i;
+	struct File *filep;
+	struct IOCQ *cqid;
+	int retval, i;
 
 #ifdef _DEBUG
-	cout << "CloseHandle() freeing : handle = " << object << " objecttype = " 
-		<< object_type << endl;
+	cout << "CloseHandle() freeing : handle = " << object << " objecttype = " << object_type << endl;
 #endif
-	
-	switch(object_type)
-	{
+
+	switch (object_type) {
 	case FILE_ELEMENT:
 		filep = (struct File *)object;
 		cqid = filep->iocq;
 		// cancel any pending aio requests.
 		retval = aio_cancel64(filep->fd, NULL);
-		while (retval == AIO_NOTCANCELED)
-		{
-			retval = aio_cancel64(filep->fd,NULL);
+		while (retval == AIO_NOTCANCELED) {
+			retval = aio_cancel64(filep->fd, NULL);
 		}
 
-		if (cqid != NULL && cqid->element_list != NULL && cqid->aiocb_list != NULL)
-		{
-			for (i = 0; i < cqid->size; i++)
-			{
+		if (cqid != NULL && cqid->element_list != NULL && cqid->aiocb_list != NULL) {
+			for (i = 0; i < cqid->size; i++) {
 				if (cqid->element_list[i].aiocbp.aio_fildes != filep->fd)
 					continue;
-				
+
 				// We are not interested in the return values of aio_error() and aio_return().
 				// only have to dequeue all the requests.
 				if (!cqid->aiocb_list[i])
@@ -841,20 +757,19 @@
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		close(filep->fd);
 #elif defined(IOMTR_OS_NETWARE)
-		if ( IsType( filep->type, LogicalDiskType ) )
+		if (IsType(filep->type, LogicalDiskType))
 			NXClose(filep->fd);
-		else if ( IsType( filep->type, PhysicalDiskType ) )
+		else if (IsType(filep->type, PhysicalDiskType))
 			MM_ReleaseIOObject(filep->fd);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		break;
 	case CQ_ELEMENT:
 		cqid = (struct IOCQ *)object;
-		
+
 		// cancel any pending aio requests.
-		for (i = 0; i < cqid->size; i++)
-		{
+		for (i = 0; i < cqid->size; i++) {
 			if (!cqid->aiocb_list[i])
 				continue;
 
@@ -869,21 +784,20 @@
 #elif defined(IOMTR_OS_SOLARIS)
 			retval = aio_cancel64(cqid->element_list[i].aiocbp.aio_fildes, cqid->aiocb_list[i]);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-			if (retval == AIO_NOTCANCELED)
-			{
+			if (retval == AIO_NOTCANCELED) {
 				retval = aio_error64(cqid->aiocb_list[i]);
 				retval = aio_return64(cqid->aiocb_list[i]);
 			}
-		}       
+		}
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		free(cqid->aiocb_list);
 #elif defined(IOMTR_OS_NETWARE)
 		NXMemFree(cqid->aiocb_list);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		// Something strange here. If I free the element_list, the next round
 		// of aio_write() and aio_read() calls fail. If I dont free this, then they
@@ -902,24 +816,20 @@
 		NXMemFree(cqid->element_list);
 		NXMemFree(cqid);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-		break;	
+		break;
 	default:
 		break;
 	}
-	return(TRUE);
+	return (TRUE);
 }
 
-
-
-
-
 //
 // Here are some simple self-explanatory routines.
 //
 // A note on "errno". 
-//		According to the threads man pages and documents, when the compilation symbol 
+//              According to the threads man pages and documents, when the compilation symbol 
 // _REENTRANT is defined, the all important global error variable "errno" is made 
 // thread-specific. This is done in the errno.h
 //
@@ -931,29 +841,26 @@
 	errno = num;
 }
 
-
 DWORD GetLastError(void)
 {
 	int error_to_return;
 
 	error_to_return = errno;
-	return(error_to_return);
+	return (error_to_return);
 }
 
-
 void WSASetLastError(DWORD num)
 {
 	errno = num;
 }
 
-
 int WSAGetLastError(void)
 {
 	int error_to_return;
 
 	error_to_return = errno;
 	errno = 0;
-	return(error_to_return);
+	return (error_to_return);
 }
 
 //
@@ -962,31 +869,20 @@
 {
 	if (radix == 10)
 		sprintf(string, "%d", value);
-	else
-	{
+	else {
 		cerr << "_itoa() not implemented for radix != 10" << endl;
 		exit(1);
 	}
-	return(string);
+	return (string);
 }
 
-
-
-
-
 unsigned int SetErrorMode(unsigned int umode)
 {
 	// This function does nothing. Just a dummy equivalent of NT calls.
 	// But it can be made more functional, if required.
-	return(0);
+	return (0);
 }
 
-
-
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-
-
-
-

Modified: branches/IOMETER-restruct/iometer/src/IOGlobals.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOGlobals.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOGlobals.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,10 +60,8 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include "stdafx.h"
+#include "stdafx.h"
 #endif
 #include "IOCommon.h"
 
@@ -77,90 +75,90 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
-//	Function Name:
-//		GetAppFileVersionString
+//      Function Name:
+//              GetAppFileVersionString
 //
-//	Purpose:
-//		Obtain file version string (standard one as well as the on with DEBUG indicator).
+//      Purpose:
+//              Obtain file version string (standard one as well as the on with DEBUG indicator).
 //
-//	Syntax:
-//		void	GetAppFileVersionString(char **ppStrStandard, char **ppStrWithDebug)
-//	
-//	Parameters:
-//		ppStrStandard	Ptr (must not be NULL) to a variable where the newly
-//						created string pointer can be returned in.
-//		ppStrWithDebug	Ptr (must not be NULL) to a variable where the newly
-//						created string with debug indicator can be returned in.
-//			(caller owns these strings, and is responsible for its cleanup).
+//      Syntax:
+//              void    GetAppFileVersionString(char **ppStrStandard, char **ppStrWithDebug)
+//      
+//      Parameters:
+//              ppStrStandard   Ptr (must not be NULL) to a variable where the newly
+//                                              created string pointer can be returned in.
+//              ppStrWithDebug  Ptr (must not be NULL) to a variable where the newly
+//                                              created string with debug indicator can be returned in.
+//                      (caller owns these strings, and is responsible for its cleanup).
 //
-//	Processing:
-//		1. Get file version string of the app module.
-//		2. If unable to do so or UNIX case, use the constant value IOVER_FILEVERSION.
-//		3. Form 'with debug indicator' string by concatenating VERSION_DEBUG value.
+//      Processing:
+//              1. Get file version string of the app module.
+//              2. If unable to do so or UNIX case, use the constant value IOVER_FILEVERSION.
+//              3. Form 'with debug indicator' string by concatenating VERSION_DEBUG value.
 //
-//	Notes:
-//		If a DLL calls this function, its EXE module's version info will be
-//		returned.  If the DLL's version info needs to be returned, 'NULL'
-//		parameter in the GetModuleFileName() call can be replaced by 
-//		'AfxGetInstanceHandle()'.
+//      Notes:
+//              If a DLL calls this function, its EXE module's version info will be
+//              returned.  If the DLL's version info needs to be returned, 'NULL'
+//              parameter in the GetModuleFileName() call can be replaced by 
+//              'AfxGetInstanceHandle()'.
 /////////////////////////////////////////////////////////////////////////////
-void	GetAppFileVersionString(char **ppStrStandard, char **ppStrWithDebug)
+void GetAppFileVersionString(char **ppStrStandard, char **ppStrWithDebug)
 {
-	char   *pStrStandard = NULL;
+	char *pStrStandard = NULL;
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	ASSERT((ppStrStandard != NULL) && (ppStrWithDebug != NULL));
 
 	//Get app(EXE module)'s file path
 	char modulePathBuff[MAX_PATH];
-	if (::GetModuleFileName(NULL, modulePathBuff, sizeof(modulePathBuff)) != 0)
-	{
-		DWORD	dwHandle=0;		//not used
-		DWORD	dwVerInfoSize = ::GetFileVersionInfoSize(modulePathBuff, &dwHandle);
+
+	if (::GetModuleFileName(NULL, modulePathBuff, sizeof(modulePathBuff)) != 0) {
+		DWORD dwHandle = 0;	//not used
+		DWORD dwVerInfoSize =::GetFileVersionInfoSize(modulePathBuff, &dwHandle);
+
 		//The module provides VersionInfo data
-		if (dwVerInfoSize != 0)
-		{
+		if (dwVerInfoSize != 0) {
 			//ptr to buffer to hold version information
-			char   *pVerInfo = new char[dwVerInfoSize];
-			if (::GetFileVersionInfo(modulePathBuff, NULL, dwVerInfoSize, pVerInfo))
-			{
-				UINT	dataLen;		//receives size of fixed data area (not used)
-				char   *pFileVersion;
+			char *pVerInfo = new char[dwVerInfoSize];
+
+			if (::GetFileVersionInfo(modulePathBuff, NULL, dwVerInfoSize, pVerInfo)) {
+				UINT dataLen;	//receives size of fixed data area (not used)
+				char *pFileVersion;
+
 				//04b0 == 1200 codepage denoting Unicode used for win95 and NT resource dlls (see Iometer.rc2)
 				if (::VerQueryValue(pVerInfo, TEXT("\\StringFileInfo\\040904b0\\FileVersion"),
-									 (void **)&pFileVersion, &dataLen))
-				{
+						    (void **)&pFileVersion, &dataLen)) {
 					pStrStandard = new char[strlen(pFileVersion) + 1];
+
 					strcpy(pStrStandard, pFileVersion);
 				}
 			}
-			delete [] pVerInfo;
+			delete[]pVerInfo;
 		}
 		//It should have VersionInfo!
 		else
 			ASSERT(0);
 	}
-#endif /* IOMTR_OS_WIN32 || IOMTR_OS_WIN64 */
+#endif				/* IOMTR_OS_WIN32 || IOMTR_OS_WIN64 */
 
 	//UNIX or last resort, use product-wide constant
-	if (pStrStandard == NULL)
-	{
+	if (pStrStandard == NULL) {
 		pStrStandard = new char[strlen(IOVER_FILEVERSION) + 1];
+
 		strcpy(pStrStandard, IOVER_FILEVERSION);
 	}
 
 	*ppStrStandard = pStrStandard;
 	*ppStrWithDebug = new char[strlen(pStrStandard) + strlen(VERSION_DEBUG) + 1];
+
 	strcpy(*ppStrWithDebug, pStrStandard);
 	strcat(*ppStrWithDebug, VERSION_DEBUG);
 }
-

Modified: branches/IOMETER-restruct/iometer/src/IOGrunt.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOGrunt.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOGrunt.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -93,36 +93,31 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
-
 #include "IOGrunt.h"
 #include "IOTargetDisk.h"
 #include "IOTargetTCP.h"
 
 #if defined(IOMTR_SETTING_VI_SUPPORT)
- #include "IOTargetVI.h"
+#include "IOTargetVI.h"
 #endif
 
 #if defined(IOMTR_OS_SOLARIS)
- #include <thread.h>
+#include <thread.h>
 #endif
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE)
- #include <assert.h>
+#include <assert.h>
 #endif
 
-
 #if defined(IOMTR_OS_NETWARE)
-void nwtime(timeb *a)
+void nwtime(timeb * a)
 {
 	double time = clock();
 
-	a->time    = time / CLOCKS_PER_SEC;
-	a->millitm = (time - (a->time*CLOCKS_PER_SEC)) * 10;
-} 
+	a->time = time / CLOCKS_PER_SEC;
+	a->millitm = (time - (a->time * CLOCKS_PER_SEC)) * 10;
+}
 #endif
 
-
-
 //
 // Initializing Grunt variables before their first use.
 //
@@ -153,110 +148,102 @@
 	targets = NULL;
 }
 
-
-
 //
 // Grunt destructor.
 //
 Grunt::~Grunt()
 {
 	// Remove completion queue, if any.
-	if ( (type != InvalidType) && !IsType(type, GenericVIType) && io_cq )
+	if ((type != InvalidType) && !IsType(type, GenericVIType) && io_cq)
 		delete io_cq;
 
-	Size_Target_Array( 0 );
+	Size_Target_Array(0);
 
 	// Release grunt's I/O data buffers if they are in use.
-	if ( data_size )
+	if (data_size)
 #if defined(IOMTR_OSFAMILY_NETWARE)
-		NXMemFree( read_data );
-		NXMemFree( write_data );
+		NXMemFree(read_data);
+	NXMemFree(write_data);
 #elif defined(IOMTR_OSFAMILY_UNIX)
-		free( read_data );
-		free( write_data );
+		free(read_data);
+	free(write_data);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-		VirtualFree( read_data, 0, MEM_RELEASE );
-		VirtualFree( write_data, 0, MEM_RELEASE );
+		VirtualFree(read_data, 0, MEM_RELEASE);
+	VirtualFree(write_data, 0, MEM_RELEASE);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	Free_Transaction_Arrays();
+		Free_Transaction_Arrays();
 }
 
-
-
 //
 // Initialize all results for all targets.
 //
 void Grunt::Initialize_Results()
 {
-	memset( &worker_performance, 0, sizeof(Worker_Results) );
-	memset( &prev_worker_performance, 0, sizeof(Worker_Results) );
+	memset(&worker_performance, 0, sizeof(Worker_Results));
+	memset(&prev_worker_performance, 0, sizeof(Worker_Results));
 }
 
-
-
 //
 // Setting the size of the target array to hold the number and type of 
 // targets specified.  If the requested number of targets is 0, the 
 // array will be freed.
 //
-BOOL Grunt::Size_Target_Array( int count, const Target_Spec *target_specs )
+BOOL Grunt::Size_Target_Array(int count, const Target_Spec * target_specs)
 {
 	int i;
 
 	// Free all current targets.  This is needed in case the newer targets
 	// are of a different type, even if we have the same number of targets.
-	for ( i = 0; i < target_count; i++ )
+	for (i = 0; i < target_count; i++)
 		delete targets[i];
+
 	target_count = 0;
 
 	// Reset the grunt's target type.
 	type = InvalidType;
 
 	// Release the memory if everything is being freed.
-	if ( !count || !target_specs )
-	{
+	if (!count || !target_specs) {
 #if defined(IOMTR_OSFAMILY_NETWARE)
-		NXMemFree( targets );
+		NXMemFree(targets);
 #elif defined(IOMTR_OSFAMILY_UNIX)
-		free( targets );
+		free(targets);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-		free( targets );   // TODO: Check if VirtualFree() is not needed here.
+		free(targets);	// TODO: Check if VirtualFree() is not needed here.
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		targets = NULL;
 		return TRUE;
 	}
-
 	// Allocate enough pointers to refer to all targets.
-#if defined(IOMTR_OSFAMILY_NETWARE)	
-	targets = (Target**)NXMemRealloc( targets, sizeof(Target*) * count, 1 );
+#if defined(IOMTR_OSFAMILY_NETWARE)
+	targets = (Target **) NXMemRealloc(targets, sizeof(Target *) * count, 1);
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
-	targets = (Target**)realloc( targets, sizeof(Target*) * count );
+	targets = (Target **) realloc(targets, sizeof(Target *) * count);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	if ( !targets )
+	if (!targets)
 		return FALSE;
 
 	// Create the requested number of targets.
-	for ( i = 0; i < count; i++ )
-	{
-		type = (TargetType)(type | target_specs[i].type);
+	for (i = 0; i < count; i++) {
+		type = (TargetType) (type | target_specs[i].type);
 
-		if ( IsType( target_specs[i].type, GenericDiskType ) )
+		if (IsType(target_specs[i].type, GenericDiskType))
 			targets[i] = new TargetDisk;
-		else if ( IsType( target_specs[i].type, GenericTCPType ) )
+		else if (IsType(target_specs[i].type, GenericTCPType))
 			targets[i] = new TargetTCP;
 #if defined(IOMTR_SETTING_VI_SUPPORT)
-		else if ( IsType( target_specs[i].type, GenericVIType ) )
+		else if (IsType(target_specs[i].type, GenericVIType))
 			targets[i] = new TargetVI;
-#endif // IOMTR_SETTING_VI_SUPPORT
+#endif				// IOMTR_SETTING_VI_SUPPORT
 
-		if ( !targets[i] )
+		if (!targets[i])
 			return FALSE;
 	}
 
@@ -264,26 +251,22 @@
 	return TRUE;
 }
 
-
-
 //
 // Checking and resizing the related transaction arrays based on the requested
 // number of outstanding I/Os.
 //
 BOOL Grunt::Resize_Transaction_Arrays()
 {
-	int	i;
-	int	max_queue_per_target = 0;
-	void	*new_mem;
+	int i;
+	int max_queue_per_target = 0;
+	void *new_mem;
 
 	cur_trans_slots = 0;
 
 	// Get the maximum number of I/O's which can be outstanding at one time 
 	// to all targets and a single target.
-	for ( i = 0; i < target_count; i++ )
-	{
-		max_queue_per_target = __max( targets[i]->spec.queue_depth,
-			max_queue_per_target );
+	for (i = 0; i < target_count; i++) {
+		max_queue_per_target = __max(targets[i]->spec.queue_depth, max_queue_per_target);
 		cur_trans_slots += targets[i]->spec.queue_depth;
 	}
 
@@ -294,108 +277,98 @@
 #elif(IOMTR_OSFAMILY_WINDOWS)
 	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	
+
 	//
 	// Ensure that the related I/O request arrays are large enough.
 	//
-	if ( total_trans_slots >= cur_trans_slots ) {
+	if (total_trans_slots >= cur_trans_slots) {
 		return TRUE;
 	}
-
 	// Grow the transaction array.  We perform two casts to ensure that the
 	// memory is aligned properly.
-#if defined(IOMTR_OSFAMILY_NETWARE)	
-	if ( !(new_mem = (void*)((Transaction*)NXMemRealloc( trans_slots, cur_trans_slots * sizeof(Transaction), 1 )) ) )
+#if defined(IOMTR_OSFAMILY_NETWARE)
+	if (!(new_mem = (void *)((Transaction *) NXMemRealloc(trans_slots, cur_trans_slots * sizeof(Transaction), 1))))
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
-	if ( !(new_mem = (void*)((Transaction*)realloc( trans_slots, cur_trans_slots * sizeof(Transaction) )) ) )
+	if (!(new_mem = (void *)((Transaction *) realloc(trans_slots, cur_trans_slots * sizeof(Transaction)))))
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		Free_Transaction_Arrays();
 		cout << "*** Grunt could not allocate transaction request list." << endl;
 		return FALSE;
 	}
-	trans_slots = (Transaction*)new_mem;
+	trans_slots = (Transaction *) new_mem;
 
 	// Grow the available queue.  We need one more element in the available
 	// queue than there are transactions.  This allows us to determine if the
 	// queue is empty by checking that head == tail.  (Without it, head == tail
 	// could also indicate that the queue is entirely full.)
-#if defined(IOMTR_OSFAMILY_NETWARE)	
-	if ( !(new_mem = (void*)((int*)NXMemRealloc( available_trans_queue, 
-		(cur_trans_slots + 1) * sizeof(int), 1 )) ) )
+#if defined(IOMTR_OSFAMILY_NETWARE)
+	if (!(new_mem = (void *)((int *)NXMemRealloc(available_trans_queue, (cur_trans_slots + 1) * sizeof(int), 1))))
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
-	if ( !(new_mem = (void*)((int*)realloc( available_trans_queue, 
-		(cur_trans_slots + 1) * sizeof(int) )) ) )
+	if (!(new_mem = (void *)((int *)realloc(available_trans_queue, (cur_trans_slots + 1) * sizeof(int)))))
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		Free_Transaction_Arrays();
 		cout << "*** Grunt could not allocate available queue." << endl;
 		return FALSE;
 	}
-	available_trans_queue = (int*)new_mem;
+	available_trans_queue = (int *)new_mem;
 
 	// Successfully resized all related transaction arrays.
 	total_trans_slots = cur_trans_slots;
 	return TRUE;
 }
 
-
-
 //
 // Free all memory associated with related I/O request arrays.
 //
 void Grunt::Free_Transaction_Arrays()
 {
-	if ( trans_slots )
-#if defined(IOMTR_OSFAMILY_NETWARE)	
-		NXMemFree( trans_slots );
+	if (trans_slots)
+#if defined(IOMTR_OSFAMILY_NETWARE)
+		NXMemFree(trans_slots);
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
-		free( trans_slots );
+		free(trans_slots);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	if ( available_trans_queue )
-#if defined(IOMTR_OSFAMILY_NETWARE)	
-		NXMemFree( available_trans_queue );
+		if (available_trans_queue)
+#if defined(IOMTR_OSFAMILY_NETWARE)
+			NXMemFree(available_trans_queue);
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
-		free( available_trans_queue );
+			free(available_trans_queue);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	total_trans_slots = 0;
+			total_trans_slots = 0;
 	cur_trans_slots = 0;
 }
 
-
-
 //
 // Initialize transaction availability queue.
 //
 void Grunt::Initialize_Transaction_Arrays()
 {
-	int		i, depth;
-	int		max_queue_per_target = 0;
-	int		trans_slot = 0;
+	int i, depth;
+	int max_queue_per_target = 0;
+	int trans_slot = 0;
 
 	// Get the maximum number of I/O's which can be outstanding at one time 
 	// to a single target.
-	for ( i = 0; i < target_count; i++ )
-	{
-		max_queue_per_target = __max( targets[i]->spec.queue_depth,
-			max_queue_per_target );
+	for (i = 0; i < target_count; i++) {
+		max_queue_per_target = __max(targets[i]->spec.queue_depth, max_queue_per_target);
 	}
 
 	//
 	// Initialize transaction information.
 	//
-	for ( i = 0; i < cur_trans_slots; i++ )
-	{
+	for (i = 0; i < cur_trans_slots; i++) {
 		trans_slots[i].asynchronous_io.hEvent = NULL;
 		trans_slots[i].request_number = i;
 
@@ -408,12 +381,9 @@
 	available_tail = 0;
 
 	// Adding transactions to available queue in a round robin fashion.
-	for ( depth = 0; depth < max_queue_per_target; depth++ )
-	{
-		for ( i = 0; i < target_count; i++ )
-		{
-			if ( targets[i]->spec.queue_depth > depth )
-			{
+	for (depth = 0; depth < max_queue_per_target; depth++) {
+		for (i = 0; i < target_count; i++) {
+			if (targets[i]->spec.queue_depth > depth) {
 				trans_slots[trans_slot++].target_id = i;
 				// We have to init available_trans_queue[] slots in two steps
 				// because the order of execution could give different results
@@ -425,29 +395,24 @@
 	}
 }
 
-
-
 //
 // Setting the targets that this grunt will access.
 //
-BOOL Grunt::Set_Targets( int count, Target_Spec *target_specs )
+BOOL Grunt::Set_Targets(int count, Target_Spec * target_specs)
 {
 	// Remove previous completion queue if it was created by the Grunt.
-	if ( !IsType( type, GenericVIType ) && io_cq )
-	{
+	if (!IsType(type, GenericVIType) && io_cq) {
 		delete io_cq;
 	}
 	io_cq = NULL;
 
 	// If no targets are being set, simply clear the target list.
-	if ( !count )
-	{
+	if (!count) {
 		cout << "   clearing target list." << endl;
-		return Size_Target_Array( 0 );
+		return Size_Target_Array(0);
 	}
-
 	// Allocate enough targets
-	if ( !Size_Target_Array( count, target_specs ) )
+	if (!Size_Target_Array(count, target_specs))
 		return FALSE;
 
 	worker_performance.target_results.count = count;
@@ -456,124 +421,109 @@
 	// If the Grunt will manage VI targets, the targets will provide a
 	// pointer to the completion queue to use.
 #if defined(IOMTR_SETTING_VI_SUPPORT)
-	if ( IsType( type, GenericVIType ) )
-	{
+	if (IsType(type, GenericVIType)) {
 		// VI targets must know where the data buffer is and its size before
 		// being initialized.
-		((TargetVI*)targets[0])->data_buffer = (char*) read_data;
-		((TargetVI*)targets[0])->data_buffer_size = access_spec.max_transfer;
-		io_cq = &((TargetVI*)targets[0])->vi.vi_cq;
-	}
-	else
-#endif // IOMTR_SETTING_VI_SUPPORT
+		((TargetVI *) targets[0])->data_buffer = (char *)read_data;
+		((TargetVI *) targets[0])->data_buffer_size = access_spec.max_transfer;
+		io_cq = &((TargetVI *) targets[0])->vi.vi_cq;
+	} else
+#endif				// IOMTR_SETTING_VI_SUPPORT
 	{
 		// Create completion queue and verify its creation.
-		if ( !(io_cq = new CQAIO) )
-		{
-			cout << "*** Unable to create completion queue while setting "
-				<< "targets." << endl;
+		if (!(io_cq = new CQAIO)) {
+			cout << "*** Unable to create completion queue while setting " << "targets." << endl;
 			return FALSE;
 		}
 	}
 
 	// Initialize the specific targets.
-	for ( int i = 0; i < count; i++ )
-	{
-		if ( !targets[i]->Initialize( &target_specs[i], io_cq ) )
+	for (int i = 0; i < count; i++) {
+		if (!targets[i]->Initialize(&target_specs[i], io_cq))
 			return FALSE;
 	}
 
 	// Seed the random number generator.  Grunts transferring data over a
 	// network will use the same seed to produce the same sequence of random
 	// numbers.  This will keep them in synch.
-	Srand( target_specs[0].random );
+	Srand(target_specs[0].random);
 
 	return Resize_Transaction_Arrays();
 }
 
-
-
 //
 // Start recording test data.
 //
 void Grunt::Record_On()
 {
-	if ( !target_count || idle || critical_error )
+	if (!target_count || idle || critical_error)
 		return;
 
 	worker_performance.time[FIRST_SNAPSHOT] = rdtsc();
 	prev_worker_performance.time[LAST_SNAPSHOT] = rdtsc();
 
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(int) &grunt_state, (int)TestRecording );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(int)&grunt_state, (int)TestRecording);
 }
 
-
-
 //
 // Stop recording test data.
 //
 void Grunt::Record_Off()
 {
-	if ( !target_count || idle || critical_error )
+	if (!target_count || idle || critical_error)
 		return;
 
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(int) &grunt_state, (int)TestRampingDown );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(int)&grunt_state, (int)TestRampingDown);
 	worker_performance.time[LAST_SNAPSHOT] = rdtsc();
 }
 
-
-
 //
 // Stopping a test.
 //
 void Grunt::Stop_Test()
 {
-	if ( !target_count || idle || critical_error )
+	if (!target_count || idle || critical_error)
 		return;
 
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(long) &not_ready,   1L );
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(int)  &grunt_state, (int)TestIdle );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(long)&not_ready, 1L);
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(int) & grunt_state, (int)TestIdle);
 }
 
-
-
 //
 // Waiting for threads to process stop command.
 //
 void Grunt::Wait_For_Stop()
 {
-	if ( !target_count || idle )
+	if (!target_count || idle)
 		return;
 
 	// Waiting for all threads to finish.
-	while ( not_ready )
-		Sleep( 1 );
+	while (not_ready)
+		Sleep(1);
 }
 
-
-
 //
 // Setting access specifications for worker.  Also ensuring that a data buffer
 // large enough to support the maximum requested transfer has been allocated.
 // Note that Iometer will call Set_Access before testing starts to ensure that
 // Dynamo can run the spec with the largest transfer request.
 //
-BOOL Grunt::Set_Access( const Test_Spec* spec )
+BOOL Grunt::Set_Access(const Test_Spec * spec)
 {
 	// Check for idle spec.
-	if ((idle = ( spec->access[0].of_size == IOERROR)))
+	if ((idle = (spec->access[0].of_size == IOERROR)))
 		return TRUE;
 
-	access_spec.Initialize( &(spec->access[0]) );
+	access_spec.Initialize(&(spec->access[0]));
 
 	// Allocate a data buffer large enough to support the maximum requested 
 	// transfer.  We do this only if the current buffer is too small and
 	// we're using per worker data buffers.
-	if ( data_size >= access_spec.max_transfer ) {
-		cout << "Grunt: Grunt data buffer size " << data_size << " >= " 
-			 << access_spec.max_transfer << ", returning" << endl;
+	if (data_size >= access_spec.max_transfer) {
+		cout << "Grunt: Grunt data buffer size " << data_size << " >= "
+		    << access_spec.max_transfer << ", returning" << endl;
 		return TRUE;
-	} else if ( !data_size ) {
+	} else if (!data_size) {
 		// We always want to use our own buffers, not the manager's
 		// buffer.  This is due to a bug in some ServerWorks chipsets
 		// (confirmed on the HE-SL chipset) where performing both
@@ -585,35 +535,33 @@
 		// aren't thrashing on the same buffer for both read and
 		// write operations.
 		data_size = access_spec.max_transfer;
-		cout << "Grunt: Growing grunt data buffer from " << data_size << " to " 
-			 << access_spec.max_transfer << endl;
+		cout << "Grunt: Growing grunt data buffer from " << data_size << " to "
+		    << access_spec.max_transfer << endl;
 	}
-
 	// Allocating a larger buffer.
-	#if _DEBUG
-		cout << "Growing grunt data buffers from " << data_size << " to " 
-			 << access_spec.max_transfer << endl;
-	#endif
+#if _DEBUG
+	cout << "Growing grunt data buffers from " << data_size << " to " << access_spec.max_transfer << endl;
+#endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
-	if ( read_data ) {
-		NXMemFree( read_data );
+	if (read_data) {
+		NXMemFree(read_data);
 	}
 	errno = 0;
-	if ( !(read_data = NXMemAlloc(access_spec.max_transfer, 1) ))
+	if (!(read_data = NXMemAlloc(access_spec.max_transfer, 1)))
 #elif defined(IOMTR_OSFAMILY_UNIX)
-	if ( read_data ) {
-		free( read_data );
+	if (read_data) {
+		free(read_data);
 	}
 	errno = 0;
-	if ( !(read_data = valloc(access_spec.max_transfer) ))		
+	if (!(read_data = valloc(access_spec.max_transfer)))
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-	if ( read_data ) {
-		VirtualFree( read_data, 0, MEM_RELEASE );
+	if (read_data) {
+		VirtualFree(read_data, 0, MEM_RELEASE);
 	}
-	if ( !(read_data = VirtualAlloc(NULL, access_spec.max_transfer, MEM_COMMIT, PAGE_READWRITE)))
+	if (!(read_data = VirtualAlloc(NULL, access_spec.max_transfer, MEM_COMMIT, PAGE_READWRITE)))
 #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		// Could not allocate a larger buffer.  Signal failure.
@@ -623,24 +571,24 @@
 	}
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
-	if ( write_data ) {
-		NXMemFree( write_data );
+	if (write_data) {
+		NXMemFree(write_data);
 	}
 	errno = 0;
-	if ( !(write_data = NXMemAlloc(access_spec.max_transfer, 1) ))
+	if (!(write_data = NXMemAlloc(access_spec.max_transfer, 1)))
 #elif defined(IOMTR_OSFAMILY_UNIX)
-	if ( write_data ) {
-		free( write_data );
+	if (write_data) {
+		free(write_data);
 	}
 	errno = 0;
-	if ( !(write_data = valloc(access_spec.max_transfer) ))
+	if (!(write_data = valloc(access_spec.max_transfer)))
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-	if ( write_data ) {
-		VirtualFree( write_data, 0, MEM_RELEASE );
+	if (write_data) {
+		VirtualFree(write_data, 0, MEM_RELEASE);
 	}
-	if ( !(write_data = VirtualAlloc(NULL, access_spec.max_transfer, MEM_COMMIT, PAGE_READWRITE)))
+	if (!(write_data = VirtualAlloc(NULL, access_spec.max_transfer, MEM_COMMIT, PAGE_READWRITE)))
 #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		// Could not allocate a larger buffer.  Signal failure.
@@ -653,9 +601,6 @@
 	return TRUE;
 }
 
-
-
-
 //
 // Starting threads to prepare disks for tests.  Returning TRUE if we
 // successfully started the disk preparation.
@@ -667,99 +612,93 @@
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
 	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 	grunt_state = TestPreparing;
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(long) &not_ready, (long)target_count );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(long)&not_ready, (long)target_count);
 
 	// Creating a thread to prepare each disk.
 	cout << "Preparing disks..." << endl;
 
-#if defined(IOMTR_OSFAMILY_NETWARE)	
-	prepare_thread = (Thread_Info*)NXMemAlloc(sizeof(Thread_Info) * target_count, 1 );
+#if defined(IOMTR_OSFAMILY_NETWARE)
+	prepare_thread = (Thread_Info *) NXMemAlloc(sizeof(Thread_Info) * target_count, 1);
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
-	prepare_thread = (Thread_Info*)malloc(sizeof(Thread_Info) * target_count );
+	prepare_thread = (Thread_Info *) malloc(sizeof(Thread_Info) * target_count);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	if ( !prepare_thread )
-	{
+	if (!prepare_thread) {
 		cout << "*** Unable to allocate memory for preparation threads." << endl;
 		return FALSE;
 	};
 
-	for ( int i = 0; i < target_count; i++ )
-	{
-		if ( IsType( targets[i]->spec.type, LogicalDiskType ) )
-		{
+	for (int i = 0; i < target_count; i++) {
+		if (IsType(targets[i]->spec.type, LogicalDiskType)) {
 			prepare_thread[i].parent = this;
 			prepare_thread[i].id = i;
 			cout << "   " << targets[i]->spec.name << " preparing." << endl;
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 			// Assuming that thr_create call will not fail !!!
 
-			pthread_create(&newThread, NULL, (void *(*)(void *))Prepare_Disk_Wrapper, 
-										 (void *) &(prepare_thread[i]));
+			pthread_create(&newThread, NULL, (void *(*)(void *))Prepare_Disk_Wrapper,
+				       (void *)&(prepare_thread[i]));
 			pthread_detach(newThread);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-			_beginthread( Prepare_Disk_Wrapper, 0, (void *) &(prepare_thread[i]) );
+			_beginthread(Prepare_Disk_Wrapper, 0, (void *)&(prepare_thread[i]));
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		}
 	}
 	return TRUE;
 }
 
-
-
 //
 // Wrapper for Grunt::Prepare_Disk(), used by _beginthread().
 //
-void CDECL Prepare_Disk_Wrapper( void* disk_thread_info )
+void CDECL Prepare_Disk_Wrapper(void *disk_thread_info)
 {
-	Grunt *grunt = (Grunt *)(((Thread_Info *)disk_thread_info)->parent);
-	int    disk_id = ((Thread_Info*)disk_thread_info)->id;
-	
-	grunt->Prepare_Disk( disk_id );
+	Grunt *grunt = (Grunt *) (((Thread_Info *) disk_thread_info)->parent);
+	int disk_id = ((Thread_Info *) disk_thread_info)->id;
+
+	grunt->Prepare_Disk(disk_id);
 }
 
-
-
 //
 // Preparing a disk for access by a worker thread.  The disk must have been 
 // previously initialized.
 //
-void Grunt::Prepare_Disk( int disk_id )
+void Grunt::Prepare_Disk(int disk_id)
 {
-	void		*buffer = NULL;
-	DWORD		buffer_size;
-	DWORDLONG	prepare_offset = 0;
-	TargetDisk	*disk = (TargetDisk *) targets[disk_id];
+	void *buffer = NULL;
+	DWORD buffer_size;
+	DWORDLONG prepare_offset = 0;
+	TargetDisk *disk = (TargetDisk *) targets[disk_id];
 
 	critical_error = FALSE;
 
 	// Allocate a large (64k for 512 byte sector size) buffer for the preparation.
 	buffer_size = disk->spec.disk_info.sector_size * 128;
 #if defined(IOMTR_OSFAMILY_NETWARE)
-	NXMemFree( buffer );
+	NXMemFree(buffer);
 	errno = 0;
-	if ( !(buffer = NXMemAlloc(buffer_size, 1) ))
+	if (!(buffer = NXMemAlloc(buffer_size, 1)))
 #elif defined(IOMTR_OSFAMILY_UNIX)
-	free( buffer );
+	free(buffer);
 	errno = 0;
-	if ( !(buffer = valloc(buffer_size) ))
+	if (!(buffer = valloc(buffer_size)))
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-	VirtualFree( buffer, 0, MEM_RELEASE );
-	if ( !(buffer = VirtualAlloc( NULL, buffer_size, MEM_COMMIT, PAGE_READWRITE )) )
+	VirtualFree(buffer, 0, MEM_RELEASE);
+	if (!(buffer = VirtualAlloc(NULL, buffer_size, MEM_COMMIT, PAGE_READWRITE)))
 #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		cout << "*** Could not allocate buffer to prepare disk." << endl;
 		critical_error = TRUE;
-		InterlockedDecrement( IOMTR_MACRO_INTERLOCK_CAST(long) &not_ready );
+		InterlockedDecrement(IOMTR_MACRO_INTERLOCK_CAST(long) & not_ready);
+
 		return;
 	}
 
@@ -777,44 +716,40 @@
 	// than the available space on the disk. A later write to the unfilled
 	// portion throws up an ENOSPC error. To avoid this problem, we use the
 	// O_APPEND flag which always sets the write offset to the eof.
-	if ( !disk->Open( &grunt_state, O_APPEND ) )
+	if (!disk->Open(&grunt_state, O_APPEND))
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-	if ( !disk->Open( &grunt_state ) )
+	if (!disk->Open(&grunt_state))
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		cout << "*** Could not open disk." << endl;
 		critical_error = TRUE;
 	}
-	else
-	{
+	else {
 		// Prepare the disk, first with large block sizes, then with single sectors.
-		if ( !disk->Prepare( buffer, &prepare_offset, buffer_size, &grunt_state ) ||
-			 !disk->Prepare( buffer, &prepare_offset, disk->spec.disk_info.sector_size, &grunt_state ) )
-		{
+		if (!disk->Prepare(buffer, &prepare_offset, buffer_size, &grunt_state) ||
+		    !disk->Prepare(buffer, &prepare_offset, disk->spec.disk_info.sector_size, &grunt_state)) {
 			cout << "*** An error occurred while preparing the disk." << endl;
 			critical_error = TRUE;
 		}
 
-		disk->Close( NULL );
+		disk->Close(NULL);
 	}
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
-	NXMemFree( buffer );
+	NXMemFree(buffer);
 #elif defined(IOMTR_OSFAMILY_UNIX)
-	free( buffer );
+	free(buffer);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-	VirtualFree( buffer, 0, MEM_RELEASE );
+	VirtualFree(buffer, 0, MEM_RELEASE);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	cout << "   " << disk->spec.name << " done." << endl;
-	InterlockedDecrement( IOMTR_MACRO_INTERLOCK_CAST(long) &not_ready );
+	InterlockedDecrement(IOMTR_MACRO_INTERLOCK_CAST(long) & not_ready);
 }
 
-
-
  //
 // Recording information about an asynchronous I/O.  The results of the
 // I/O may or may not actually be added to the total results, depending on if
@@ -826,76 +761,63 @@
 // Each I/O is part of a transaction.  The transaction slots hold information
 // about the number of I/Os remaining in each transaction.
 //
-void Grunt::Record_IO( Transaction *transaction, DWORDLONG end_IO )
+void Grunt::Record_IO(Transaction * transaction, DWORDLONG end_IO)
 {
-	DWORDLONG	transfer_time;			// Time to complete a successful transfer.
-	Raw_Result	*result = &(worker_performance.target_results.result[transaction->target_id]);
-	Raw_Result	*prev_result = &(prev_worker_performance.target_results.result[transaction->target_id]);
+	DWORDLONG transfer_time;	// Time to complete a successful transfer.
+	Raw_Result *result = &(worker_performance.target_results.result[transaction->target_id]);
+	Raw_Result *prev_result = &(prev_worker_performance.target_results.result[transaction->target_id]);
 
 	// Update the target's number of outstanding I/Os.
 	targets[transaction->target_id]->outstanding_ios--;
-	
+
 	// Update the grunt's number of outstanding I/Os
 	outstanding_ios--;
 
 	// See if it's okay to record the completed I/O.
-	if ( transaction->start_IO && (ramp_up_ios_pending <= 0) && (grunt_state == TestRecording) )
-	{
+	if (transaction->start_IO && (ramp_up_ios_pending <= 0) && (grunt_state == TestRecording)) {
 		// Updating results for I/O.
 		// (If end_IO is zero, this value won't be used anyway)
 		transfer_time = end_IO - transaction->start_IO;
 
 		// Calculating is_read...the value is the opposite for client threads.
-		if ( transaction->is_read ^ IsType( targets[transaction->target_id]->spec.type,
-			GenericServerType ) )
-		{
-			if ( end_IO )
-			{
+		if (transaction->is_read ^ IsType(targets[transaction->target_id]->spec.type, GenericServerType)) {
+			if (end_IO) {
 				// I/O was completed without an error.
 				result->read_count++;
 				result->bytes_read += transaction->remaining_requests
-										? transaction->request_size
-										: transaction->reply_size;
+				    ? transaction->request_size : transaction->reply_size;
 				result->read_latency_sum += transfer_time;
 				// Finding if last transfer took the longest.
-				if ( transfer_time > result->max_raw_read_latency )
+				if (transfer_time > result->max_raw_read_latency)
 					result->max_raw_read_latency = transfer_time;
-				if ( transfer_time > prev_result->max_raw_read_latency )
+				if (transfer_time > prev_result->max_raw_read_latency)
 					prev_result->max_raw_read_latency = transfer_time;
-			}
-			else
-			{
+			} else {
 				// Error occurred.
 				result->read_errors++;
 			}
-		}
-		else	// was a write I/O
+		} else		// was a write I/O
 		{
-			if ( end_IO )
-			{
+			if (end_IO) {
 				// I/O was completed without an error.
 				result->write_count++;
 				result->bytes_written += transaction->remaining_requests
-											? transaction->request_size
-											: transaction->reply_size;
+				    ? transaction->request_size : transaction->reply_size;
 				result->write_latency_sum += transfer_time;
 				// Finding if last transfer took the longest.
-				if ( transfer_time > result->max_raw_write_latency )
+				if (transfer_time > result->max_raw_write_latency)
 					result->max_raw_write_latency = transfer_time;
-				if ( transfer_time > prev_result->max_raw_write_latency )
+				if (transfer_time > prev_result->max_raw_write_latency)
 					prev_result->max_raw_write_latency = transfer_time;
-			}
-			else
-			{
+			} else {
 				// Error occurred.
 				result->write_errors++;
 			}
 		}
 
 		// If this I/O was the last in the transaction, record the transaction time.
-		if ( transaction->start_transaction &&
-			(transaction->remaining_requests + transaction->remaining_replies) == 1)
-		{
+		if (transaction->start_transaction &&
+		    (transaction->remaining_requests + transaction->remaining_replies) == 1) {
 			// A transaction was completed.
 			result->transaction_count++;
 
@@ -904,24 +826,20 @@
 			transfer_time = end_IO - transaction->start_transaction;
 
 			result->transaction_latency_sum += transfer_time;
-			if ( transfer_time > result->max_raw_transaction_latency )
+			if (transfer_time > result->max_raw_transaction_latency)
 				result->max_raw_transaction_latency = transfer_time;
-			if ( transfer_time > prev_result->max_raw_transaction_latency )
+			if (transfer_time > prev_result->max_raw_transaction_latency)
 				prev_result->max_raw_transaction_latency = transfer_time;
 		}
-	}
-	else
-	{
+	} else {
 		// there was no starting time on this transfer
 
-		if ( ramp_up_ios_pending )
-		{
+		if (ramp_up_ios_pending) {
 			--ramp_up_ios_pending;
 
 			// If ramp_up_ios_pending just went to ZERO and the grunt is in the
 			// recording state, set the test's start_counter to the current time.
-			if ( (ramp_up_ios_pending <= 0) && (grunt_state == TestRecording) )
-			{
+			if ((ramp_up_ios_pending <= 0) && (grunt_state == TestRecording)) {
 				worker_performance.time[FIRST_SNAPSHOT] = rdtsc();
 			}
 		}
@@ -929,88 +847,77 @@
 
 	// If there are any REQUEST I/Os remaining for this transfer
 	// deduct the completed I/O from the REQUEST counter.
-	if ( transaction->remaining_requests > 0 )
-	{
-		if ( ! --(transaction->remaining_requests) )
-		{
+	if (transaction->remaining_requests > 0) {
+		if (!--(transaction->remaining_requests)) {
 			// If this was the last REQUEST, start replies
 			transaction->is_read = !transaction->is_read;
 		}
-	}
-	else
-	#ifdef _DEBUG
-		if ( transaction->remaining_requests == 0 && transaction->remaining_replies > 0 )
-	#endif
+	} else
+#ifdef _DEBUG
+	if (transaction->remaining_requests == 0 && transaction->remaining_replies > 0)
+#endif
 	{
 		--transaction->remaining_replies;
 	}
-	#ifdef _DEBUG
-	else
-	{
-		if ( transaction->remaining_requests < 0 )
+#ifdef _DEBUG
+	else {
+		if (transaction->remaining_requests < 0)
 			cout << "*** ERROR: remaining_requests is negative" << endl;
 
-		if ( transaction->remaining_replies < 0 )
+		if (transaction->remaining_replies < 0)
 			cout << "*** ERROR: remaining_replies is negative" << endl;
 	}
-	#endif
+#endif
 
 	// Put this transaction slot back on the available queue.
 	available_trans_queue[available_tail] = transaction->request_number;
-	if ( (++available_tail) > cur_trans_slots ) {
+	if ((++available_tail) > cur_trans_slots) {
 		available_tail = 0;
 	}
 }
 
-
-
 //
 // Inserting a delay between transfers.  We still need to process completed 
 // I/O's, but no new ones should be initiated.
 //
-void Grunt::Asynchronous_Delay( int transfer_delay )
+void Grunt::Asynchronous_Delay(int transfer_delay)
 {
-	struct _timeb	start_wait_time;	// Time before thread started waiting for an I/O to complete.
-	struct _timeb	end_wait_time;		// Time after a thread waited for an I/O to complete./
+	struct _timeb start_wait_time;	// Time before thread started waiting for an I/O to complete.
+	struct _timeb end_wait_time;	// Time after a thread waited for an I/O to complete./
 
-	do
-	{
-		_ftime( &start_wait_time );
+	do {
+		_ftime(&start_wait_time);
 
-		if ( Complete_IO( transfer_delay ) == ReturnTimeout )
+		if (Complete_IO(transfer_delay) == ReturnTimeout)
 			return;
 
 		// More waiting is needed before allowing additional requests.
-		_ftime( &end_wait_time );
-		transfer_delay -= ( ( ( end_wait_time._time - start_wait_time._time ) * 1000 )
-			+ end_wait_time._millitm - start_wait_time._millitm );
+		_ftime(&end_wait_time);
+		transfer_delay -= (((end_wait_time._time - start_wait_time._time) * 1000)
+				   + end_wait_time._millitm - start_wait_time._millitm);
 	}
-	while ( transfer_delay > 0 );
+	while (transfer_delay > 0);
 }
 
-
-
 //
 // Wrapper for Grunt::DoIOs(), used by _beginthread().
 //
-void CDECL Grunt_Thread_Wrapper( void* grunt )
+void CDECL Grunt_Thread_Wrapper(void *grunt)
 {
 	// open targets
-	((Grunt*)grunt)->Open_Targets();
+	((Grunt *) grunt)->Open_Targets();
 
 	// If open failed, abort.
-	if ( ((Grunt*)grunt)->critical_error )
+	if (((Grunt *) grunt)->critical_error)
 		return;
 
 	// run the tests
-	((Grunt*)grunt)->Do_IOs();
+	((Grunt *) grunt)->Do_IOs();
 
 	// close targets
-	((Grunt*)grunt)->Close_Targets();
+	((Grunt *) grunt)->Close_Targets();
 }
 
-
-
 //
 // Opens all targets before Do_IOs() runs - returns FALSE if any opens failed
 // (In case of failure, this function will behave as if it is running the IO tests.)
@@ -1020,51 +927,43 @@
 void Grunt::Open_Targets()
 {
 	int i;
+
 	// Opening all targets for access.
 	cout << "   Opening targets." << endl;
-	for ( i = 0; i < target_count; i++ )
-	{
+	for (i = 0; i < target_count; i++) {
 		// All targets are opened to ensure that they can connect.
-		if ( !targets[i]->Open( &grunt_state ) )
-		{
+		if (!targets[i]->Open(&grunt_state)) {
 			// An error occurred opening a target.  Do not go any further.
 			cout << "*** Error opening " << targets[i]->spec.name << endl;
 			break;
 		}
-		#if _DETAILS
-			cout << "Opened " << targets[i]->spec.name << endl;
-		#endif
+#if _DETAILS
+		cout << "Opened " << targets[i]->spec.name << endl;
+#endif
 
 		// If the target is testing connection rate, it will be opened when
 		// we first begin doing I/O.  Close these targets.
-		if ( targets[i]->spec.test_connection_rate )
-		{
+		if (targets[i]->spec.test_connection_rate) {
 			targets[i]->trans_left_in_conn = 0;
-			#if _DEBUG
-				cout << "Defering open for " << targets[i]->spec.name << endl;
-			#endif
-			if ( !targets[i]->Close( &grunt_state ) )
-			{
-				cout << "*** Error re-closing target " << targets[i]->spec.name
-					<< endl;
+#if _DEBUG
+			cout << "Defering open for " << targets[i]->spec.name << endl;
+#endif
+			if (!targets[i]->Close(&grunt_state)) {
+				cout << "*** Error re-closing target " << targets[i]->spec.name << endl;
 				break;
 			}
 		}
 	}
 
 	// See if an error occurred.  If so, close any that are open and stop.
-	if ( i < target_count )
-	{
+	if (i < target_count) {
 		critical_error = TRUE;
 		Close_Targets();
 	}
-
 	// Signalling that thread is done (successfully or not) opening its targets.
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(long) &not_ready, 0 );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(long) & not_ready, 0);
 }
 
-
-
 //
 // Closes all targets after Do_IOs() runs
 //
@@ -1073,15 +972,13 @@
 void Grunt::Close_Targets()
 {
 	// Closing disks.
-	for ( int i = 0; i < target_count; i++ )
-	{
-		if ( !( targets[i]->Close( &grunt_state ) ) )
+	for (int i = 0; i < target_count; i++) {
+		if (!(targets[i]->Close(&grunt_state)))
 			cout << "*** Error closing " << targets[i]->spec.name << endl;
 	}
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(long) &not_ready, 0 );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(long) & not_ready, 0);
 }
 
-
 //
 // Performing accesses based on specifications to targets.
 // The following function initiates I/O, recording performance information only when the
@@ -1096,40 +993,38 @@
 	// these are working variables for the IO loop - they aren't referenced
 	// outside of it and their values don't span more than one burst of data.
 	//
-	int				remaining_transactions_in_burst=0;	// how's that for a name?
-	int				access_percent = 0;		// Determines the access spec.
-	int				target_id;			// Index into target array of target to access.
-	DWORD			size;				// Size of transfer request to target.
-	int				transfer_delay;		// Milliseconds to wait before accessing.
-	ReturnVal		transfer_result;	// Success/failure result of read or write operation.
-	Transaction*	transaction = NULL;		// Pointer to the transaction being processed.
-	DWORD			user_alignment;
-	DWORDLONG		user_align_mask;
-	DWORD			reply;				// Size of reply, or 0 for no reply
-	DWORDLONG		conn_time;			// Used to calculate average and max connection times.
-	Target*			target;
-	Raw_Result		*target_results;	// Pointer to results for selected target.
-	Raw_Result		*prev_target_results;
+	int remaining_transactions_in_burst = 0;	// how's that for a name?
+	int access_percent = 0;	// Determines the access spec.
+	int target_id;		// Index into target array of target to access.
+	DWORD size;		// Size of transfer request to target.
+	int transfer_delay;	// Milliseconds to wait before accessing.
+	ReturnVal transfer_result;	// Success/failure result of read or write operation.
+	Transaction *transaction = NULL;	// Pointer to the transaction being processed.
+	DWORD user_alignment;
+	DWORDLONG user_align_mask;
+	DWORD reply;		// Size of reply, or 0 for no reply
+	DWORDLONG conn_time;	// Used to calculate average and max connection times.
+	Target *target;
+	Raw_Result *target_results;	// Pointer to results for selected target.
+	Raw_Result *prev_target_results;
 
-	
-	while ( grunt_state != TestIdle )
-	{
+	while (grunt_state != TestIdle) {
 #if defined(IOMTR_OSFAMILY_NETWARE)
 		pthread_yield();	// NetWare is non-preemptive
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
 		// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		// If we can't queue another request, wait for a completion.
 		// If we CAN queue another request, get only one completion and do 
 		// so immediately (with a time out of 0).
-		Complete_IO( ( available_head == available_tail || 
-			target_count == targets_closing_count ) ? TIMEOUT_TIME : 0 );
+		Complete_IO((available_head == available_tail ||
+			     target_count == targets_closing_count) ? TIMEOUT_TIME : 0);
 
 		// Now check to see if there really are any completed requests.
 		// Complete_IO may not have freed a slot in the available queue.
-		if ( available_head == available_tail )
+		if (available_head == available_tail)
 			continue;	// repeat the outermost while loop
 
 		// Getting an index into the target array of the next target to access.
@@ -1138,96 +1033,83 @@
 
 		// Checking the next target to access to see if it is closing.
 		// This if statement is separated from the one below for performance.
-		if ( target->spec.test_connection_rate && target->is_closing )
-		{
+		if (target->spec.test_connection_rate && target->is_closing) {
 			// Target is closing.  Move it to the tail of the available queue.
-			available_trans_queue[available_tail++] = 
-				available_trans_queue[available_head++];
-			if ( available_head > cur_trans_slots ) {
+			available_trans_queue[available_tail++] = available_trans_queue[available_head++];
+			if (available_head > cur_trans_slots) {
 				available_head = 0;
 			}
-			if ( available_tail > cur_trans_slots ) {
+			if (available_tail > cur_trans_slots) {
 				available_tail = 0;
 			}
-
 			// Check to see if we can close the target.  Targets are not closed
 			// until all outstanding I/Os have completed.
-			if ( target->outstanding_ios == 0 )
-			{
-				#if _DEBUG 
-					cout << "Testing connection rate: Closing " 
-						 << targets[target_id]->spec.name << endl;
-				#endif
+			if (target->outstanding_ios == 0) {
+#if _DEBUG
+				cout << "Testing connection rate: Closing " << targets[target_id]->spec.name << endl;
+#endif
 
 				// Close target and record connection time.
-				target->Close( &grunt_state );
+				target->Close(&grunt_state);
 				conn_time = rdtsc() - target->conn_start_time;
 
 				// Since target is closed, it is no longer closing.
 				target->is_closing = FALSE;
 
 				// Record connection latencies.
-				if ( ramp_up_ios_pending <= 0 && grunt_state == TestRecording )
-				{
+				if (ramp_up_ios_pending <= 0 && grunt_state == TestRecording) {
 					target_results = &(worker_performance.target_results.result[target_id]);
 					target_results->connection_count++;
 					target_results->connection_latency_sum += conn_time;
-					if ( conn_time > target_results->max_raw_connection_latency )
+					if (conn_time > target_results->max_raw_connection_latency)
 						target_results->max_raw_connection_latency = conn_time;
 
-					prev_target_results = &(prev_worker_performance.target_results.result[target_id]);
-					if ( conn_time > prev_target_results->max_raw_connection_latency )
+					prev_target_results =
+					    &(prev_worker_performance.target_results.result[target_id]);
+					if (conn_time > prev_target_results->max_raw_connection_latency)
 						prev_target_results->max_raw_connection_latency = conn_time;
 				}
 			}
 			continue;
 		}
-
 		// Check to see if we need to open the target.
-		if ( target->spec.test_connection_rate && target->trans_left_in_conn <= 0 )
-		{
-			#if _DEBUG
-				cout << "Testing connection rate: Opening " 
-					<< target->spec.name << endl;
-			#endif
+		if (target->spec.test_connection_rate && target->trans_left_in_conn <= 0) {
+#if _DEBUG
+			cout << "Testing connection rate: Opening " << target->spec.name << endl;
+#endif
 			// Set the number of transactions to do before closing.
 			target->trans_left_in_conn = target->spec.trans_per_conn;
 			// Record the start time for the transaction.
 			target->conn_start_time = rdtsc();
 			// Open the target.
-			target->Open( &grunt_state );
+			target->Open(&grunt_state);
 
 			// If not doing any transactions, set the target to close.
 			if ((target->is_closing = !target->spec.trans_per_conn))
 				continue;
 		}
-
 		// "transaction" will now point to the next available
 		// transaction slot
-		transaction = &( trans_slots[ available_trans_queue[available_head] ] );
+		transaction = &(trans_slots[available_trans_queue[available_head]]);
 
 		// See if this is the start of a new transaction
-		if ( ! (transaction->remaining_requests || transaction->remaining_replies) )
-		{
+		if (!(transaction->remaining_requests || transaction->remaining_replies)) {
 			// No requests or replies remain, start a new transaction.
 
 			// Check to see if this transaction will be the last one
 			// before closing the target.
-			target->is_closing = ( target->spec.test_connection_rate && 
-				--target->trans_left_in_conn <= 0 );
+			target->is_closing = (target->spec.test_connection_rate && --target->trans_left_in_conn <= 0);
 
 			// See if we need to get a new access spec line.  All transactions
 			// for the current burst have been sent.
-			if ( --remaining_transactions_in_burst <= 0 )
-			{
-				access_spec.GetNextBurst( access_percent = (unsigned int)Rand() % 100,
-					&remaining_transactions_in_burst, &size, &transfer_delay,
-					&user_alignment, &user_align_mask, &reply );
+			if (--remaining_transactions_in_burst <= 0) {
+				access_spec.GetNextBurst(access_percent = (unsigned int)Rand() % 100,
+							 &remaining_transactions_in_burst, &size, &transfer_delay,
+							 &user_alignment, &user_align_mask, &reply);
 				// Possibly waiting some delay before sending next burst of transfers.
-				if ( transfer_delay )
-					Asynchronous_Delay( transfer_delay );
+				if (transfer_delay)
+					Asynchronous_Delay(transfer_delay);
 			}
-
 			// Fill in the information for a new transaction
 
 			// Set number and size of requests.  (Currently always one request; we can support 
@@ -1239,37 +1121,35 @@
 			// reply size != 0 means one reply; we can support any number, but this is not
 			// yet implemented in Iometer.)
 			transaction->reply_size = reply;
-			transaction->remaining_replies = ( reply ? 1 : 0 );
+			transaction->remaining_replies = (reply ? 1 : 0);
 
 			// Determine if the first I/O will be a read or write.
 			// (is_read will change when replies are sent)
-			transaction->is_read = access_spec.Read( access_percent,
-							(unsigned int)target->Rand() % 100 );
+			transaction->is_read = access_spec.Read(access_percent, (unsigned int)target->Rand() % 100);
 
 			// Set flag to record transaction start time when the transaction actually begins.
 			transaction->start_transaction = 0;
 		}
-
 		// Prepare the next I/O of the transaction...
 
 		// Set the transaction's size.
-		if ( transaction->remaining_requests )
+		if (transaction->remaining_requests)
 			transaction->size = transaction->request_size;
 		else
 			transaction->size = transaction->reply_size;
 
-		if ( IsType( target->spec.type, GenericDiskType ) )
-		{
-			((TargetDisk *) targets[target_id])->Seek( access_spec.Random( access_percent,
-				(unsigned int)targets[target_id]->Rand() % 100 ), size,
-				user_alignment, user_align_mask );
+		if (IsType(target->spec.type, GenericDiskType)) {
+			((TargetDisk *) targets[target_id])->Seek(access_spec.Random(access_percent,
+										     (unsigned int)targets[target_id]->
+										     Rand() % 100), size,
+								  user_alignment, user_align_mask);
 		}
 
 		transaction->start_IO = (grunt_state == TestRecording) ? rdtsc() : 0;
 
 		// If the transaction start time hasn't been set,
 		// this is the first I/O of this transaction.  Set the start time.
-		if ( !transaction->start_transaction )
+		if (!transaction->start_transaction)
 			transaction->start_transaction = transaction->start_IO;
 
 		//
@@ -1277,35 +1157,30 @@
 		// the I/O while it should be retried.  A retry indicates that there
 		// currently aren't enough reources to fulfill the request.
 		//
-		do
-		{
+		do {
 #if defined(IOMTR_OSFAMILY_NETWARE)
 			pthread_yield();	// NetWare is Non-preemptive
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_WINDOWS)
 			// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-			if ( transaction->is_read )
-			{
-				transfer_result = target->Read( read_data, transaction );
+			if (transaction->is_read) {
+				transfer_result = target->Read(read_data, transaction);
+			} else {
+				transfer_result = target->Write(write_data, transaction);
 			}
-			else
-			{
-				transfer_result = target->Write( write_data, transaction );
-			}
 
 			// Continue to process completions.  This may free up the resource
 			// that is needed.
-			if ( transfer_result == ReturnRetry )
-				Complete_IO( TIMEOUT_TIME );
+			if (transfer_result == ReturnRetry)
+				Complete_IO(TIMEOUT_TIME);
 		}
-		while ( transfer_result == ReturnRetry && grunt_state != TestIdle );
+		while (transfer_result == ReturnRetry && grunt_state != TestIdle);
 
 		// The request finished.  See what the result was and process it
 		// accordingly.
-		switch ( transfer_result )
-		{
+		switch (transfer_result) {
 		case ReturnPending:
 			// An I/O was successfully started, and its completion will be
 			// posted to the completion queue.
@@ -1317,7 +1192,7 @@
 			outstanding_ios++;
 
 			// See if the I/O occurred during the ramp up period.
-			if ( !transaction->start_IO )
+			if (!transaction->start_IO)
 				++ramp_up_ios_pending;
 			break;
 		case ReturnSuccess:
@@ -1333,41 +1208,38 @@
 			outstanding_ios++;
 
 			// See if the I/O occurred during the ramp up period.
-			if ( !transaction->start_IO )
+			if (!transaction->start_IO)
 				++ramp_up_ios_pending;
 
 			// An I/O completed successfully and will not go to the completion 
 			// queue.  Record the request as done.
-			Record_IO( transaction, rdtsc() );
+			Record_IO(transaction, rdtsc());
 			break;
 		default:
 			// see whether it should record the error
-			if ( grunt_state == TestRecording )
-			{
+			if (grunt_state == TestRecording) {
 				// ERROR: The I/O was not queued successfully.
 				cout << "*** Error performing I/O to " << target->spec.name << endl;
 
-				if ( transaction->is_read )
+				if (transaction->is_read)
 					worker_performance.target_results.result[target_id].read_errors++;
 				else
 					worker_performance.target_results.result[target_id].write_errors++;
 			}
-
 			// Move the failed transaction to the end of the available queue to
 			// allow other requests, if any, to have a chance of going.
-			available_trans_queue[available_tail++] = 
-				available_trans_queue[available_head];
-			if ( available_tail > cur_trans_slots ) {
+			available_trans_queue[available_tail++] = available_trans_queue[available_head];
+			if (available_tail > cur_trans_slots) {
 				available_tail = 0;
 			}
 		}
 
 		// Move the head of the available queue to reflect the last request.
-		if ( (++available_head) > cur_trans_slots ) {
+		if ((++available_head) > cur_trans_slots) {
 			available_head = 0;
 		}
-	} // while grunt_state is not TestIdle
-	
+	}			// while grunt_state is not TestIdle
+
 	// Drain any outstanding I/Os from the completion queue
 	while (outstanding_ios > 0) {
 #if defined(IOMTR_OSFAMILY_NETWARE)
@@ -1377,37 +1249,36 @@
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	
+
 		switch (Complete_IO(TIMEOUT_TIME)) {
 		case ReturnTimeout:
 			cout << "*** Grunt thread exiting with " << outstanding_ios << " still active" << endl;
-			break;		
+			break;
 		default:
 			break;
 		}
-	}	
+	}
 }
 
 //
 // Checking for a completed I/O and processing the completion.
 //
-ReturnVal Grunt::Complete_IO( int timeout )
+ReturnVal Grunt::Complete_IO(int timeout)
 {
 	int bytes, trans_id;
 
 	// See if any I/Os completed.
-	switch ( io_cq->GetStatus( &bytes, &trans_id, timeout ) )
-	{
+	switch (io_cq->GetStatus(&bytes, &trans_id, timeout)) {
 	case ReturnSuccess:
 		// I/O completed.  Make sure we received everything we requested.
-		if ( bytes < (int) trans_slots[trans_id].size )
-			Do_Partial_IO( &trans_slots[trans_id], bytes );
+		if (bytes < (int)trans_slots[trans_id].size)
+			Do_Partial_IO(&trans_slots[trans_id], bytes);
 		else
-			Record_IO( &trans_slots[trans_id], rdtsc() );
+			Record_IO(&trans_slots[trans_id], rdtsc());
 		return ReturnSuccess;
 
 	case ReturnAbort:
-		Record_IO( &trans_slots[trans_id], 0 );
+		Record_IO(&trans_slots[trans_id], 0);
 		return ReturnSuccess;
 
 	case ReturnTimeout:
@@ -1421,48 +1292,39 @@
 	}
 }
 
-
-
 //
 // Issues an additional I/O request for one that partially completed.  Note
 // that currently only TCP target types will complete partial I/Os.
 //
-void Grunt::Do_Partial_IO( Transaction *transaction, int bytes_done )
+void Grunt::Do_Partial_IO(Transaction * transaction, int bytes_done)
 {
-	ReturnVal	result;
+	ReturnVal result;
 
 	// Queue another request for the rest of the bytes.
 	transaction->size -= bytes_done;
 
-	#if _DETAILS
-		cout << "Doing another " << ( transaction->is_read ? "read" : "write" )
-			<< " for the remaining " << transaction->size << " bytes." << endl;
-	#endif
+#if _DETAILS
+	cout << "Doing another " << (transaction->is_read ? "read" : "write")
+	    << " for the remaining " << transaction->size << " bytes." << endl;
+#endif
 
-	if ( transaction->is_read )
-	{
-		result = targets[transaction->target_id]->Read( read_data, transaction );
+	if (transaction->is_read) {
+		result = targets[transaction->target_id]->Read(read_data, transaction);
+	} else {
+		result = targets[transaction->target_id]->Write(write_data, transaction);
 	}
-	else
-	{
-		result = targets[transaction->target_id]->Write( write_data, transaction );
-	}
 
-	if ( (result != ReturnSuccess) && (result != ReturnPending) && (grunt_state == TestRecording) )
-	{
+	if ((result != ReturnSuccess) && (result != ReturnPending) && (grunt_state == TestRecording)) {
 		// The I/O was not started successfully.
-		cout << "*** ERROR performing read or write to "
-			 << targets[transaction->target_id]->spec.name << endl;
+		cout << "*** ERROR performing read or write to " << targets[transaction->target_id]->spec.name << endl;
 
-		if ( transaction->is_read )
+		if (transaction->is_read)
 			worker_performance.target_results.result[transaction->target_id].read_errors++;
 		else
 			worker_performance.target_results.result[transaction->target_id].write_errors++;
 	}
 }
 
-
-
 //
 // Start threads to access targets.
 //
@@ -1473,7 +1335,7 @@
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
 	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 	// Clear the results.
@@ -1482,7 +1344,7 @@
 
 	// If no drives are selected, or the access spec is the idle spec, 
 	// do not create the thread.
- 	if ( !target_count || idle )
+	if (!target_count || idle)
 		return;
 
 	ramp_up_ios_pending = 0;
@@ -1490,57 +1352,52 @@
 	Initialize_Transaction_Arrays();
 
 	// The grunt thread will become ready after opening its targets.
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(long) &not_ready, 1 );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(long)&not_ready, 1);
 	// Tell the grunt to begin opening its devices, but not to perform I/O yet.
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(int) &grunt_state, (int)TestOpening );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(int) & grunt_state, (int)TestOpening);
+
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	pthread_create(&newThread, NULL,
-		       (void *(*)(void *))Grunt_Thread_Wrapper, (void *)this);
+	pthread_create(&newThread, NULL, (void *(*)(void *))Grunt_Thread_Wrapper, (void *)this);
 	pthread_detach(newThread);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-	_beginthread( Grunt_Thread_Wrapper, 0, (void*)this );
+	_beginthread(Grunt_Thread_Wrapper, 0, (void *)this);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
 //
 // Start performing I/O.
 //
 void Grunt::Begin_IO()
 {
-	if ( !target_count || idle )
+	if (!target_count || idle)
 		return;
 
 	// Wait for all threads to finish opening their devices.
-	while ( not_ready )
-	{
+	while (not_ready) {
 #if defined(IOMTR_OSFAMILY_NETWARE)
 		pthread_yield();
 #elif defined(IOMTR_OSFAMILY_UNIX)
- #if defined(IOMTR_OS_SOLARIS)
+#if defined(IOMTR_OS_SOLARIS)
 		thr_yield();
- #elif defined(IOMTR_OS_LINUX)
- 		sleep(0);
- #elif defined(IOMTR_OS_OSX)
+#elif defined(IOMTR_OS_LINUX)
+		sleep(0);
+#elif defined(IOMTR_OS_OSX)
 		pthread_yield_np();
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
- #endif
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-		Sleep( 0 );
+		Sleep(0);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	}
 
-	InterlockedExchange( IOMTR_MACRO_INTERLOCK_CAST(int) &grunt_state, (int)TestRampingUp );
+	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(int) & grunt_state, (int)TestRampingUp);
 }
 
-
-
 //
 // Return a 64-bit random number, using the following random function and conditions.
 //
@@ -1555,23 +1412,21 @@
 // When we use gcc, we add "LL" to take out a warning about integer overflow.
 //
 #if defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
- #define A 136204069LL		// 3x7x11x13x17x23x   29x4 + 1
- #define B 28500701229LL	// 3x7x11x13x17x23x27x29x31
+#define A 136204069LL		// 3x7x11x13x17x23x   29x4 + 1
+#define B 28500701229LL		// 3x7x11x13x17x23x27x29x31
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #define A 136204069		// 3x7x11x13x17x23x   29x4 + 1
- #define B 28500701229		// 3x7x11x13x17x23x27x29x31
+#define A 136204069		// 3x7x11x13x17x23x   29x4 + 1
+#define B 28500701229		// 3x7x11x13x17x23x27x29x31
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-void Grunt::Srand( DWORDLONG seed )
+void Grunt::Srand(DWORDLONG seed)
 {
 	holdrand = seed;
 }
 
-
 DWORDLONG Grunt::Rand()
 {
-	return( holdrand = A * holdrand + B );
+	return (holdrand = A * holdrand + B);
 }

Modified: branches/IOMETER-restruct/iometer/src/IOGrunt.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOGrunt.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOGrunt.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -70,8 +70,6 @@
 #ifndef	GRUNT_DEFINED
 #define	GRUNT_DEFINED
 
-
-
 #include "IOCommon.h"
 #include "IOTarget.h"
 #include "IOAccess.h"
@@ -79,13 +77,12 @@
 #include "IOTransfers.h"
 
 #if defined(IOMTR_SETTING_VI_SUPPORT)
- #include "VINic.h"
+#include "VINic.h"
 #endif
 
-
 // Wrappers for Grunt member functions, used by _beginthread()
-void CDECL Prepare_Disk_Wrapper( void *disk_thread_info );
-void CDECL Grunt_Thread_Wrapper( void *grunt );
+void CDECL Prepare_Disk_Wrapper(void *disk_thread_info);
+void CDECL Grunt_Thread_Wrapper(void *grunt);
 
 #define TIMEOUT_TIME	1000	// max time to wait for an asynch
 				// I/O to complete, in milliseconds
@@ -93,146 +90,137 @@
 //
 // An I/O worker who does all of the dirty work.
 //
-class Grunt
-{
-public:
+class Grunt {
+      public:
 	Grunt();
 	~Grunt();
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Indicates type of targets assigned to grunt.
 	//
-	TargetType	type;
+	TargetType type;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to set test configuration information.
 	//
-	BOOL		Set_Targets( int count, Target_Spec *target_specs = NULL );
-	BOOL		Set_Access( const Test_Spec* spec );
-	void		Start_Test();
-	void		Begin_IO();
-	void		Record_On();
-	void		Record_Off();
-	void		Stop_Test();
-	void		Wait_For_Stop();
+	BOOL Set_Targets(int count, Target_Spec * target_specs = NULL);
+	BOOL Set_Access(const Test_Spec * spec);
+	void Start_Test();
+	void Begin_IO();
+	void Record_On();
+	void Record_Off();
+	void Stop_Test();
+	void Wait_For_Stop();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
 	// Function to prepare logical drives for access.
-	BOOL		Prepare_Disks();
+	BOOL Prepare_Disks();
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to access the targets (called via _Wrapper() interfaces)
 	// These functions are run by threads which perform the actual I/O transfers.
 	// They are intentially monolithic in nature for performance reasons.
 	//
-	void		Prepare_Disk( int disk_id );
+	void Prepare_Disk(int disk_id);
 	//
 	// the three functions called by Grunt_Thread_Wrapper()
-	void		Open_Targets();
-	void		Do_IOs();
-	void		Close_Targets();
+	void Open_Targets();
+	void Do_IOs();
+	void Close_Targets();
 	//
 	// Number of threads still not ready.
-	volatile long	not_ready;
+	volatile long not_ready;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-	ReturnVal	Complete_IO( int delay );
-	void		Do_Partial_IO( Transaction *transaction, int bytes_done );
-		
-	volatile TestState	grunt_state;	// Grunt's status within the test
+	ReturnVal Complete_IO(int delay);
+	void Do_Partial_IO(Transaction * transaction, int bytes_done);
 
-	int			target_count;	// Number of disks/networks.
-	Access		access_spec;		// Access specs for a test.
-	void*		read_data;		// Pointer to general data memory area for reading and writing.
-	void*		write_data;
-	int		data_size;		// Size of currently allocated data buffers.
-						// This is 0 when the grunt is using the manager's buffer.
+	volatile TestState grunt_state;	// Grunt's status within the test
 
-	BOOL		critical_error;
+	int target_count;	// Number of disks/networks.
+	Access access_spec;	// Access specs for a test.
+	void *read_data;	// Pointer to general data memory area for reading and writing.
+	void *write_data;
+	int data_size;		// Size of currently allocated data buffers.
+	// This is 0 when the grunt is using the manager's buffer.
 
+	BOOL critical_error;
+
 	// Worker results are to be stored.
-	Worker_Results	worker_performance;
-	Worker_Results	prev_worker_performance;
-	
+	Worker_Results worker_performance;
+	Worker_Results prev_worker_performance;
+
 	// Indicates the grunt was assigned an idle access spec.
-	BOOL		idle;
+	BOOL idle;
 
-private:
-	void		Initialize_Results();
+      private:
+	void Initialize_Results();
 
 	///////////////////////////////////////////////////////////////////////////
 	// Manages list of targets currently assigned to a worker for testing.
 	//
-	BOOL		Size_Target_Array( int count, const Target_Spec *target_specs = NULL );
-	Target		**targets;
+	BOOL Size_Target_Array(int count, const Target_Spec * target_specs = NULL);
+	Target **targets;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
 	// To process an I/O error with Record_IO(),
 	// pass in a zero for the end_IO time.
-	void		Record_IO( Transaction *transaction, DWORDLONG end_IO );
-	void		Asynchronous_Delay( int transfer_delay );
+	void Record_IO(Transaction * transaction, DWORDLONG end_IO);
+	void Asynchronous_Delay(int transfer_delay);
 
 	// Handle of completion queue for asynchronous I/O operations.
-	CQ			*io_cq;
+	CQ *io_cq;
 
 	// Information needed by an disk preparation IO thread.
-	Thread_Info	*prepare_thread;
+	Thread_Info *prepare_thread;
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Related I/O request arrays.
 	//
-	Transaction		*trans_slots;
-	int			total_trans_slots;
-	int             	cur_trans_slots;
+	Transaction *trans_slots;
+	int total_trans_slots;
+	int cur_trans_slots;
 	//
 	//
 	// Queue of I/O requests which are available for transmitting.
 	// Each entry in this queue refers to a Transaction that may
 	// be used to generate I/O.  That is, the transaction has no
 	// pending I/O requests.
-	int		*available_trans_queue;
-	int		available_head;
-	int		available_tail;
-	int		outstanding_ios;
+	int *available_trans_queue;
+	int available_head;
+	int available_tail;
+	int outstanding_ios;
 	//
 	// Operations on related I/O transaction arrays.
-	void	Initialize_Transaction_Arrays();
-	BOOL	Resize_Transaction_Arrays();
-	void	Free_Transaction_Arrays();
+	void Initialize_Transaction_Arrays();
+	BOOL Resize_Transaction_Arrays();
+	void Free_Transaction_Arrays();
 	//
 	///////////////////////////////////////////////////////////////////////////
-	
 
 	///////////////////////////////////////////////////////////////////////////
 	// Variables used to control operation while testing performance.
 	//
 	// Number of requested nonrecorded asynch I/O's pending.
 	// Recording of performance data does not begin until this is 0.
-	int			ramp_up_ios_pending;
+	int ramp_up_ios_pending;
 	//
 	// Number of disks/networks that are closing for connection rate testing.
-	int			targets_closing_count;
+	int targets_closing_count;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	// Random number generation functions
-	void		Srand( DWORDLONG seed );
-	DWORDLONG	Rand();
+	void Srand(DWORDLONG seed);
+	DWORDLONG Rand();
 
 	// Used by random number generator functions.
-	DWORDLONG	holdrand;
+	DWORDLONG holdrand;
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOManager.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOManager.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOManager.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -104,19 +104,17 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
-
 #include "IOCommon.h"
 #include "IOManager.h"
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include "winsock2.h"
+#include "winsock2.h"
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
- #include <netdb.h>
- #include <arpa/inet.h>
- #include <sys/types.h>
+#include <netdb.h>
+#include <arpa/inet.h>
+#include <sys/types.h>
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 #include "IOPortTCP.h"
@@ -133,32 +131,29 @@
 // Initializing manager variables before their first use.
 //
 Manager::Manager()
- : m_pVersionString(NULL), m_pVersionStringWithDebug(NULL)
+:  m_pVersionString(NULL), m_pVersionStringWithDebug(NULL)
 {
 	data_size = 0;
 	data = NULL;
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 	swap_devices = NULL;
-#endif // IOMTR_OSFAMILY_UNIX
-	SetLastError( 0 );
+#endif				// IOMTR_OSFAMILY_UNIX
+	SetLastError(0);
 
 	//init file version strings
 	GetAppFileVersionString(&m_pVersionString, &m_pVersionStringWithDebug);
 
 	prt = new PortTCP;
-	if ( !prt->Create() )
-	{
+	if (!prt->Create()) {
 		cout << "*** Could not create a TCP/IP Port. exiting....." << endl;
 		exit(1);
 	}
-	
+
 	record = FALSE;
 	grunt_count = 0;
 	memset(blkdevlist, 0, sizeof(char) * MAX_TARGETS * MAX_NAME);
 }
- 
 
-
 //
 // Destructor
 //
@@ -166,291 +161,261 @@
 {
 	int g;
 
-	delete [] m_pVersionString;
-	delete [] m_pVersionStringWithDebug;
+	delete[]m_pVersionString;
+	delete[]m_pVersionStringWithDebug;
 
 	prt->Close();
 	delete prt;
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	if(data != NULL)	
+	if (data != NULL)
 		free(data);
-	if(swap_devices != NULL)	
-		free(swap_devices);	
+	if (swap_devices != NULL)
+		free(swap_devices);
 #elif defined(IOMTR_OS_NETWARE)
-	if(data != NULL)	
+	if (data != NULL)
 		NXMemFree(data);
-	if(swap_devices != NULL)	
+	if (swap_devices != NULL)
 		NXMemFree(swap_devices);
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	VirtualFree( data, 0, MEM_RELEASE );
+	VirtualFree(data, 0, MEM_RELEASE);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	for ( g = 0; g < grunt_count; g++ )
+	for (g = 0; g < grunt_count; g++)
 		delete grunts[g];
 }
 
 ///////////////////////////////////////////////////////////////////////////////
-//	Function Name:
-//		Manager::GetVersionString
+//      Function Name:
+//              Manager::GetVersionString
 //
-//	Syntax:
-//		const char*		GetVersionString(BOOL fWithDebugIndicator = FALSE);
+//      Syntax:
+//              const char*             GetVersionString(BOOL fWithDebugIndicator = FALSE);
 //
-//	Processing:
-//		Return version string ptr (m_pVersionString or m_pVersionStringWithDebug).
+//      Processing:
+//              Return version string ptr (m_pVersionString or m_pVersionStringWithDebug).
 ///////////////////////////////////////////////////////////////////////////////
-const char*		Manager::GetVersionString(BOOL fWithDebugIndicator)
+const char *Manager::GetVersionString(BOOL fWithDebugIndicator)
 {
-	if (! fWithDebugIndicator)
+	if (!fWithDebugIndicator)
 		return m_pVersionString;
 	else
 		return m_pVersionStringWithDebug;
 }
 
-
 //
 // Logging into Iometer.  Returns success.
 //
-BOOL Manager::Login( char* port_name )
+BOOL Manager::Login(char *port_name)
 {
-	Port			*login_port;
-	Message			msg, reply;
-	Data_Message	data_msg;
-	size_t			name_size = MAX_NETWORK_NAME;
-	int				year, month, day;
+	Port *login_port;
+	Message msg, reply;
+	Data_Message data_msg;
+	size_t name_size = MAX_NETWORK_NAME;
+	int year, month, day;
 
 	// Creating login messages that include the machine name and Dynamo version.
 	// The version number is included in two places for backward compatibility.
 	msg.purpose = LOGIN;
 	strcpy(data_msg.data.manager_info.version, m_pVersionStringWithDebug);
- #ifdef _DEBUG
+#ifdef _DEBUG
 	cout << "dynamo version: " << data_msg.data.manager_info.version << endl;
- #endif
-	sscanf( data_msg.data.manager_info.version, "%d.%d.%d", &year, &month, &day );
+#endif
+	sscanf(data_msg.data.manager_info.version, "%d.%d.%d", &year, &month, &day);
 	msg.data = (year * 10000) + (month * 100) + day;
 
-	if ( manager_name[0] != '\0' )
-	{
-		if ( strlen(manager_name) > MAX_NETWORK_NAME )
-		{
+	if (manager_name[0] != '\0') {
+		if (strlen(manager_name) > MAX_NETWORK_NAME) {
 			cout << "*** Specified manager name cannot be more than "
-				 << MAX_NETWORK_NAME << " characters" << endl;
+			    << MAX_NETWORK_NAME << " characters" << endl;
 			exit(1);
 		}
 
-		strcpy( data_msg.data.manager_info.names[0], manager_name );
+		strcpy(data_msg.data.manager_info.names[0], manager_name);
 		name_size = strlen(manager_name);
-	}
-	else
-	{
+	} else {
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		// This will not work correctly if hostname length > MAX_NETWORK_NAME
-		if (gethostname(manager_name, name_size) < 0)
-		{
+		if (gethostname(manager_name, name_size) < 0) {
 			cout << "*** Exiting... gethostname() returned error " << errno << endl;
 			exit(1);
 		}
 		name_size = strlen(data_msg.data.manager_info.names[0]);
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		GetComputerName( manager_name, (LPDWORD)&name_size );
+		GetComputerName(manager_name, (LPDWORD) & name_size);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		strcpy(data_msg.data.manager_info.names[0], manager_name);
 	}
-	strcpy( data_msg.data.manager_info.names[1], prt->network_name );
-	data_msg.data.manager_info.port_number     = prt->network_port;
+	strcpy(data_msg.data.manager_info.names[1], prt->network_name);
+	data_msg.data.manager_info.port_number = prt->network_port;
 	data_msg.data.manager_info.processor_speed = perf_data[WHOLE_TEST_PERF].processor_speed;
-	data_msg.data.manager_info.processors      = perf_data[WHOLE_TEST_PERF].processor_count;
+	data_msg.data.manager_info.processors = perf_data[WHOLE_TEST_PERF].processor_count;
 
 #if defined(IOMTR_CPU_SPARC)
- #if defined(IOMTR_OS_SOLARIS)
+#if defined(IOMTR_OS_SOLARIS)
 	// Calculate processor_speed_to_nsecs for use in rdtsc.c
 	// Note that this works only for MHz CPUs. For GHz CPUs the divisor will change.
-	processor_speed_to_nsecs = (double)perf_data[WHOLE_TEST_PERF].processor_speed / 1000000000; 
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif
+	processor_speed_to_nsecs = (double)perf_data[WHOLE_TEST_PERF].processor_speed / 1000000000;
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
+#endif
 #if defined(IOMTR_CPU_PPC)
- #if defined(IOMTR_OS_OSX)
+#if defined(IOMTR_OS_OSX)
 	// Calculate processor_speed_to_nsecs for use in rdtsc.c
 	// This is multiplied by the timestamp in nanosecs
 	// That gives (time in ns) * (proc speed in HZ) / 1000000000 = time in cpu cycles
 	processor_speed_to_nsecs = (double)perf_data[WHOLE_TEST_PERF].processor_speed / 1000000000;
- #elif defined(IOMTR_OS_LINUX)
+#elif defined(IOMTR_OS_LINUX)
 	// nop
- #else
-  #error ===> ERROR: You have to do some coding here to get the port done!
- #endif
+#else
+#error ===> ERROR: You have to do some coding here to get the port done!
 #endif
+#endif
 
 	// Sending login request message.
 	cout << "Sending login request..." << endl;
 	cout << "   " << data_msg.data.manager_info.names[0] << endl;
-	cout << "   " << data_msg.data.manager_info.names[1] 
-		 << " (port " << data_msg.data.manager_info.port_number << ")" << endl;
+	cout << "   " << data_msg.data.manager_info.names[1]
+	    << " (port " << data_msg.data.manager_info.port_number << ")" << endl;
 
-	if ( prt->type == PORT_TYPE_TCP )
-	{
+	if (prt->type == PORT_TYPE_TCP) {
 		login_port = new PortTCP;
 
-		if ( !login_port->Connect( port_name ) )
-		{
+		if (!login_port->Connect(port_name)) {
 			cout << "*** Could not create TCP/IP port to connect with Iometer!" << endl;
 			return FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		cout << "*** Invalid port type in Manager::Login()" << endl;
 		return FALSE;
 	}
 
-	if( IsBigEndian() )
-	{
+	if (IsBigEndian()) {
 		(void)reorder(msg);
 		(void)reorder(data_msg, DATA_MESSAGE_MANAGER_INFO, SEND);
 	}
 #if defined (IOMTR_OS_LINUX) && defined (IOMTR_CPU_XSCALE)
 	Manager_Info_double_swap(&data_msg.data.manager_info);
 #endif
-	login_port->Send( &msg );
-	login_port->Send( &data_msg, DATA_MESSAGE_SIZE );
+	login_port->Send(&msg);
+	login_port->Send(&data_msg, DATA_MESSAGE_SIZE);
 
 	// wait to receive reply to login request, then get the incoming message...
-	if ( login_port->Receive( &reply ) == PORT_ERROR )
-	{
+	if (login_port->Receive(&reply) == PORT_ERROR) {
 		cout << endl << "*** Unable to receive a reply from Iometer" << endl;
 		return FALSE;
 	}
 
-	if( IsBigEndian() )
-	{
+	if (IsBigEndian()) {
 		(void)reorder(reply);
 	}
-
 	// Delete login port because we don't need it anymore.
-	delete  login_port;
+	delete login_port;
 
 	// process the login reply message from Iometer
-	switch (reply.data)
-	{
-		case WRONG_VERSION:
-			cout << endl << "*** Incorrect version of Dynamo for this Iometer" << endl;
-			return FALSE;
+	switch (reply.data) {
+	case WRONG_VERSION:
+		cout << endl << "*** Incorrect version of Dynamo for this Iometer" << endl;
+		return FALSE;
 
-		case LOGIN_OK:
-			//
-			// Waiting for login to be accepted.
-			cout << endl;
-			cout << "*** If dynamo and iometer hangs here, please make sure" << endl;
-			cout << "*** you use a correct -m <manager_computer_name> that" << endl;
-			cout << "*** can ping from iometer machine. use IP if need." << endl;
+	case LOGIN_OK:
+		//
+		// Waiting for login to be accepted.
+		cout << endl;
+		cout << "*** If dynamo and iometer hangs here, please make sure" << endl;
+		cout << "*** you use a correct -m <manager_computer_name> that" << endl;
+		cout << "*** can ping from iometer machine. use IP if need." << endl;
 
-			if ( prt->Accept() )
-				cout << "   Login accepted." << endl << flush;
-			return TRUE;
-		default:
-			cout << endl << "*** Bad login status reply received - don't know what to do" << endl;
-			return FALSE;
+		if (prt->Accept())
+			cout << "   Login accepted." << endl << flush;
+		return TRUE;
+	default:
+		cout << endl << "*** Bad login status reply received - don't know what to do" << endl;
+		return FALSE;
 	}
 }
 
-
-
-
-
 #if defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS) || defined(IOMTR_OSFAMILY_WINDOWS)
 //
 // Checking for all TCP network interfaces.  Storing them, and returning the number
 // of interfaces found.  
 //
-int Manager::Report_TCP( Target_Spec *tcp_spec )
+int Manager::Report_TCP(Target_Spec * tcp_spec)
 {
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-	int 			 retval;
-	WSADATA 		 wd;
+	int retval;
+	WSADATA wd;
 #endif
-	struct hostent		*hostinfo;
-	struct sockaddr_in	 sin;
-	char			 hostname[128];
-	int			 count = 0;
-	int 			 i;
+	struct hostent *hostinfo;
+	struct sockaddr_in sin;
+	char hostname[128];
+	int count = 0;
+	int i;
 
 	cout << "Reporting TCP network information..." << endl;
 
 #if defined(IOMTR_OSFAMILY_WINDOWS)
 	// initialize WinSock version 2.0
-	retval = WSAStartup( MAKEWORD(2, 0), &wd ); 
-	if ( retval != 0 )
-	{
+	retval = WSAStartup(MAKEWORD(2, 0), &wd);
+	if (retval != 0) {
 		cout << "*** Error " << retval << "initializing WinSock." << endl;
 		return 0;
-	} 
+	}
 #endif
 
 	// get the unqualified local host name
-	if (gethostname(hostname, sizeof(hostname)) == SOCKET_ERROR)
-	{
+	if (gethostname(hostname, sizeof(hostname)) == SOCKET_ERROR) {
 		cout << "*** Error " << WSAGetLastError() << "getting local host name.\n";
 		return 0;
 	}
-
 	// now get the host info for that host name
-	hostinfo = gethostbyname ( hostname );
-	if ( hostinfo == NULL )
-	{
-		cout << "*** Error " << WSAGetLastError() << "getting host info for \"" 
-			 << hostname << "\".\n";
+	hostinfo = gethostbyname(hostname);
+	if (hostinfo == NULL) {
+		cout << "*** Error " << WSAGetLastError() << "getting host info for \"" << hostname << "\".\n";
 		return 0;
 	}
+#ifdef _DEBUG
+	printf("   My hostname: \"%s\"\n", hostinfo->h_name);
 
-	#ifdef _DEBUG
-		printf("   My hostname: \"%s\"\n", hostinfo->h_name);
+	i = 0;
+	while (hostinfo->h_aliases[i] != NULL) {
+		printf("   Alias: \"%s\"\n", hostinfo->h_aliases[i]);
+		i++;
+	}
+#endif
 
-		i=0;
-		while ( hostinfo->h_aliases[i] != NULL )
-		{
-			printf("   Alias: \"%s\"\n", hostinfo->h_aliases[i]);
-			i++;
-		}
-	#endif
-
 	// report the network addresses.
-	for ( i = 0; hostinfo->h_addr_list[i] != NULL; i++ ) 
-	{
-		memcpy ( &sin.sin_addr.s_addr, hostinfo->h_addr_list[i], hostinfo->h_length );
-		strncpy ( tcp_spec[count].name, inet_ntoa(sin.sin_addr), 
-			sizeof(tcp_spec[count].name) - 1 );
+	for (i = 0; hostinfo->h_addr_list[i] != NULL; i++) {
+		memcpy(&sin.sin_addr.s_addr, hostinfo->h_addr_list[i], hostinfo->h_length);
+		strncpy(tcp_spec[count].name, inet_ntoa(sin.sin_addr), sizeof(tcp_spec[count].name) - 1);
 		tcp_spec[count].type = TCPClientType;	// interface to access a client
 
-		#if _DEBUG
-			cout << "   Found " << tcp_spec[count].name << "." << endl;
-		#endif
+#if _DEBUG
+		cout << "   Found " << tcp_spec[count].name << "." << endl;
+#endif
 
-		if ( ++count >= MAX_NUM_INTERFACES )
-		{
-			cout << "*** Found the maximum number of supported network interfaces: " 
-				<< endl << "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
+		if (++count >= MAX_NUM_INTERFACES) {
+			cout << "*** Found the maximum number of supported network interfaces: "
+			    << endl << "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
 			count = MAX_NUM_INTERFACES;
 			break;
 		}
 	}
 
-	#if 0	// for debugging multiple-network-interface GUI; change "#if 0" to "#if 1" to enable
-		strncpy ( nets[count], "foo", sizeof(nets[count]) - 1 );
-		cout << "   Added fake entry " << nets[count] << "." << endl << flush;
-		count++;
-	#endif
+#if 0				// for debugging multiple-network-interface GUI; change "#if 0" to "#if 1" to enable
+	strncpy(nets[count], "foo", sizeof(nets[count]) - 1);
+	cout << "   Added fake entry " << nets[count] << "." << endl << flush;
+	count++;
+#endif
 
 #if defined(IOMTR_OSFAMILY_WINDOWS)
 	// clean up WinSock
-	if ( WSACleanup() != 0 )
-	{
+	if (WSACleanup() != 0) {
 		cout << "*** Error " << WSAGetLastError() << "cleaning up WinSock." << endl;
 		return 0;
 	}
@@ -462,134 +427,117 @@
 }
 #endif
 
-
-
 //
 // Checking for all VI network interfaces.  Storing them, and returning the 
 // number of interfaces found.
 //
-int Manager::Report_VIs( Target_Spec *vi_spec )
+int Manager::Report_VIs(Target_Spec * vi_spec)
 {
 #if defined(IOMTR_SETTING_VI_SUPPORT)
-	int		count = 0, nic_base;
-	VIPL	vipl;
-	VINic	nic;
-	UINT	address_buffer_size, nic_address_size;
-	char	vi_nic_name[KNOWN_VI_NIC_NAMES][MAX_NAME];
-	int		vi_nic_name_no[KNOWN_VI_NIC_NAMES];
-	char	env_var_name[MAX_NAME];
+	int count = 0, nic_base;
+	VIPL vipl;
+	VINic nic;
+	UINT address_buffer_size, nic_address_size;
+	char vi_nic_name[KNOWN_VI_NIC_NAMES][MAX_NAME];
+	int vi_nic_name_no[KNOWN_VI_NIC_NAMES];
+	char env_var_name[MAX_NAME];
 
 	cout << "Reporting VI information..." << endl;
 	// Verify that VI is loaded on this system.
-	if ( !vipl.vipl_dll )
-	{
+	if (!vipl.vipl_dll) {
 		cout << "   VI library is not installed." << endl;
 		return 0;
 	}
-
 	// Initialize the base name and number for default VI nic names.
-	strcpy( vi_nic_name[0], "VINIC" );
+	strcpy(vi_nic_name[0], "VINIC");
 	vi_nic_name_no[0] = 0;
-	strcpy( vi_nic_name[1], "nic" );
+	strcpy(vi_nic_name[1], "nic");
 	vi_nic_name_no[1] = 0;
-	strcpy( vi_nic_name[2], "\\\\.\\VI" );
+	strcpy(vi_nic_name[2], "\\\\.\\VI");
 	vi_nic_name_no[2] = 1;
 
 	// Look for VI NIC's.  If no nic's are found matching the default
 	// names, look for system environment variables that 
 	// contain a mapping to the actual name.  (e.g. SET VINIC0=NIC1...)
-	for ( nic_base = 0; nic_base < KNOWN_VI_NIC_NAMES; nic_base++ )
-	{
+	for (nic_base = 0; nic_base < KNOWN_VI_NIC_NAMES; nic_base++) {
 		// Continue using the same base nic name until we've found all the 
 		// nics that are available.
-		while ( TRUE )
-		{
+		while (TRUE) {
 			// Form VI NIC name to open.
 			vi_spec[count].type = VIClientType;
-			sprintf( vi_spec[count].name, "%s%i", vi_nic_name[nic_base],
-				vi_nic_name_no[nic_base]++ );
+			sprintf(vi_spec[count].name, "%s%i", vi_nic_name[nic_base], vi_nic_name_no[nic_base]++);
 
 			// Try opening VI NIC.
-			if ( !nic.Open( vi_spec[count].name ) )
-			{
+			if (!nic.Open(vi_spec[count].name)) {
 				// Only search for environment variable mappings using the
 				// first (VINIC) name base.
-				if ( nic_base )
+				if (nic_base)
 					break;
 
 				// Nic does not exist.  See if there is an environment variable
 				// mapping to another NIC name.
-				strcpy( env_var_name, vi_spec[count].name );
+				strcpy(env_var_name, vi_spec[count].name);
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-				if ( !GetEnvironmentVariable( env_var_name, vi_spec[count].name,
-					MAX_NAME ) )
-				{
+				if (!GetEnvironmentVariable(env_var_name, vi_spec[count].name, MAX_NAME)) {
 					break;
 				}
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS) 
-				if ( getenv( env_var_name ) == NULL )
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+				if (getenv(env_var_name) == NULL)
 					break;
 
-				strncpy( vi_spec[count].name, getenv( env_var_name ), 
-					MAX_NAME - 1 );
+				strncpy(vi_spec[count].name, getenv(env_var_name), MAX_NAME - 1);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 				// A mapping exists.  Try to open the VI NIC using the 
 				// environment variable setting.
-				if ( !nic.Open( vi_spec[count].name ) )
+				if (!nic.Open(vi_spec[count].name))
 					break;
 			}
-
 			// Determine how many bytes are needed for the NIC address
 			// (not including the discriminator, which is null at this point).
-			nic_address_size = sizeof( *(nic.nic_address) ) +
-				nic.nic_attributes.NicAddressLen - 1;
+			nic_address_size = sizeof(*(nic.nic_address)) + nic.nic_attributes.NicAddressLen - 1;
 
 			// Determine the (static) size of the address buffer in the vi_spec structure.
-			address_buffer_size = sizeof( vi_spec[count].vi_info.local_address ) + 
-				sizeof( vi_spec[count].vi_info.local_address_fill_bytes );
+			address_buffer_size = sizeof(vi_spec[count].vi_info.local_address) +
+			    sizeof(vi_spec[count].vi_info.local_address_fill_bytes);
 
 			// Zero the address buffer.
-			memset( &vi_spec[count].vi_info.local_address, 0, address_buffer_size );
+			memset(&vi_spec[count].vi_info.local_address, 0, address_buffer_size);
 
 			// Copy the NIC's address into the local_address buffer
 			// (as much as will fit or the whole thing, whichever is less).
-			memcpy( &vi_spec[count].vi_info.local_address, nic.nic_address, 
-				min( address_buffer_size, nic_address_size ) );
+			memcpy(&vi_spec[count].vi_info.local_address, nic.nic_address,
+			       min(address_buffer_size, nic_address_size));
 
 			// Did the address fit, leaving enough room for the discriminator?
-			if ( nic_address_size + min( VI_DISCRIMINATOR_SIZE, nic.nic_attributes.MaxDiscriminatorLen )
-				> address_buffer_size )
-			{
+			if (nic_address_size + min(VI_DISCRIMINATOR_SIZE, nic.nic_attributes.MaxDiscriminatorLen)
+			    > address_buffer_size) {
 				cout << "*** WARNING: VI NIC \"" << vi_spec[count].name
-					<< "\"'s address size (" << nic_address_size
-					<< ") + discriminator length (" << min( VI_DISCRIMINATOR_SIZE, nic.nic_attributes.MaxDiscriminatorLen )
-					<< ") is larger than address buffer size (" << address_buffer_size
-					<< ")!" << endl;
+				    << "\"'s address size (" << nic_address_size
+				    << ") + discriminator length (" << min(VI_DISCRIMINATOR_SIZE,
+									   nic.nic_attributes.MaxDiscriminatorLen)
+				    << ") is larger than address buffer size (" << address_buffer_size << ")!" << endl;
 			}
 
-			vi_spec[count].vi_info.max_transfer_size = 
-				nic.nic_attributes.MaxTransferSize;
+			vi_spec[count].vi_info.max_transfer_size = nic.nic_attributes.MaxTransferSize;
 
 			// Each connection requires its own completion queue.
 			vi_spec[count].vi_info.max_connections = nic.nic_attributes.MaxCQ;
 
 			// Due to pre-postin requirements, we support only half of the
 			// available queue depth.
-			vi_spec[count].vi_info.outstanding_ios = 
-				nic.nic_attributes.MaxDescriptorsPerQueue >> 1;
+			vi_spec[count].vi_info.outstanding_ios = nic.nic_attributes.MaxDescriptorsPerQueue >> 1;
 
 			nic.Close();
-			#if _DEBUG
-				cout << "   Found " << vi_spec[count].name << "." << endl;
-			#endif
+#if _DEBUG
+			cout << "   Found " << vi_spec[count].name << "." << endl;
+#endif
 
 			// Prevent reporting more than the maximum number of VIs.
-			if ( ++count >= MAX_NUM_INTERFACES )
-			{
+			if (++count >= MAX_NUM_INTERFACES) {
 				cout << "*** Found the maximum number of supported VI interfaces: " << endl
-					<< "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
+				    << "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
 				return MAX_NUM_INTERFACES;
 			}
 		}
@@ -602,53 +550,43 @@
 #endif
 	return count;
 #else
-	return(0);
-#endif // IOMTR_SETTING_VI_SUPPORT
+	return (0);
+#endif				// IOMTR_SETTING_VI_SUPPORT
 }
 
-
-
 //
 // Preparing drives for selected grunts.
 //
-void Manager::Prepare_Disks( int target )
-{   
+void Manager::Prepare_Disks(int target)
+{
 	int i, loop_start, loop_finish;
 
-	if ( target == ALL_WORKERS )
-	{
+	if (target == ALL_WORKERS) {
 		// Preparing all grunts at the same time.  This requires a great
 		// amount of coordination on the part of Iometer to ensure that the
 		// grunts do not prepare the same drives.
-		for ( i = 0; i < grunt_count; i++ )
-		{
-			if ( !grunts[i]->Prepare_Disks() )
-			{
+		for (i = 0; i < grunt_count; i++) {
+			if (!grunts[i]->Prepare_Disks()) {
 				// Send failure message back to Iometer.
 				msg.data = 0;
-				if( IsBigEndian() )
-				{
+				if (IsBigEndian()) {
 					(void)reorder(msg);
 				}
-				prt->Send( &msg );
+				prt->Send(&msg);
 				return;
 			}
 		}
 		loop_start = 0;
 		loop_finish = grunt_count;
-	}
-	else
-	{
+	} else {
 		// Preparing a single grunt.
-		if ( !grunts[target]->Prepare_Disks() )
-		{
+		if (!grunts[target]->Prepare_Disks()) {
 			// Send failure message back to Iometer.
 			msg.data = 0;
-			if( IsBigEndian() )
-			{
-				(void) reorder(msg);
+			if (IsBigEndian()) {
+				(void)reorder(msg);
 			}
-			prt->Send( &msg );
+			prt->Send(&msg);
 			return;
 		}
 
@@ -657,186 +595,153 @@
 	}
 
 	// Peek to see if the prepare was be canceled by the user.
-	for ( i = loop_start; i < loop_finish; i++ )
-	{
-		while( grunts[i]->not_ready )
-		{
-			if ( prt->Peek() )
-			{
-				prt->Receive( &msg );
-				if( IsBigEndian() )
-				{
-					(void) reorder(msg);
+	for (i = loop_start; i < loop_finish; i++) {
+		while (grunts[i]->not_ready) {
+			if (prt->Peek()) {
+				prt->Receive(&msg);
+				if (IsBigEndian()) {
+					(void)reorder(msg);
 				}
 				Process_Message();
+			} else {
+				Sleep(LONG_DELAY);
 			}
-			else
-			{
-				Sleep( LONG_DELAY );
-			}
 		}
 		grunts[i]->grunt_state = TestIdle;
 	}
 	// Send a message back to Iometer to indicate that we're done preparing.
-	msg.data = 1;	// indicates success
-	if( IsBigEndian() )
-	{
-		(void) reorder(msg);
+	msg.data = 1;		// indicates success
+	if (IsBigEndian()) {
+		(void)reorder(msg);
 	}
-	prt->Send( &msg );
+	prt->Send(&msg);
 }
 
-
-
 //
 // Collecting and extracting system performance data.
 //
-void Manager::Get_Performance( int which_perf, int snapshot )
+void Manager::Get_Performance(int which_perf, int snapshot)
 {
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF)
-		|| (snapshot < 0) || (snapshot >= MAX_SNAPSHOTS) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF)
+	    || (snapshot < 0) || (snapshot >= MAX_SNAPSHOTS))
 		return;
 
 	// Get all performance data.
-	perf_data[which_perf].Get_Perf_Data( PERF_PROCESSOR, snapshot );
-	perf_data[which_perf].Get_Perf_Data( PERF_NETWORK_TCP, snapshot );
-	perf_data[which_perf].Get_Perf_Data( PERF_NETWORK_INTERFACE, snapshot );
+	perf_data[which_perf].Get_Perf_Data(PERF_PROCESSOR, snapshot);
+	perf_data[which_perf].Get_Perf_Data(PERF_NETWORK_TCP, snapshot);
+	perf_data[which_perf].Get_Perf_Data(PERF_NETWORK_INTERFACE, snapshot);
 
 	// Record time that performance snapshot was taken.
 	manager_performance[which_perf].time_counter[snapshot] = perf_data[which_perf].time_counter[snapshot];
 
 	// If this is the last snapshot to be taken, calculate the performance statistics
 	// to return to Iometer.
-	if ( snapshot == LAST_SNAPSHOT )
-	{
-		perf_data[which_perf].Calculate_CPU_Stats( &(manager_performance[which_perf].cpu_results) );
-		perf_data[which_perf].Calculate_TCP_Stats( &(manager_performance[which_perf].net_results) );
-		perf_data[which_perf].Calculate_NI_Stats( &(manager_performance[which_perf].net_results) );
+	if (snapshot == LAST_SNAPSHOT) {
+		perf_data[which_perf].Calculate_CPU_Stats(&(manager_performance[which_perf].cpu_results));
+		perf_data[which_perf].Calculate_TCP_Stats(&(manager_performance[which_perf].net_results));
+		perf_data[which_perf].Calculate_NI_Stats(&(manager_performance[which_perf].net_results));
 	}
 }
 
-
-
 //
 // Gathering results from all threads and reporting them back to Iometer.
 //
-void Manager::Report_Results( int which_perf )
+void Manager::Report_Results(int which_perf)
 {
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF))
 		return;
 
 	// Shortcut pointers to where results are stored.
-	Worker_Results	*worker_results;
+	Worker_Results *worker_results;
 
 	// If recording, update the ending results for the system performance.
-	if ( record )
-	{
-		Get_Performance( which_perf, LAST_SNAPSHOT );
+	if (record) {
+		Get_Performance(which_perf, LAST_SNAPSHOT);
 	}
-
 	// Copy the current system results into a message.
-	memcpy( (void*) &data_msg.data.manager_results, (void*) 
-		&(manager_performance[which_perf]), sizeof( Manager_Results ) );
-	if( IsBigEndian() )
-	{
-		(void) reorder(data_msg, DATA_MESSAGE_MANAGER_RESULTS, SEND);
+	memcpy((void *)&data_msg.data.manager_results, (void *)
+	       &(manager_performance[which_perf]), sizeof(Manager_Results));
+	if (IsBigEndian()) {
+		(void)reorder(data_msg, DATA_MESSAGE_MANAGER_RESULTS, SEND);
 	}
 #if defined (IOMTR_OS_LINUX) && defined (IOMTR_CPU_XSCALE)
 	Manager_Results_double_swap(&data_msg.data.manager_results);
 #endif
-	prt->Send( &data_msg, DATA_MESSAGE_SIZE );
+	prt->Send(&data_msg, DATA_MESSAGE_SIZE);
 
 	// Sending back a result message for each worker thread.  Using multiple
 	// messages keeps the message size down to a reasonable limit.
 	worker_results = &(data_msg.data.worker_results);
-	for ( int g = 0; g < grunt_count; g++ )
-	{
+	for (int g = 0; g < grunt_count; g++) {
 		// Only send results for grunts that are running.
-		if ( grunts[g]->target_count && !grunts[g]->idle )
-		{
-			#if _DEBUG
-				cout << "Reporting results for grunt " << g << " ...";
-			#endif
+		if (grunts[g]->target_count && !grunts[g]->idle) {
+#if _DEBUG
+			cout << "Reporting results for grunt " << g << " ...";
+#endif
 			// Copying worker's results into the message.
-			memcpy( (void*) worker_results, (void*) &(grunts[g]->worker_performance), 
-				sizeof( Worker_Results ) );
+			memcpy((void *)worker_results, (void *)&(grunts[g]->worker_performance),
+			       sizeof(Worker_Results));
 			worker_results->target_results.count = grunts[g]->target_count;
 
 			// If recording, update the ending results for the worker's drive performance.
-			if ( grunts[g]->grunt_state == TestRecording )
-			{
+			if (grunts[g]->grunt_state == TestRecording) {
 				worker_results->time[LAST_SNAPSHOT] = rdtsc();
 			}
 
-			if ( which_perf == LAST_UPDATE_PERF )
-			{
+			if (which_perf == LAST_UPDATE_PERF) {
 				// Subtract previous update's results from current results to give 
 				// results since last update.
 
-				Raw_Result	*target_result;
-				Raw_Result	*prev_target_result;
+				Raw_Result *target_result;
+				Raw_Result *prev_target_result;
 				int i;
 
-				worker_results->time[FIRST_SNAPSHOT] = 
-					grunts[g]->prev_worker_performance.time[LAST_SNAPSHOT];
+				worker_results->time[FIRST_SNAPSHOT] =
+				    grunts[g]->prev_worker_performance.time[LAST_SNAPSHOT];
 
-				for ( i = 0; i < worker_results->target_results.count; i++ )
-				{
+				for (i = 0; i < worker_results->target_results.count; i++) {
 					target_result = &(worker_results->target_results.result[i]);
 					prev_target_result
-						= &(grunts[g]->prev_worker_performance.target_results.result[i]);
+					    = &(grunts[g]->prev_worker_performance.target_results.result[i]);
 
 					// Subtract current result from each counter.
-					target_result->bytes_read
-						-= prev_target_result->bytes_read;
-					target_result->bytes_written
-						-= prev_target_result->bytes_written;
-					target_result->read_count
-						-= prev_target_result->read_count;
-					target_result->write_count
-						-= prev_target_result->write_count;
-					target_result->transaction_count
-						-= prev_target_result->transaction_count;
-					target_result->connection_count
-						-= prev_target_result->connection_count;
-					target_result->read_errors
-						-= prev_target_result->read_errors;
-					target_result->write_errors
-						-= prev_target_result->write_errors;
-					target_result->read_latency_sum
-						-= prev_target_result->read_latency_sum;
-					target_result->write_latency_sum
-						-= prev_target_result->write_latency_sum;
+					target_result->bytes_read -= prev_target_result->bytes_read;
+					target_result->bytes_written -= prev_target_result->bytes_written;
+					target_result->read_count -= prev_target_result->read_count;
+					target_result->write_count -= prev_target_result->write_count;
+					target_result->transaction_count -= prev_target_result->transaction_count;
+					target_result->connection_count -= prev_target_result->connection_count;
+					target_result->read_errors -= prev_target_result->read_errors;
+					target_result->write_errors -= prev_target_result->write_errors;
+					target_result->read_latency_sum -= prev_target_result->read_latency_sum;
+					target_result->write_latency_sum -= prev_target_result->write_latency_sum;
 					target_result->transaction_latency_sum
-						-= prev_target_result->transaction_latency_sum;
+					    -= prev_target_result->transaction_latency_sum;
 					target_result->connection_latency_sum
-						-= prev_target_result->connection_latency_sum;
-					target_result->counter_time
-						-= prev_target_result->counter_time;
+					    -= prev_target_result->connection_latency_sum;
+					target_result->counter_time -= prev_target_result->counter_time;
 
 					// Use values from prev_worker_performance for "max_" values.
-					target_result->max_raw_read_latency
-						= prev_target_result->max_raw_read_latency;
+					target_result->max_raw_read_latency = prev_target_result->max_raw_read_latency;
 					target_result->max_raw_write_latency
-						= prev_target_result->max_raw_write_latency;
+					    = prev_target_result->max_raw_write_latency;
 					target_result->max_raw_transaction_latency
-						= prev_target_result->max_raw_transaction_latency;
+					    = prev_target_result->max_raw_transaction_latency;
 					target_result->max_raw_connection_latency
-						= prev_target_result->max_raw_connection_latency;
+					    = prev_target_result->max_raw_connection_latency;
 				}
 
 				// Store away a copy of the current results for next time.
-				memcpy( &(grunts[g]->prev_worker_performance), &(grunts[g]->worker_performance), 
-					sizeof( Worker_Results ) );
+				memcpy(&(grunts[g]->prev_worker_performance), &(grunts[g]->worker_performance),
+				       sizeof(Worker_Results));
 
 				// Record time of last update.
 				grunts[g]->prev_worker_performance.time[LAST_SNAPSHOT] = rdtsc();
 
 				// Clear "max_" values in prev_worker_performance.
-				for ( i = 0; i < worker_results->target_results.count; i++ )
-				{
+				for (i = 0; i < worker_results->target_results.count; i++) {
 					Raw_Result *prev_target_result
-						= &(grunts[g]->prev_worker_performance.target_results.result[i]);
+					    = &(grunts[g]->prev_worker_performance.target_results.result[i]);
 
 					prev_target_result->max_raw_read_latency = 0;
 					prev_target_result->max_raw_write_latency = 0;
@@ -844,32 +749,26 @@
 					prev_target_result->max_raw_connection_latency = 0;
 				}
 			}
-
 			// Sending results to Iometer.
-			if( IsBigEndian() )
-			{
-				(void) reorder(data_msg, DATA_MESSAGE_WORKER_RESULTS, SEND);
+			if (IsBigEndian()) {
+				(void)reorder(data_msg, DATA_MESSAGE_WORKER_RESULTS, SEND);
 			}
-			prt->Send( &data_msg, DATA_MESSAGE_SIZE );
-			#if _DEBUG
-				cout << "sent." << endl;
-			#endif
+			prt->Send(&data_msg, DATA_MESSAGE_SIZE);
+#if _DEBUG
+			cout << "sent." << endl;
+#endif
 		}
 	}
 
-	if ( record && (which_perf == LAST_UPDATE_PERF) )
-	{
+	if (record && (which_perf == LAST_UPDATE_PERF)) {
 		// Store current performance counters as baseline for next update.
-		Get_Performance( LAST_UPDATE_PERF, FIRST_SNAPSHOT );
+		Get_Performance(LAST_UPDATE_PERF, FIRST_SNAPSHOT);
 	}
-
-	#if _DEBUG
-		cout << "   Finished reporting results." << endl;
-	#endif
+#if _DEBUG
+	cout << "   Finished reporting results." << endl;
+#endif
 }
 
-
-
 //
 // Manager runs assuming Iometer control.  Returns TRUE if Dynamo should
 // continue to run, otherwise FALSE.
@@ -881,199 +780,183 @@
 #ifdef _DEBUG
 		cout << "in while loop : Manager::Run() " << endl;
 #endif
-		if ( prt->Receive( &msg ) == PORT_ERROR )
-		{
+		if (prt->Receive(&msg) == PORT_ERROR) {
 			// Error receiving data message, stop running.
 			cout << "Error receiving message." << endl << flush;
 			return FALSE;
-		}
-		else
-		{
-			if( IsBigEndian() )
-			{
-				(void) reorder(msg);
+		} else {
+			if (IsBigEndian()) {
+				(void)reorder(msg);
 			}
 			// Continue to process messages until manager indicates stopping.
-			if ( !Process_Message() )
+			if (!Process_Message())
 				return FALSE;
 
 			// On a reset, stop then restart running the manager.
-			if ( msg.purpose == RESET )
+			if (msg.purpose == RESET)
 				return TRUE;
 		}
 	}
 }
 
-
-
 //
 // Processing messages from Iometer based on their purpose and
 // returns TRUE if the manager can process additional messages.
 //
 BOOL Manager::Process_Message()
 {
-	switch ( msg.purpose )
-	{
+	switch (msg.purpose) {
 	case ADD_WORKERS:
 #ifdef _DETAILS
 		cout << "in Process_Message() : ADD_WORKERS" << endl;
 #endif
-		Add_Workers( msg.data );
+		Add_Workers(msg.data);
 		break;
 
-	// Signaling to reset all workers
+		// Signaling to reset all workers
 	case RESET:
 		// Remove all workers.
 #ifdef _DETAILS
 		cout << "in Process_Message() : RESET" << endl;
 #endif
-		Remove_Workers( ALL_WORKERS );
+		Remove_Workers(ALL_WORKERS);
 		prt->Disconnect();
 		break;
-	// Received call to end program or thread execution.
+		// Received call to end program or thread execution.
 	case EXIT:
 #ifdef _DETAILS
 		cout << "in Process_Message() : EXIT" << endl;
 #endif
-		Remove_Workers( msg.data );
-		return ( msg.data != MANAGER );
+		Remove_Workers(msg.data);
+		return (msg.data != MANAGER);
 
-	// Preparing drives for access.
+		// Preparing drives for access.
 	case PREP_DISKS:
 #ifdef _DETAILS
 		cout << "in Process_Message() : PREP_DISKS" << endl;
 #endif
-		Prepare_Disks( msg.data );
+		Prepare_Disks(msg.data);
 		break;
-	// Signalling to stop disk preparation.
+		// Signalling to stop disk preparation.
 	case STOP_PREPARE:
 #ifdef _DETAILS
 		cout << "in Process_Message() : STOP_PREPARE" << endl;
 #endif
-		Stop_Prepare( msg.data );
+		Stop_Prepare(msg.data);
 		break;
-	
-	// Reporting all targets accessible by this manager.
+
+		// Reporting all targets accessible by this manager.
 	case REPORT_TARGETS:
 #ifdef _DETAILS
 		cout << "in Process_Message() : REPORT_TARGETS" << endl;
 #endif
-		data_msg.count = Report_Disks( data_msg.data.targets );
-		if( IsBigEndian() )
-		{
-			(void) reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
+		data_msg.count = Report_Disks(data_msg.data.targets);
+		if (IsBigEndian()) {
+			(void)reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
 		}
-		prt->Send( &data_msg, DATA_MESSAGE_SIZE );
+		prt->Send(&data_msg, DATA_MESSAGE_SIZE);
 
-		data_msg.count = Report_TCP( data_msg.data.targets );
-		if( IsBigEndian() )
-		{
-			(void) reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
+		data_msg.count = Report_TCP(data_msg.data.targets);
+		if (IsBigEndian()) {
+			(void)reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
 		}
-		prt->Send( &data_msg, DATA_MESSAGE_SIZE );
+		prt->Send(&data_msg, DATA_MESSAGE_SIZE);
 
-		data_msg.count = Report_VIs( data_msg.data.targets );
-		if( IsBigEndian() )
-		{
-			(void) reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
+		data_msg.count = Report_VIs(data_msg.data.targets);
+		if (IsBigEndian()) {
+			(void)reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
 		}
-		prt->Send( &data_msg, DATA_MESSAGE_SIZE );
+		prt->Send(&data_msg, DATA_MESSAGE_SIZE);
 		break;
-	// Setting targets for a given grunt and reporting back.
+		// Setting targets for a given grunt and reporting back.
 	case SET_TARGETS:
 #ifdef _DETAILS
 		cout << "in Process_Message() : SET_TARGETS" << endl;
 #endif
-		prt->Receive( &data_msg, DATA_MESSAGE_SIZE );
-		if( IsBigEndian() )
-		{
-			(void) reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, RECV);
+		prt->Receive(&data_msg, DATA_MESSAGE_SIZE);
+		if (IsBigEndian()) {
+			(void)reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, RECV);
 		}
-		msg.data = Set_Targets( msg.data, data_msg.count, 
-			data_msg.data.targets );
+		msg.data = Set_Targets(msg.data, data_msg.count, data_msg.data.targets);
 		// Send back success/failure indication along with additional error
 		// information or target settings (such as TCP port).
-		if( IsBigEndian() )
-		{
-			(void) reorder(msg);
+		if (IsBigEndian()) {
+			(void)reorder(msg);
 		}
-		prt->Send( &msg );
-		if( IsBigEndian() )
-		{
-			(void) reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
+		prt->Send(&msg);
+		if (IsBigEndian()) {
+			(void)reorder(data_msg, DATA_MESSAGE_TARGET_SPEC, SEND);
 		}
-		prt->Send( &data_msg, DATA_MESSAGE_SIZE );
+		prt->Send(&data_msg, DATA_MESSAGE_SIZE);
 		break;
 
-	// Setting access specifications for next test.
+		// Setting access specifications for next test.
 	case SET_ACCESS:
 #ifdef _DETAILS
 		cout << "in Process_Message() : SET_ACCESS" << endl;
 #endif
-		prt->Receive( &data_msg, DATA_MESSAGE_SIZE );
-		if( IsBigEndian() )
-		{
-			(void) reorder(data_msg, DATA_MESSAGE_TEST_SPEC, RECV);
+		prt->Receive(&data_msg, DATA_MESSAGE_SIZE);
+		if (IsBigEndian()) {
+			(void)reorder(data_msg, DATA_MESSAGE_TEST_SPEC, RECV);
 		}
-		msg.data = (int)Set_Access( msg.data, &(data_msg.data.spec) );
-		
-		if( IsBigEndian() )
-		{
-			(void) reorder(msg);
+		msg.data = (int)Set_Access(msg.data, &(data_msg.data.spec));
+
+		if (IsBigEndian()) {
+			(void)reorder(msg);
 		}
-		prt->Send( &msg );	// notify Iometer of success
+		prt->Send(&msg);	// notify Iometer of success
 		break;
 
-	// Signalling start of test.
+		// Signalling start of test.
 	case START:
 #ifdef _DETAILS
 		cout << "in Process_Message() : START" << endl;
 #endif
-		Start_Test( msg.data );
+		Start_Test(msg.data);
 		break;
-	// Beginning to perform I/O.
+		// Beginning to perform I/O.
 	case BEGIN_IO:
 #ifdef _DETAILS
 		cout << "in Process_Message() : BEGIN_IO" << endl;
 #endif
-		Begin_IO( msg.data );
+		Begin_IO(msg.data);
 		break;
-	// Beginning recording of test results.
+		// Beginning recording of test results.
 	case RECORD_ON:
 #ifdef _DETAILS
 		cout << "in Process_Message() : RECORD_ON" << endl;
 #endif
-		Record_On( msg.data );
+		Record_On(msg.data);
 		break;
-	// Stopping recording of test results.
+		// Stopping recording of test results.
 	case RECORD_OFF:
 #ifdef _DETAILS
 		cout << "in Process_Message() : RECORD_OFF" << endl;
 #endif
-		Record_Off( msg.data );
+		Record_Off(msg.data);
 		break;
-	// Signalling to stop testing.
+		// Signalling to stop testing.
 	case STOP:
 #ifdef _DETAILS
 		cout << "in Process_Message() : STOP" << endl;
 #endif
-		Stop_Test( msg.data );
+		Stop_Test(msg.data);
 		break;
 
-	// Reporting results of whole test to Iometer.
+		// Reporting results of whole test to Iometer.
 	case REPORT_RESULTS:
 #ifdef _DETAILS
 		cout << "in Process_Message() : REPORT_RESULTS" << endl;
 #endif
-		Report_Results( WHOLE_TEST_PERF );
+		Report_Results(WHOLE_TEST_PERF);
 		break;
 
-	// Reporting results since last update to Iometer.
+		// Reporting results since last update to Iometer.
 	case REPORT_UPDATE:
 #ifdef _DETAILS
 		cout << "in Process_Message() : REPORT_UPDATE" << endl;
 #endif
-		Report_Results( LAST_UPDATE_PERF );
+		Report_Results(LAST_UPDATE_PERF);
 		break;
 
 	default:
@@ -1083,42 +966,35 @@
 	return TRUE;
 }
 
-
 //
 // Signalling all threads to start testing.
 //
-void Manager::Start_Test( int target )
+void Manager::Start_Test(int target)
 {
 	int g;
 
 	cout << "Starting..." << endl << flush;
 
 	// Start all the grunts.  This creates the grunt threads.
-	if ( target == ALL_WORKERS )
-	{
-		for ( g = 0; g < grunt_count; g++ )
-		{
+	if (target == ALL_WORKERS) {
+		for (g = 0; g < grunt_count; g++) {
 			grunts[g]->Start_Test();
 		}
-	}
-	else
-	{
+	} else {
 		grunts[target]->Start_Test();
 	}
-	#if _DEBUG
-		cout << "   Started." << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "   Started." << endl << flush;
+#endif
 	// Reply that test has started.
 	msg.data = TRUE;
-	prt->Send( &msg );
+	prt->Send(&msg);
 }
 
-
-
 //
 // Signalling all threads to begin performing I/O.
 //
-void Manager::Begin_IO( int target )
+void Manager::Begin_IO(int target)
 {
 	msg.data = TRUE;
 	cout << "Beginning to perform I/O..." << endl << flush;
@@ -1129,73 +1005,58 @@
 	}
 #endif
 
-	if ( target == ALL_WORKERS )
-	{
-		for ( int i = 0; i < grunt_count; i++ )
-		{
+	if (target == ALL_WORKERS) {
+		for (int i = 0; i < grunt_count; i++) {
 			grunts[i]->Begin_IO();
-			if ( grunts[i]->critical_error )
+			if (grunts[i]->critical_error)
 				msg.data = FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		grunts[target]->Begin_IO();
-		if ( grunts[target]->critical_error )
+		if (grunts[target]->critical_error)
 			msg.data = FALSE;
 	}
-	#if _DEBUG
-		cout << "   Performing I/O." << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "   Performing I/O." << endl << flush;
+#endif
 
 	// Reply that I/O has started.
-	if( IsBigEndian() )
-	{
-		(void) reorder(msg);
+	if (IsBigEndian()) {
+		(void)reorder(msg);
 	}
-	prt->Send( &msg );
+	prt->Send(&msg);
 }
 
-
 //
 // Signalling to stop testing.
 //
-void Manager::Stop_Test( int target )
+void Manager::Stop_Test(int target)
 {
-	if ( target == ALL_WORKERS )
-	{
-		for ( int i = 0; i < grunt_count; i++ )
-		{
+	if (target == ALL_WORKERS) {
+		for (int i = 0; i < grunt_count; i++) {
 			grunts[i]->Stop_Test();
 		}
-	}
-	else
-	{
+	} else {
 		grunts[target]->Stop_Test();
 	}
 
 	cout << "Stopping..." << endl << flush;
 
-	if ( target == ALL_WORKERS )
-	{
-		for ( int i = 0; i < grunt_count; i++ )
-		{
+	if (target == ALL_WORKERS) {
+		for (int i = 0; i < grunt_count; i++) {
 			grunts[i]->Wait_For_Stop();
 		}
-	}
-	else
-	{
+	} else {
 		grunts[target]->Wait_For_Stop();
 	}
 
 	cout << "   Stopped." << endl << flush;
 
 	// Reply that test has stopped.
-	if( IsBigEndian() )
-	{
-		(void) reorder(msg);
+	if (IsBigEndian()) {
+		(void)reorder(msg);
 	}
-	prt->Send( &msg );
+	prt->Send(&msg);
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
 	if (do_syslog) {
@@ -1204,17 +1065,15 @@
 #endif
 }
 
-
-
 //
 // Signalling to stop disk preparation.
 //
-void Manager::Stop_Prepare( int target )
+void Manager::Stop_Prepare(int target)
 {
 	cout << "Stopping..." << endl << flush;
 
-	if ( target == ALL_WORKERS )
-		for ( int i = 0; i < grunt_count; i++ )
+	if (target == ALL_WORKERS)
+		for (int i = 0; i < grunt_count; i++)
 			grunts[i]->grunt_state = TestIdle;
 	else
 		grunts[target]->grunt_state = TestIdle;
@@ -1222,70 +1081,57 @@
 	cout << "   Stopped." << endl << flush;
 }
 
-
 //
 // Received call to remove workers
 //
-void Manager::Remove_Workers( int target )
+void Manager::Remove_Workers(int target)
 {
 	// If we're removing just one worker, remove it and return.
-	if ( target >= 0 && target < grunt_count )
-	{
+	if (target >= 0 && target < grunt_count) {
 		// Remove a worker.  It does not matter which one.
 		cout << "Removing worker " << target << "." << endl << flush;
 		delete grunts[--grunt_count];
+
 		return;
 	}
-
 	// Remove all workers.
 	cout << "Removing all workers." << endl << flush;
-	while ( grunt_count )
+	while (grunt_count)
 		delete grunts[--grunt_count];
 }
 
-
-
 //
 // Setting the targets for one or more grunts.
 //
-BOOL Manager::Set_Targets( int worker_no, int count, Target_Spec* target_specs )
+BOOL Manager::Set_Targets(int worker_no, int count, Target_Spec * target_specs)
 {
-	if ( worker_no == ALL_WORKERS )
-	{
-		for ( int i = 0; i < grunt_count; i++ )
-		{
+	if (worker_no == ALL_WORKERS) {
+		for (int i = 0; i < grunt_count; i++) {
 			cout << "Worker " << i << " setting targets..." << endl;
-			if ( !grunts[i]->Set_Targets( count, target_specs ) )
+			if (!grunts[i]->Set_Targets(count, target_specs))
 				return FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		cout << "Worker " << worker_no << " setting targets..." << endl;
-		return grunts[worker_no]->Set_Targets( count, target_specs );
+		return grunts[worker_no]->Set_Targets(count, target_specs);
 	}
 	return TRUE;
 }
 
-
-
-
 //
 // Setting access specifications for next test.
 // Note that Iometer will call Set_Access before testing starts to ensure that
 // Dynamo can run the spec with the largest transfer request.
 //
-BOOL Manager::Set_Access( int target, const Test_Spec *spec )
+BOOL Manager::Set_Access(int target, const Test_Spec * spec)
 {
-	int		g;			// loop control variable
+	int g;			// loop control variable
 
 	// Recursively assign all workers the same access specification.
-	if ( target == ALL_WORKERS )
-	{
+	if (target == ALL_WORKERS) {
 		cout << "All workers running Access Spec: " << spec->name << endl;
-		for ( g = 0; g < grunt_count; g++ )
-		{
-			if ( !Set_Access( g, spec ) )
+		for (g = 0; g < grunt_count; g++) {
+			if (!Set_Access(g, spec))
 				return FALSE;
 		}
 		return TRUE;
@@ -1295,22 +1141,19 @@
 
 	// If the grunt could not set the access spec properly, return.
 	// The grunt may not have been able to grow its data buffer.
-	if ( !grunts[target]->Set_Access( spec ) )
+	if (!grunts[target]->Set_Access(spec))
 		return FALSE;
 
 	// If the grunt is not using the manager's data buffer or the manager's
 	// buffer is already large enough, just return.
-	if ( grunts[target]->data_size ||
-		data_size >= grunts[target]->access_spec.max_transfer )
-	{
+	if (grunts[target]->data_size || data_size >= grunts[target]->access_spec.max_transfer) {
 		return TRUE;
 	}
-
 	// Grow the manager's data buffer and update all grunts using it.
-	#if _DEBUG
-		cout << "Growing manager data buffer from " << data_size << " to " 
-			 << grunts[target]->access_spec.max_transfer << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "Growing manager data buffer from " << data_size << " to "
+	    << grunts[target]->access_spec.max_transfer << endl << flush;
+#endif
 
 	// Align all data transfers on a page boundary.  This will work for all disks
 	// with sector sizes that divide evenly into the page size - which is always
@@ -1318,32 +1161,28 @@
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	free(data);
 	errno = 0;
-	if ( !(data = valloc(grunts[target]->access_spec.max_transfer) ))
-#elif defined(IOMTR_OS_NETWARE) 
+	if (!(data = valloc(grunts[target]->access_spec.max_transfer)))
+#elif defined(IOMTR_OS_NETWARE)
 	NXMemFree(data);
 	errno = 0;
-	if ( !(data = NXMemAlloc(grunts[target]->access_spec.max_transfer, 1) ))
+	if (!(data = NXMemAlloc(grunts[target]->access_spec.max_transfer, 1)))
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	VirtualFree( data, 0, MEM_RELEASE );
-	if ( !(data = VirtualAlloc( NULL, grunts[target]->access_spec.max_transfer, 
-		MEM_COMMIT, PAGE_READWRITE )) )
+	VirtualFree(data, 0, MEM_RELEASE);
+	if (!(data = VirtualAlloc(NULL, grunts[target]->access_spec.max_transfer, MEM_COMMIT, PAGE_READWRITE)))
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		// Could not allocate a larger buffer.  Signal failure.
-		cout << "*** Manager could not allocate data buffer for I/O transfers." 
-			<< endl << flush;
+		cout << "*** Manager could not allocate data buffer for I/O transfers." << endl << flush;
 		data_size = 0;
 		return FALSE;
 	}
 	data_size = grunts[target]->access_spec.max_transfer;
 
 	// Update all grunts using the manager's data buffer.
-	for ( g = 0; g < grunt_count; g++ )
-	{
-		if ( !grunts[g]->data_size )
-		{
+	for (g = 0; g < grunt_count; g++) {
+		if (!grunts[g]->data_size) {
 			grunts[g]->read_data = data;
 			grunts[g]->write_data = data;
 		}
@@ -1351,89 +1190,73 @@
 	return TRUE;
 }
 
-
-
 //
 // Beginning recording of test results.
 //
-void Manager::Record_On( int target )
+void Manager::Record_On(int target)
 {
 	record = TRUE;		// At least 1 worker is recording.
 
-	#if _DEBUG
-		cout << "Recording Started." << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "Recording Started." << endl << flush;
+#endif
 
-	if ( target == ALL_WORKERS )
-	{
-		for ( int i = 0; i < grunt_count; i++ )
-		{
+	if (target == ALL_WORKERS) {
+		for (int i = 0; i < grunt_count; i++) {
 			grunts[i]->Record_On();
 		}
-	}
-	else
-	{
+	} else {
 		grunts[target]->Record_On();
 	}
 
 	// Get performance data for start of test.
-	Get_Performance( WHOLE_TEST_PERF, FIRST_SNAPSHOT );
-	Get_Performance( LAST_UPDATE_PERF, FIRST_SNAPSHOT );
+	Get_Performance(WHOLE_TEST_PERF, FIRST_SNAPSHOT);
+	Get_Performance(LAST_UPDATE_PERF, FIRST_SNAPSHOT);
 }
 
-
-
 //
 // Stopping recording of test results.
 //
-void Manager::Record_Off( int target )
+void Manager::Record_Off(int target)
 {
 	// Get performance data for end of test.
-	Get_Performance( WHOLE_TEST_PERF, LAST_SNAPSHOT );
-	Get_Performance( LAST_UPDATE_PERF, LAST_SNAPSHOT );
+	Get_Performance(WHOLE_TEST_PERF, LAST_SNAPSHOT);
+	Get_Performance(LAST_UPDATE_PERF, LAST_SNAPSHOT);
 
-	if ( target == ALL_WORKERS )
-	{
-		for ( int i = 0; i < grunt_count; i++ )
-		{
+	if (target == ALL_WORKERS) {
+		for (int i = 0; i < grunt_count; i++) {
 			grunts[i]->Record_Off();
 		}
-	}
-	else
-	{
+	} else {
 		grunts[target]->Record_Off();
 	}
 	cout << "   Stopped." << endl << flush;
 
 	record = FALSE;		// No workers are recording data.
-	#if _DEBUG
-		cout << "Recording stopped." << endl << flush;
-	#endif
-	if( IsBigEndian() )
-	{
-		(void) reorder(msg);
+#if _DEBUG
+	cout << "Recording stopped." << endl << flush;
+#endif
+	if (IsBigEndian()) {
+		(void)reorder(msg);
 	}
-	prt->Send( &msg );
+	prt->Send(&msg);
 }
 
-
-
 //
 // Starting a new grunt worker.  Sending a message back to Iometer indicating 
 // the number of workers actually created.
 //
-void Manager::Add_Workers( int count )
+void Manager::Add_Workers(int count)
 {
 	msg.data = 0;
 
-	#if _DEBUG 
-		cout << "Adding " << count << " new worker(s)." << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "Adding " << count << " new worker(s)." << endl << flush;
+#endif
 
-	for ( int i = 0; i < count; i++ )
-	{
+	for (int i = 0; i < count; i++) {
 		// Create a new grunt.
-		if ( !(grunts[grunt_count] = new Grunt) )
+		if (!(grunts[grunt_count] = new Grunt))
 			break;
 
 		// Assign grunt to manager's data buffer by default.
@@ -1444,24 +1267,20 @@
 	}
 
 	// See if we successfully create all workers requested.
-	if ( msg.data != count )
-	{
+	if (msg.data != count) {
 		// Failed to create all workers.
-		while ( msg.data )
-		{
-			Remove_Workers( grunt_count-- );
+		while (msg.data) {
+			Remove_Workers(grunt_count--);
 			msg.data--;
 		}
 	}
-
 #if _DEBUG
 	cout << msg.data << " worker(s) are created." << endl;
 #endif
 
-	if( IsBigEndian() )
-	{
-		(void) reorder(msg);
+	if (IsBigEndian()) {
+		(void)reorder(msg);
 	}
-	
-	prt->Send( &msg );
+
+	prt->Send(&msg);
 }

Modified: branches/IOMETER-restruct/iometer/src/IOManager.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOManager.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOManager.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -89,121 +89,112 @@
 #ifndef MANAGER_DEFINED
 #define MANAGER_DEFINED
 
-
-
 #include "IOGrunt.h"
 #include "IOPort.h"
 #include "IOPerformance.h"
 
-
-
 #if defined(IOMTR_OSFAMILY_UNIX)
- #if defined(IOMTR_OS_LINUX)
-  #define DEFAULT_EXCLUDE_FILESYS   "proc shm swap devpts"
- #elif defined(IOMTR_OS_SOLARIS)
-  #define DEFAULT_EXCLUDE_FILESYS   "proc specfs config" 
- #elif defined(IOMTR_OS_OSX)
-  #define DEFAULT_EXCLUDE_FILESYS   "devfs nfs fdesc afpfs"
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
- #endif
+#if defined(IOMTR_OS_LINUX)
+#define DEFAULT_EXCLUDE_FILESYS   "proc shm swap devpts"
+#elif defined(IOMTR_OS_SOLARIS)
+#define DEFAULT_EXCLUDE_FILESYS   "proc specfs config"
+#elif defined(IOMTR_OS_OSX)
+#define DEFAULT_EXCLUDE_FILESYS   "devfs nfs fdesc afpfs"
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 #elif defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_WINDOWS)
  // if we are not on UNIX the excluded filesystem stuff doesn't really matter
- #define DEFAULT_EXCLUDE_FILESYS   ""
+#define DEFAULT_EXCLUDE_FILESYS   ""
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
+void Wait_for_Prepare(void *grunt_thread_info);
 
-
-void Wait_for_Prepare( void *grunt_thread_info );
-
-
-
 //
 // Class to manager grunt worker threads.
 //
-class Manager
-{
-public:
+class Manager {
+      public:
 	Manager();
 	~Manager();
 
-	const char* 	GetVersionString(BOOL fWithDebugIndicator = FALSE);
-	BOOL		Process_Message();
-	BOOL		Login( char* port_name );
-	BOOL		Run();
+	const char *GetVersionString(BOOL fWithDebugIndicator = FALSE);
+	BOOL Process_Message();
+	BOOL Login(char *port_name);
+	BOOL Run();
 
-	Port	        *prt;                  // Communication port to Iometer.
+	Port *prt;		// Communication port to Iometer.
 
-	Grunt*		grunts[MAX_WORKERS];   // I/O workers.
-	
-	void	        *data;					// Buffer for I/O requests.
-	int		data_size;				// Size of currently allocated data buffer.
+	Grunt *grunts[MAX_WORKERS];	// I/O workers.
 
-	char		manager_name[MAX_WORKER_NAME];	        // Name of manager, customizable on command line.
-	char            exclude_filesys[MAX_EXCLUDE_FILESYS];   // filesystem types to exclude, command line option
-	
-	char		blkdevlist[MAX_TARGETS][MAX_NAME];	// store command line supplied device name.
+	void *data;		// Buffer for I/O requests.
+	int data_size;		// Size of currently allocated data buffer.
+
+	char manager_name[MAX_WORKER_NAME];	// Name of manager, customizable on command line.
+	char exclude_filesys[MAX_EXCLUDE_FILESYS];	// filesystem types to exclude, command line option
+
+	char blkdevlist[MAX_TARGETS][MAX_NAME];	// store command line supplied device name.
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	char* 		swap_devices;
-	BOOL		is_destructive;
-	BOOL		is_buffered;
-#endif // IOMTR_OSFAMILY_UNIX
+	char *swap_devices;
+	BOOL is_destructive;
+	BOOL is_buffered;
+#endif				// IOMTR_OSFAMILY_UNIX
 
-private:
-	Message		msg;	       // Directional messages from Iometer.
-	Data_Message	data_msg;      // Data messages from Iometer.
-	int		grunt_count;   // Number of worker threads available.
-	char	       	*m_pVersionString;
-	char	       	*m_pVersionStringWithDebug;
+      private:
+	 Message msg;		// Directional messages from Iometer.
+	Data_Message data_msg;	// Data messages from Iometer.
+	int grunt_count;	// Number of worker threads available.
+	char *m_pVersionString;
+	char *m_pVersionStringWithDebug;
 
 	// Performance results functions and data.
-	void		Report_Results( int which_perf );
-	void		Get_Performance( int which_perf, int snapshot );
+	void Report_Results(int which_perf);
+	void Get_Performance(int which_perf, int snapshot);
 
-	Manager_Results	manager_performance[MAX_PERF];   // System performance results.
-	Performance	perf_data[MAX_PERF];		 // System performance information.
+	Manager_Results manager_performance[MAX_PERF];	// System performance results.
+	Performance perf_data[MAX_PERF];	// System performance information.
 
 	// Functions to process specific messages.
-	void		Start_Test( int target );
-	void		Begin_IO( int target );
-	void		Record_On( int target );
-	void		Record_Off( int target );
-	void		Stop_Test( int target );
+	void Start_Test(int target);
+	void Begin_IO(int target);
+	void Record_On(int target);
+	void Record_Off(int target);
+	void Stop_Test(int target);
 
-	BOOL		Set_Targets( int worker_no, int count, Target_Spec* target_specs );
+	BOOL Set_Targets(int worker_no, int count, Target_Spec * target_specs);
 
 	// Processing messages aimed at disk stuff.
-	void		Prepare_Disks( int target );
-	void		Stop_Prepare( int target );
+	void Prepare_Disks(int target);
+	void Stop_Prepare(int target);
 
-	int		Report_Disks( Target_Spec *disk_spec );
+	int Report_Disks(Target_Spec * disk_spec);
 #if defined(IOMTR_OSFAMILY_UNIX)
 	// These UNIX-specific methods are defined in IOManagerUNIX.cpp.
- #if defined(IOMTR_OS_OSX)
-	BOOL		containsPartitions(mach_port_t masterPort, char *bsdname);
- #endif
-	BOOL		Part_Reported_As_Logical(Target_Spec *spec, char *rdisk, int count);
+#if defined(IOMTR_OS_OSX)
+	BOOL containsPartitions(mach_port_t masterPort, char *bsdname);
+#endif
+	BOOL Part_Reported_As_Logical(Target_Spec * spec, char *rdisk, int count);
 
-	BOOL 		Sort_Raw_Disk_Names(Target_Spec *disk_spec, int start, int end);
-	int		Compare_Raw_Disk_Names(char *str1, char *str2);
+	BOOL Sort_Raw_Disk_Names(Target_Spec * disk_spec, int start, int end);
+	int Compare_Raw_Disk_Names(char *str1, char *str2);
 
-	BOOL 		Report_FDISK_Partitions(char *name, Target_Spec *disk_spec, int *count, int logical_count);
-	BOOL 		Report_VTOC_Partitions(char *name, Target_Spec *disk_spec, int *count, int logical_count);
-	BOOL 		Has_File_System(char *, char *);
-	void 		Get_All_Swap_Devices();
-#endif // IOMTR_OSFAMILY_UNIX
+	BOOL Report_FDISK_Partitions(char *name, Target_Spec * disk_spec, int *count, int logical_count);
+	BOOL Report_VTOC_Partitions(char *name, Target_Spec * disk_spec, int *count, int logical_count);
+	BOOL Has_File_System(char *, char *);
+	void Get_All_Swap_Devices();
+#endif				// IOMTR_OSFAMILY_UNIX
 
-	int		Report_TCP( Target_Spec *tcp_spec );
-	int		Report_VIs( Target_Spec *vi_spec );
+	int Report_TCP(Target_Spec * tcp_spec);
+	int Report_VIs(Target_Spec * vi_spec);
 
-	BOOL		Set_Access( int target, const Test_Spec* spec );
+	BOOL Set_Access(int target, const Test_Spec * spec);
 
-	void		Add_Workers( int count );
-	void		Remove_Workers( int target );
+	void Add_Workers(int count);
+	void Remove_Workers(int target);
 
-	BOOL		record;
+	BOOL record;
 };
 
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOManagerLinux.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOManagerLinux.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOManagerLinux.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -85,7 +85,6 @@
 /* ######################################################################### */
 #if defined(IOMTR_OS_LINUX)
 
-
 #include "IOManager.h"
 #include "IOTargetDisk.h"
 #include <dirent.h>
@@ -116,15 +115,17 @@
 // of disks found.  Drives are reported in order so that Iometer does not
 // need to sort them.
 //
-int Manager::Report_Disks( Target_Spec* disk_spec )
+int Manager::Report_Disks(Target_Spec * disk_spec)
 {
-	TargetDisk	d;
-	int		count = 0;
+	TargetDisk d;
+	int count = 0;
 	char usedDevs[USED_DEVS_MAX_SIZE + 1];
+
 	usedDevs[0] = '\0';
 
 	FILE *sfile;
 	char *swapbuf = NULL;
+
 	// prepare swap buffer which contains content of /proc/swaps
 	if ((sfile = fopen("/proc/swaps", "r")) == NULL)
 		swapbuf = NULL;
@@ -142,7 +143,7 @@
 	}
 
 	cout << "Reporting drive information..." << endl;
-	
+
 	// *********************************************************************************
 	// DEVELOPER NOTES
 	// ---------------
@@ -156,39 +157,36 @@
 	//    that are in mtab.
 	//
 	// **********************************************************************************
-	
+
 	//
 	// First find all virtual disks by inspecting the mount table. Then search for
 	// physical disks that aren't mounted.
 	//
 
-
 	if ((mnttab = getenv("MNTTAB")) == NULL)
 		mnttab = _PATH_MOUNTED;
 
 	FILE *file;
-	if ((file = fopen(mnttab, "r")) == NULL)
-	{
+
+	if ((file = fopen(mnttab, "r")) == NULL) {
 		cout << "open (mount tab) file " << mnttab << " failed with error " << errno << endl;
 		cout << "Set environment variable MNTTAB to correct pathname" << endl;
 		exit(1);
 	}
-	
+
 	struct mntent *ment;
 
 	int length;
 	char disk_name[MAX_NAME];
 
-	while ((ment = getmntent(file)) != NULL)
-	{
+	while ((ment = getmntent(file)) != NULL) {
 #ifdef _DEBUG
 		cout << "*** File system found: " << ment->mnt_fsname << "\n";
 #endif
 		if (!strncmp(ment->mnt_fsname, "/dev/", 5)) {
 			// This is a real disk. Add it to our list of disks not to use as
 			// physical devices.
-			if (strlen(usedDevs) + 2 + strlen(ment->mnt_fsname + 5) >=
-					USED_DEVS_MAX_SIZE) {
+			if (strlen(usedDevs) + 2 + strlen(ment->mnt_fsname + 5) >= USED_DEVS_MAX_SIZE) {
 				cerr << "Too many devices for our list! Aborting.\n";
 				exit(1);
 			}
@@ -196,7 +194,6 @@
 			strcat(usedDevs, ment->mnt_fsname + 5);
 			strcat(usedDevs, " ");
 		}
-
 		// see if the current file sys is an excluded file system type for dynamo.
 		if (strstr(exclude_filesys, ment->mnt_type) != NULL) {
 #ifdef _DEBUG
@@ -213,16 +210,15 @@
 		strncpy(disk_name, ment->mnt_dir, length);
 		disk_name[length] = 0;
 
-		if ( ! d.Init_Logical( disk_name ) ) {
+		if (!d.Init_Logical(disk_name)) {
 #ifdef _DEBUG
 			cout << "*** " << __FUNCTION__ << ": Init_Logical failed.\n";
 #endif
 			continue;
 		}
-
 		// Drive exists and ready for use.
 		d.spec.type = LogicalDiskType;
-		memcpy( &disk_spec[count], &d.spec, sizeof( Target_Spec ) );
+		memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
 
 		disk_spec[count].name[length] = 0;
 		// and TargetDisk::Init_Logical().
@@ -231,7 +227,7 @@
 		strcat(disk_spec[count].name, "]");
 
 #ifdef _DEBUG
-			cout << "   Found " << disk_spec[count].name << "." << endl << flush;
+		cout << "   Found " << disk_spec[count].name << "." << endl << flush;
 #endif
 		count++;
 		if (count >= MAX_TARGETS)
@@ -243,8 +239,9 @@
 		return count;
 
 	cout << "  Physical drives (raw devices)..." << endl;
-	
+
 	int i, valid_devcnt;
+
 	for (i = 0; i < MAX_TARGETS; i++) {
 		if (blkdevlist[i][0] == 0) {
 			break;
@@ -257,7 +254,7 @@
 		}
 	}
 	valid_devcnt = i;
-	
+
 	// Now reporting physical drives (raw devices). Data from /proc/partitions.
 	// Example output from /proc/partitions:
 	//////////////////////////////////////////////////////////////////////
@@ -270,11 +267,10 @@
 	//////////////////////////////////////////////////////////////////////
 	// Note: In the above example, "hdc" is a CD-ROM, and "sda1" and "sda2" are
 	// two partitions on the disk represented by "sda".
-		
+
 	file = fopen("/proc/partitions", "r");
 	if (file == NULL) {
-		cerr << "Open \"/proc/partitions\" failed (errno " << errno <<"). "
-			"Cannot locate physical disks.\n";
+		cerr << "Open \"/proc/partitions\" failed (errno " << errno << "). " "Cannot locate physical disks.\n";
 		exit(1);
 	}
 	//
@@ -282,23 +278,25 @@
 	// is blank, but fscanf will skip that automatically.
 	//
 	int c;
+
 	do {
 		c = getc(file);
 	} while ((c != '\n') && (c != EOF));
 
-	char devName[MAX_NAME], paddedDevName[MAX_NAME+2];
+	char devName[MAX_NAME], paddedDevName[MAX_NAME + 2];
+
 #if MAX_NAME != 80
- #warning ===> WARNING: You have to keep the fscanf() and MAX_NAME in sync!
- // "fscanf(... %<nn>s)" has to be "MAX_NAME - 1"
+#warning ===> WARNING: You have to keep the fscanf() and MAX_NAME in sync!
+	// "fscanf(... %<nn>s)" has to be "MAX_NAME - 1"
 #endif
-	while ((count < MAX_TARGETS) &&
-				 (fscanf(file, "%*d %*d %*d %79s", devName) == 1)) {
+	while ((count < MAX_TARGETS) && (fscanf(file, "%*d %*d %*d %79s", devName) == 1)) {
 		sprintf(paddedDevName, " %s ", devName);
 #ifdef _DEBUG
 		cout << __FUNCTION__ << ": Found device " << devName << "\n";
 #endif
 		if (strstr(usedDevs, paddedDevName) == NULL) {
 			int skip;
+
 			// Nobody has mounted this device. Try to open it for reading; if we can,
 			// then add it to our list of physical devices.
 #ifdef _DEBUG
@@ -307,7 +305,7 @@
 			skip = 0;
 			for (i = 0; i < valid_devcnt; i++) {
 				if ((devName[0] == '/' && !strcmp(devName, blkdevlist[i])) ||
-					(devName[0] != '/' && !strcmp(devName, blkdevlist[i] + strlen("/dev/")))) {
+				    (devName[0] != '/' && !strcmp(devName, blkdevlist[i] + strlen("/dev/")))) {
 #ifdef _DEBUG
 					cout << "Find duplicate device " << devName << ", Ignoring." << endl;
 #endif
@@ -326,7 +324,8 @@
 					tmp[i - 2] = ' ';
 					if (strstr(swapbuf, tmp) != NULL) {
 #ifdef _DEBUG
-					cout << __FUNCTION__ << ": Device " << devName << " is a swap device, Ignoring." << endl;
+						cout << __FUNCTION__ << ": Device " << devName <<
+						    " is a swap device, Ignoring." << endl;
 #endif
 						skip = 1;
 					}
@@ -357,23 +356,21 @@
 		free(swapbuf);
 	}
 	qsort(disk_spec, count, sizeof(Target_Spec), compareRawDiskNames);
-	return(count);
+	return (count);
 }
 
-
-
 //
 // This function compares two disk names. It just uses strcmp. I'm lazy.
 //
-static int compareRawDiskNames(const void *a, const void *b) {
+static int compareRawDiskNames(const void *a, const void *b)
+{
 	const Target_Spec *at = (const Target_Spec *)a;
 	const Target_Spec *bt = (const Target_Spec *)b;
-	return(strcmp(at->name, bt->name));
+
+	return (strcmp(at->name, bt->name));
 }
 
-
-
-int Manager::Report_TCP( Target_Spec *tcp_spec )
+int Manager::Report_TCP(Target_Spec * tcp_spec)
 {
 	int c, scanCount, i, skfd, count = 0;
 	char ifname[32];
@@ -381,7 +378,7 @@
 	struct ifreq ifr;
 
 	cout << "Reporting TCP network information..." << endl;
-	
+
 	netInfo = fopen("/proc/net/dev", "r");
 	assert(netInfo != NULL);
 	skfd = socket(PF_INET, SOCK_DGRAM, 0);
@@ -389,7 +386,6 @@
 		cerr << "Can not create socket in Manager::Report_TCP" << endl;
 		return -1;
 	}
-
 	// Pull out the first two lines of the file. These two lines contain
 	// labels for the columns.
 	for (i = 0; i < 2; ++i) {
@@ -412,16 +408,15 @@
 		strcpy(ifr.ifr_name, ifname);
 		ifr.ifr_addr.sa_family = AF_INET;
 		if (ioctl(skfd, SIOCGIFADDR, &ifr) == 0) {
-			strncpy ( tcp_spec[count].name, inet_ntoa(((struct sockaddr_in *)&(ifr.ifr_addr))->sin_addr), 
-					sizeof(tcp_spec[count].name) - 1 );
+			strncpy(tcp_spec[count].name, inet_ntoa(((struct sockaddr_in *)&(ifr.ifr_addr))->sin_addr),
+				sizeof(tcp_spec[count].name) - 1);
 			tcp_spec[count].type = TCPClientType;	// interface to access a client
 
-			#if _DEBUG
-				cout << "   Found " << tcp_spec[count].name << "." << endl;
-			#endif
+#if _DEBUG
+			cout << "   Found " << tcp_spec[count].name << "." << endl;
+#endif
 			count++;
-		}
-		else {
+		} else {
 #if _DEBUG
 			cerr << "ioctl fail in Manager::Report_TCP()" << endl;
 #endif
@@ -438,4 +433,4 @@
 	return count;
 }
 
-#endif // IOMTR_OS_LINUX
+#endif				// IOMTR_OS_LINUX

Modified: branches/IOMETER-restruct/iometer/src/IOManagerNetware.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOManagerNetware.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOManagerNetware.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -84,17 +84,18 @@
 // of disks found.  Drives are reported in order so that Iometer does not
 // need to sort them.
 //
-int Manager::Report_Disks( Target_Spec* disk_spec )
+int Manager::Report_Disks(Target_Spec * disk_spec)
 {
-	TargetDisk	d;
-	int		count = 0;
+	TargetDisk d;
+	int count = 0;
 	struct volume_info vInfo;
 	struct IOObjectGenericInfoDef info;
 	int length, volNum;
 	DWORD ret = 0;
 	DWORD next;
 	char disk_name[128];
-	#define MM_DIRECT_ACCESS_DEVICE 0
+
+#define MM_DIRECT_ACCESS_DEVICE 0
 	cout << "Reporting drive information..." << endl;
 	// *********************************************************************************
 	// DEVELOPER NOTES
@@ -103,7 +104,7 @@
 	// For NetWare
 	//
 	// **********************************************************************************
-	
+
 	//
 	// First find all virtual disks by returning volumes. Then search for
 	// physical disks using Media Manager.
@@ -111,36 +112,34 @@
 	cout << "  Logical drives (volumes)..." << endl;
 	for (volNum = 0, ret = 0; ret == 0;)	// volNum++
 	{
-		ret = netware_vol_info(&vInfo, &volNum);		// volNum is sequenced by the call - do not touch
+		ret = netware_vol_info(&vInfo, &volNum);	// volNum is sequenced by the call - do not touch
 
-		if (strstr("_ADMIN", (char *)vInfo.name) != NULL) 
+		if (strstr("_ADMIN", (char *)vInfo.name) != NULL)
 			continue;
 		if (vInfo.mounted != TRUE)
 			continue;
 
 		cout << "    Volume [" << vInfo.which << "] \"" << vInfo.name << "\" found.\n";
 		// see if the current volName is an excluded for dynamo.
-		if (strstr(exclude_filesys, (char *)vInfo.name) != NULL) 
-		{
+		if (strstr(exclude_filesys, (char *)vInfo.name) != NULL) {
 			cout << "    Volume [" << vInfo.which << "] \"" << vInfo.name << "\" excluded.\n";
 			continue;
 		}
 		length = strlen((char *)vInfo.name);
 		strncpy(disk_name, (char *)vInfo.name, length);
 		disk_name[length] = 0;
-		if ( ! d.Init_Logical( disk_name ) ) 
-		{
+		if (!d.Init_Logical(disk_name)) {
 			cout << "    * " << __FUNCTION__ << ": Init_Logical failed (RO?).\n";
 			continue;
 		}
 		// Drive exists and ready for use.
 		d.spec.type = LogicalDiskType;
-		memcpy( &disk_spec[count], &d.spec, sizeof( Target_Spec ) );
+		memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
 		disk_spec[count].name[length] = 0;
 		// check for this pattern is also in TargetDisk::Init_Logical().
-//		strcat(disk_spec[count].name, " [");
-//		strcat(disk_spec[count].name, "NSS");
-//		strcat(disk_spec[count].name, "]");
+//              strcat(disk_spec[count].name, " [");
+//              strcat(disk_spec[count].name, "NSS");
+//              strcat(disk_spec[count].name, "]");
 		count++;
 		if (count >= MAX_TARGETS)
 			break;
@@ -149,8 +148,7 @@
 		return count;
 	// Now reporting physical drives (raw devices).
 	cout << "  Physical drives (raw devices)..." << endl;
-	for (next = -1; (MM_FindObjectType(MM_IO_CLASS ,MM_DEVICE_OBJECT, &next) != MM_OBJECT_NOT_FOUND);)
-	{
+	for (next = -1; (MM_FindObjectType(MM_IO_CLASS, MM_DEVICE_OBJECT, &next) != MM_OBJECT_NOT_FOUND);) {
 		ret = MM_ReturnObjectGenericInfo(next, sizeof(struct IOObjectGenericInfoDef), &info);
 		if (!(info.status & MM_IOOBJECT_FROM_NWPA))
 			continue;
@@ -160,25 +158,24 @@
 			continue;
 		if (strstr((char *)info.name, "Floppy"))
 			continue;
-	 	if((ret=d.NWOpenDevice(next,1)) != -1)
-	 		d.NWCloseDevice(ret);
-	 	else
+		if ((ret = d.NWOpenDevice(next, 1)) != -1)
+			d.NWCloseDevice(ret);
+		else
 			continue;
 #ifdef _DEBUG
 		cout << __FUNCTION__ << ": Found device " << info.name << "\n";
 #endif
-		if ((info.status & MM_IOOBJECT_RESERVED) == 0) 
-		{	// If it can be reserved then add it to our list of physical devices.
+		if ((info.status & MM_IOOBJECT_RESERVED) == 0) {	// If it can be reserved then add it to our list of physical devices.
 #ifdef _DEBUG
 			cout << __FUNCTION__ << ": Device is not reserved.\n";
 #endif
-			sprintf( disk_name, "[%d]", next);
-			if (d.Init_Physical(disk_name)) 
-			{
+			sprintf(disk_name, "[%d]", next);
+			if (d.Init_Physical(disk_name)) {
 				d.spec.type = PhysicalDiskType;
 				memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
 #ifdef _DEBUG
-				cout << "name=" << disk_spec[count].name << ",type=" << disk_spec[count].type << endl << flush;
+				cout << "name=" << disk_spec[count].name << ",type=" << disk_spec[count].
+				    type << endl << flush;
 #endif
 				++count;
 			}
@@ -190,72 +187,70 @@
 #endif
 	}
 	qsort(disk_spec, count, sizeof(Target_Spec), compareRawDiskNames);
-	return(count);
+	return (count);
 }
 
 //
 // This function compares two disk names. It just uses strcmp. I'm lazy.
 //
-static int compareRawDiskNames(const void *a, const void *b) {
+static int compareRawDiskNames(const void *a, const void *b)
+{
 	const Target_Spec *at = (const Target_Spec *)a;
 	const Target_Spec *bt = (const Target_Spec *)b;
-	return(strcmp(at->name, bt->name));
+
+	return (strcmp(at->name, bt->name));
 }
+
 //
 //
-int Manager::Report_TCP( Target_Spec *tcp_spec )
+int Manager::Report_TCP(Target_Spec * tcp_spec)
 {
-	struct hostent		*hostinfo;
-	struct sockaddr_in	 sin;
-	char			 hostname[128];
-	int			 count = 0;
-	int 			 i;
+	struct hostent *hostinfo;
+	struct sockaddr_in sin;
+	char hostname[128];
+	int count = 0;
+	int i;
+
 	cout << "Reporting TCP network information..." << endl;
 	// get the unqualified local host name
-	if (gethostname(hostname, sizeof(hostname)) == SOCKET_ERROR)
-	{
+	if (gethostname(hostname, sizeof(hostname)) == SOCKET_ERROR) {
 		cout << "*** Error " << WSAGetLastError() << "getting local host name.\n";
 		return 0;
 	}
 	// now get the host info for that host name
-	hostinfo = gethostbyname ( hostname );
-	if ( hostinfo == NULL )
-	{
-		cout << "*** Error " << WSAGetLastError() << "getting host info for \"" 
-			 << hostname << "\".\n";
+	hostinfo = gethostbyname(hostname);
+	if (hostinfo == NULL) {
+		cout << "*** Error " << WSAGetLastError() << "getting host info for \"" << hostname << "\".\n";
 		return 0;
 	}
 	cout << "   My hostname: \"" << hostinfo->h_name << "\"" << endl;
-	#ifdef _DEBUG
-		i=0;
-	   // this blows up - don't know why
-	   //	while ( hostinfo->h_aliases[i] != NULL )
-	   //	{
-	   //		printf("   Alias: \"%s\"\n", hostinfo->h_aliases[i]);
-	   //		i++;
-	   //	}
-	#endif
+#ifdef _DEBUG
+	i = 0;
+	// this blows up - don't know why
+	//   while ( hostinfo->h_aliases[i] != NULL )
+	//   {
+	//           printf("   Alias: \"%s\"\n", hostinfo->h_aliases[i]);
+	//           i++;
+	//   }
+#endif
 	// report the network addresses.
-	for ( i = 0; hostinfo->h_addr_list[i] != NULL; i++ ) 
-	{
-		memcpy ( &sin.sin_addr.s_addr, hostinfo->h_addr_list[i], hostinfo->h_length );
-		strncpy ( tcp_spec[count].name, inet_ntoa(sin.sin_addr), 
-			sizeof(tcp_spec[count].name) - 1 );
+	for (i = 0; hostinfo->h_addr_list[i] != NULL; i++) {
+		memcpy(&sin.sin_addr.s_addr, hostinfo->h_addr_list[i], hostinfo->h_length);
+		strncpy(tcp_spec[count].name, inet_ntoa(sin.sin_addr), sizeof(tcp_spec[count].name) - 1);
 		tcp_spec[count].type = TCPClientType;	// interface to access a client
 		cout << "   Found " << tcp_spec[count].name << "." << endl;
-		if ( ++count >= MAX_NUM_INTERFACES )
-		{
-			cout << "*** Found the maximum number of supported network interfaces: " 
-				<< endl << "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
+		if (++count >= MAX_NUM_INTERFACES) {
+			cout << "*** Found the maximum number of supported network interfaces: "
+			    << endl << "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
 			count = MAX_NUM_INTERFACES;
 			break;
 		}
 	}
-	#if 0	// for debugging multiple-network-interface GUI; change "#if 0" to "#if 1" to enable
-		strncpy ( nets[count], "foo", sizeof(nets[count]) - 1 );
-		cout << "   Added fake entry " << nets[count] << "." << endl << flush;
-		count++;
-	#endif
+#if 0				// for debugging multiple-network-interface GUI; change "#if 0" to "#if 1" to enable
+	strncpy(nets[count], "foo", sizeof(nets[count]) - 1);
+	cout << "   Added fake entry " << nets[count] << "." << endl << flush;
+	count++;
+#endif
 	// All done.
 	cout << "   done." << endl;
 	return count;
@@ -263,111 +258,119 @@
 int aio_suspend64(struct aiocb64 **cb, int a, struct timespec *)
 {
 	pthread_t tid = pthread_self();
+
 	// for (cd list; if any not in progress; return else block till one exist)
 	//use semaphores to start and stop
 	// suspend until an IO completes and restarts this thread - loop?
 	return 0;
 }
+
 //
 //
 int aio_error64(struct aiocb64 *cb)
 {
 	return cb->error;
 }
+
 //
 //
 int aio_return64(struct aiocb64 *cb)
 {
 	return cb->returnval;
 }
+
 //
 //
 int aio_read64(struct aiocb64 *cb, int type)
 {
-	if ( IsType( type, LogicalDiskType ) )
-	{
-		cb->error = NXRead(cb->aio_fildes, (NXOffset_t)cb->aio_offset, cb->aio_nbytes, cb->aio_buf, (unsigned long)0, (size_t *)&cb->returnval);
+	if (IsType(type, LogicalDiskType)) {
+		cb->error =
+		    NXRead(cb->aio_fildes, (NXOffset_t) cb->aio_offset, cb->aio_nbytes, cb->aio_buf, (unsigned long)0,
+			   (size_t *) & cb->returnval);
 		cb->completion_key = EBUSY;
-	}
-	else if ( IsType( type, PhysicalDiskType ) )
-	{
-		cb->error = MM_ObjectIO(&cb->completion_key, cb->aio_fildes, MM_RANDOM_READ, (cb->aio_nbytes/512),
-						(cb->aio_offset/512),0, cb->aio_nbytes, cb->aio_buf, (LONG)cb, (void (*)())MM_CallBackRoutine);
+	} else if (IsType(type, PhysicalDiskType)) {
+		cb->error = MM_ObjectIO(&cb->completion_key, cb->aio_fildes, MM_RANDOM_READ, (cb->aio_nbytes / 512),
+					(cb->aio_offset / 512), 0, cb->aio_nbytes, cb->aio_buf, (LONG) cb,
+					(void (*)())MM_CallBackRoutine);
 		cb->returnval = cb->aio_nbytes;
-		if (cb->error == 0)
-		{
+		if (cb->error == 0) {
 			cb->error = EINPROGRESS;
 			cb->completion_key = EBUSY;
 		}
 	}
 	return (cb->error);
 }
+
 //
 //
 int aio_write64(struct aiocb64 *cb, int type)
 {
-	if ( IsType( type, LogicalDiskType ) )
-	{
-		cb->error = NXWrite(cb->aio_fildes, (NXOffset_t)cb->aio_offset, cb->aio_nbytes, cb->aio_buf, (unsigned long)0, (size_t *)&cb->returnval);
+	if (IsType(type, LogicalDiskType)) {
+		cb->error =
+		    NXWrite(cb->aio_fildes, (NXOffset_t) cb->aio_offset, cb->aio_nbytes, cb->aio_buf, (unsigned long)0,
+			    (size_t *) & cb->returnval);
 		cb->completion_key = EBUSY;
-	}
-	else if ( IsType( type, PhysicalDiskType ) )
-	{
-		cb->error = MM_ObjectIO(&cb->completion_key,cb->aio_fildes,MM_RANDOM_WRITE, (cb->aio_nbytes/512),
-						(cb->aio_offset/512),0,cb->aio_nbytes, cb->aio_buf, (LONG)cb, (void (*)())MM_CallBackRoutine);
+	} else if (IsType(type, PhysicalDiskType)) {
+		cb->error = MM_ObjectIO(&cb->completion_key, cb->aio_fildes, MM_RANDOM_WRITE, (cb->aio_nbytes / 512),
+					(cb->aio_offset / 512), 0, cb->aio_nbytes, cb->aio_buf, (LONG) cb,
+					(void (*)())MM_CallBackRoutine);
 		cb->returnval = cb->aio_nbytes;
-		if (cb->error == 0)
-		{
+		if (cb->error == 0) {
 			cb->error = EINPROGRESS;
 			cb->completion_key = EBUSY;
 		}
 	}
 	return cb->error;
 }
+
 //
 //
 int aio_cancel64(int a, struct aiocb64 *cb)
 {
-	if (cb == NULL)
-	{
+	if (cb == NULL) {
 		//printf("cancel all in queue\n");
-	}
-	else
-	{
+	} else {
 		printf("cancel one\n");
 	}
 	return FALSE;
 }
+
 //
 //
 void MM_CallBackRoutine(LONG requestHandle, LONG applicationRequestToken, LONG returnParameter, LONG completionCode)
 {
 	struct aiocb64 *cb = (struct aiocb64 *)applicationRequestToken;
+
 	cb->error = completionCode;
 }
+
 int TargetDisk::NWOpenDevice(LONG device, LONG mode)
 {
 	LONG rc = 0;
-	
-	rc=MM_ReserveIOObject(&reservationHandle, device, (mode?MM_IO_MODE:(MM_IO_MODE|MM_SHARED_PRIMARY_RESERVE)),
-	 							device, NWalertroutine,applicationHandle);
+
+	rc = MM_ReserveIOObject(&reservationHandle, device,
+				(mode ? MM_IO_MODE : (MM_IO_MODE | MM_SHARED_PRIMARY_RESERVE)), device, NWalertroutine,
+				applicationHandle);
 	if (rc)
- 		((struct File *)disk_file)->fd = -1L;
- 	else
- 		((struct File *)disk_file)->fd = (int)reservationHandle;
- 	((struct File *)disk_file)->type = PhysicalDiskType;
- 	if(rc)
- 		cout << "TargetDisk::Open: MM_ReserveIOObject rc=" << rc << " for MMID " << atoi(file_name) << endl;
+		((struct File *)disk_file)->fd = -1L;
+	else
+		((struct File *)disk_file)->fd = (int)reservationHandle;
+	((struct File *)disk_file)->type = PhysicalDiskType;
+	if (rc)
+		cout << "TargetDisk::Open: MM_ReserveIOObject rc=" << rc << " for MMID " << atoi(file_name) << endl;
 	return ((struct File *)disk_file)->fd;
 }
+
 int TargetDisk::NWCloseDevice(HNDL handle)
 {
 	return MM_ReleaseIOObject(handle);
 }
-LONG NWalertroutine(unsigned long reservationHandle, unsigned long alertToken, unsigned long alertType, unsigned long alertReasion)
+
+LONG NWalertroutine(unsigned long reservationHandle, unsigned long alertToken, unsigned long alertType,
+		    unsigned long alertReasion)
 {
 	// drive alerts - i.e deactivation and so on
 	return MM_SHARED_RESERVE_GRANTED;
 }
 
-#endif // IOMTR_OS_NETWARE
+#endif				// IOMTR_OS_NETWARE

Modified: branches/IOMETER-restruct/iometer/src/IOManagerOSX.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOManagerOSX.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOManagerOSX.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -53,7 +53,6 @@
 /* ######################################################################### */
 #if defined(IOMTR_OS_OSX)
 
-
 #include "IOManager.h"
 #include "IOTargetDisk.h"
 #include <dirent.h>
@@ -68,39 +67,39 @@
 // of disks found.  Drives are reported in order so that Iometer does not
 // need to sort them.
 //
-int Manager::Report_Disks( Target_Spec* disk_spec )
+int Manager::Report_Disks(Target_Spec * disk_spec)
 {
-	TargetDisk	d;
-	int		count = 0, disksFound = 0, i, logicalDisks;
-	struct statfs	*buf = NULL;
-	char		disk_name[MNAMELEN], rawDeviceName[MNAMELEN];
-	kern_return_t	kernResult;
-	DIR		*directory;
-	struct dirent	*directoryEntry;
-	mach_port_t	masterPort;
+	TargetDisk d;
+	int count = 0, disksFound = 0, i, logicalDisks;
+	struct statfs *buf = NULL;
+	char disk_name[MNAMELEN], rawDeviceName[MNAMELEN];
+	kern_return_t kernResult;
+	DIR *directory;
+	struct dirent *directoryEntry;
+	mach_port_t masterPort;
 
 	cout << "Reporting drive information..." << endl;
 
 	// Reporting Logical drives first (filesystems).
 	cout << "  Logical drives (mounted filesystems)..." << endl;
 
-	count = getfsstat(NULL,0,MNT_WAIT);
-	buf = (struct statfs *)malloc(sizeof(struct statfs)*count);
+	count = getfsstat(NULL, 0, MNT_WAIT);
+	buf = (struct statfs *)malloc(sizeof(struct statfs) * count);
 
 	if (buf != NULL) {
-		getfsstat(buf,sizeof(struct statfs)*count,MNT_WAIT);
+		getfsstat(buf, sizeof(struct statfs) * count, MNT_WAIT);
 
 		for (i = 0; i < count; i++) {
 			if (strstr(exclude_filesys, buf[i].f_fstypename) != NULL)
 				continue;
 
 			strcpy(disk_name, buf[i].f_mntonname);
-			if (! d.Init_Logical( disk_name) )
+			if (!d.Init_Logical(disk_name))
 				continue;
 
 			// Drive exists and ready for use
 			d.spec.type = LogicalDiskType;
-			memcpy( &disk_spec[disksFound], &d.spec, sizeof( Target_Spec ) );
+			memcpy(&disk_spec[disksFound], &d.spec, sizeof(Target_Spec));
 
 			disksFound++;
 
@@ -121,15 +120,16 @@
 	} else {
 		directory = opendir(RAW_DEVICE_DIR);
 		while ((directoryEntry = readdir(directory)) != NULL) {
-			if (strstr(directoryEntry->d_name,"disk") != NULL && strstr(directoryEntry->d_name,"rdisk") == NULL) {
-				if (!containsPartitions(masterPort,directoryEntry->d_name)) {
+			if (strstr(directoryEntry->d_name, "disk") != NULL
+			    && strstr(directoryEntry->d_name, "rdisk") == NULL) {
+				if (!containsPartitions(masterPort, directoryEntry->d_name)) {
 					strcpy(rawDeviceName, "r");
-					strcat(rawDeviceName,directoryEntry->d_name);
-					if ( ! d.Init_Physical( rawDeviceName ) )
+					strcat(rawDeviceName, directoryEntry->d_name);
+					if (!d.Init_Physical(rawDeviceName))
 						continue;
 
 					// the physical drive is ready for use
-					memcpy( &disk_spec[disksFound], &d.spec, sizeof( Target_Spec ) );
+					memcpy(&disk_spec[disksFound], &d.spec, sizeof(Target_Spec));
 
 					disksFound++;
 					if (disksFound >= MAX_TARGETS)
@@ -147,7 +147,6 @@
 	return disksFound;
 }
 
-
 BOOL Manager::containsPartitions(mach_port_t masterPort, char *bsdName)
 {
 	// This is a rather simple and probably incorrect way to determine if there
@@ -160,14 +159,14 @@
 	// that no partition structure (at least those identified by IOKit) is present
 	// and that the device is blank.
 
-	CFMutableDictionaryRef	matchingDict;
-	kern_return_t			kernResult;
-	io_iterator_t			iter;
-	io_service_t			service;
-	CFTypeRef				wholeMedia;
-	CFTypeRef				contents;
-	char					contentsCSTR[255];
-	bool					result = FALSE; // Start assuming it's a clean disk
+	CFMutableDictionaryRef matchingDict;
+	kern_return_t kernResult;
+	io_iterator_t iter;
+	io_service_t service;
+	CFTypeRef wholeMedia;
+	CFTypeRef contents;
+	char contentsCSTR[255];
+	bool result = FALSE;	// Start assuming it's a clean disk
 
 	matchingDict = IOBSDNameMatching(masterPort, 0, bsdName);
 	if (NULL == matchingDict) {
@@ -180,7 +179,7 @@
 		if (KERN_SUCCESS != kernResult) {
 			// If anything fails, we play it safe and just claim it has partitions
 			result = TRUE;
-		} else if ( NULL == iter) {
+		} else if (NULL == iter) {
 			result = true;
 		} else {
 			service = IOIteratorNext(iter);
@@ -194,24 +193,20 @@
 			} else {
 				// retrieve the Whole property
 				wholeMedia = IORegistryEntryCreateCFProperty(service,
-								CFSTR(kIOMediaWholeKey),
-								kCFAllocatorDefault,
-								0);
+									     CFSTR(kIOMediaWholeKey),
+									     kCFAllocatorDefault, 0);
 				if (NULL == wholeMedia) {
 					return TRUE;
-				} else if (CFBooleanGetValue((CFBooleanRef)wholeMedia)) {
+				} else if (CFBooleanGetValue((CFBooleanRef) wholeMedia)) {
 					// retrieve the Contents property
 					contents = IORegistryEntryCreateCFProperty(service,
-									CFSTR(kIOMediaContentKey),
-									kCFAllocatorDefault,
-									0);
+										   CFSTR(kIOMediaContentKey),
+										   kCFAllocatorDefault, 0);
 					if (NULL == contents) {
 						result = TRUE;
 					} else {
-						CFStringGetCString((CFStringRef)contents,
-									contentsCSTR,
-									255,
-									kCFStringEncodingASCII);
+						CFStringGetCString((CFStringRef) contents,
+								   contentsCSTR, 255, kCFStringEncodingASCII);
 						// Empty string is assumed to mean no partition structure
 						// WARNING: this is probably wrong, but it seems to work
 						if (strcmp(contentsCSTR, "") != 0) {
@@ -219,7 +214,7 @@
 						}
 					}
 					CFRelease(contents);
-				} else { // Not whole media
+				} else {	// Not whole media
 
 					result = TRUE;
 				}
@@ -233,7 +228,7 @@
 	return result;
 }
 
-BOOL Manager::Sort_Raw_Disk_Names(Target_Spec *disk_spec, int start, int end)
+BOOL Manager::Sort_Raw_Disk_Names(Target_Spec * disk_spec, int start, int end)
 {
 	int i, j;
 	Target_Spec temp_spec;
@@ -246,21 +241,18 @@
 	// Plain, old, simplified bubble sort is being used here. Most of the disk path names
 	// are already sorted. So it is ok to use this method.
 	//
-	for (i = start; i < end - 1 ; i++)
-	{
-		for (j = i + 1; j < end; j++)
-		{
+	for (i = start; i < end - 1; i++) {
+		for (j = i + 1; j < end; j++) {
 			//
 			// The function Compare...() compares two disk names and returns values 
 			// similar to strcmp().
 			//
-			switch(Compare_Raw_Disk_Names(disk_spec[i].name, disk_spec[j].name))
-			{
-			case 0:			// both are equal
+			switch (Compare_Raw_Disk_Names(disk_spec[i].name, disk_spec[j].name)) {
+			case 0:	// both are equal
 				break;
-			case -1:		// 1st < 2nd
+			case -1:	// 1st < 2nd
 				break;
-			case 1:			// 1st > 2nd
+			case 1:	// 1st > 2nd
 				// Swap the two.
 				memcpy(&temp_spec, &disk_spec[i], sizeof(Target_Spec));
 				memcpy(&disk_spec[i], &disk_spec[j], sizeof(Target_Spec));
@@ -276,12 +268,12 @@
 // This function compares two disk names and returns values similar to strcmp().
 // The comparison is not pure lexical but pure Numeric.
 // For example,
-//		- When comparing disk names c0t10d0p0 and c0t2d0p0, the function determines
-//		  that c0t2d0p0 is less than c0t10d0p0.
-//		- When comparing disk names c0t0d0p0 and c0d0p0, the function determines
-//		  that c0d0p0 is less than c0t0d0p0 (going by the shorter string length).
-//		- Disk names c0t0d0p0 and a0b0c0d0 are returned as equal. This is acceptable
-//		  because we do not come across such cases in the UNIX environment.
+//              - When comparing disk names c0t10d0p0 and c0t2d0p0, the function determines
+//                that c0t2d0p0 is less than c0t10d0p0.
+//              - When comparing disk names c0t0d0p0 and c0d0p0, the function determines
+//                that c0d0p0 is less than c0t0d0p0 (going by the shorter string length).
+//              - Disk names c0t0d0p0 and a0b0c0d0 are returned as equal. This is acceptable
+//                because we do not come across such cases in the UNIX environment.
 //
 int Manager::Compare_Raw_Disk_Names(char *str1, char *str2)
 {
@@ -291,41 +283,35 @@
 	BOOL alpha1 = FALSE;
 	BOOL alpha2 = FALSE;
 
-	while(1)
-	{
-		if ((! *str1) || (! *str2))
-		{
+	while (1) {
+		if ((!*str1) || (!*str2)) {
 			// either one or both strings have hit eos.
-			if ( *str1)		// str2 hit eos first.
-				return(1);
-			else if ( *str2) // str1 hit eos first.
-				return(-1);
+			if (*str1)	// str2 hit eos first.
+				return (1);
+			else if (*str2)	// str1 hit eos first.
+				return (-1);
 			else
-				return 0; // both hit eos.
+				return 0;	// both hit eos.
 		}
 
-		if (alpha1 && alpha2)
-		{
+		if (alpha1 && alpha2) {
 			// compare the characters at this position.
-			if ( *(str1-1) < *(str2-1) )
-				return(-1);
-			if ( *(str1-1) > *(str2-1) )
-				return(1);
+			if (*(str1 - 1) < *(str2 - 1))
+				return (-1);
+			if (*(str1 - 1) > *(str2 - 1))
+				return (1);
 
 			alpha1 = FALSE;
 			alpha2 = FALSE;
 		}
-
 		// Scan the strings for the next available number.
-		if (isalpha(*str1))
-		{
+		if (isalpha(*str1)) {
 			str1++;
 			alpha1 = TRUE;
 			continue;
 		}
 
-		if (isalpha(*str2))
-		{
+		if (isalpha(*str2)) {
 			str2++;
 			alpha2 = TRUE;
 			continue;
@@ -352,13 +338,13 @@
 
 		if (num1 < num2)
 			// String 1 is less than string 2.
-			return(-1);
+			return (-1);
 
 		if (num1 > num2)
 			// String 1 is greater than string 2.
-			return(1);
+			return (1);
 
-	} // end-while().
+	}			// end-while().
 }
 
-#endif // IOMTR_OS_OSX
+#endif				// IOMTR_OS_OSX

Modified: branches/IOMETER-restruct/iometer/src/IOManagerSolaris.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOManagerSolaris.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOManagerSolaris.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -79,7 +79,6 @@
 /* ######################################################################### */
 #if defined(IOMTR_OS_SOLARIS)
 
-
 #include "IOManager.h"
 #include "IOTargetDisk.h"
 #include <dirent.h>
@@ -99,23 +98,25 @@
 // of disks found.  Drives are reported in order so that Iometer does not
 // need to sort them.
 //
-int Manager::Report_Disks( Target_Spec* disk_spec )
+int Manager::Report_Disks(Target_Spec * disk_spec)
 {
-//	DWORD	dummy_word;
-	TargetDisk	d;
-//	char	drive_letter;
-//	int		drive_number = 0;
-	int		count = 0;
-	DIR		*dirp;
+//      DWORD   dummy_word;
+	TargetDisk d;
+
+//      char    drive_letter;
+//      int             drive_number = 0;
+	int count = 0;
+	DIR *dirp;
 	struct dirent *dp;
-//	int		i;
 
+//      int             i;
+
 	cout << "Reporting drive information..." << endl;
 
 	// *********************************************************************************
 	// DEVELOPER NOTES
 	// ---------------
-	//		Currently the only disk types supported are Logical Disks (through the magic 
+	//              Currently the only disk types supported are Logical Disks (through the magic 
 	// file iobw.tst on a mounted file system) and Physical disks (through the /dev/rdsk
 	// interface).
 	//
@@ -126,12 +127,12 @@
 	// 3) Meta Physical disks. (      -do-               )
 	//
 	// 1)
-	//		The Direct Logical Disks (*DO NOT* go through the magic file iobw.tst) can be
+	//              The Direct Logical Disks (*DO NOT* go through the magic file iobw.tst) can be
 	// accessed through the /dev/dsk interfaces. Only ensure that the disks are not 
 	// already mounted as file systems and also sort the list of disks.
 	//
 	// 2)
-	//		The Meta Logical Disks (probably Solaris specific) are similar to Direct Logical
+	//              The Meta Logical Disks (probably Solaris specific) are similar to Direct Logical
 	// Disks. They are actually one or more logical disks grouped together and handled by a 
 	// special driver. RAID Logical Disks come under this category.
 	//
@@ -139,7 +140,7 @@
 	// are not already mounted as file systems and again file name sorting is required.
 	//
 	// 3)
-	//		The Meta Physical Disks (probably Solaris specific) are similar to Direct 
+	//              The Meta Physical Disks (probably Solaris specific) are similar to Direct 
 	// Physical Disks. Again, Meta is for a grouping of one or more physical disks and RAID 
 	// Physical Disks come under this category.
 	//
@@ -156,8 +157,7 @@
 	// type along with the path names.
 	//
 	// **********************************************************************************
-	
-	
+
 	// Reporting Logical drives first (filesystems).
 	cout << "  Logical drives (mounted filesystems)..." << endl;
 
@@ -165,29 +165,27 @@
 		mnttab = MNTTAB_FILE;
 
 	FILE *fp;
-	if ((fp = fopen(mnttab, "r")) == NULL)
-	{
+
+	if ((fp = fopen(mnttab, "r")) == NULL) {
 		cout << "open (mount tab) file " << mnttab << " failed with error " << errno << endl;
 		cout << "Set environment variable MNTTAB to correct pathname" << endl;
 		exit(1);
 	}
-	
+
 	struct mnttab mtab;
 	int retval, length, buffered;
 	char disk_name[MAX_NAME];
 
-	while ((retval = getmntent(fp, &mtab)) == 0)
-	{
+	while ((retval = getmntent(fp, &mtab)) == 0) {
 		buffered = FALSE;
 		// see if the current file sys is an excluded file system type for dynamo.
 		if (strstr(exclude_filesys, mtab.mnt_fstype) != NULL)
 			continue;
 
-		if (hasmntopt(&mtab, "forcedirectio") == NULL)
-		{
-			cout << "NOTICE: filesystem " << mtab.mnt_mountp 
-				<< " not mounted with option - forcedirectio" << endl;
-			// continue;		// enable only if we do not want to report this disk.
+		if (hasmntopt(&mtab, "forcedirectio") == NULL) {
+			cout << "NOTICE: filesystem " << mtab.mnt_mountp
+			    << " not mounted with option - forcedirectio" << endl;
+			// continue;            // enable only if we do not want to report this disk.
 			buffered = TRUE;
 			this->is_buffered = TRUE;
 		}
@@ -204,12 +202,12 @@
 		strncpy(disk_name, mtab.mnt_mountp, length);
 		disk_name[length] = 0;
 
-		if ( ! d.Init_Logical( disk_name ) )
+		if (!d.Init_Logical(disk_name))
 			continue;
 
 		// Drive exists and ready for use.
 		d.spec.type = LogicalDiskType;
-		memcpy( &disk_spec[count], &d.spec, sizeof( Target_Spec ) );
+		memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
 
 		disk_spec[count].name[length] = 0;
 		// check for this pattern is also in TargetDisk::Init_Logical().
@@ -220,7 +218,7 @@
 		strcat(disk_spec[count].name, "]");
 
 #if _DEBUG
-			cout << "   Found " << disk_spec[count].name << "." << endl << flush;
+		cout << "   Found " << disk_spec[count].name << "." << endl << flush;
 #endif
 		count++;
 		if (count >= MAX_TARGETS)
@@ -228,15 +226,12 @@
 	}
 	fclose(fp);
 
-	if (this->is_buffered)
-	{
+	if (this->is_buffered) {
 		cout << endl
-			 << "NOTICE: One or more filesystems not mounted with 'forcedirecio'"
-			 << endl
-			 << "        option set. All I/O will be via kernel buffers."
-			 << endl
-			 << "  --->  See mount(1), mount_ufs(1) for details."
-			 << endl << endl;
+		    << "NOTICE: One or more filesystems not mounted with 'forcedirecio'"
+		    << endl
+		    << "        option set. All I/O will be via kernel buffers."
+		    << endl << "  --->  See mount(1), mount_ufs(1) for details." << endl << endl;
 		this->is_buffered = FALSE;
 	}
 
@@ -246,15 +241,14 @@
 	// Now reporting physical drives (raw devices)
 	cout << "  Physical drives (raw devices)..." << endl;
 	int logical_count = count;
-	
+
 	// Get a list of all the swap devices into a static public variable.
 	// Its easier to lookup. We need to check if the partition/slice under
 	// consideration is a swap device or not.
 	Get_All_Swap_Devices();
 
 	dirp = opendir(RAW_DEVICE_DIR);
-	while ((dp = readdir(dirp)) != NULL)
-	{
+	while ((dp = readdir(dirp)) != NULL) {
 		//
 		// Either we take all of the disk or none. No individual partitions. 
 		// Do we really want to test partition by partition ? I guess not.
@@ -266,51 +260,46 @@
 #elif defined(IOMTR_CPU_SPARC)
 		if (strstr(dp->d_name, "s2") != NULL)
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		{
 #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64)
 			// Read partition table on fdisk partition p0.
-			if ( Report_FDISK_Partitions(dp->d_name, disk_spec, &count, 
-				logical_count) == TRUE )
-			{
+			if (Report_FDISK_Partitions(dp->d_name, disk_spec, &count, logical_count) == TRUE) {
 				// Some partitions were processed. The disk is not empty.
 				// Skip this disk and jump back to start of while loop.
 				if (count >= MAX_TARGETS)
-					break;			// no room for more.
+					break;	// no room for more.
 
 				continue;
 			}
 			// Here we continue with reporting fdisk partition p0. The fdisk
 			// table is empty.
 #elif defined(IOMTR_CPU_SPARC)
-			if ( Report_VTOC_Partitions(dp->d_name, disk_spec, &count,
-				logical_count) == TRUE )
-			{
+			if (Report_VTOC_Partitions(dp->d_name, disk_spec, &count, logical_count) == TRUE) {
 				// some vtoc partitions were processed. The disk is not empty
 				// skip this disk and jump back to start of while loop.
 				if (count == MAX_TARGETS)
-					break;			// no room for more.
+					break;	// no room for more.
 
 				continue;
 			}
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 			// Check if this is a swap device.
-			if (strstr(swap_devices, dp->d_name))
-			{
+			if (strstr(swap_devices, dp->d_name)) {
 				// Yes, it is. skip.
 				continue;
 			}
 
-			if ( ! d.Init_Physical( dp->d_name ) )
+			if (!d.Init_Physical(dp->d_name))
 				continue;
 
 			// the physical drive is ready for use.
-			memcpy( &disk_spec[count], &d.spec, sizeof( Target_Spec ) );
-			d.spec.type = PhysicalDiskType;		
+			memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
+			d.spec.type = PhysicalDiskType;
 #if _DEBUG
 			cout << "   Found " << disk_spec[count].name << "." << endl << flush;
 #endif
@@ -323,19 +312,16 @@
 
 	// sort all the raw disk names in disk_spec array.
 	Sort_Raw_Disk_Names(disk_spec, logical_count, count);
-	if (this->is_destructive)
-	{
+	if (this->is_destructive) {
 		cout << endl
-			 << "NOTICE: One or more disk partitions/slices ignored because Iometer"
-			 << endl
-			 << "        detected the presence of file systems."
-			 << endl
-			 << "  --->  To enable access to the partition/slice mount it or destroy"
-			 << endl
-			 << "        it or over-ride protection by setting the IOMTR_SETTING_OVERRIDE_FS"
-			 << endl
-			 << "        environment var."
-			 << endl << endl;
+		    << "NOTICE: One or more disk partitions/slices ignored because Iometer"
+		    << endl
+		    << "        detected the presence of file systems."
+		    << endl
+		    << "  --->  To enable access to the partition/slice mount it or destroy"
+		    << endl
+		    << "        it or over-ride protection by setting the IOMTR_SETTING_OVERRIDE_FS"
+		    << endl << "        environment var." << endl << endl;
 		this->is_destructive = FALSE;
 	}
 
@@ -343,10 +329,8 @@
 	return count;
 }
 
-
 #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64)
-BOOL Manager::Report_FDISK_Partitions(char *name, Target_Spec *disk_spec, 
-									  int *count, int logical_count)
+BOOL Manager::Report_FDISK_Partitions(char *name, Target_Spec * disk_spec, int *count, int logical_count)
 {
 	static BOOL has_solaris_parts = FALSE;
 	BOOL FDISK_table_valid = FALSE;
@@ -355,7 +339,7 @@
 	int i, fd, bytes_read, length;
 	struct mboot *mb;
 	struct ipart *ip;
-	char fstype[32];				// to hold the file system type.
+	char fstype[32];	// to hold the file system type.
 	char base_name[MAX_NAME];
 	char file_name[MAX_NAME];
 	char buffer[512];
@@ -368,58 +352,50 @@
 	cout << "   Reporting disk partitions: " << file_name << endl << flush;
 #endif
 
-	fd = open(file_name, O_RDWR|O_LARGEFILE, S_IRUSR|S_IWUSR);
-	if (fd < 0)
-	{
+	fd = open(file_name, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
+	if (fd < 0) {
 #if _DEBUG
 		cout << "  open failed.." << endl << flush;
 #endif
-		return(TRUE);
+		return (TRUE);
 	}
 
-	if ((bytes_read = read(fd, buffer, 512)) < 512)
-	{
+	if ((bytes_read = read(fd, buffer, 512)) < 512) {
 		// cannot read start sector. Disk might be bad.
 #if _DEBUG
 		cout << "  read failed.. returning" << endl << flush;
 #endif
 		close(fd);
-		return(TRUE);
+		return (TRUE);
 	}
 	close(fd);
 
 	mb = (struct mboot *)buffer;
-	if (mb->signature != MBB_MAGIC)
-	{
+	if (mb->signature != MBB_MAGIC) {
 		// Don't worry about including disk spec in disk_spec. The caller
 		// will take care of it when you return FALSE.
 		// But yes, there is an additional loop going on here - a waste
 		// of time but that does'nt matter for now.
 		close(fd);
-		return(FALSE);
-	}
-	else
-	{
+		return (FALSE);
+	} else {
 		// We do have partitions.
 		strncpy(base_name, name, (strstr(name, "p0") - name));
 #if _DEBUG
-			cout << "   basename: " << base_name << endl << flush;
+		cout << "   basename: " << base_name << endl << flush;
 #endif
-		for (i = 1; i <= FD_NUMPART; i++)
-		{
-			ip = (struct ipart *) (buffer + BOOTSZ + ((i - 1) * sizeof(struct ipart)));
+		for (i = 1; i <= FD_NUMPART; i++) {
+			ip = (struct ipart *)(buffer + BOOTSZ + ((i - 1) * sizeof(struct ipart)));
 
-			if ((ip->systid  == SUNIXOS) && (has_solaris_parts == FALSE))
-			{
+			if ((ip->systid == SUNIXOS) && (has_solaris_parts == FALSE)) {
 				// Do this only once even if you have multiple solaris partitions.
 				// Other Solaris parts are invisible through the disk label/vtoc.
 				has_solaris_parts = TRUE;
 				sprintf(file_name, "%ss2", base_name);
-				if (Report_VTOC_Partitions(file_name, disk_spec, count, logical_count) == TRUE)
-				{
+				if (Report_VTOC_Partitions(file_name, disk_spec, count, logical_count) == TRUE) {
 					VTOC_valid = TRUE;
 					continue;
-				}	
+				}
 			}
 
 			sprintf(file_name, "%sp%d", base_name, i);
@@ -431,36 +407,31 @@
 				// Yes, this is a swap device, skip
 				continue;
 
-			if (d.Init_Physical(file_name))
-			{
+			if (d.Init_Physical(file_name)) {
 				// Disk Initialization succeeded, 
 				// note that this is not needed here. We get here only if SUNIXOS 
 				// partition does not have any VTOC (which is not possible on IA32) and
 				// for other partitions.
-				if ( Part_Reported_As_Logical(disk_spec, file_name, logical_count) )
+				if (Part_Reported_As_Logical(disk_spec, file_name, logical_count))
 					continue;
 
 				// Not mounted! Next check if there is a file system on it.
-				if (Has_File_System(file_name, fstype) == TRUE)
-				{
+				if (Has_File_System(file_name, fstype) == TRUE) {
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
-					if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL)
-					{
+					if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
 						cout << "WARNING: allowing raw access to unmounted fs: "
-							<< file_name << endl;
-					}
-					else // environ variable not set
+						    << file_name << endl;
+					} else	// environ variable not set
 					{
 #endif
 						cout << "NOTICE: ignoring " << file_name
-							<< ". File system found on disk" << endl;
+						    << ". File system found on disk" << endl;
 						this->is_destructive = TRUE;
-						continue; 	// jump to start of for-loop
+						continue;	// jump to start of for-loop
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
 					}
 #endif
 				}
-
 				// take away 16 bytes the largest of fdisk part names and
 				// and 5 bytes for the string elements. "[  ]"
 				length = MAX_NAME - 16 - 5;
@@ -470,12 +441,11 @@
 				// Reset it to correct value.
 				d.spec.disk_info.maximum_size = ip->numsect;
 				d.Set_Size(ip->numsect);
-				memcpy( &disk_spec[*count], &d.spec, sizeof( Target_Spec ) );
+				memcpy(&disk_spec[*count], &d.spec, sizeof(Target_Spec));
 				// Get the fdisk partition type info.
 				disk_spec[*count].name[length] = 0;
 				strcat(disk_spec[*count].name, " [ ");
-				switch (ip->systid)
-				{
+				switch (ip->systid) {
 				case DOSOS12:
 					strcat(disk_spec[*count].name, "dosos12");
 					break;
@@ -508,13 +478,13 @@
 //       build and exclude it for i386 build (because it is not defined
 //       within /usr/include/sys/dktp/fdisk.h).
 #if defined(IOMTR_CPU_I386)
- // nop
+					// nop
 #elif defined(IOMTR_CPU_SPARC)
 				case PPCBOOT:
 					strcat(disk_spec[*count].name, "ppcboot");
 					break;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 				case SUNIXOS:
 					strcat(disk_spec[*count].name, "sunixos");
@@ -529,8 +499,7 @@
 					strcat(disk_spec[*count].name, "unknown");
 					break;
 				}
-				if (fstype[0] != 0)
-				{
+				if (fstype[0] != 0) {
 					strcat(disk_spec[*count].name, ", ");
 					strcat(disk_spec[*count].name, fstype);
 				}
@@ -544,10 +513,8 @@
 				FDISK_table_valid = TRUE;
 				if (*count >= MAX_TARGETS)
 					break;
-			}
-			else
-			{
-				// partition access failed.				
+			} else {
+				// partition access failed.                             
 #if _DEBUG
 				cout << "   Not found " << file_name << endl << flush;
 #endif
@@ -556,27 +523,25 @@
 		// Done with this disk. Reset the bool flag has_solaris_parts
 		has_solaris_parts = FALSE;
 		if (VTOC_valid)
-			return(TRUE);
+			return (TRUE);
 
 		if (FDISK_table_valid)
-			return(TRUE);
+			return (TRUE);
 		else
-			return(FALSE);
+			return (FALSE);
 	}
-	return(FALSE); 			// a dummy
+	return (FALSE);		// a dummy
 }
-#endif  // IOMTR_CPU_I386 || IOMTR_CPU_IA64
+#endif				// IOMTR_CPU_I386 || IOMTR_CPU_IA64
 
-
-
-BOOL Manager::Report_VTOC_Partitions(char *name, Target_Spec *disk_spec, 
-									 int *count, int logical_count)
+BOOL Manager::Report_VTOC_Partitions(char *name, Target_Spec * disk_spec, int *count, int logical_count)
 {
 	TargetDisk d;
 	int i, j, fd, length;
+
 //  int bytes_read;
 	struct vtoc this_vtoc;
-	char fstype[32];				// to hold the file system type.
+	char fstype[32];	// to hold the file system type.
 	char base_name[MAX_NAME];
 	char file_name[MAX_NAME];
 	BOOL vtoc_has_only_backup_slice = TRUE;
@@ -588,38 +553,34 @@
 #if _DEBUG
 	cout << "   Reporting vtoc partitions: " << file_name << endl << flush;
 #endif
-	fd = open(file_name, O_RDWR|O_LARGEFILE, S_IRUSR|S_IWUSR);
-	if (fd < 0)
-	{
+	fd = open(file_name, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
+	if (fd < 0) {
 #if _DEBUG
 		cout << "  open failed.." << endl << flush;
 #endif
-		return(TRUE);
+		return (TRUE);
 	}
 
-	if (ioctl(fd, DKIOCGVTOC, &this_vtoc) < 0)
-	{
+	if (ioctl(fd, DKIOCGVTOC, &this_vtoc) < 0) {
 		// Get VTOC failed. Something wrong here.
 		// Ignore all slices in this partition.
 		close(fd);
-		return(TRUE);
+		return (TRUE);
 	}
 	close(fd);
 
-	if (this_vtoc.v_sanity != VTOC_SANE)
-	{
+	if (this_vtoc.v_sanity != VTOC_SANE) {
 		// this vtoc is insane. report TRUE to ignore this partition 
 		// and all slices within.
-		return(TRUE);
+		return (TRUE);
 	}
 
 	strncpy(base_name, name, (strstr(name, "s2") - name));
 #if _DEBUG
-		cout << "  vtoc basename: " << base_name << endl << flush;
+	cout << "  vtoc basename: " << base_name << endl << flush;
 #endif
 
-	for(i = 0; i < this_vtoc.v_nparts; i++)
-	{
+	for (i = 0; i < this_vtoc.v_nparts; i++) {
 		if (this_vtoc.v_part[i].p_size <= 3)
 			continue;
 
@@ -636,68 +597,67 @@
 		// disk data in harm's way simply because if the disk has some data
 		// say somefilesystem in it, it is not reported to Galileo.
 		//
-		if ( (this_vtoc.v_part[i].p_tag == V_BOOT) ||
-			// (this_vtoc.v_part[i].p_tag == V_BACKUP) ||
-			(this_vtoc.v_part[i].p_tag == V_ALTSCTR) )
+		if ((this_vtoc.v_part[i].p_tag == V_BOOT) ||
+		    // (this_vtoc.v_part[i].p_tag == V_BACKUP) ||
+		    (this_vtoc.v_part[i].p_tag == V_ALTSCTR))
 			continue;
 
 		// Having reached here, we now know that the vtoc has other valid
 		// slices too.
 		vtoc_has_only_backup_slice = FALSE;
-	
+
 		if (this_vtoc.v_part[i].p_flag == V_RONLY)
 			continue;
 
 		// Next check if this vtoc partition overlaps with any of the
 		// subsequent parts.
 		BOOL overlap = FALSE;
-		for (j = 0; j < this_vtoc.v_nparts; j++)
-		{
-			if (i == j) continue;
-			switch (this_vtoc.v_part[j].p_tag)
-			{
+
+		for (j = 0; j < this_vtoc.v_nparts; j++) {
+			if (i == j)
+				continue;
+			switch (this_vtoc.v_part[j].p_tag) {
 				//
 				// We ignore V_BOOT AND V_ALTSCTR slices. The V_BACKUP
 				// slice is going to overlap with every other slice, so...
-				case V_BOOT:
-					continue;
-				case V_BACKUP:
-					break;
-				case V_ALTSCTR:
-					continue;
-				default:
-					break;
+			case V_BOOT:
+				continue;
+			case V_BACKUP:
+				break;
+			case V_ALTSCTR:
+				continue;
+			default:
+				break;
 			}
 
 			//
 			// algorithm to determine overlapping partitions.
 			//
 			// if (start[i] < start[j])
-			// 		if (end[i] > start[j])
-			// 			overlap = TRUE;
+			//              if (end[i] > start[j])
+			//                      overlap = TRUE;
 			// if (start[i] > start[j])
-			// 		if (start[i] < end[j])
-			//			overlap = TRUE;
+			//              if (start[i] < end[j])
+			//                      overlap = TRUE;
 			//
-			if ( (this_vtoc.v_part[i].p_start < this_vtoc.v_part[j].p_start) &&
-				((this_vtoc.v_part[i].p_start + this_vtoc.v_part[i].p_size) > this_vtoc.v_part[j].p_start) )
-
+			if ((this_vtoc.v_part[i].p_start < this_vtoc.v_part[j].p_start) &&
+			    ((this_vtoc.v_part[i].p_start + this_vtoc.v_part[i].p_size) > this_vtoc.v_part[j].p_start))
 			{
 				overlap = TRUE;
-				break;	
+				break;
 			}
 
-			if ( (this_vtoc.v_part[i].p_start > this_vtoc.v_part[j].p_start) &&
-				(this_vtoc.v_part[i].p_start < (this_vtoc.v_part[j].p_start + this_vtoc.v_part[j].p_size)) )
+			if ((this_vtoc.v_part[i].p_start > this_vtoc.v_part[j].p_start) &&
+			    (this_vtoc.v_part[i].p_start < (this_vtoc.v_part[j].p_start + this_vtoc.v_part[j].p_size)))
 			{
 				overlap = TRUE;
 				break;
 			}
 		}
 
-		if (overlap == TRUE)
-		{
+		if (overlap == TRUE) {
 			char temp[MAX_NAME];
+
 			// Note that index i is the current slice and index j is the overlapping
 			// slice.
 			// check  if overlap is with a slice containing an unmounted file system.
@@ -707,19 +667,16 @@
 			cerr << "NOTE: Overlapping slices : " << i << ", " << j << endl;
 #endif
 			sprintf(temp, "%ss%d", base_name, j);
-			if (Has_File_System(temp, fstype) == TRUE)
-			{
+			if (Has_File_System(temp, fstype) == TRUE) {
 				// this slice 'i' overlaps with an unmounted file system.
 				continue;
 			}
-			if (strstr(swap_devices, temp))
-			{
+			if (strstr(swap_devices, temp)) {
 				// this slice 'i' overlaps with a swap device.
 				continue;
 			}
 			// else we are ok. overlapping empty slices is just fine.
 		}
-
 		// Here we do have VTOC parts to report.
 		sprintf(file_name, "%ss%d", base_name, i);
 #if _DEBUG
@@ -730,31 +687,27 @@
 			// Yes, this is a swap device, skip
 			continue;
 
-		if (d.Init_Physical(file_name))
-		{
+		if (d.Init_Physical(file_name)) {
 			// Disk Initialization succeeded,
-			if ( Part_Reported_As_Logical(disk_spec, file_name, logical_count) )
+			if (Part_Reported_As_Logical(disk_spec, file_name, logical_count))
 				continue;
 
 			// Not mounted! Next check if there is a file system on it.
-			if (Has_File_System(file_name, fstype) == TRUE)
-			{
+			if (Has_File_System(file_name, fstype) == TRUE) {
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
-				if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL)
-				{
+				if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
 					cout << "WARNING: allowing raw access to unmounted fs: " << file_name << endl;
-				}
-				else // environ variable not set
+				} else	// environ variable not set
 				{
 #endif
-					cout << "NOTICE: ignoring " << file_name << ". file system found on disk" << endl;
+					cout << "NOTICE: ignoring " << file_name << ". file system found on disk" <<
+					    endl;
 					this->is_destructive = TRUE;
 					continue;
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
 				}
 #endif
 			}
-
 			// take away 10 bytes for the largest of vtoc part names and
 			// and 5 bytes for the string elements. "[  ]"
 			length = MAX_NAME - 10 - 5;
@@ -764,13 +717,12 @@
 			// Reset it to correct value.
 			d.spec.disk_info.maximum_size = this_vtoc.v_part[i].p_size;
 			d.Set_Size(this_vtoc.v_part[i].p_size);
-			memcpy( &disk_spec[*count], &d.spec, sizeof( Target_Spec ) );
+			memcpy(&disk_spec[*count], &d.spec, sizeof(Target_Spec));
 
 			// Get the vtoc partition type info.
 			disk_spec[*count].name[length] = 0;
 			strcat(disk_spec[*count].name, " [ ");
-			switch(this_vtoc.v_part[i].p_tag)
-			{
+			switch (this_vtoc.v_part[i].p_tag) {
 			case V_UNASSIGNED:
 				strcat(disk_spec[*count].name, "unassigned");
 				break;
@@ -809,8 +761,7 @@
 				break;
 			}
 
-			if (fstype[0] != 0)
-			{
+			if (fstype[0] != 0) {
 				strcat(disk_spec[*count].name, ", ");
 				strcat(disk_spec[*count].name, fstype);
 			}
@@ -827,45 +778,39 @@
 		}
 	}
 
-	if (vtoc_has_only_backup_slice == TRUE)
-	{
+	if (vtoc_has_only_backup_slice == TRUE) {
 		// No VTOC slices qualified. We only have slices less than 3 sectors and backup
 		// slices.
 		// Report backup slice i.e whole disk.
 		// It is beyond our control if backup slice does not span the whole disk
 		// however, the format utility does warn the admin if that is the case.
 		// NOTE: EXTRA LOOP TO GRAB WHOLE SLICE if nothing else left.
-		for(i = 0; i < this_vtoc.v_nparts; i++)
-		{
-			if (this_vtoc.v_part[i].p_tag == V_BACKUP)
-			{
+		for (i = 0; i < this_vtoc.v_nparts; i++) {
+			if (this_vtoc.v_part[i].p_tag == V_BACKUP) {
 				sprintf(file_name, "%ss%d", base_name, i);
-				if (d.Init_Physical(file_name))
-				{
+				if (d.Init_Physical(file_name)) {
 					if (d.Init_Physical(file_name))
-					// Disk Initialization succeeded,
-					if ( Part_Reported_As_Logical(disk_spec, file_name, logical_count) )
-						continue;
+						// Disk Initialization succeeded,
+						if (Part_Reported_As_Logical(disk_spec, file_name, logical_count))
+							continue;
 
 					// Not mounted! Next check if there is a file system on it.
-					if (Has_File_System(file_name, fstype) == TRUE)
-					{
+					if (Has_File_System(file_name, fstype) == TRUE) {
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
-						if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL)
+						if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
+							cout << "WARNING: allowing raw access to unmounted fs: " <<
+							    file_name << endl;
+						} else	// environ variable not set
 						{
-							cout << "WARNING: allowing raw access to unmounted fs: " << file_name << endl;
-						}
-						else // environ variable not set
-						{
 #endif
-							cout << "NOTICE: ignoring " << file_name << ". file system found on disk" << endl;
+							cout << "NOTICE: ignoring " << file_name <<
+							    ". file system found on disk" << endl;
 							this->is_destructive = TRUE;
 							continue;
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
 						}
 #endif
 					}
-
 					// take away 10 bytes for the largest of vtoc part names and
 					// and 5 bytes for the string elements. "[  ]"
 					length = MAX_NAME - 10 - 5;
@@ -875,14 +820,13 @@
 					// Reset it to correct value.
 					d.spec.disk_info.maximum_size = this_vtoc.v_part[i].p_size;
 					d.Set_Size(this_vtoc.v_part[i].p_size);
-					memcpy( &disk_spec[*count], &d.spec, sizeof( Target_Spec ) );
+					memcpy(&disk_spec[*count], &d.spec, sizeof(Target_Spec));
 
 					// Get the vtoc partition type info.
 					disk_spec[*count].name[length] = 0;
 					strcat(disk_spec[*count].name, " [ ");
 					strcat(disk_spec[*count].name, "backup");
-					if (fstype[0] != 0)
-					{
+					if (fstype[0] != 0) {
 						strcat(disk_spec[*count].name, ", ");
 						strcat(disk_spec[*count].name, fstype);
 					}
@@ -895,18 +839,17 @@
 					(*count)++;
 					if (*count >= MAX_TARGETS)
 						break;
-				}	
+				}
 			}
 		}
 	}
-	return(TRUE);
+	return (TRUE);
 }
 
-
 BOOL Manager::Has_File_System(char *file_name, char *fstype)
 {
 // int pid, status;
-  int retval;
+	int retval;
 	FILE *pptr;
 	char path[MAX_NAME];
 	char cmd[MAX_NAME];
@@ -916,8 +859,7 @@
 	fstype[0] = 0;
 	sprintf(path, "/dev/rdsk/%s", file_name);
 	sprintf(cmd, "/usr/sbin/fstyp %s 2>/dev/null", path);
-	if ((pptr = popen(cmd, "r")) != NULL)
-	{
+	if ((pptr = popen(cmd, "r")) != NULL) {
 		// popen succeeded.
 		fgets(buf, BUFSIZ, pptr);
 
@@ -928,29 +870,25 @@
 		// fork1() + exec(), on the other hand, return values correctly
 		// but then how do we get the file system type, if it exists ?
 		retval = pclose(pptr);
-		if (retval == 0)
-		{
+		if (retval == 0) {
 			strcpy(fstype, buf);
-			return(TRUE);
-		}
-		else
-			return(FALSE);
-	}	
-	return(FALSE);
+			return (TRUE);
+		} else
+			return (FALSE);
+	}
+	return (FALSE);
 }
 
-
-
-BOOL Manager::Part_Reported_As_Logical(Target_Spec *spec, char *rdisk, int count)
+BOOL Manager::Part_Reported_As_Logical(Target_Spec * spec, char *rdisk, int count)
 {
-	int					i, retval;
-	char				*p;
-	char				rstr[MAX_NAME], lstr[MAX_NAME];		// for physical/logical disks.
-	FILE 				*fp;
-	struct mnttab		mtab, mpref;
+	int i, retval;
+	char *p;
+	char rstr[MAX_NAME], lstr[MAX_NAME];	// for physical/logical disks.
+	FILE *fp;
+	struct mnttab mtab, mpref;
 
 	//
-	//		checks if the named partition/slice has already been mounted.
+	//              checks if the named partition/slice has already been mounted.
 	// The file systems listed in the mnttab file are already mounted. So, we have two cases :
 	// The file system is listed for testing (eg: ufs) or not listed (eg. procfs)
 	// But we need only check if the file sys is mounted and thats sufficient. That will
@@ -958,21 +896,19 @@
 	//
 	strcpy(rstr, rdisk);
 
-	if ((fp = fopen(mnttab, "r")) == NULL)
-	{
+	if ((fp = fopen(mnttab, "r")) == NULL) {
 		cout << "open (mount tab) file " << mnttab << " failed with error " << errno << endl;
 		cout << "Set environment variable MNTTAB to correct pathname" << endl;
 		// We wont try to report any disk. Could expose the OS partition to destructive tests.
 		return TRUE;
 	}
 
-	for (i = 0; i < count; i++)
-	{
+	for (i = 0; i < count; i++) {
 		// Initialize the mpref structure to NULL. Solaris does'nt do it.
 		memset(&mpref, 0, sizeof(struct mnttab));
 #ifdef _DEBUG
 		cout << "checking if physical disk already reported as logical." << endl
-			<< "	logical disk : " << spec[i].name << " physical disk : " << rdisk << endl;
+		    << "	logical disk : " << spec[i].name << " physical disk : " << rdisk << endl;
 #endif
 		// check for this pattern is also in Manager::Report_Disks()
 		// and TargetDisk::Init_Logical().
@@ -981,17 +917,15 @@
 		lstr[p - spec[i].name] = 0;
 
 		mpref.mnt_mountp = lstr;
-		if ((retval = getmntany(fp, &mtab, &mpref)) == 0)
-		{
+		if ((retval = getmntany(fp, &mtab, &mpref)) == 0) {
 			// found the entry in mnttab.
-			if (strstr(mtab.mnt_special, rstr))
-			{
+			if (strstr(mtab.mnt_special, rstr)) {
 				// equal! the entry contains this physical disk name (in the form c0t0d0[p|s]?).
 				// further the entry is in the list of reported logical disks.
 				// So, this physical disk has already been reported as a logical disk.
 #ifdef _DEBUG
 				cout << "physical disk " << rdisk << " reported logical disk "
-					<< mtab.mnt_mountp << endl;
+				    << mtab.mnt_mountp << endl;
 #endif
 				fclose(fp);
 				return TRUE;
@@ -1002,9 +936,7 @@
 	return FALSE;
 }
 
-
-
-BOOL Manager::Sort_Raw_Disk_Names(Target_Spec *disk_spec, int start, int end)
+BOOL Manager::Sort_Raw_Disk_Names(Target_Spec * disk_spec, int start, int end)
 {
 	int i, j;
 	Target_Spec temp_spec;
@@ -1017,21 +949,18 @@
 	// Plain, old, simplified bubble sort is being used here. Most of the disk path names
 	// are already sorted. So it is ok to use this method.
 	//
-	for (i = start; i < end - 1 ; i++)
-	{
-		for (j = i + 1; j < end; j++)
-		{
+	for (i = start; i < end - 1; i++) {
+		for (j = i + 1; j < end; j++) {
 			//
 			// The function Compare...() compares two disk names and returns values 
 			// similar to strcmp().
 			//
-			switch(Compare_Raw_Disk_Names(disk_spec[i].name, disk_spec[j].name))
-			{
-			case 0:			// both are equal
+			switch (Compare_Raw_Disk_Names(disk_spec[i].name, disk_spec[j].name)) {
+			case 0:	// both are equal
 				break;
-			case -1:		// 1st < 2nd
+			case -1:	// 1st < 2nd
 				break;
-			case 1:			// 1st > 2nd
+			case 1:	// 1st > 2nd
 				// Swap the two.
 				memcpy(&temp_spec, &disk_spec[i], sizeof(Target_Spec));
 				memcpy(&disk_spec[i], &disk_spec[j], sizeof(Target_Spec));
@@ -1047,12 +976,12 @@
 // This function compares two disk names and returns values similar to strcmp().
 // The comparison is not pure lexical but pure Numeric.
 // For example,
-//		- When comparing disk names c0t10d0p0 and c0t2d0p0, the function determines
-//		  that c0t2d0p0 is less than c0t10d0p0.
-//		- When comparing disk names c0t0d0p0 and c0d0p0, the function determines
-//		  that c0d0p0 is less than c0t0d0p0 (going by the shorter string length).
-//		- Disk names c0t0d0p0 and a0b0c0d0 are returned as equal. This is acceptable
-//		  because we do not come across such cases in the UNIX environment.
+//              - When comparing disk names c0t10d0p0 and c0t2d0p0, the function determines
+//                that c0t2d0p0 is less than c0t10d0p0.
+//              - When comparing disk names c0t0d0p0 and c0d0p0, the function determines
+//                that c0d0p0 is less than c0t0d0p0 (going by the shorter string length).
+//              - Disk names c0t0d0p0 and a0b0c0d0 are returned as equal. This is acceptable
+//                because we do not come across such cases in the UNIX environment.
 //
 int Manager::Compare_Raw_Disk_Names(char *str1, char *str2)
 {
@@ -1062,41 +991,35 @@
 	BOOL alpha1 = FALSE;
 	BOOL alpha2 = FALSE;
 
-	while(1)
-	{
-		if ((! *str1) || (! *str2))
-		{
+	while (1) {
+		if ((!*str1) || (!*str2)) {
 			// either one or both strings have hit eos.
-			if ( *str1)		// str2 hit eos first.
-				return(1);
-			else if ( *str2) // str1 hit eos first.
-				return(-1);
+			if (*str1)	// str2 hit eos first.
+				return (1);
+			else if (*str2)	// str1 hit eos first.
+				return (-1);
 			else
-				return 0; // both hit eos.
+				return 0;	// both hit eos.
 		}
 
-		if (alpha1 && alpha2)
-		{
+		if (alpha1 && alpha2) {
 			// compare the characters at this position.
-			if ( *(str1-1) < *(str2-1) )
-				return(-1);
-			if ( *(str1-1) > *(str2-1) )
-				return(1);
+			if (*(str1 - 1) < *(str2 - 1))
+				return (-1);
+			if (*(str1 - 1) > *(str2 - 1))
+				return (1);
 
 			alpha1 = FALSE;
 			alpha2 = FALSE;
 		}
-
 		// Scan the strings for the next available number.
-		if (isalpha(*str1))
-		{
+		if (isalpha(*str1)) {
 			str1++;
 			alpha1 = TRUE;
 			continue;
 		}
 
-		if (isalpha(*str2))
-		{
+		if (isalpha(*str2)) {
 			str2++;
 			alpha2 = TRUE;
 			continue;
@@ -1123,17 +1046,15 @@
 
 		if (num1 < num2)
 			// String 1 is less than string 2.
-			return(-1);
+			return (-1);
 
 		if (num1 > num2)
 			// String 1 is greater than string 2.
-			return(1);
+			return (1);
 
-	} // end-while().
+	}			// end-while().
 }
 
-
-
 // Function to get all swap device names into a single string of the form
 // <string1>:<string2>:<string3> and so on.
 // It is easier to lookup if in this form.
@@ -1141,85 +1062,75 @@
 void Manager::Get_All_Swap_Devices()
 {
 	// Presettings
-	
-	int 		num, i, n;
-	swaptbl_t	*pSwapTable;
-	char 		*pcSwapNames;
 
+	int num, i, n;
+	swaptbl_t *pSwapTable;
+	char *pcSwapNames;
+
 	// Loop till list of swap devices is created
 
-	for(;;) {
+	for (;;) {
 
 		// Get the number of swap devices
 		// (if non is found or error occurred - simply return)
 
-		if( ( num = swapctl(SC_GETNSWP, 0) ) <= 0 ) {
+		if ((num = swapctl(SC_GETNSWP, 0)) <= 0) {
 			return;
 		}
-
 		// Allocate the needed temporary memory structures
-		
-		pSwapTable = (swaptbl_t *) malloc( ( ( num + 1 ) * sizeof(swapent_t) ) + sizeof(struct swaptable) );
-		if( pSwapTable == NULL ) {
+
+		pSwapTable = (swaptbl_t *) malloc(((num + 1) * sizeof(swapent_t)) + sizeof(struct swaptable));
+		if (pSwapTable == NULL) {
 			return;
 		}
-		pcSwapNames = (char *) malloc( ( num + 1 ) * MAX_NAME );
-		if( pcSwapNames == NULL ) {
-			free( pSwapTable );
+		pcSwapNames = (char *)malloc((num + 1) * MAX_NAME);
+		if (pcSwapNames == NULL) {
+			free(pSwapTable);
 			return;
 		}
-
 		// Initialize string pointers in the swaptable
-		
-		for( i = 0; i < ( num + 1 ); i++ ) {
-			pSwapTable->swt_ent[i].ste_path = pcSwapNames + ( i * MAX_NAME );	
+
+		for (i = 0; i < (num + 1); i++) {
+			pSwapTable->swt_ent[i].ste_path = pcSwapNames + (i * MAX_NAME);
 		}
 		pSwapTable->swt_n = num + 1;
-		
+
 		// Request filling the swaptable
-		
-		if( ( n = swapctl(SC_LIST, pSwapTable) ) < 0 ) {
+
+		if ((n = swapctl(SC_LIST, pSwapTable)) < 0) {
 			cerr << "WARN: swapctl failed with error " << errno << endl;
-			free( pSwapTable );
-			free( pcSwapNames );
+			free(pSwapTable);
+			free(pcSwapNames);
 			return;
 		}
-
 		// Ensure that the swaptable was big enough for the data
-		
-		if( n > num ) {
-			free( pSwapTable );
-			free( pcSwapNames );
-			continue;			
+
+		if (n > num) {
+			free(pSwapTable);
+			free(pcSwapNames);
+			continue;
 		}
-		
 		// Allocate the memory for the final destination of the swap device list
 		// (n * swap_device_name) + (n * ":") + 1
 
-		swap_devices = (char *) malloc( ( n * MAX_NAME ) + n + 1 );
-		if( swap_devices == NULL ) {
-			free( pSwapTable );
-			free( pcSwapNames );
+		swap_devices = (char *)malloc((n * MAX_NAME) + n + 1);
+		if (swap_devices == NULL) {
+			free(pSwapTable);
+			free(pcSwapNames);
 			return;
 		}
 
-		for( i = 0; i < n; i++ ) {
-			strcat( swap_devices, pSwapTable->swt_ent[i].ste_path );
-			strcat( swap_devices, ":" );
+		for (i = 0; i < n; i++) {
+			strcat(swap_devices, pSwapTable->swt_ent[i].ste_path);
+			strcat(swap_devices, ":");
 		}
 #ifdef _DEBUG
 		cout << "swap devices: " << swap_devices << endl;
 #endif
-		free( pSwapTable );
-		free( pcSwapNames );
+		free(pSwapTable);
+		free(pcSwapNames);
 		return;
 	}
 }
 
-
-
-#endif // IOMTR_OS_SOLARIS
-
-
-
-
+#endif				// IOMTR_OS_SOLARIS

Modified: branches/IOMETER-restruct/iometer/src/IOManagerWin.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOManagerWin.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOManagerWin.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -58,81 +58,71 @@
 #include "IOManager.h"
 #include "IOTargetDisk.h"
 
-
-
 //
 // Checking for all accessible drives.  Storing them, and returning the number
 // of disks found.  Drives are reported in order so that Iometer does not
 // need to sort them.
 //
-int Manager::Report_Disks( Target_Spec* disk_spec )
+int Manager::Report_Disks(Target_Spec * disk_spec)
 {
-	DWORD	dummy_word;
-	TargetDisk	d;
-	char	drive_letter;
-	int		drive_number = 0;
-	int		count = 0;
+	DWORD dummy_word;
+	TargetDisk d;
+	char drive_letter;
+	int drive_number = 0;
+	int count = 0;
 
 	cout << "Reporting drive information..." << endl;
 
 	// Reporting logical drives first.
-	for ( drive_letter = 'A'; drive_letter <= 'Z'; drive_letter++ )
-	{
+	for (drive_letter = 'A'; drive_letter <= 'Z'; drive_letter++) {
 		// Checking to see if drive exists.
-		if ( ! d.Init_Logical( drive_letter ) )
+		if (!d.Init_Logical(drive_letter))
 			continue;
 
 		// Drive exists.  Getting its sector size, label, and volume name.
-		memcpy( &disk_spec[count], &d.spec, sizeof( Target_Spec ) );
-		strcat( disk_spec[count].name, "\\" );
-		if ( !GetVolumeInformation( disk_spec[count].name, disk_spec[count].name + 2, 
-			MAX_NAME - 1, NULL, &dummy_word, &dummy_word, NULL, 0 ) )
-		{
-			cout << "   Unable to retrieve volume information for " 
-				<< d.spec.name << "." << endl;
+		memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
+		strcat(disk_spec[count].name, "\\");
+		if (!GetVolumeInformation(disk_spec[count].name, disk_spec[count].name + 2,
+					  MAX_NAME - 1, NULL, &dummy_word, &dummy_word, NULL, 0)) {
+			cout << "   Unable to retrieve volume information for " << d.spec.name << "." << endl;
 			disk_spec[count].name[2] = '\0';
 		}
-
-		#if _DEBUG
-				cout << "   Found " << disk_spec[count].name << "." << endl;
-		#endif
+#if _DEBUG
+		cout << "   Found " << disk_spec[count].name << "." << endl;
+#endif
 		count++;
 	}
 
 	// Reporting physical drives.
-	while ( count < MAX_TARGETS )
-	{
+	while (count < MAX_TARGETS) {
 		// See if the physical drive exists.
-		sprintf( d.spec.name, "%s%i", PHYSICAL_DISK, drive_number );
-		strcpy( d.file_name, d.spec.name );
+		sprintf(d.spec.name, "%s%i", PHYSICAL_DISK, drive_number);
+		strcpy(d.file_name, d.spec.name);
 		d.spec.type = PhysicalDiskType;
 
 		// Try to open the drive, if it exists close it and initialize it.  If
 		// it doesn't exist, no more physical drives will be found.  This is
 		// temporary code until the TargetDisk class is split up.
-		if ( !d.Open( NULL ) )
+		if (!d.Open(NULL))
 			break;
-		d.Close( NULL );
+		d.Close(NULL);
 
 		// Drive exists, see if it is available for accessing.
-		if( ! d.Init_Physical( drive_number ) )
-		{
+		if (!d.Init_Physical(drive_number)) {
 			drive_number++;
 			continue;
 		}
 
-		memcpy( &disk_spec[count], &d.spec, sizeof( Target_Spec ) );
-		strcpy( disk_spec[count].name, PHYSICAL_DRIVE_PREFIX );
-		_itoa( drive_number, disk_spec[count].name + strlen( disk_spec[count].name ), 10 );
+		memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
+		strcpy(disk_spec[count].name, PHYSICAL_DRIVE_PREFIX);
+		_itoa(drive_number, disk_spec[count].name + strlen(disk_spec[count].name), 10);
 		drive_number++;
 
-		#if _DEBUG
-				cout << "   Found " << disk_spec[count].name << "." << endl;
-		#endif
+#if _DEBUG
+		cout << "   Found " << disk_spec[count].name << "." << endl;
+#endif
 		count++;
 	}
 	cout << "   done." << endl << flush;
 	return count;
 }
-
-

Modified: branches/IOMETER-restruct/iometer/src/IOMessage.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOMessage.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOMessage.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -63,19 +63,15 @@
 #ifndef MESSAGE_DEFINED
 #define MESSAGE_DEFINED
 
-
-
 #include "IOCommon.h"
 #include "IOTest.h"
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // Message purposes.
 //
 // The following messages require an immediate reply.
 //
-#define REPLY_FILTER		0x10000000		// DO NOT CHANGE!!!
+#define REPLY_FILTER		0x10000000	// DO NOT CHANGE!!!
 #define LOGIN			REPLY_FILTER + 1	// DO NOT CHANGE!!!
 #define ADD_WORKERS		REPLY_FILTER + 2
 #define REPORT_TARGETS		REPLY_FILTER + 3
@@ -102,17 +98,16 @@
 //
 ///////////////////////////////////////////////////////////////////////////////
 
-
 //
 // The following messages require a reply, but not immediately.
 //
-#define DELAY_REPLY_FILTER	0x00100000			// DO NOT CHANGE!!!
+#define DELAY_REPLY_FILTER	0x00100000	// DO NOT CHANGE!!!
 #define PREP_DISKS		DELAY_REPLY_FILTER + 1
 
 //
 // A reply is NOT expected (or wanted) for the following messages.
 //
-#define	NO_REPLY_FILTER		0x01000000			// DO NOT CHANGE!!!
+#define	NO_REPLY_FILTER		0x01000000	// DO NOT CHANGE!!!
 #define READY			NO_REPLY_FILTER + 1
 #define RECORD_ON		NO_REPLY_FILTER + 2
 #define RESET			NO_REPLY_FILTER + 3
@@ -120,49 +115,43 @@
 //
 ///////////////////////////////////////////////////////////////////////////////
 
-
-
 // Different data a message can contain.
-union Message_Data
-{
-	Manager_Info	manager_info;
+union Message_Data {
+	Manager_Info manager_info;
 
 	//
 	// Specifications used to access specific targets.
 	//
-	Target_Spec	targets[MAX_TARGETS];
+	Target_Spec targets[MAX_TARGETS];
 
 	// Access specifications for a test.
-	Test_Spec	spec;
+	Test_Spec spec;
 
 	// 
 	// Test results for Dynamo, including CPU utilization.
 	//
-	Manager_Results	manager_results;
+	Manager_Results manager_results;
 	// Results for worker threads, including target results.
-	Worker_Results	worker_results;
+	Worker_Results worker_results;
 };
 
-
 // Format of informative and data messages.
-struct Message
-{
-	int		purpose;	// Reason message was sent.  See constants above.
-	int		data;		// Brief amount of data sent with the message.
+struct Message {
+	int purpose;		// Reason message was sent.  See constants above.
+	int data;		// Brief amount of data sent with the message.
 };
 
-struct Data_Message
-{
-	int		count;		// Number of data items in the message.
-	char		pad[4];		// coz of Solaris - NT differences
-	Message_Data	data;		// Detailed data sent with the data message.
+struct Data_Message {
+	int count;		// Number of data items in the message.
+	char pad[4];		// coz of Solaris - NT differences
+	Message_Data data;	// Detailed data sent with the data message.
 };
 
 #define MESSAGE_SIZE		sizeof( Message )
 #define DATA_MESSAGE_SIZE	sizeof( Data_Message )
 
-void reorder(Message&);
-void reorder(Data_Message&, int union_type, int send_recv);
+void reorder(Message &);
+void reorder(Data_Message &, int union_type, int send_recv);
 
 #define DATA_MESSAGE_MANAGER_INFO	1
 #define DATA_MESSAGE_TARGET_SPEC	2
@@ -170,6 +159,4 @@
 #define DATA_MESSAGE_MANAGER_RESULTS	4
 #define DATA_MESSAGE_WORKER_RESULTS	5
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOPerformance.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPerformance.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPerformance.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -92,20 +92,16 @@
 /* ##                 Get_Processor_Speed() method).                      ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
-#define PERFORMANCE_DETAILS	0 // Turn on to display additional performance messages.
+#define PERFORMANCE_DETAILS	0	// Turn on to display additional performance messages.
 #if !defined(IOMTR_OS_LINUX) && !defined(IOMTR_OS_NETWARE) && !defined(IOMTR_OS_OSX)
 
-
-
 #include "IOPerformance.h"
 #if defined(IOMTR_OS_SOLARIS)
- #include <sys/types.h>
- #include <unistd.h>
- #include <sys/processor.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/processor.h>
 #endif
 
-
-
 //
 // Initializing system performance data.
 //
@@ -115,17 +111,16 @@
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	// Allocating buffer to receive performance data.
-	if ( !( perf_data = (LPBYTE) malloc( MAX_PERF_SIZE ) ) )
-	{
+	if (!(perf_data = (LPBYTE) malloc(MAX_PERF_SIZE))) {
 		cout << "*** Unable to allocate space for performance data." << endl << flush;
-		exit( 1 );
+		exit(1);
 	}
-	perf_size   = MAX_PERF_SIZE;
+	perf_size = MAX_PERF_SIZE;
 	perf_object = NULL;
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_SOLARIS)
- // nop
+	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 	// Obtaining the number of CPUs in the system and their speed.
@@ -136,15 +131,13 @@
 	// performance calls succeed.  Then, set the correct number of interfaces.
 	network_interfaces = 0;
 
-	if ( !processor_speed || !processor_count )
-	{
+	if (!processor_speed || !processor_count) {
 		cout << "*** Unable to initialize needed performance data." << endl
-			<< "This error may indicate that you are trying to run on an unsupported" << endl
-			<< "processor or OS.  See the Iometer User's Guide for information on" << endl
-			<< "supported platforms." << endl;
-		exit( 1 );
+		    << "This error may indicate that you are trying to run on an unsupported" << endl
+		    << "processor or OS.  See the Iometer User's Guide for information on" << endl
+		    << "supported platforms." << endl;
+		exit(1);
 	}
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	// Setting the NT CPU performance counters to extract.
 	cpu_perf_counter_info[CPU_TOTAL_UTILIZATION].index = PERF_CPU_TOTAL_UTILIZATION;
@@ -161,11 +154,11 @@
 	ni_perf_counter_info[NI_IN_ERRORS].index = PERF_NI_IN_ERRORS;
 
 	// Initializing the offsets to specific performance counters to invalid.
-	for ( i = 0; i < CPU_RESULTS; i++ )
+	for (i = 0; i < CPU_RESULTS; i++)
 		cpu_perf_counter_info[i].offset = IOERROR;
-	for ( i = 0; i < TCP_RESULTS; i++ )
+	for (i = 0; i < TCP_RESULTS; i++)
 		tcp_perf_counter_info[i].offset = IOERROR;
-	for ( i = 0; i < NI_RESULTS; i++ )
+	for (i = 0; i < NI_RESULTS; i++)
 		ni_perf_counter_info[i].offset = IOERROR;
 #elif defined(IOMTR_OS_SOLARIS)
 	// Initialize all the arrays to 0.
@@ -174,28 +167,25 @@
 	memset(raw_tcp_data, 0, (TCP_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
 
 	// Note:
-	//		We get a handle to the kstat data which contains CPU and Net Interface info.
-	//		The TCP info is obtained through streams.
+	//              We get a handle to the kstat data which contains CPU and Net Interface info.
+	//              The TCP info is obtained through streams.
 	//
 	clock_tick = sysconf(_SC_CLK_TCK);
 
 	// Open and obtain a handle to the kstat.
 	kc = kstat_open();
-	if (kc == NULL)
-	{
+	if (kc == NULL) {
 		cout << "kstat open failed with error " << errno << endl;
 		// exit(1);
 	}
-
 	// Note that cpu count is already in place.
 	// Get all the network interface names into a array.
 	int sockfd;
-	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
-	{
+
+	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
 		perror("socket open failed ");
 		exit(1);
 	}
-
 	// Now do an ioctl (SIOCGIFCONF) on the socket. The ioctl(SIGIOCIFCONF)
 	// is used to get info about all the network interfaces in the system
 	// including the interface names.
@@ -205,92 +195,79 @@
 	//
 	struct ifconf myifconf;
 	char buf[(sizeof(struct ifreq) * MAX_NUM_INTERFACES) + BUFSIZ];
+
 	myifconf.ifc_len = sizeof(buf);
 	myifconf.ifc_buf = buf;
 
-	if (ioctl(sockfd, SIOCGIFCONF, (char *) &myifconf) < 0)
-	{
+	if (ioctl(sockfd, SIOCGIFCONF, (char *)&myifconf) < 0) {
 		cout << "ioctl (SIOCGIFCONF) failed with error " << errno << endl;
 		exit(1);
 	}
 	// else ioctl succeeded and we have all the data !
-	struct ifreq	*ifreqp;
+	struct ifreq *ifreqp;
+
 	ifreqp = myifconf.ifc_req;
-	for (i = 0; i < (int)(myifconf.ifc_len/sizeof(struct ifreq)); i++, ifreqp++)
-	{
+	for (i = 0; i < (int)(myifconf.ifc_len / sizeof(struct ifreq)); i++, ifreqp++) {
 		if (ifreqp->ifr_addr.sa_family != AF_INET)
 			continue;
 		// ioctl (SIOCGIFFLAGS) on the socket.
-		if (ioctl(sockfd, SIOCGIFFLAGS, (char *)ifreqp) < 0)
-		{
+		if (ioctl(sockfd, SIOCGIFFLAGS, (char *)ifreqp) < 0) {
 			cout << "ioctl (SIOCGIFFLAGS) failed with error " << errno << endl;
 			exit(1);
 		}
-		if (! (ifreqp->ifr_flags & IFF_LOOPBACK) )
+		if (!(ifreqp->ifr_flags & IFF_LOOPBACK))
 			// We have a non-loopback IP interface name. get the name into the array
 			// and increment network_interfaces.
 			strcpy(nic_names[network_interfaces++], ifreqp->ifr_name);
 	}
 	close(sockfd);
 
-
 	// Set up the Streams modules to get the tcpSegments retrans data.
 	// This is moved to the get_tcp_counters call because after reading the initial data
 	// off the stream, we still have to run getmsg() many more times (till we get a -1)
 	// to read off all mib2_tcp data off the stream queues.
-	if ((getuid() == 0) || (geteuid() == 0))
-	{
+	if ((getuid() == 0) || (geteuid() == 0)) {
 		// only the super-user can play with Streams.
 		// We are allocating 64 and 1024 bytes because we know that that the data we
 		// are sending to and receivng from the streams is under our control and never
 		// comes anywhere near these numbers.
-		ctlbuf	= (char *)malloc(64);
-		if (ctlbuf == NULL)
-		{
+		ctlbuf = (char *)malloc(64);
+		if (ctlbuf == NULL) {
 			cout << "unable to allocate memory " << endl;
 			exit(1);
 		}
 		databuf = (char *)malloc(1024);
-		if (databuf == NULL)
-		{
+		if (databuf == NULL) {
 			cout << "unable to allocate memory " << endl;
 			exit(1);
 		}
 		streamfd = 0;
-	}
-	else streamfd = -1;
+	} else
+		streamfd = -1;
 #elif defined(IOMTR_OS_LINUX)
- // nop
+	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
-
-
 //
 // Freeing memory used by class object.
 //
 Performance::~Performance()
 {
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	free( perf_data );
+	free(perf_data);
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
 	free(ctlbuf);
 	free(databuf);
 	kstat_close(kc);
 	streamfd = -1;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
-
-
 //
 // Getting the number of processors in the system.
 //
@@ -299,28 +276,23 @@
 #if defined(IOMTR_OS_SOLARIS)
 	return (sysconf(_SC_NPROCESSORS_CONF));
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE)
- // nop
+	// nop
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	SYSTEM_INFO	system_info;
+	SYSTEM_INFO system_info;
 
-	SetLastError( 0 );
-	GetSystemInfo( &system_info );
-	if ( GetLastError() )
-	{
+	SetLastError(0);
+	GetSystemInfo(&system_info);
+	if (GetLastError()) {
 		cout << "*** Unable to determine number of processors in system.";
 		return 0;
 	}
 	cout << "Number of processors: " << system_info.dwNumberOfProcessors << endl;
-	return (int) system_info.dwNumberOfProcessors;
+	return (int)system_info.dwNumberOfProcessors;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
-
-
 #define SPEED_VALUE_COUNT 117
 //
 // Getting the speed of the processors in Hz.
@@ -333,157 +305,130 @@
 		3060, 3000, 2930, 2900, 2800, 2700, 2660, 2600, 2530,
 		2500, 2400, 2300, 2260, 2200, 2000, 1900, 1800, 1700,
 		1600, 1500, 1400, 1300, 1260, 1200, 1130, 1100, 1060,
-		1000,  980,  975,  966,  950,  940,  933,  920,  910,
-	 	 900,  880,  875,  866,  850,  840,  833,  820,  810,
-		 800,  780,  775,  766,  750,  740,  733,  720,  710,
-		 700,  680,  675,  666,  650,  640,  633,  620,  610,
-		 600,  580,  575,  566,  550,  540,  533,  520,  510,
-		 500,  480,  475,  466,  450,  440,  433,  420,  410,
-		 400,  380,  375,  366,  350,  340,  333,  320,  310,
-		 300,  280,  275,  266,  250,  240,  233,  220,  210,
-		 200,  180,  175,  166,  150,  140,  133,  120,  110,
-		 100,   80,   75,   66,   50,   40,   33,   25,   20 };
+		1000, 980, 975, 966, 950, 940, 933, 920, 910,
+		900, 880, 875, 866, 850, 840, 833, 820, 810,
+		800, 780, 775, 766, 750, 740, 733, 720, 710,
+		700, 680, 675, 666, 650, 640, 633, 620, 610,
+		600, 580, 575, 566, 550, 540, 533, 520, 510,
+		500, 480, 475, 466, 450, 440, 433, 420, 410,
+		400, 380, 375, 366, 350, 340, 333, 320, 310,
+		300, 280, 275, 266, 250, 240, 233, 220, 210,
+		200, 180, 175, 166, 150, 140, 133, 120, 110,
+		100, 80, 75, 66, 50, 40, 33, 25, 20
+	};
 	DWORD speed;
 
-#if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64) 
-	int speed_magnitude; /* 0=MHz,1=GHz */
+#if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
+	int speed_magnitude;	/* 0=MHz,1=GHz */
 	DWORD type;
-	DWORD size_of_speed = sizeof( DWORD );
+	DWORD size_of_speed = sizeof(DWORD);
 
 	BOOL rdtsc_supported = TRUE;
 	HKEY processor_speed_key;
 
 	// Try RDTSC and see if it causes an exception.  (This code is NT-specific 
 	// because Solaris does not support __try/__except.)
-	__try
-	{
+	__try {
 		rdtsc();
 	}
-	__except( EXCEPTION_EXECUTE_HANDLER )
-	{
+	__except(EXCEPTION_EXECUTE_HANDLER) {
 		rdtsc_supported = FALSE;
 	}
 
-	if ( !rdtsc_supported )
-	{
+	if (!rdtsc_supported) {
 #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_X86_64)
-		cout << "*** Processor does not support RDTSC instruction!"    << endl <<
-			"    Dynamo requires this for high-resolution timing." << endl;
+		cout << "*** Processor does not support RDTSC instruction!" << endl <<
+		    "    Dynamo requires this for high-resolution timing." << endl;
 #elif defined(IOMTR_CPU_IA64)
-		cout << "*** Processor does not support ITC instruction!"      << endl <<
-			"    Dynamo requires this for high-resolution timing." << endl;
+		cout << "*** Processor does not support ITC instruction!" << endl <<
+		    "    Dynamo requires this for high-resolution timing." << endl;
 #endif
-		return (double) 0.0;
+		return (double)0.0;
 	}
 	// Retrieving the estimated speed from the NT system registry.
-	if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0\0",
-			0, KEY_READ, &processor_speed_key ) != ERROR_SUCCESS )
-	{
+	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0\0",
+			 0, KEY_READ, &processor_speed_key) != ERROR_SUCCESS) {
 		cout << "*** Could not locate processor information in registry." << endl;
-		return (double) 0.0;
+		return (double)0.0;
 	}
-	if ( RegQueryValueEx( processor_speed_key, "~MHz\0", NULL, &type, (LPBYTE)&speed, &size_of_speed ) 
-		!= ERROR_SUCCESS )
-	{
+	if (RegQueryValueEx(processor_speed_key, "~MHz\0", NULL, &type, (LPBYTE) & speed, &size_of_speed)
+	    != ERROR_SUCCESS) {
 		/* if getting MHz fails try to get GHz */
-		if ( RegQueryValueEx( processor_speed_key, "~GHz\0", NULL, &type, (LPBYTE)&speed, &size_of_speed ) 
-			!= ERROR_SUCCESS )
-		{
+		if (RegQueryValueEx(processor_speed_key, "~GHz\0", NULL, &type, (LPBYTE) & speed, &size_of_speed)
+		    != ERROR_SUCCESS) {
 			cout << "*** Could not retrieve estimated processor speed from registry." << endl;
-			return (double) 0.0;
+			return (double)0.0;
+		} else {
+			speed_magnitude = 1;	/* set to GHz */
 		}
-		else
-		{
-			speed_magnitude = 1; /* set to GHz */
-		}
+	} else {
+		speed_magnitude = 0;	/* set to MHz */
 	}
-	else
-	{
-		speed_magnitude = 0; /* set to MHz */
-	}
 
-	if(speed_magnitude == 1)
-	{
-		speed *= 1000; /* convert the GHz value to MHz */
+	if (speed_magnitude == 1) {
+		speed *= 1000;	/* convert the GHz value to MHz */
 	}
-
 	//#ifdef WIN64_COUNTER_WORKAROUND
-   	// *** Removed ***
+	// *** Removed ***
 	//
 	//currently Win64 uses GetTickCOunt whose units are in milliseconds.
 	//
-    	//return (double) MILLISECOND;
-   	//
+	//return (double) MILLISECOND;
+	//
 	// *** End Removed ***
 #elif defined(IOMTR_OS_SOLARIS)
 	processor_info_t infop;
 	int j, status;
 
-	for (j = 0; j < MAX_CPUS; j++)
-	{
-		status = p_online((processorid_t)j, P_STATUS);
+	for (j = 0; j < MAX_CPUS; j++) {
+		status = p_online((processorid_t) j, P_STATUS);
 		if ((status == -1) || (status == EINVAL))
 			continue;
 
 		// Ok we found a processor.
 		// This call should succeed. Else it means that the system has no processors !!!
 		// ("its haunted" !!!) or that this call is unsupported.
-		if (processor_info((processorid_t)j, &infop) < 0)
-		{
+		if (processor_info((processorid_t) j, &infop) < 0) {
 			cout << "*** Could not determine processor speed." << endl << flush;
-			return (double) 0.0;
+			return (double)0.0;
 		}
 		// found a processor and also the obtained the infop structure. So break.
 		break;
 	}
-	if (j == MAX_CPUS)
-	{
+	if (j == MAX_CPUS) {
 		cout << "*** Could not determine processor speed." << endl << flush;
-		return (double) 0.0;
+		return (double)0.0;
 	}
-
 	// If there are more than one processors, well, we get the speed of the first one.
 	speed = infop.pi_clock;
 #elif defined(IOMTR_OS_LINUX)
- // nop
+	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	for ( int i = 0; i < SPEED_VALUE_COUNT; i++ )
-	{
+	for (int i = 0; i < SPEED_VALUE_COUNT; i++) {
 		// Try to match estimated speed with a known one.
-		if ( ( (int)speed > speed_values[i] - 5 ) && ( (int)speed < speed_values[i] + 5 ) )
-		{
+		if (((int)speed > speed_values[i] - 5) && ((int)speed < speed_values[i] + 5)) {
 			speed = speed_values[i];
-			if ( speed < 1000 )
-			{
+			if (speed < 1000) {
 				cout << "Processor speed: " << speed << " MHz." << endl;
-			}
-			else
-			{
+			} else {
 				cout << "Processor speed: " << speed / 1000.0 << " GHz." << endl;
 			}
-			return (double) (speed * 1000000);
+			return (double)(speed * 1000000);
 		}
 	}
 	// Round the registry value to the nearest 10
-	speed = ( ( speed + 5 ) / 10 ) * 10;
-	if ( speed < 1000 )
-	{
+	speed = ((speed + 5) / 10) * 10;
+	if (speed < 1000) {
 		cout << "Processor speed: " << speed << " MHz." << endl;
-	}
-	else
-	{
+	} else {
 		cout << "Processor speed: " << speed / 1000.0 << " GHz." << endl;
 	}
-	return (double) (speed * 1000000);
+	return (double)(speed * 1000000);
 }
 
-
-
-
-
 /*
 Getting NT performance counters.  These counters provide the same performance
 information found running perfmon.
@@ -522,119 +467,104 @@
 //
 // Extracting system performance data.  The data is accessed through the NT registry, but stored elsewhere.
 //
-void Performance::Get_Perf_Data( DWORD perf_data_type, int snapshot )
+void Performance::Get_Perf_Data(DWORD perf_data_type, int snapshot)
 {
-#if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64) 
-	long	query_result;			// Value returned trying to query performance data.
-	DWORD	perf_object_size;		// Size of buffer allocated to storing performance data.
-	char	perf_data_type_name[10];	// ASCII representation of performance data index.
-	_int64	perf_update_freq;		// Frequency that performance counters are updated.
+#if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
+	long query_result;	// Value returned trying to query performance data.
+	DWORD perf_object_size;	// Size of buffer allocated to storing performance data.
+	char perf_data_type_name[10];	// ASCII representation of performance data index.
+	_int64 perf_update_freq;	// Frequency that performance counters are updated.
 #elif defined(IOMTR_OS_SOLARIS) || defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE)
- // nop
+	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 	// Get the performance data stored by the system.
-	#if _DEBUG
-		cout << "   Getting system performance data." << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "   Getting system performance data." << endl << flush;
+#endif
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	perf_object_size = perf_size;
-	_itoa( perf_data_type, perf_data_type_name, 10 );  // convert index to a string
+	_itoa(perf_data_type, perf_data_type_name, 10);	// convert index to a string
 
 	// Continue trying to get the performance data until successful or utter failure.
 	// Grow the buffer allocated to hold the performance data until it is big enough.
-	while ( (query_result = RegQueryValueEx( HKEY_PERFORMANCE_DATA, perf_data_type_name,
-		NULL, NULL, perf_data, &perf_object_size ) ) != ERROR_SUCCESS )
-	{
-		if ( query_result == ERROR_MORE_DATA )
-		{
+	while ((query_result = RegQueryValueEx(HKEY_PERFORMANCE_DATA, perf_data_type_name,
+					       NULL, NULL, perf_data, &perf_object_size)) != ERROR_SUCCESS) {
+		if (query_result == ERROR_MORE_DATA) {
 			// More data than we had room for!  Try a bigger buffer.
-			#if _DEBUG
-				cout << "   RegQueryValueEx() returned ERROR_MORE_DATA!  Number of bytes used: " 
-					<< perf_object_size << endl << flush 
-					<< "   Bumping performance data buffer up from " << perf_size 
-					<< " to " << perf_size + MAX_PERF_SIZE << " bytes." << endl << flush;
-			#endif
+#if _DEBUG
+			cout << "   RegQueryValueEx() returned ERROR_MORE_DATA!  Number of bytes used: "
+			    << perf_object_size << endl << flush
+			    << "   Bumping performance data buffer up from " << perf_size
+			    << " to " << perf_size + MAX_PERF_SIZE << " bytes." << endl << flush;
+#endif
 			perf_size += MAX_PERF_SIZE;
-			if ( !( perf_data = (LPBYTE) realloc( perf_data, perf_size ) ) )
-			{
+			if (!(perf_data = (LPBYTE) realloc(perf_data, perf_size))) {
 				cout << "Error allocating more space for performance data." << endl << flush;
-				exit( 1 );
+				exit(1);
 			}
 			perf_object_size = perf_size;
-		}
-		else
-		{
+		} else {
 			// RegQueryValueEx failed -- get error message text from system
 			LPSTR message;
-			if ( FormatMessage (
-					FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
-					NULL, // get message from system
-					query_result,
-					MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
-					(LPSTR) &message,
-					0,
-					NULL ) )
-			{
+
+			if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, NULL,	// get message from system
+					  query_result, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),	// default language
+					  (LPSTR) & message, 0, NULL)) {
 				cout << "Error " << query_result << " getting performance data: " << message << flush;
 				LocalFree(message);
-			}
-			else
-			{
+			} else {
 				// FormatMessage failed, just print error number
 				cout << "Error " << query_result << " getting performance data." << endl << flush;
 			}
 
 			// special case for known Win95 error
-			if ( query_result == ERROR_KEY_DELETED )
-			{
-				cout << "This error may indicate that Dynamo is being run under Windows 95." << endl 
-					 << "Windows 95 is not supported; Dynamo requires Windows NT 4.0 or greater." << endl
-					 << flush;
+			if (query_result == ERROR_KEY_DELETED) {
+				cout << "This error may indicate that Dynamo is being run under Windows 95." << endl
+				    << "Windows 95 is not supported; Dynamo requires Windows NT 4.0 or greater." << endl
+				    << flush;
 			}
 			return;
 		}
-	}	// end while (trying to query registry values)
-	#if PERFORMANCE_DETAILS || _DETAILS
-		cout << "   Number of bytes used for performance data: " << perf_object_size << endl << flush;
-	#endif
+	}			// end while (trying to query registry values)
+#if PERFORMANCE_DETAILS || _DETAILS
+	cout << "   Number of bytes used for performance data: " << perf_object_size << endl << flush;
+#endif
 
 	// Record time that snapshot was taken.
-	time_counter[snapshot] = (_int64)((PERF_DATA_BLOCK*)perf_data)->PerfTime.QuadPart;
+	time_counter[snapshot] = (_int64) ((PERF_DATA_BLOCK *) perf_data)->PerfTime.QuadPart;
 
 	// Do we need to record the length of time between snapshots?
-	if ( snapshot == LAST_SNAPSHOT )
-	{
+	if (snapshot == LAST_SNAPSHOT) {
 		// Yes, get the update frequency.
-		perf_update_freq = (_int64)((PERF_DATA_BLOCK*)perf_data)->PerfFreq.QuadPart;
-		#if PERFORMANCE_DETAILS || _DETAILS
-			cout << "   Performance update frequency = " << perf_update_freq << endl << flush;
-		#endif
+		perf_update_freq = (_int64) ((PERF_DATA_BLOCK *) perf_data)->PerfFreq.QuadPart;
+#if PERFORMANCE_DETAILS || _DETAILS
+		cout << "   Performance update frequency = " << perf_update_freq << endl << flush;
+#endif
 
 		// Calculate the length of time that measurements were taken.
-		if ( perf_update_freq && ((time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]) > 0) )
-			perf_time = (double)(time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]) / perf_update_freq;
-		else
-		{
-			perf_time = (double) 0.0;	// Error gathering performance time, mark as invalid.
+		if (perf_update_freq && ((time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]) > 0))
+			perf_time =
+			    (double)(time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]) / perf_update_freq;
+		else {
+			perf_time = (double)0.0;	// Error gathering performance time, mark as invalid.
 		}
-		#if _DEBUG
-			cout << "   Performance time = " << perf_time << endl << flush;
-		#endif
+#if _DEBUG
+		cout << "   Performance time = " << perf_time << endl << flush;
+#endif
 	}
-	Extract_Counters( perf_data_type, snapshot );
+	Extract_Counters(perf_data_type, snapshot);
 #elif defined(IOMTR_OS_SOLARIS)
 	time_counter[snapshot] = gethrtime();
 	if (snapshot == LAST_SNAPSHOT)
 		// calculate time diff in clock ticks..
-		timediff = ((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]) * clock_tick
-					/ (double) 1000000000;
+		timediff = ((double)time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]) * clock_tick
+		    / (double)1000000000;
 
-	switch (perf_data_type)
-	{
+	switch (perf_data_type) {
 	case PERF_PROCESSOR:
 		Get_CPU_Counters(snapshot);
 		break;
@@ -648,72 +578,59 @@
 		break;
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE)
- // nop
+	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
-
-
 //
 // Calculating CPU statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_CPU_Stats( CPU_Results *cpu_results )
+void Performance::Calculate_CPU_Stats(CPU_Results * cpu_results)
 {
-	int		cpu, stat;		// Loop control variables.
+	int cpu, stat;		// Loop control variables.
 
 	// Loop though all CPUs and determine various utilization statistics.
 	cpu_results->count = processor_count;
-	for ( cpu = 0; cpu < processor_count; cpu++ )
-	{
+	for (cpu = 0; cpu < processor_count; cpu++) {
 		// Loop through the counters and calculate performance.
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		{
-			#if PERFORMANCE_DETAILS
-				cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
-			#endif
+		for (stat = 0; stat < CPU_RESULTS; stat++) {
+#if PERFORMANCE_DETAILS
+			cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
+#endif
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 			// If we've never set the counter offsets, then we've never successfully retrieved
 			// the performance data.  Set all of the values to 0.
-			if ( cpu_perf_counter_info[stat].offset == IOERROR )
-			{
-				cout << "*** Offset to CPU performance counter not defined for stat " 
-					 << stat << "." << endl;
+			if (cpu_perf_counter_info[stat].offset == IOERROR) {
+				cout << "*** Offset to CPU performance counter not defined for stat "
+				    << stat << "." << endl;
 				cpu_results->CPU_utilization[cpu][stat] = (double)0.0;
+			} else {
+				cpu_results->CPU_utilization[cpu][stat] =
+				    Calculate_Stat(raw_cpu_data[cpu][stat][FIRST_SNAPSHOT],
+						   raw_cpu_data[cpu][stat][LAST_SNAPSHOT],
+						   cpu_perf_counter_info[stat].type);
 			}
-			else
-			{
-				cpu_results->CPU_utilization[cpu][stat] = Calculate_Stat( 
-					raw_cpu_data[cpu][stat][FIRST_SNAPSHOT],
-					raw_cpu_data[cpu][stat][LAST_SNAPSHOT],
-					cpu_perf_counter_info[stat].type );
-			}
 #elif defined(IOMTR_OS_SOLARIS)
 			double result;
-			if (stat == CPU_IRQ)
-			{
+
+			if (stat == CPU_IRQ) {
 				// we have to calculate Interrupts/sec.
 				// This is similar to calculating Network packets per second
 				// but we are more fortunate here.
 				// See the corresponding Notes at the end of this file for a description.
 				//
-				result = ((double) raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
-						 - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) * 
-						 clock_tick / timediff;
-				cpu_results->CPU_utilization[cpu][stat] = result;	
-			}
-			else
-			{
+				result = ((double)raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
+					  - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) * clock_tick / timediff;
+				cpu_results->CPU_utilization[cpu][stat] = result;
+			} else {
 				// All other CPU statistics.
-				result = ((double) raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
-							- raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / timediff;
+				result = ((double)raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
+					  - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / timediff;
 
-				if (result < 0.0) 
-				{
+				if (result < 0.0) {
 					result = 0.0;
 					//
 					// CPU Utilization figures are outside valid range far too often.
@@ -723,169 +640,142 @@
 					//
 					// cout << "***** Error : CPU utilization outside valid range 0% - 100% *****" << endl;
 				}
-				if  (result > 1.0)
-				{
+				if (result > 1.0) {
 					result = 1.0;
 				}
 
 				cpu_results->CPU_utilization[cpu][stat] = (result * 100);
 			}
 #elif defined(IOMTR_OS_LINUX)
- // nop
+			// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "CPU " << cpu << " recorded stat " << stat << " = " 
-					<< cpu_results->CPU_utilization[cpu][stat] << endl;
-			#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "CPU " << cpu << " recorded stat " << stat << " = "
+			    << cpu_results->CPU_utilization[cpu][stat] << endl;
+#endif
 		}
 	}
 }
 
-
-
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_TCP_Stats( Net_Results *net_results )
+void Performance::Calculate_TCP_Stats(Net_Results * net_results)
 {
-	int		stat;		// Loop control variable.
+	int stat;		// Loop control variable.
 
 	// Loop through the counters and calculate performance.
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
-	{
+	for (stat = 0; stat < TCP_RESULTS; stat++) {
 		// If we've never set the counter offsets, then we've never successfully retrieved
 		// the performance data.  Set all of the values to 0.
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		if ( tcp_perf_counter_info[stat].offset == IOERROR )
-		{
+		if (tcp_perf_counter_info[stat].offset == IOERROR) {
 			net_results->tcp_stats[stat] = (double)0.0;
+		} else {
+			net_results->tcp_stats[stat] = Calculate_Stat(raw_tcp_data[stat][FIRST_SNAPSHOT],
+								      raw_tcp_data[stat][LAST_SNAPSHOT],
+								      tcp_perf_counter_info[stat].type);
 		}
-		else
-		{
-			net_results->tcp_stats[stat] = Calculate_Stat( 
-				raw_tcp_data[stat][FIRST_SNAPSHOT],
-				raw_tcp_data[stat][LAST_SNAPSHOT],
-				tcp_perf_counter_info[stat].type );
-		}
 #elif defined(IOMTR_OS_SOLARIS)
 		double result;
-		result = ((double) raw_tcp_data[stat][LAST_SNAPSHOT] - 
-			raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
-		result *= clock_tick;		// note that timediff is in CLK_TCKs and not seconds
+
+		result = ((double)raw_tcp_data[stat][LAST_SNAPSHOT] - raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
+		result *= clock_tick;	// note that timediff is in CLK_TCKs and not seconds
 		net_results->tcp_stats[stat] = result;
 #elif defined(IOMTR_OS_LINUX)
- // nop
+		// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-		#if PERFORMANCE_DETAILS || _DETAILS
-			cout << "TCP recorded stat " << stat << " = " 
-				<< net_results->tcp_stats[stat] << endl;
-		#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+		cout << "TCP recorded stat " << stat << " = " << net_results->tcp_stats[stat] << endl;
+#endif
 	}
 }
 
-
-
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_NI_Stats( Net_Results *net_results )
+void Performance::Calculate_NI_Stats(Net_Results * net_results)
 {
-	int		net, stat;		// Loop control variables.
+	int net, stat;		// Loop control variables.
 
 	// Loop through the counters and calculate performance.
 	net_results->ni_count = network_interfaces;
-	for ( net = 0; net < network_interfaces; net++ )
-	{
-		for ( stat = 0; stat < NI_RESULTS; stat++ )
-		{
+	for (net = 0; net < network_interfaces; net++) {
+		for (stat = 0; stat < NI_RESULTS; stat++) {
 			// If we've never set the counter offsets, then we've never successfully retrieved
 			// the performance data.  Set all of the values to 0.
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-			if ( ni_perf_counter_info[stat].offset == IOERROR )
-			{
+			if (ni_perf_counter_info[stat].offset == IOERROR) {
 				net_results->ni_stats[net][stat] = (double)0.0;
+			} else {
+				net_results->ni_stats[net][stat] =
+				    Calculate_Stat(raw_ni_data[net][stat][FIRST_SNAPSHOT],
+						   raw_ni_data[net][stat][LAST_SNAPSHOT],
+						   ni_perf_counter_info[stat].type);
 			}
-			else
-			{
-				net_results->ni_stats[net][stat] = Calculate_Stat( 
-					raw_ni_data[net][stat][FIRST_SNAPSHOT],
-					raw_ni_data[net][stat][LAST_SNAPSHOT],
-					ni_perf_counter_info[stat].type );
-			}
 #elif defined(IOMTR_OS_SOLARIS)
 			double result;
+
 			//
 			// Note:
-			//		The array time_counter[] stores time in nanoseconds.
+			//              The array time_counter[] stores time in nanoseconds.
 			// Earlier, we used to divide by the calculated value of timediff and then
 			// multiply the result by clock_ticks per second to get the NI_data per
 			// second which was theoretically correct (and mathematically same as what 
 			// we are doing now) but reported wrong values while working with such 
 			// large numbers.
 			//
-			result = ((double) raw_ni_data[net][stat][LAST_SNAPSHOT] - 
-				raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 / 
-				((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
+			result = ((double)raw_ni_data[net][stat][LAST_SNAPSHOT] -
+				  raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 /
+			    ((double)time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
 
 			net_results->ni_stats[net][stat] = result;
 #elif defined(IOMTR_OS_LINUX)
- // nop
+			// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "   Network interface " << net << " recorded stat " << stat << " = " 
-					<< net_results->ni_stats[net][stat] << endl;
-			#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "   Network interface " << net << " recorded stat " << stat << " = "
+			    << net_results->ni_stats[net][stat] << endl;
+#endif
 		}
 	}
 }
 
-
-
-
-
 #if defined(IOMTR_OS_SOLARIS)
 void Performance::Get_CPU_Counters(int snapshot)
 {
-	kstat_t		*ksp;
-	cpu_stat_t	*cpu_stat;
-	int		 current_cpu = 0;
-	
-	for (ksp = kc->kc_chain; ksp != NULL; ksp = ksp->ks_next)
-	{
+	kstat_t *ksp;
+	cpu_stat_t *cpu_stat;
+	int current_cpu = 0;
+
+	for (ksp = kc->kc_chain; ksp != NULL; ksp = ksp->ks_next) {
 		if (ksp->ks_type != KSTAT_TYPE_RAW)
 			continue;
 
 		// cpu_stat is raw data.
-		if (strcmp(ksp->ks_module, "cpu_stat") == 0)
-		{
+		if (strcmp(ksp->ks_module, "cpu_stat") == 0) {
 			// found a cpu_stat.
-			if (-1 == kstat_read(kc, ksp, NULL))
-			{
+			if (-1 == kstat_read(kc, ksp, NULL)) {
 				cout << "kstat_read() failed with error " << errno << endl;
 				exit(1);
 			}
 			// else kstat_read thru..
-			cpu_stat = (cpu_stat_t *)ksp->ks_data;
+			cpu_stat = (cpu_stat_t *) ksp->ks_data;
 			// store the cpu_data
 			raw_cpu_data[current_cpu][CPU_TOTAL_UTILIZATION][snapshot] =
-				cpu_stat->cpu_sysinfo.cpu[CPU_USER] + cpu_stat->cpu_sysinfo.cpu[CPU_KERNEL];
-			raw_cpu_data[current_cpu][CPU_USER_UTILIZATION][snapshot] =
-				cpu_stat->cpu_sysinfo.cpu[CPU_USER];
+			    cpu_stat->cpu_sysinfo.cpu[CPU_USER] + cpu_stat->cpu_sysinfo.cpu[CPU_KERNEL];
+			raw_cpu_data[current_cpu][CPU_USER_UTILIZATION][snapshot] = cpu_stat->cpu_sysinfo.cpu[CPU_USER];
 			raw_cpu_data[current_cpu][CPU_PRIVILEGED_UTILIZATION][snapshot] =
-				cpu_stat->cpu_sysinfo.cpu[CPU_KERNEL];
+			    cpu_stat->cpu_sysinfo.cpu[CPU_KERNEL];
 			raw_cpu_data[current_cpu][CPU_DPC_UTILIZATION][snapshot] = 0;
 			raw_cpu_data[current_cpu][CPU_IRQ_UTILIZATION][snapshot] = 0;
 			raw_cpu_data[current_cpu][CPU_IRQ][snapshot] = cpu_stat->cpu_sysinfo.intr;
@@ -896,145 +786,124 @@
 	return;
 }
 
-
-
 void Performance::Get_TCP_Counters(int snapshot)
 {
-	struct opthdr		*opthdr;
-	struct T_optmgmt_req	*optreq;
-	int			 flags = 0, retval;
+	struct opthdr *opthdr;
+	struct T_optmgmt_req *optreq;
+	int flags = 0, retval;
 
 	// We have already taken care of this in the constructor.
 	// streamfd will be -1 iff !superuser.
-	if (streamfd == -1)
-	{
+	if (streamfd == -1) {
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 		return;
 	}
-
 	// only root can open "/dev/ip" and push "tcp" module onto it.
-	if ((streamfd = open("/dev/ip", O_RDWR, 0600)) < 0)
-	{
+	if ((streamfd = open("/dev/ip", O_RDWR, 0600)) < 0) {
 		cout << "unable to open /dev/ip" << endl;
 		streamfd = -1;
 		return;
 	}
-	if (ioctl(streamfd, I_PUSH, "tcp") < 0)
-	{
+	if (ioctl(streamfd, I_PUSH, "tcp") < 0) {
 		cout << "unable to push tcp module onto the stream" << endl;
 		close(streamfd);
 		streamfd = -1;
-	}
-	else
-	{
+	} else {
 		// We are all okay here - get addrs of ctl and data bufs.
 		strbuf_ctl.buf = ctlbuf;
 		strbuf_data.buf = databuf;
 	}
 
 	// fill up the control info.
-	optreq = (struct T_optmgmt_req *) strbuf_ctl.buf;
+	optreq = (struct T_optmgmt_req *)strbuf_ctl.buf;
 	optreq->PRIM_type = T_OPTMGMT_REQ;
 	optreq->OPT_offset = sizeof(struct T_optmgmt_req);
 	optreq->OPT_length = sizeof(struct opthdr);
 	optreq->MGMT_flags = T_CURRENT;
 
-	opthdr = (struct opthdr *) &strbuf_ctl.buf[sizeof(struct T_optmgmt_req)];
+	opthdr = (struct opthdr *)&strbuf_ctl.buf[sizeof(struct T_optmgmt_req)];
 	opthdr->level = MIB2_TCP;
 	opthdr->name = opthdr->len = 0;
-	
+
 	strbuf_ctl.len = optreq->OPT_offset + optreq->OPT_length;
 
 	// Note:
-	//		To get the data from the TCP streams module, we first setup the streams
-	//		by opening "/dev/ip" and then pushing "tcp" module on top of it.
+	//              To get the data from the TCP streams module, we first setup the streams
+	//              by opening "/dev/ip" and then pushing "tcp" module on top of it.
 	//
-	//		We first construct a control message (optreq + opthdr) indicating that
-	//		the request is of type (management data request) T_OPTMGMT_REQ and is 
-	//		requesting for data of type MIB2_TCP.
+	//              We first construct a control message (optreq + opthdr) indicating that
+	//              the request is of type (management data request) T_OPTMGMT_REQ and is 
+	//              requesting for data of type MIB2_TCP.
 	//
-	//		we putmsg() the control info onto the stream and then getmsg() for a
-	//		reply. If successful, getmsg() returns a control message indicating
-	//		the number of bytes of data that will be returned in another call.
+	//              we putmsg() the control info onto the stream and then getmsg() for a
+	//              reply. If successful, getmsg() returns a control message indicating
+	//              the number of bytes of data that will be returned in another call.
 	//
-	//		Call getmsg() again to get the actual data bytes.
+	//              Call getmsg() again to get the actual data bytes.
 	//
 
 	// Now putmsg() the ctl info onto the stream.
-	if (putmsg(streamfd, &strbuf_ctl, NULL, 0) == -1)
-	{
+	if (putmsg(streamfd, &strbuf_ctl, NULL, 0) == -1) {
 		cout << "putmsg() call failed with error " << errno << endl;
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 		close(streamfd);
 		return;
 	}
-
 	// Message queued successfully. Process replies.
 	strbuf_ctl.maxlen = 64;
-	opthdr = (struct opthdr *) &strbuf_ctl.buf[sizeof(struct T_optmgmt_ack)];
+	opthdr = (struct opthdr *)&strbuf_ctl.buf[sizeof(struct T_optmgmt_ack)];
 
 	// First get the reponse to the control message.
-	if ((retval = getmsg(streamfd, &strbuf_ctl, NULL, &flags)) < 0)
-	{
+	if ((retval = getmsg(streamfd, &strbuf_ctl, NULL, &flags)) < 0) {
 		cout << "getmsg() call failed with error " << errno << endl;
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 		close(streamfd);
 		return;
 	}
 	// The call itself succeeded. Was it able to get the info correctly ??
-	if (retval == 0)
-	{
+	if (retval == 0) {
 		// Some or no error has occured. But the call is not returning us any
 		// data. So bail out.
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 		close(streamfd);
 		return;
 	}
-	if (retval == MOREDATA)
-	{
+	if (retval == MOREDATA) {
 		// At last!. Just what we want...... We are not checkin for the data size
 		// since we have allocated 1024 bytes which should be more than sufficient.
 		flags = 0;
 		strbuf_data.len = 0;
 		strbuf_data.maxlen = opthdr->len;
-		if ((retval == getmsg(streamfd, NULL, &strbuf_data, &flags)) != 0)
-		{
+		if ((retval == getmsg(streamfd, NULL, &strbuf_data, &flags)) != 0) {
 			cout << "getmsg() call (data) failed with error " << errno << endl;
 			raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 			close(streamfd);
 			return;
 		}
 		// retval == 0  is the only case where we have good data
-		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 
-					((struct mib2_tcp *)(strbuf_data.buf))->tcpRetransSegs;
+		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = ((struct mib2_tcp *)(strbuf_data.buf))->tcpRetransSegs;
 #ifdef _DETAILS
-		cout << "tcp segments retrans : " << ((struct mib2_tcp *)(strbuf_data.buf))->tcpRetransSegs
-			<< endl;
+		cout << "tcp segments retrans : " << ((struct mib2_tcp *)(strbuf_data.buf))->tcpRetransSegs << endl;
 #endif
 	}
 	close(streamfd);
 	return;
 }
 
-
-
 void Performance::Get_NI_Counters(int snapshot)
 {
-	kstat_t		*ksp;
+	kstat_t *ksp;
 	kstat_named_t *knamed;
-	int			current_nic = 0 , i;
+	int current_nic = 0, i;
 
-	for (ksp = kc->kc_chain; ksp != NULL; ksp = ksp->ks_next)
-	{
+	for (ksp = kc->kc_chain; ksp != NULL; ksp = ksp->ks_next) {
 		if (ksp->ks_type != KSTAT_TYPE_NAMED)
 			continue;
 
 		// NET data is NAMED data.
-		if (strcmp(ksp->ks_name, nic_names[current_nic]) == 0)
-		{
+		if (strcmp(ksp->ks_name, nic_names[current_nic]) == 0) {
 			// found the interface we are looking for.
-			if (0 > kstat_read(kc, ksp, NULL))
-			{
+			if (0 > kstat_read(kc, ksp, NULL)) {
 				cout << "kstat_read() failed with error " << errno << endl;
 				exit(1);
 			}
@@ -1043,17 +912,15 @@
 			raw_ni_data[current_nic][NI_PACKETS][snapshot] = 0;
 			raw_ni_data[current_nic][NI_ERRORS][snapshot] = 0;
 
-			for (i=0; i < (int)ksp->ks_ndata; i++)
-			{
-				knamed = KSTAT_NAMED_PTR(ksp)  + i;
+			for (i = 0; i < (int)ksp->ks_ndata; i++) {
+				knamed = KSTAT_NAMED_PTR(ksp) + i;
 				if (strcmp(knamed->name, "opackets") == 0)
 					raw_ni_data[current_nic][NI_PACKETS][snapshot] += knamed->value.ui32;
 				if (strcmp(knamed->name, "ipackets") == 0)
 					raw_ni_data[current_nic][NI_PACKETS][snapshot] += knamed->value.ui32;
 				if (strcmp(knamed->name, "oerrors") == 0)
 					raw_ni_data[current_nic][NI_ERRORS][snapshot] += knamed->value.ui32;
-				if (strcmp(knamed->name, "ierrors") == 0)
-				{
+				if (strcmp(knamed->name, "ierrors") == 0) {
 					raw_ni_data[current_nic][NI_IN_ERRORS][snapshot] = knamed->value.ui32;
 					raw_ni_data[current_nic][NI_ERRORS][snapshot] += knamed->value.ui32;
 				}
@@ -1068,36 +935,35 @@
 //
 // Obtaining the desired performance counters from the returned performance data.
 //
-void Performance::Extract_Counters( DWORD perf_data_type, int snapshot )
+void Performance::Extract_Counters(DWORD perf_data_type, int snapshot)
 {
 	// Locate and verify that we found where a valid performance object is at.
-	if ( !Locate_Perf_Object( perf_data_type ) )
+	if (!Locate_Perf_Object(perf_data_type))
 		return;
 
 	// After locating a valid performance object, set the offsets of specific performance counters.
-	if ( !Set_Counter_Info( perf_data_type ) )
+	if (!Set_Counter_Info(perf_data_type))
 		return;
 
 	// Save specific performance counters.
-	switch ( perf_data_type )
-	{
+	switch (perf_data_type) {
 	case PERF_PROCESSOR:
-		#if _DEBUG
-			cout << "Extracting processor data." << endl << flush;
-		#endif
-		Extract_CPU_Counters( snapshot );
+#if _DEBUG
+		cout << "Extracting processor data." << endl << flush;
+#endif
+		Extract_CPU_Counters(snapshot);
 		break;
 	case PERF_NETWORK_TCP:
-		#if _DEBUG
-			cout << "   Extracting network TCP data." << endl << flush;
-		#endif
-		Extract_TCP_Counters( snapshot );	
+#if _DEBUG
+		cout << "   Extracting network TCP data." << endl << flush;
+#endif
+		Extract_TCP_Counters(snapshot);
 		break;
 	case PERF_NETWORK_INTERFACE:
-		#if _DEBUG
-			cout << "   Extracting network interface data." << endl << flush;
-		#endif
-		Extract_NI_Counters( snapshot );
+#if _DEBUG
+		cout << "   Extracting network interface data." << endl << flush;
+#endif
+		Extract_NI_Counters(snapshot);
 		break;
 	default:
 		cout << "*** Unknown performance data requested: " << perf_data_type << endl << flush;
@@ -1105,276 +971,230 @@
 	}
 }
 
-
-
 //
 // Extracting counters for NT CPU performance data.
 //
-void Performance::Extract_CPU_Counters( int snapshot )
+void Performance::Extract_CPU_Counters(int snapshot)
 {
-	char	cpu_name[3], cpu_reg_name[3];
-	int		cpu, stat, i;
+	char cpu_name[3], cpu_reg_name[3];
+	int cpu, stat, i;
 
 	// Loop through all processors and record performance information.
-	for ( cpu = 0; cpu < processor_count; cpu++ )
-	{
+	for (cpu = 0; cpu < processor_count; cpu++) {
 		// Find the desired processor instance.
-		if ( !Locate_Perf_Instance( cpu ) )
+		if (!Locate_Perf_Instance(cpu))
 			return;
 
 		// Verify that the instance found is for the current processor, 
 		// otherwise perform an enhaustive search.
-		_itoa( cpu, cpu_name, 10 );
+		_itoa(cpu, cpu_name, 10);
 
-                strcpy((char*)cpu_reg_name, (char*)((LPBYTE)perf_instance + perf_instance->NameOffset));
+		strcpy((char *)cpu_reg_name, (char *)((LPBYTE) perf_instance + perf_instance->NameOffset));
 
-                if (perf_instance->NameLength = 6)
-                {
-                        strcat((char*)cpu_reg_name, 
-				(char*)((LPBYTE)perf_instance +
-                              	perf_instance->NameOffset)+2);
-                }
+		if (perf_instance->NameLength = 6) {
+			strcat((char *)cpu_reg_name, (char *)((LPBYTE) perf_instance + perf_instance->NameOffset) + 2);
+		}
 
-                if ( strncmp( cpu_name, cpu_reg_name, 2 ) )
-                {
-			#if _DEBUG
-				cout << "Performing exhaustive search for processor instance " << cpu << endl;
-			#endif
+		if (strncmp(cpu_name, cpu_reg_name, 2)) {
+#if _DEBUG
+			cout << "Performing exhaustive search for processor instance " << cpu << endl;
+#endif
 
 			// Check all processor instances and 
 			// try to match one with the desired processor.
-			for ( i = 0; i < perf_object->NumInstances; i++ )
-			{
-			if ( !Locate_Perf_Instance( i ) )
+			for (i = 0; i < perf_object->NumInstances; i++) {
+				if (!Locate_Perf_Instance(i))
+					return;
+#if PERFORMANCE_DETAILS || _DETAILS
+				cout << "Looking at processor name: " << (char *)cpu_reg_name << endl;
+#endif
+				// Match the name of the current instance with 
+				//      the name of the desired cpu.
+				if (!strncmp(cpu_name, (char *)((LPBYTE) perf_instance + perf_instance->NameOffset), 2))
+					break;	// Found the correct instance.
+			}
+			if (i == perf_object->NumInstances) {
+				cout << "*** Unable to locate performance instance of processor " << cpu_name << endl;
 				return;
-			#if PERFORMANCE_DETAILS || _DETAILS
-                        cout << "Looking at processor name: " 
-				<< (char *)cpu_reg_name << endl;
-			#endif
-			// Match the name of the current instance with 
-			// 	the name of the desired cpu.
-			if ( !strncmp( cpu_name, (char*)((LPBYTE)perf_instance+ 
-					perf_instance->NameOffset), 2 ) )
-			break;	// Found the correct instance.
 			}
-			if ( i == perf_object->NumInstances )
-			{
-			cout << "*** Unable to locate performance instance of processor " << cpu_name << endl;
-			return;
-			}
 		}
-
 		// Saving CPU specific counters.
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		{
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "Extracting CPU stat " << stat 
-					<< " for CPU " << cpu_name << endl;
-			#endif
-			raw_cpu_data[cpu][stat][snapshot] = 
-				Extract_Counter( &(cpu_perf_counter_info[stat]) );
+		for (stat = 0; stat < CPU_RESULTS; stat++) {
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "Extracting CPU stat " << stat << " for CPU " << cpu_name << endl;
+#endif
+			raw_cpu_data[cpu][stat][snapshot] = Extract_Counter(&(cpu_perf_counter_info[stat]));
 		}
 	}
 }
 
-
-
 //
 // Extracting counters for NT network performance data.
 //
-void Performance::Extract_TCP_Counters( int snapshot )
+void Performance::Extract_TCP_Counters(int snapshot)
 {
-	int		stat;
+	int stat;
 
 	// Saving network TCP specific counters.
-	if ( !Locate_Perf_Instance() )
+	if (!Locate_Perf_Instance())
 		return;
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
-	{
-		#if PERFORMANCE_DETAILS || _DETAILS
-			cout << "Extracting TCP stat " << stat << endl;
-		#endif
-		raw_tcp_data[stat][snapshot] = Extract_Counter( &(tcp_perf_counter_info[stat]) );
+	for (stat = 0; stat < TCP_RESULTS; stat++) {
+#if PERFORMANCE_DETAILS || _DETAILS
+		cout << "Extracting TCP stat " << stat << endl;
+#endif
+		raw_tcp_data[stat][snapshot] = Extract_Counter(&(tcp_perf_counter_info[stat]));
 	}
 }
 
-
-
 //
 // Extracting counters for NT network interface performance data.
 //
-void Performance::Extract_NI_Counters( int snapshot )
+void Performance::Extract_NI_Counters(int snapshot)
 {
-	int		stat;
+	int stat;
 
 	// Automatically setting the number of network interfaces that data is available for.
 	network_interfaces = 0;
-	do
-	{
+	do {
 		// Find the desired network NI interface instance.
-		if ( !Locate_Perf_Instance(network_interfaces) )
+		if (!Locate_Perf_Instance(network_interfaces))
 			return;
 
 		// Saving network NI specific counters.
-		for ( stat = 0; stat < NI_RESULTS; stat++ )
-		{
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "Extracting NI stat " << stat << " for NI " 
-					<< network_interfaces << endl;
-			#endif
-			raw_ni_data[network_interfaces][stat][snapshot] = 
-				Extract_Counter( &(ni_perf_counter_info[stat]) );
+		for (stat = 0; stat < NI_RESULTS; stat++) {
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "Extracting NI stat " << stat << " for NI " << network_interfaces << endl;
+#endif
+			raw_ni_data[network_interfaces][stat][snapshot] =
+			    Extract_Counter(&(ni_perf_counter_info[stat]));
 		}
 		network_interfaces++;
-	} while ( network_interfaces < perf_object->NumInstances );
+	} while (network_interfaces < perf_object->NumInstances);
 }
 
-
-
 //
 // Extracting and returning a performance counter.  Perf_counter must already be set to a valid
 // performance counter block by calling Locate_Perf_Instance.
 //
-_int64 Performance::Extract_Counter( const Perf_Counter_Info *counter_info )
+_int64 Performance::Extract_Counter(const Perf_Counter_Info * counter_info)
 {
 	// Verify that we know where to locate the counter.
-	if ( counter_info->offset == IOERROR )
-	{
+	if (counter_info->offset == IOERROR) {
 		cout << "*** Unable to extract performance counter, offset not set." << endl << flush;
-		return (_int64)0;
+		return (_int64) 0;
 	}
 
-	switch ( counter_info->type & PERF_SIZE_MASK )
-	{
+	switch (counter_info->type & PERF_SIZE_MASK) {
 	case PERF_SIZE_LARGE:
-		return (_int64)((LARGE_INTEGER*)((LPBYTE)perf_counters + counter_info->offset))->QuadPart;
+		return (_int64) ((LARGE_INTEGER *) ((LPBYTE) perf_counters + counter_info->offset))->QuadPart;
 	case PERF_SIZE_DWORD:
-		return (_int64)*((DWORD*)((LPBYTE)perf_counters + counter_info->offset));
-	default:					// other counter types exist, but are not currently used - signal error
+		return (_int64) * ((DWORD *) ((LPBYTE) perf_counters + counter_info->offset));
+	default:		// other counter types exist, but are not currently used - signal error
 		cout << "*** Unknown size of performance data." << endl << flush;
 	}
-	return (_int64)0;
+	return (_int64) 0;
 }
 
-
-
 //
 // Locating the desired performance object from the returned performance data.
 //
-BOOL Performance::Locate_Perf_Object( DWORD perf_object_index )
+BOOL Performance::Locate_Perf_Object(DWORD perf_object_index)
 {
-	PERF_DATA_BLOCK		*pperf_data;	// short-cut pointer to returned performance data
-	DWORD				object_offset;	// offset to current object
+	PERF_DATA_BLOCK *pperf_data;	// short-cut pointer to returned performance data
+	DWORD object_offset;	// offset to current object
 	int i;
 
-	pperf_data = (PERF_DATA_BLOCK*)perf_data;
+	pperf_data = (PERF_DATA_BLOCK *) perf_data;
 	object_offset = pperf_data->HeaderLength;
 
 	// Search through all returned objects until we find the desired one.
-	for ( i = 0; i < (int)pperf_data->NumObjectTypes; i++ )
-	{
-		perf_object = (PERF_OBJECT_TYPE*)((LPBYTE)pperf_data + object_offset);
-		if ( perf_object->ObjectNameTitleIndex == perf_object_index )
-		{
+	for (i = 0; i < (int)pperf_data->NumObjectTypes; i++) {
+		perf_object = (PERF_OBJECT_TYPE *) ((LPBYTE) pperf_data + object_offset);
+		if (perf_object->ObjectNameTitleIndex == perf_object_index) {
 			break;	// This is the object we want.
-		}
-		else
-		{
+		} else {
 			object_offset += perf_object->TotalByteLength;	// Not it, check next object.
 		}
 	}
 
 	// If we didn't find the desired object, set the pointer to NULL and signify error.
 	// This is normal for performance data disabled by default (e.g. network interface).
-	if ( i >= (int)pperf_data->NumObjectTypes )
-	{
+	if (i >= (int)pperf_data->NumObjectTypes) {
 		perf_object = NULL;
-		#if PERFORMANCE_DETAILS || _DEBUG
-			cout << "No current performance object to retrieve counters from." << endl 
-				<< "   Searching for " << perf_object_index << endl << flush;
-		#endif
+#if PERFORMANCE_DETAILS || _DEBUG
+		cout << "No current performance object to retrieve counters from." << endl
+		    << "   Searching for " << perf_object_index << endl << flush;
+#endif
 		return FALSE;
 	}
 	return TRUE;
 }
 
-
-
 //
 // Locating the specific instance, base 0, of a performance object and finding its counters.
 // You must call Locate_Perf_Object to locate a valid performance object before calling this.
 //
-BOOL Performance::Locate_Perf_Instance( int instance )
+BOOL Performance::Locate_Perf_Instance(int instance)
 {
 	// See if the current performance object supports multiple instances.
 	// The performance object should have previously been set by Locate_Perf_Object.
-	if ( perf_object->NumInstances == PERF_NO_INSTANCES )
-	{
+	if (perf_object->NumInstances == PERF_NO_INSTANCES) {
 		// Verify that we were not expecting multiple instances to be supported.
-		if ( instance != PERF_NO_INSTANCES )
-		{
+		if (instance != PERF_NO_INSTANCES) {
 			cout << "*** One performance instance was found, but more were expected." << endl << flush;
 			return FALSE;
 		}
-
 		// Only one instance supported, just set a pointer to the performance counters.
 		perf_instance = NULL;
-		perf_counters = (PERF_COUNTER_BLOCK*)((LPBYTE)perf_object + perf_object->DefinitionLength);
-	}
-	else
-	{
+		perf_counters = (PERF_COUNTER_BLOCK *) ((LPBYTE) perf_object + perf_object->DefinitionLength);
+	} else {
 		// Verify that we were expecting to find multiple instances.
-		if ( instance == PERF_NO_INSTANCES )
-		{
+		if (instance == PERF_NO_INSTANCES) {
 			cout << "*** Multiple performance instances were found, but not expected." << endl << flush;
 			return FALSE;
 		}
-
 		// Multiple instances supported.  Locate the counters to the correct one.
 		// Get a pointer to the first instance.
-		perf_instance = (PERF_INSTANCE_DEFINITION*)((LPBYTE)perf_object + perf_object->DefinitionLength);
+		perf_instance = (PERF_INSTANCE_DEFINITION *) ((LPBYTE) perf_object + perf_object->DefinitionLength);
 
 		// Walk through instances until we find the one we want.
-		for ( int i = 0; i < instance; i++ )
-		{
-			perf_counters = (PERF_COUNTER_BLOCK*)((LPBYTE)perf_instance + perf_instance->ByteLength);
-			perf_instance = (PERF_INSTANCE_DEFINITION*)((LPBYTE)perf_counters + perf_counters->ByteLength);
+		for (int i = 0; i < instance; i++) {
+			perf_counters = (PERF_COUNTER_BLOCK *) ((LPBYTE) perf_instance + perf_instance->ByteLength);
+			perf_instance =
+			    (PERF_INSTANCE_DEFINITION *) ((LPBYTE) perf_counters + perf_counters->ByteLength);
 		}
-		perf_counters = (PERF_COUNTER_BLOCK*)((LPBYTE)perf_instance + perf_instance->ByteLength);
+		perf_counters = (PERF_COUNTER_BLOCK *) ((LPBYTE) perf_instance + perf_instance->ByteLength);
 	}
 	return TRUE;
 }
 
-
-
 //
 // Setting the offsets and size of the specific performance counters.
 // You must call Locate_Perf_Object before calling this function to locate a
 // valid performance object.
 //
-BOOL Performance::Set_Counter_Info( DWORD perf_data_type )
+BOOL Performance::Set_Counter_Info(DWORD perf_data_type)
 {
-	PERF_COUNTER_DEFINITION	*counter_def;	// pointer to a specific counter definition
-	int					number_of_counters;	// number of counters to find offsets for
-	int					counter;			// number current counter from returned list
-	Perf_Counter_Info	*counter_info;		// pointer to array of counter information
+	PERF_COUNTER_DEFINITION *counter_def;	// pointer to a specific counter definition
+	int number_of_counters;	// number of counters to find offsets for
+	int counter;		// number current counter from returned list
+	Perf_Counter_Info *counter_info;	// pointer to array of counter information
 
 	// Setting pointers to specific counters based on type of performance data returned.
 	// This is used to keep the code for finding the offsets (see below) more general.
-	switch ( perf_data_type )
-	{
+	switch (perf_data_type) {
 	case PERF_PROCESSOR:
 		// Find offsets for processor specific data.
 		number_of_counters = CPU_RESULTS;
-		counter_info = (Perf_Counter_Info*)(&(cpu_perf_counter_info[0]));
+		counter_info = (Perf_Counter_Info *) (&(cpu_perf_counter_info[0]));
 		break;
 	case PERF_NETWORK_TCP:
 		number_of_counters = TCP_RESULTS;
-		counter_info = (Perf_Counter_Info*)(&(tcp_perf_counter_info[0]));
+		counter_info = (Perf_Counter_Info *) (&(tcp_perf_counter_info[0]));
 		break;
 	case PERF_NETWORK_INTERFACE:
 		number_of_counters = NI_RESULTS;
-		counter_info = (Perf_Counter_Info*)(&(ni_perf_counter_info[0]));
+		counter_info = (Perf_Counter_Info *) (&(ni_perf_counter_info[0]));
 		break;
 	default:
 		cout << "*** Unknown performance data requested: " << perf_data_type << endl << flush;
@@ -1383,16 +1203,13 @@
 
 	// Set a pointer to the first counter defition.
 	// This uses the performance object previously found by Locate_Perf_Object.
-	counter_def = (PERF_COUNTER_DEFINITION*)((LPBYTE)perf_object + perf_object->HeaderLength);
+	counter_def = (PERF_COUNTER_DEFINITION *) ((LPBYTE) perf_object + perf_object->HeaderLength);
 
 	// Check all returned counters and match to desired ones.
-	for ( counter = 0; counter < (int)perf_object->NumCounters; counter++ )
-	{
+	for (counter = 0; counter < (int)perf_object->NumCounters; counter++) {
 		// Walk through list of desired counters to find offsets for them.
-		for ( int i = 0; i < number_of_counters; i++ )
-		{
-			if ( counter_def->CounterNameTitleIndex == counter_info[i].index )
-			{
+		for (int i = 0; i < number_of_counters; i++) {
+			if (counter_def->CounterNameTitleIndex == counter_info[i].index) {
 				// We found the counter that we're looking for.  Record needed information.
 				counter_info[i].offset = counter_def->CounterOffset;
 				counter_info[i].type = counter_def->CounterType;
@@ -1400,113 +1217,102 @@
 			}
 		}
 		// Move to the next counter  definition.
-		counter_def = (PERF_COUNTER_DEFINITION*)((LPBYTE)counter_def + counter_def->ByteLength);
+		counter_def = (PERF_COUNTER_DEFINITION *) ((LPBYTE) counter_def + counter_def->ByteLength);
 	}
 	return TRUE;
 }
 
-
-
-double Performance::Calculate_Stat( _int64 start_value, _int64 end_value, DWORD counter_type )
+double Performance::Calculate_Stat(_int64 start_value, _int64 end_value, DWORD counter_type)
 {
-	double	count_difference;	// Difference between two snapshots of a counter.
-	double	perf_stat;			// Calculated performance statistic, such as % utilization.
+	double count_difference;	// Difference between two snapshots of a counter.
+	double perf_stat;	// Calculated performance statistic, such as % utilization.
 
 	// Verify valid performance time.
-	if ( perf_time <= 0 )
-	{
+	if (perf_time <= 0) {
 //
 // *** Removed:  Need to add back in if using getTickCount.
 //
 //#ifndef WIN64_COUNTER_WORKAROUND
-//		cout << "*** Performance time not positive." << endl;
+//              cout << "*** Performance time not positive." << endl;
 //#endif
 //
 // *** End Removed.
 //
 		return (double)0.0;
 	}
-
 	// Determine what type of counter we're dealing with.
-	switch ( counter_type & PERF_TYPE_MASK )
-	{
+	switch (counter_type & PERF_TYPE_MASK) {
 
-	// Dealing with a number (e.g. error count)
+		// Dealing with a number (e.g. error count)
 	case PERF_TYPE_NUMBER:
-		#if PERFORMANCE_DETAILS
-			cout << "Performing calculation on a performance number." << endl;
-		#endif
-		switch ( counter_type & PERF_SUBTYPE_MASK )
-		{
+#if PERFORMANCE_DETAILS
+		cout << "Performing calculation on a performance number." << endl;
+#endif
+		switch (counter_type & PERF_SUBTYPE_MASK) {
 		case PERF_NUMBER_DECIMAL:
-			#if PERFORMANCE_DETAILS
-				cout << "Performance number decimal." << endl;
-			#endif
+#if PERFORMANCE_DETAILS
+			cout << "Performance number decimal." << endl;
+#endif
 			perf_stat = (double)(end_value - start_value);
 			break;
 		case PERF_NUMBER_DEC_1000:	// divide result by 1000 before displaying
-			#if PERFORMANCE_DETAILS
-				cout << "Performance number decimal x 1000." << endl;
-			#endif
+#if PERFORMANCE_DETAILS
+			cout << "Performance number decimal x 1000." << endl;
+#endif
 			perf_stat = (double)(end_value - start_value) / (double)1000.0;
 			break;
-		// other subtypes exist, but are not handled
+			// other subtypes exist, but are not handled
 		default:
 			cout << "*** Performance counter number subtype not handled" << endl;
 			return (double)0.0;
 		}
 		break;
 
-	// Dealing with an actual counter value.
+		// Dealing with an actual counter value.
 	case PERF_TYPE_COUNTER:
-		#if PERFORMANCE_DETAILS
-			cout << "Performing calculation on a performance counter." << endl;
-		#endif
+#if PERFORMANCE_DETAILS
+		cout << "Performing calculation on a performance counter." << endl;
+#endif
 
 		// Computing the difference between the two counters.
-		if ( counter_type & PERF_DELTA_COUNTER )
-		{
-			#if PERFORMANCE_DETAILS
-				cout << "Performance delta counter." << endl;
-			#endif
+		if (counter_type & PERF_DELTA_COUNTER) {
+#if PERFORMANCE_DETAILS
+			cout << "Performance delta counter." << endl;
+#endif
 			count_difference = (double)(end_value - start_value);
-		}
-		else
-		{
+		} else {
 			cout << "*** Unhandled performance counter delta type." << endl;
 			return (double)0.0;
 		}
 
 		// Determine the calculated value based on the counter's subtype.
-		switch ( counter_type & PERF_SUBTYPE_MASK )
-		{
+		switch (counter_type & PERF_SUBTYPE_MASK) {
 
-		// Divide the counter by the time difference
+			// Divide the counter by the time difference
 		case PERF_COUNTER_RATE:
-			#if PERFORMANCE_DETAILS
-				cout << "Performance counter is a rate." << endl;
-			#endif
+#if PERFORMANCE_DETAILS
+			cout << "Performance counter is a rate." << endl;
+#endif
 
 			// Adjust the time based on the counter's update frequency.
-			switch ( counter_type & PERF_TIMER_MASK )
-			{
-			// Timer is based on the system timer, just use it.
+			switch (counter_type & PERF_TIMER_MASK) {
+				// Timer is based on the system timer, just use it.
 			case PERF_TIMER_TICK:
-				#if PERFORMANCE_DETAILS
-					cout << "Using system timer for update frequency." << endl;
-				#endif
+#if PERFORMANCE_DETAILS
+				cout << "Using system timer for update frequency." << endl;
+#endif
 				perf_stat = count_difference / perf_time;
 				break;
 
-			// These timers are based on a 100-ns timer, so multiply timer by 10,000,000 to get seconds.
+				// These timers are based on a 100-ns timer, so multiply timer by 10,000,000 to get seconds.
 			case PERF_TIMER_100NS:
-				#if PERFORMANCE_DETAILS
-					cout << "Using 100-ns timer for update frequency." << endl;
-				#endif
+#if PERFORMANCE_DETAILS
+				cout << "Using 100-ns timer for update frequency." << endl;
+#endif
 				perf_stat = count_difference / (perf_time * (double)10000000.0);
 				break;
 
-			// other timer rates exist, but are not handled.
+				// other timer rates exist, but are not handled.
 			default:
 				cout << "*** Performance update frequency type not handled." << endl;
 				return (double)0.0;
@@ -1520,49 +1326,39 @@
 
 		break;
 
-	// other types exist, but are not handled
+		// other types exist, but are not handled
 	default:
 		cout << "*** Unhandled performance counter type." << endl;
 		return (double)0.0;
 	}
 
 	// Handle any inverted performance counters.
-	if ( counter_type & PERF_INVERSE_COUNTER )
-	{
-		#if PERFORMANCE_DETAILS
-			cout << "Inverting performance counter (1 - value)." << endl;
-		#endif
-		perf_stat = (double) 1.0 - perf_stat;
+	if (counter_type & PERF_INVERSE_COUNTER) {
+#if PERFORMANCE_DETAILS
+		cout << "Inverting performance counter (1 - value)." << endl;
+#endif
+		perf_stat = (double)1.0 - perf_stat;
 	}
-
 	// Perform any additional operations needed based on the counter's display suffix.
-	switch ( counter_type & PERF_SUFFIX_MASK )
-	{
-	case PERF_DISPLAY_NO_SUFFIX:		// just return value
-	case PERF_DISPLAY_PER_SEC:			// no additional calculations needed
+	switch (counter_type & PERF_SUFFIX_MASK) {
+	case PERF_DISPLAY_NO_SUFFIX:	// just return value
+	case PERF_DISPLAY_PER_SEC:	// no additional calculations needed
 		return perf_stat;
 
-	case PERF_DISPLAY_PERCENT:			// scale by 100 to reflect a percentage
-		#if PERFORMANCE_DETAILS
-			cout << "Performance counter is a percent." << endl;
-		#endif
+	case PERF_DISPLAY_PERCENT:	// scale by 100 to reflect a percentage
+#if PERFORMANCE_DETAILS
+		cout << "Performance counter is a percent." << endl;
+#endif
 		// Verify valid values.  
 		// Do not print an error message unless it's more than trivially invalid.
-		if ( perf_stat < (double)0.0 ) 
-		{
-			if ( perf_stat < (double)-0.001 ) 
-			{
-				cout << "*** Performance counter percentage is less than zero: " 
-					 << perf_stat << endl;
+		if (perf_stat < (double)0.0) {
+			if (perf_stat < (double)-0.001) {
+				cout << "*** Performance counter percentage is less than zero: " << perf_stat << endl;
 			}
 			return (double)0.0;
-		}
-		else if ( perf_stat > (double)1.0 )
-		{
-			if ( perf_stat > (double)1.001 ) 
-			{
-				cout << "*** Performance counter percentage is greater than 1: " 
-					 << perf_stat << endl;
+		} else if (perf_stat > (double)1.0) {
+			if (perf_stat > (double)1.001) {
+				cout << "*** Performance counter percentage is greater than 1: " << perf_stat << endl;
 			}
 			return (double)100.0;
 		}
@@ -1576,12 +1372,8 @@
 }
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE)
  // nop
-#else    
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
-
-
-#endif   // !IOMTR_OS_LINUX || !IOMTR_OS_NETWARE || !MTR_OS_OSX
+#endif				// !IOMTR_OS_LINUX || !IOMTR_OS_NETWARE || !MTR_OS_OSX

Modified: branches/IOMETER-restruct/iometer/src/IOPerformance.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPerformance.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPerformance.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -71,58 +71,50 @@
 #ifndef PERFORMANCE_DEFINED
 #define PERFORMANCE_DEFINED
 
-
-
 #include "IOCommon.h"
 
-
-
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 
- #include <stdio.h>
+#include <stdio.h>
 
- #if defined(IOMTR_OS_SOLARIS)
-  #include <kstat.h>
- #endif
+#if defined(IOMTR_OS_SOLARIS)
+#include <kstat.h>
+#endif
 
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-  #include <sys/sysinfo.h>
- #endif
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+#include <sys/sysinfo.h>
+#endif
 
- #include <sys/socket.h>
+#include <sys/socket.h>
 
- #if defined(IOMTR_OS_SOLARIS)
-  #include <sys/sockio.h>
- #endif
+#if defined(IOMTR_OS_SOLARIS)
+#include <sys/sockio.h>
+#endif
 
- #include <netinet/in.h>
+#include <netinet/in.h>
 
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-  #include <net/if.h>
- #endif
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
+#include <net/if.h>
+#endif
 
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OS_SOLARIS)
-  #include <stropts.h>
- #endif
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OS_SOLARIS)
+#include <stropts.h>
+#endif
 
- #if defined(IOMTR_OS_SOLARIS)
-  #include <sys/stream.h>
-  #include <sys/tihdr.h>
-  #include <inet/mib2.h>
- #endif
+#if defined(IOMTR_OS_SOLARIS)
+#include <sys/stream.h>
+#include <sys/tihdr.h>
+#include <inet/mib2.h>
+#endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
-  #include <monitor.h>
+#include <monitor.h>
 #endif
 
 #endif
 
-
-
 #define MAX_PERF_SIZE	4096	// Initial memory size allocated to NT performance data.
 
-
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 // Bit masks to expose information about performance counter types.
 // See winperf.h for additional details about counter definitions.
@@ -131,7 +123,7 @@
 #define PERF_SUBTYPE_MASK	0x000F0000
 #define PERF_TIMER_MASK		0x00300000
 #define PERF_SUFFIX_MASK	0xF0000000
-#endif // WIN32 || _WIN64
+#endif				// WIN32 || _WIN64
 
 //
 // NT performance counter indexes.  These indexes are accessible through
@@ -159,83 +151,77 @@
 
 #define MILLISECOND                    		1000
 
-
-
-struct Perf_Counter_Info
-{
-	DWORD	index;		// identification of counter
-	int	offset;		// offset of counter from counter block header
-	DWORD	type;		// information retrieved about the counter's type,
-				// such as its update frequency, size, etc.
+struct Perf_Counter_Info {
+	DWORD index;		// identification of counter
+	int offset;		// offset of counter from counter block header
+	DWORD type;		// information retrieved about the counter's type,
+	// such as its update frequency, size, etc.
 };
 
-
-
-class Performance  
-{
-public:
+class Performance {
+      public:
 	Performance();
 	~Performance();
 
-	void Get_Perf_Data( DWORD perf_data_type, int snapshot );
-	void Calculate_CPU_Stats( CPU_Results *cpu_results );
-	void Calculate_TCP_Stats( Net_Results *net_results );
-	void Calculate_NI_Stats( Net_Results *net_results );
+	void Get_Perf_Data(DWORD perf_data_type, int snapshot);
+	void Calculate_CPU_Stats(CPU_Results * cpu_results);
+	void Calculate_TCP_Stats(Net_Results * net_results);
+	void Calculate_NI_Stats(Net_Results * net_results);
 
-	double		processor_speed;		// Frequency (Hz) of system processors.
-	int		processor_count;		// Number of system processors.
-	int		network_interfaces;		// Number of (virtual) NICs in the system.
+	double processor_speed;	// Frequency (Hz) of system processors.
+	int processor_count;	// Number of system processors.
+	int network_interfaces;	// Number of (virtual) NICs in the system.
 
-	__int64		time_counter[MAX_SNAPSHOTS];	// Time that NT performance snapshots were taken.
-	int		clock_tick;
+	__int64 time_counter[MAX_SNAPSHOTS];	// Time that NT performance snapshots were taken.
+	int clock_tick;
 #if defined(IOMTR_OS_SOLARIS)
-	double		timediff;
-	kstat_ctl_t	*kc;
-	char		nic_names[MAX_NUM_INTERFACES][IFNAMSIZ]; // array of pointers to hold network interface names.
-	struct strbuf	strbuf_ctl, strbuf_data;
-	int		streamfd;				 // File descriptor to the stream.
-	char		*ctlbuf, *databuf;
+	double timediff;
+	kstat_ctl_t *kc;
+	char nic_names[MAX_NUM_INTERFACES][IFNAMSIZ];	// array of pointers to hold network interface names.
+	struct strbuf strbuf_ctl, strbuf_data;
+	int streamfd;		// File descriptor to the stream.
+	char *ctlbuf, *databuf;
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE)
 	long long timediff;
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	DWORDLONG timediff;
 #elif defined(IOMTR_OS_OSX)
-	double		timediff;
-	char		nic_names[MAX_NUM_INTERFACES][IFNAMSIZ];
+	double timediff;
+	char nic_names[MAX_NUM_INTERFACES][IFNAMSIZ];
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-private:
-	int		Get_Processor_Count();
-	double		Get_Processor_Speed();
+      private:
+	int Get_Processor_Count();
+	double Get_Processor_Speed();
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	void		Extract_Counters( DWORD perf_data_type, int snapshot );
-	void		Extract_CPU_Counters( int snapshot );
-	void		Extract_TCP_Counters( int snapshot );
-	void		Extract_NI_Counters( int snapshot );
-	__int64		Extract_Counter( const Perf_Counter_Info *counter_info );
+	void Extract_Counters(DWORD perf_data_type, int snapshot);
+	void Extract_CPU_Counters(int snapshot);
+	void Extract_TCP_Counters(int snapshot);
+	void Extract_NI_Counters(int snapshot);
+	__int64 Extract_Counter(const Perf_Counter_Info * counter_info);
 
-	BOOL		Locate_Perf_Object( DWORD perf_object_index );
-	BOOL		Locate_Perf_Instance( int instance = PERF_NO_INSTANCES );
-	BOOL		Set_Counter_Info( DWORD perf_data_type );
+	BOOL Locate_Perf_Object(DWORD perf_object_index);
+	BOOL Locate_Perf_Instance(int instance = PERF_NO_INSTANCES);
+	BOOL Set_Counter_Info(DWORD perf_data_type);
 
-	double		Calculate_Stat( __int64 start_value, __int64 end_value, DWORD counter_type );
+	double Calculate_Stat(__int64 start_value, __int64 end_value, DWORD counter_type);
 #endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	void		Get_CPU_Counters(int snapshot);
-	void		Get_NI_Counters(int snapshot);
-	void		Get_TCP_Counters(int snapshot);
+	void Get_CPU_Counters(int snapshot);
+	void Get_NI_Counters(int snapshot);
+	void Get_TCP_Counters(int snapshot);
 #endif
 
-	LPBYTE		perf_data;				// Pointer to performance data.
-	DWORD		perf_size;				// Size of performance data buffer.
+	LPBYTE perf_data;	// Pointer to performance data.
+	DWORD perf_size;	// Size of performance data buffer.
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	PERF_OBJECT_TYPE		*perf_object;	// pointer to NT performance data for a specific object
-	PERF_INSTANCE_DEFINITION	*perf_instance; // pointer to an instance of a specific object
-	PERF_COUNTER_BLOCK		*perf_counters;	// pointer to NT performance counters for a specific instance of an object
+	PERF_OBJECT_TYPE *perf_object;	// pointer to NT performance data for a specific object
+	PERF_INSTANCE_DEFINITION *perf_instance;	// pointer to an instance of a specific object
+	PERF_COUNTER_BLOCK *perf_counters;	// pointer to NT performance counters for a specific instance of an object
 #endif
 #if defined(IOMTR_OS_NETWARE)
 	struct cpu_info info;
@@ -243,17 +229,15 @@
 	//
 	// raw CPU performance counters for Windows NT
 	//
-	double		perf_time;				// Time that performance data was captured.
-	__int64		raw_cpu_data[MAX_CPUS][CPU_RESULTS][MAX_SNAPSHOTS];
-	__int64		raw_tcp_data[TCP_RESULTS][MAX_SNAPSHOTS];
-	__int64		raw_ni_data[MAX_NUM_INTERFACES][NI_RESULTS][MAX_SNAPSHOTS];
+	double perf_time;	// Time that performance data was captured.
+	__int64 raw_cpu_data[MAX_CPUS][CPU_RESULTS][MAX_SNAPSHOTS];
+	__int64 raw_tcp_data[TCP_RESULTS][MAX_SNAPSHOTS];
+	__int64 raw_ni_data[MAX_NUM_INTERFACES][NI_RESULTS][MAX_SNAPSHOTS];
 
 	// List of counter information that should be extracted and stored.
-	Perf_Counter_Info		cpu_perf_counter_info[CPU_RESULTS];
-	Perf_Counter_Info		tcp_perf_counter_info[TCP_RESULTS];
-	Perf_Counter_Info		ni_perf_counter_info[NI_RESULTS];
+	Perf_Counter_Info cpu_perf_counter_info[CPU_RESULTS];
+	Perf_Counter_Info tcp_perf_counter_info[TCP_RESULTS];
+	Perf_Counter_Info ni_perf_counter_info[NI_RESULTS];
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -105,10 +105,9 @@
 /* ##                 (brings some minor changes to main() function).     ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
-#define PERFORMANCE_DETAILS	0   // Turn on to display additional performance messages.
+#define PERFORMANCE_DETAILS	0	// Turn on to display additional performance messages.
 #if defined(IOMTR_OS_LINUX)
 
-
 #include <sys/time.h>
 #include <assert.h>
 
@@ -118,14 +117,11 @@
 extern int kstatfd;
 extern int procstatstyle;
 
-
-
-
-
 //
 // Initializing system performance data.
 //
-Performance::Performance() {
+Performance::Performance()
+{
 	// Obtaining the number of CPUs in the system and their speed.
 	processor_count = Get_Processor_Count();
 	processor_speed = Get_Processor_Speed();
@@ -137,33 +133,29 @@
 
 	if (!processor_speed || !processor_count) {
 		cout << "*** Unable to initialize needed performance data.\n"
-				 << "This error may indicate that you are trying to run on an\n"
-				 << "unsupported processor or OS.  See the Iometer User's Guide for\n"
-				 << "information on supported platforms.\n";
+		    << "This error may indicate that you are trying to run on an\n"
+		    << "unsupported processor or OS.  See the Iometer User's Guide for\n"
+		    << "information on supported platforms.\n";
 		exit(1);
 	}
-
-        // Set the clock ticks per second
+	// Set the clock ticks per second
 	// TODO: try to find a correct way to get this number
 	// DF: Base on ''man sysconf'', this macro is obsolete now. so things become tricky
 	clock_tick = sysconf(_SC_CLK_TCK);
-	
+
 	// Initialize all the arrays to 0.
 	memset(raw_cpu_data, 0, (MAX_CPUS * CPU_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
-	memset(raw_ni_data,  0, (MAX_NUM_INTERFACES * NI_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
+	memset(raw_ni_data, 0, (MAX_NUM_INTERFACES * NI_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
 	memset(raw_tcp_data, 0, (TCP_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
 }
 
-
-
 //
 // Freeing memory used by class object.
 //
-Performance::~Performance() {
+Performance::~Performance()
+{
 }
 
-
-
 //
 // Getting the number of processors in the system.
 //
@@ -193,6 +185,7 @@
 	int fd, byteCount, cpuCount;
 
 	int nr_cpu = 0;
+
 	if (kstatfd > 0 && ioctl(kstatfd, IM_IOC_GETCPUNUM, &nr_cpu) >= 0) {
 		cout << "# CPU: " << nr_cpu << endl;
 		return nr_cpu;
@@ -200,44 +193,42 @@
 
 	fd = open("/proc/stat", O_RDONLY);
 	if (fd < 0) {
-	  cout << "*** Unable to determine number of processors in system.";
-	  return 0;
+		cout << "*** Unable to determine number of processors in system.";
+		return 0;
 	}
 	byteCount = read(fd, stats + 1, sizeof(stats) - 1);
 	close(fd);
 	if ((byteCount < 0) || (byteCount == sizeof(stats) - 1)) {
-	  cout << "*** Unable to determine number of processors in system.";
-	  return 0;
+		cout << "*** Unable to determine number of processors in system.";
+		return 0;
 	}
-	stats[0] = '\n'; // Make the first line begin with a \n, like the others.
+	stats[0] = '\n';	// Make the first line begin with a \n, like the others.
 	stats[byteCount + 1] = '\0';
 	search = stats;
 	cpuCount = 0;
 	while ((search = strstr(search, "\ncpu")) != NULL) {
-	  ++cpuCount;
-	  ++search; // Make sure we don't find the same CPU again!
+		++cpuCount;
+		++search;	// Make sure we don't find the same CPU again!
 	}
 
-        // Decrease result by one, because on a single processor
+	// Decrease result by one, because on a single processor
 	// machine, the code above counts "cpu" and "cpu0"!
 	cpuCount--;
-	return(cpuCount);
+	return (cpuCount);
 }
 
-
-
 //
 // Getting the speed of the processors in Hz. We get this from /proc/cpuinfo.
 // Example output of /proc/cpuinfo:
 //////////////////////////////////////////////////////////////////////
-// processor	: 0
-// vendor_id	: GenuineIntel
-// cpu family	: 6
-// model		: 7
-// model name	: Pentium III (Katmai)
-// stepping	: 3
-// cpu MHz		: 497.845315
-// cache size	: 512 KB
+// processor    : 0
+// vendor_id    : GenuineIntel
+// cpu family   : 6
+// model                : 7
+// model name   : Pentium III (Katmai)
+// stepping     : 3
+// cpu MHz              : 497.845315
+// cache size   : 512 KB
 // ... file continues on ...
 //////////////////////////////////////////////////////////////////////
 // Note: We just take the first CPU we find and return its CPU speed.
@@ -251,11 +242,12 @@
 	FILE *cpuInfo;
 
 	int khz;
+
 	if (kstatfd > 0 && ioctl(kstatfd, IM_IOC_GETCPUKHZ, &khz) >= 0) {
 		cout << "CPU KHZ: " << khz << endl;
-		return (double)khz * 1000.0;
+		return (double)khz *1000.0;
 	}
-	
+
 	cpuInfo = fopen("/proc/cpuinfo", "r");
 	do {
 		fscanf(cpuInfo, "%7c", label);
@@ -264,21 +256,20 @@
 			result *= 1000000.0;
 			fclose(cpuInfo);
 			if (scanDecodes == 1) {
-				return(result);
+				return (result);
 			} else {
 				cerr << "Error determining CPU speed.\n";
-				return(0.0);
+				return (0.0);
 			}
-		}
-		else if (!strncmp(label, "cpu GHz", 7)) {
+		} else if (!strncmp(label, "cpu GHz", 7)) {
 			scanDecodes = fscanf(cpuInfo, "%*s %lf", &result);
 			result *= 1000000000.0;
 			fclose(cpuInfo);
 			if (scanDecodes == 1) {
-				return(result);
+				return (result);
 			} else {
 				cerr << "Error determining CPU speed.\n";
-				return(0.0);
+				return (0.0);
 			}
 		}
 		// Skip to the next line.
@@ -288,31 +279,31 @@
 	} while (c != EOF);
 	fclose(cpuInfo);
 	cerr << "Error determining CPU speed.\n";
-	return(0.0);
+	return (0.0);
 #elif defined(IOMTR_CPU_PPC)
-	#define USEC(tv)	(tv.tv_sec*1000000+tv.tv_usec)
-	
+#define USEC(tv)	(tv.tv_sec*1000000+tv.tv_usec)
+
 	struct timeval tv1, tv2;
 	DWORD t1, t2;
 
 	double result;
 
-	gettimeofday( &tv1, NULL );
+	gettimeofday(&tv1, NULL);
 	t1 = get_tbl();
 	sleep(1);
 	t2 = get_tbl();
-	gettimeofday( &tv2, NULL );
-	
+	gettimeofday(&tv2, NULL);
+
 	result = ((double)(t2 - t1)) * (1000000.0 / (double)(USEC(tv2) - USEC(tv1)));
 
-	return( result );
+	return (result);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-}	
+}
 
-
-void Performance::Get_Perf_Data(DWORD perf_data_type, int snapshot) {
+void Performance::Get_Perf_Data(DWORD perf_data_type, int snapshot)
+{
 	// Get the performance data stored by the system.
 #if _DEBUG
 	cout << "   Getting system performance data." << endl << flush;
@@ -323,8 +314,8 @@
 		// calculate time diff in clock ticks..
 		timediff = (time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
 	}
-	
-	switch (perf_data_type)	{
+
+	switch (perf_data_type) {
 	case PERF_PROCESSOR:
 		Get_CPU_Counters(snapshot);
 		break;
@@ -339,21 +330,21 @@
 	}
 }
 
-
-
 void Performance::Get_CPU_Counters(int snapshot)
 {
-	int	  numScans, c, i;
-	char      tmpBuf[100];
-	__int64   jiffiesCpuNiceUtilization, jiffiesCpuidle, jiffiesCpuiowait, jiffiesCpuirq, jiffiesCpusoftirq;
+	int numScans, c, i;
+	char tmpBuf[100];
+	__int64 jiffiesCpuNiceUtilization, jiffiesCpuidle, jiffiesCpuiowait, jiffiesCpuirq, jiffiesCpusoftirq;
 	FILE *cpuStat;
 	struct cpu_data_type raw_cpu;
-	
+
 	if (kstatfd > 0 && ioctl(kstatfd, IM_IOC_GETCPUDATA, &raw_cpu) >= 0) {
 		for (i = 0; i < processor_count; i++) {
 			raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] = raw_cpu.user_time[i];
 			raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot] = raw_cpu.system_time[i];
-			raw_cpu_data[i][CPU_TOTAL_UTILIZATION][snapshot] = raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] + raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot];
+			raw_cpu_data[i][CPU_TOTAL_UTILIZATION][snapshot] =
+			    raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] +
+			    raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot];
 		}
 		raw_cpu_data[0][CPU_IRQ][snapshot] = raw_cpu.intr;
 		return;
@@ -372,15 +363,17 @@
 		// intr 1896409 1142648 2 0 0 128558 0 0 0 2 0 34836 465132 4 0 91210 34017 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 		// ...
 		// --------------------------------------------------------------------
-		fscanf(cpuStat, "cpu %*s %*s %*s %*s\n");	
-		for(i = 0; i < processor_count; i++) {
+		fscanf(cpuStat, "cpu %*s %*s %*s %*s\n");
+		for (i = 0; i < processor_count; i++) {
 			numScans = fscanf(cpuStat, "%s", tmpBuf);
-			if((numScans == 1) && (strlen(tmpBuf) >= 3) && (strncmp(tmpBuf, "cpu", 3) == 0)) {
-				fscanf(cpuStat, " %lld %lld %lld %*s\n", &raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot],
-									&jiffiesCpuNiceUtilization,
-									&raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot]);
+			if ((numScans == 1) && (strlen(tmpBuf) >= 3) && (strncmp(tmpBuf, "cpu", 3) == 0)) {
+				fscanf(cpuStat, " %lld %lld %lld %*s\n",
+				       &raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot], &jiffiesCpuNiceUtilization,
+				       &raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot]);
 				raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] += jiffiesCpuNiceUtilization;
-				raw_cpu_data[i][CPU_TOTAL_UTILIZATION][snapshot] = raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] + raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot];
+				raw_cpu_data[i][CPU_TOTAL_UTILIZATION][snapshot] =
+				    raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] +
+				    raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot];
 				continue;
 			}
 			do {
@@ -388,16 +381,16 @@
 			} while ((c != '\n') && (c != EOF));
 			break;
 		}
-		for(;;) {
+		for (;;) {
 			numScans = fscanf(cpuStat, "%s", tmpBuf);
-			if((numScans == 1) && (strlen(tmpBuf) == 4) && (strncmp(tmpBuf, "intr", 4) == 0)) {
+			if ((numScans == 1) && (strlen(tmpBuf) == 4) && (strncmp(tmpBuf, "intr", 4) == 0)) {
 				fscanf(cpuStat, " %lld ", &raw_cpu_data[0][CPU_IRQ][snapshot]);
 				break;
-			}		
+			}
 			do {
 				c = getc(cpuStat);
 			} while ((c != '\n') && (c != EOF));
-			if(c == EOF) {
+			if (c == EOF) {
 				break;
 			}
 		}
@@ -409,32 +402,32 @@
 		// intr 6473496 5918277 10963 0 0 0 0 0 7 1 2 0 365055 154381 0 24810 0 0 
 		//...
 		fscanf(cpuStat, "cpu %*s %*s %*s %*s %*s %*s %*s\n");
-		for(i = 0; i < processor_count; i++) {
+		for (i = 0; i < processor_count; i++) {
 			numScans = fscanf(cpuStat, "%s", tmpBuf);
-			if((numScans == 1) && (strlen(tmpBuf) >= 3) && (strncmp(tmpBuf, "cpu", 3) == 0)) {
-				fscanf(cpuStat, " %lld %lld %lld %lld %lld %lld %lld\n", 
-									&raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot],
-									&jiffiesCpuNiceUtilization,
-									&raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot],
-									&jiffiesCpuidle, 
-									&jiffiesCpuiowait, 
-									&jiffiesCpuirq, 
-									&jiffiesCpusoftirq);
+			if ((numScans == 1) && (strlen(tmpBuf) >= 3) && (strncmp(tmpBuf, "cpu", 3) == 0)) {
+				fscanf(cpuStat, " %lld %lld %lld %lld %lld %lld %lld\n",
+				       &raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot],
+				       &jiffiesCpuNiceUtilization,
+				       &raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot],
+				       &jiffiesCpuidle, &jiffiesCpuiowait, &jiffiesCpuirq, &jiffiesCpusoftirq);
 				raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] += jiffiesCpuNiceUtilization;
-				raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot] += jiffiesCpuirq + jiffiesCpusoftirq;
-				raw_cpu_data[i][CPU_TOTAL_UTILIZATION][snapshot] = raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] + raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot];
+				raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot] +=
+				    jiffiesCpuirq + jiffiesCpusoftirq;
+				raw_cpu_data[i][CPU_TOTAL_UTILIZATION][snapshot] =
+				    raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] +
+				    raw_cpu_data[i][CPU_PRIVILEGED_UTILIZATION][snapshot];
 			}
 		}
-		for(;;) {
+		for (;;) {
 			numScans = fscanf(cpuStat, "%s", tmpBuf);
-			if((numScans == 1) && (strlen(tmpBuf) == 4) && (strncmp(tmpBuf, "intr", 4) == 0)) {
+			if ((numScans == 1) && (strlen(tmpBuf) == 4) && (strncmp(tmpBuf, "intr", 4) == 0)) {
 				fscanf(cpuStat, " %lld ", &raw_cpu_data[0][CPU_IRQ][snapshot]);
 				break;
-			}		
+			}
 			do {
 				c = getc(cpuStat);
 			} while ((c != '\n') && (c != EOF));
-			if(c == EOF) {
+			if (c == EOF) {
 				break;
 			}
 		}
@@ -446,25 +439,27 @@
 	fclose(cpuStat);
 }
 
-void Performance::Get_TCP_Counters(int snapshot) 
+void Performance::Get_TCP_Counters(int snapshot)
 {
 	FILE *fp;
 	__int64 insegs, outsegs, retranssegs;
 	struct tcp_data_type raw_tcp;
-	
+
 	if (kstatfd > 0 && ioctl(kstatfd, IM_IOC_GETTCPDATA, &raw_tcp) >= 0) {
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = raw_tcp.retranssegs;
 		return;
 	}
-	
 	// DF: a kind of stupid workable solution. :)
 	fp = fopen("/proc/net/snmp", "r");
 	fscanf(fp, "Ip: %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n");
 	fscanf(fp, "Ip: %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n");
-	fscanf(fp, "Icmp: %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n");
-	fscanf(fp, "Icmp: %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n");
+	fscanf(fp,
+	       "Icmp: %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n");
+	fscanf(fp,
+	       "Icmp: %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n");
 	fscanf(fp, "Tcp: %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n");
-	fscanf(fp, "Tcp: %*s %*s %*s %*s %*s %*s %*s %*s %*s %lld %lld %lld %*s %*s\n", &insegs, &outsegs, &retranssegs);
+	fscanf(fp, "Tcp: %*s %*s %*s %*s %*s %*s %*s %*s %*s %lld %lld %lld %*s %*s\n", &insegs, &outsegs,
+	       &retranssegs);
 	raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = retranssegs;
 	fclose(fp);
 }
@@ -472,39 +467,38 @@
 //
 // Calculating CPU statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_CPU_Stats( CPU_Results *cpu_results )
+void Performance::Calculate_CPU_Stats(CPU_Results * cpu_results)
 {
-	int		cpu, stat;		// Loop control variables.
+	int cpu, stat;		// Loop control variables.
 
 	// Loop though all CPUs and determine various utilization statistics.
 	cpu_results->count = processor_count;
-	for ( cpu = 0; cpu < processor_count; cpu++ )
-	{
+	for (cpu = 0; cpu < processor_count; cpu++) {
 		// Loop through the counters and calculate performance.
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		{
-			#if PERFORMANCE_DETAILS
-				cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
-			#endif
+		for (stat = 0; stat < CPU_RESULTS; stat++) {
+#if PERFORMANCE_DETAILS
+			cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
+#endif
 
 			double result;
-			if (stat == CPU_IRQ)
-			{
+
+			if (stat == CPU_IRQ) {
 				// we have to calculate Interrupts/sec.
 				// This is similar to calculating Network packets per second
 				// but we are more fortunate here.
 				// See the corresponding Notes at the end of this file for a description.
 				//
-				result = ((double) raw_cpu_data[cpu][stat][LAST_SNAPSHOT] - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) * clock_tick / timediff;
+				result =
+				    ((double)raw_cpu_data[cpu][stat][LAST_SNAPSHOT] -
+				     raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) * clock_tick / timediff;
 				cpu_results->CPU_utilization[cpu][stat] = result;
-			}
-			else
-			{
+			} else {
 				// All other CPU statistics.
-				result = ((double) raw_cpu_data[cpu][stat][LAST_SNAPSHOT] - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / timediff;
+				result =
+				    ((double)raw_cpu_data[cpu][stat][LAST_SNAPSHOT] -
+				     raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / timediff;
 
-				if (result < 0.0) 
-				{
+				if (result < 0.0) {
 					result = 0.0;
 					//
 					// CPU Utilization figures are outside valid range far too often.
@@ -514,50 +508,44 @@
 					//
 					// cout << "***** Error : CPU utilization outside valid timerange 0% - 100% *****" << endl;
 				}
-				if  (result > 1.0)
-				{
+				if (result > 1.0) {
 					result = 1.0;
 				}
 
 				cpu_results->CPU_utilization[cpu][stat] = (result * 100);
 			}
 
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "CPU " << cpu << " recorded stat " << stat << " = " 
-					<< cpu_results->CPU_utilization[cpu][stat] << endl;
-			#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "CPU " << cpu << " recorded stat " << stat << " = "
+			    << cpu_results->CPU_utilization[cpu][stat] << endl;
+#endif
 		}
 	}
 }
 
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_TCP_Stats( Net_Results *net_results )
+void Performance::Calculate_TCP_Stats(Net_Results * net_results)
 {
-	int		stat;		// Loop control variable.
+	int stat;		// Loop control variable.
 
 	// Loop through the counters and calculate performance.
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
-	{
+	for (stat = 0; stat < TCP_RESULTS; stat++) {
 		// If we've never set the counter offsets, then we've never successfully retrieved
 		// the performance data.  Set all of the values to 0.
 		double result;
-		result = ((double) raw_tcp_data[stat][LAST_SNAPSHOT] - 
-			raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
-		result *= clock_tick;		// note that timediff is in CLK_TCKs and not seconds
+
+		result = ((double)raw_tcp_data[stat][LAST_SNAPSHOT] - raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
+		result *= clock_tick;	// note that timediff is in CLK_TCKs and not seconds
 		net_results->tcp_stats[stat] = result;
 
-		#if PERFORMANCE_DETAILS || _DETAILS
-			cout << "TCP recorded stat " << stat << " = " 
-				<< net_results->tcp_stats[stat] << endl;
-		#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+		cout << "TCP recorded stat " << stat << " = " << net_results->tcp_stats[stat] << endl;
+#endif
 	}
 }
 
-
 //
 // Extracting counters for NT network interface performance data. This is done
 // by reading the file "/proc/net/dev". WARNING: This file changes from one
@@ -576,12 +564,13 @@
 // Updated: This file is same from 2.4 to 2.6 kernel. so should works at most of the time.
 #define NET_IF_TO_IGNORE "ians"
 
-void Performance::Get_NI_Counters(int snapshot) {
+void Performance::Get_NI_Counters(int snapshot)
+{
 	int c, scanCount, packetIn, packetOut;
 	char ifname[32];
 	FILE *netInfo;
 	struct ni_data_type raw_net;
-	
+
 	if (kstatfd > 0 && ioctl(kstatfd, IM_IOC_GETNIDATA, &raw_net) >= 0) {
 		for (network_interfaces = 0; network_interfaces < MAX_NUM_INTERFACES; network_interfaces++) {
 			raw_ni_data[network_interfaces][NI_IN_ERRORS][snapshot] = raw_net.in_err[network_interfaces];
@@ -600,34 +589,27 @@
 			c = getc(netInfo);
 		} while ((c != '\n') && (c != EOF));
 	}
-	for (network_interfaces = 0;
-			 network_interfaces < MAX_NUM_INTERFACES;
-			 ++network_interfaces) {
+	for (network_interfaces = 0; network_interfaces < MAX_NUM_INTERFACES; ++network_interfaces) {
 		// grab the interface names (if there are leading blanks,
 		// then they are removed using the Strip() function)
-		scanCount = fscanf(netInfo, "%[^:]: %*d %d %lld %*d %*d %*d %*d %*d %*d %d %lld",ifname,
-											 &packetIn,
-											 &raw_ni_data[network_interfaces]
-											             [NI_IN_ERRORS][snapshot],
-											 &packetOut,
-											 &raw_ni_data[network_interfaces]
-											             [NI_OUT_ERRORS][snapshot]);
+		scanCount = fscanf(netInfo, "%[^:]: %*d %d %lld %*d %*d %*d %*d %*d %*d %d %lld", ifname,
+				   &packetIn, &raw_ni_data[network_interfaces]
+				   [NI_IN_ERRORS][snapshot], &packetOut, &raw_ni_data[network_interfaces]
+				   [NI_OUT_ERRORS][snapshot]);
 		if (scanCount == EOF) {
 			fclose(netInfo);
 			return;
 		}
 		Strip(ifname);
-		if(strstr(NET_IF_TO_IGNORE,ifname) != NULL) {
-			#ifdef _DEBUG
-				cout << "Ignoring network interface: " << ifname << endl;
-			#endif
+		if (strstr(NET_IF_TO_IGNORE, ifname) != NULL) {
+#ifdef _DEBUG
+			cout << "Ignoring network interface: " << ifname << endl;
+#endif
 			// We are supposed to ignore this interface so...
 			network_interfaces--;
-		}
-		else {
+		} else {
 			assert(scanCount == 5);
-			raw_ni_data[network_interfaces][NI_PACKETS][snapshot] =
-				packetIn + packetOut;
+			raw_ni_data[network_interfaces][NI_PACKETS][snapshot] = packetIn + packetOut;
 		}
 		// Skip to the next line.
 		do {
@@ -637,27 +619,24 @@
 	fclose(netInfo);
 }
 
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_NI_Stats( Net_Results *net_results )
+void Performance::Calculate_NI_Stats(Net_Results * net_results)
 {
-	int		net, stat;		// Loop control variables.
+	int net, stat;		// Loop control variables.
 
 	// Loop through the counters and calculate performance.
 	net_results->ni_count = network_interfaces;
-	for ( net = 0; net < network_interfaces; net++ )
-	{
-		for ( stat = 0; stat < NI_RESULTS; stat++ )
-		{
+	for (net = 0; net < network_interfaces; net++) {
+		for (stat = 0; stat < NI_RESULTS; stat++) {
 			// If we've never set the counter offsets, then we've never successfully retrieved
 			// the performance data.  Set all of the values to 0.
 			double result;
+
 			//
 			// Note:
-			//		The array time_counter[] stores time in nanoseconds.
+			//              The array time_counter[] stores time in nanoseconds.
 			// Earlier, we used to divide by the calculated value of timediff and then
 			// multiply the result by clock_ticks per second to get the NI_data per
 			// second which was theoretically correct (and mathematically same as what 
@@ -665,21 +644,21 @@
 			// large numbers.
 			//
 			//result = ((double) raw_ni_data[net][stat][LAST_SNAPSHOT] - 
-			//	raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 / 
-			//	((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
-			
+			//      raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 / 
+			//      ((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
+
 			// DF: I think the time_counter do not use nanoseconds but clock_tick
-			result = ((double) raw_ni_data[net][stat][LAST_SNAPSHOT] - 
-				raw_ni_data[net][stat][FIRST_SNAPSHOT]) * clock_tick / timediff;
+			result = ((double)raw_ni_data[net][stat][LAST_SNAPSHOT] -
+				  raw_ni_data[net][stat][FIRST_SNAPSHOT]) * clock_tick / timediff;
 
 			net_results->ni_stats[net][stat] = result;
 
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "   Network interface " << net << " recorded stat " << stat << " = " 
-					<< net_results->ni_stats[net][stat] << endl;
-			#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "   Network interface " << net << " recorded stat " << stat << " = "
+			    << net_results->ni_stats[net][stat] << endl;
+#endif
 		}
 	}
 }
 
-#endif /* LINUX */
+#endif				/* LINUX */

Modified: branches/IOMETER-restruct/iometer/src/IOPerformanceNetware.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPerformanceNetware.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPerformanceNetware.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,7 +60,7 @@
 /* ##               - Initial code.                                       ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
-#define PERFORMANCE_DETAILS	0 // Turn on to display additional performance messages.
+#define PERFORMANCE_DETAILS	0	// Turn on to display additional performance messages.
 #if defined(IOMTR_OS_NETWARE)
 
 #include <assert.h>
@@ -70,7 +70,7 @@
 //
 // Initializing system performance data.
 //
-Performance::Performance() 
+Performance::Performance()
 {
 	// Obtaining the number of CPUs in the system and their speed.
 	processor_count = Get_Processor_Count();
@@ -82,31 +82,27 @@
 
 	if (!processor_speed || !processor_count) {
 		cout << "*** Unable to initialize needed performance data.\n"
-				 << "This error may indicate that you are trying to run on an\n"
-				 << "unsupported processor or OS.  See the Iometer User's Guide for\n"
-				 << "information on supported platforms.\n";
-		exit(1);	}
-
-        // Set the clock ticks per second
+		    << "This error may indicate that you are trying to run on an\n"
+		    << "unsupported processor or OS.  See the Iometer User's Guide for\n"
+		    << "information on supported platforms.\n";
+		exit(1);
+	}
+	// Set the clock ticks per second
 	clock_tick = GetTimerMinorTicksPerSecond();
-	
+
 	// Initialize all the arrays to 0.
 	memset(raw_cpu_data, 0, (MAX_CPUS * CPU_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
-	memset(raw_ni_data,  0, (MAX_NUM_INTERFACES * NI_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
+	memset(raw_ni_data, 0, (MAX_NUM_INTERFACES * NI_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
 	memset(raw_tcp_data, 0, (TCP_RESULTS * MAX_SNAPSHOTS * sizeof(_int64)));
 }
 
-
-
 //
 // Freeing memory used by class object.
 //
-Performance::~Performance() 
+Performance::~Performance()
 {
 }
 
-
-
 //
 // Getting the number of processors in the system.
 //
@@ -115,40 +111,37 @@
 	return NXGetCpuCount();
 }
 
-
 // Note: We just take the first CPU we find and return its CPU speed.
 double Performance::Get_Processor_Speed()
 {
 	double speed = 0.0;
 	struct cpu_info info;
 	int seq = 0;
-	
-	netware_cpu_info(&info,&seq);
-	speed = (double)(info.Speed * 1000000.0); // in MHz
 
- 	return speed;
-}	
+	netware_cpu_info(&info, &seq);
+	speed = (double)(info.Speed * 1000000.0);	// in MHz
 
+	return speed;
+}
 
-void Performance::Get_Perf_Data(DWORD perf_data_type, int snapshot) 
+void Performance::Get_Perf_Data(DWORD perf_data_type, int snapshot)
 {
 	NXTime_t NXTime;
+
 	// Get the performance data stored by the system.
 #ifdef _DEBUG
 	cout << "   Getting system performance data." << endl << flush;
 #endif
 
-//	NXGetTime(NX_SINCE_BOOT, NX_MSECONDS, &NXTime); //NX_TICKS
-	NXGetTime(NX_SINCE_BOOT, NX_NSECONDS, &NXTime); //NX_NSECONDS
-	time_counter[snapshot] = (__int64)NXTime;
-	if (snapshot == LAST_SNAPSHOT) 
-	{
+//      NXGetTime(NX_SINCE_BOOT, NX_MSECONDS, &NXTime); //NX_TICKS
+	NXGetTime(NX_SINCE_BOOT, NX_NSECONDS, &NXTime);	//NX_NSECONDS
+	time_counter[snapshot] = (__int64) NXTime;
+	if (snapshot == LAST_SNAPSHOT) {
 		// calculate time diff in clock ticks..
 		timediff = (time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
 	}
-	
-	switch (perf_data_type)	
-	{
+
+	switch (perf_data_type) {
 	case PERF_PROCESSOR:
 		Get_CPU_Counters(snapshot);
 		break;
@@ -163,70 +156,65 @@
 	}
 }
 
-
-
 void Performance::Get_CPU_Counters(int snapshot)
 {
 	int i, j;
 
-	for(i = j = 0; i < processor_count; i++) 
-	{
-		netware_cpu_info(&info, &j);   // j is auto-incremented by the call itself 
-		raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot]  = info.ProcessorUtilization;
+	for (i = j = 0; i < processor_count; i++) {
+		netware_cpu_info(&info, &j);	// j is auto-incremented by the call itself 
+		raw_cpu_data[i][CPU_USER_UTILIZATION][snapshot] = info.ProcessorUtilization;
 		raw_cpu_data[i][CPU_TOTAL_UTILIZATION][snapshot] = info.ProcessorUtilization;
 		raw_cpu_data[i][CPU_IRQ][snapshot] = 1000;
 	}
 }
 
-void Performance::Get_TCP_Counters(int snapshot) 
+void Performance::Get_TCP_Counters(int snapshot)
 {
-	long rc=0;
+	long rc = 0;
 	LONG blkNumber = 0;
-	typedef struct CommonLANStructure
-	{
-	   LONG  notSupportedMask;
-	   LONG  TotalTxPacketCount;
-	   LONG  TotalRxPacketCount;
-	   LONG  NoECBAvailableCount;
-	   LONG  PacketTxTooBigCount;
-	   LONG  PacketTxTooSmallCount;
-	   LONG  PacketRxOverflowCount;
-	   LONG  PacketRxTooBigCount;
-	   LONG  PacketRxTooSmallCount;
-	   LONG  PacketTxMiscErrorCount;
-	   LONG  PacketRxMiscErrorCount;
-	   LONG  RetryTxCount;
-	   LONG  ChecksumErrorCount;
-	   LONG  HardwareRxMismatchCount;
-	   /* to here */
-	   LONG  TotalTxOKByteCountLow;
-	   LONG  TotalTxOKByteCountHigh;
-	   LONG  TotalRxOKByteCountLow;
-	   LONG  TotalRxOKByteCountHigh;
-	   LONG  TotalGroupAddrTxCount;
-	   LONG  TotalGroupAddrRxCount;
-	   LONG  AdapterResetCount;
-	   LONG  AdapterOprTimeStamp;
-	   LONG  AdapterQueDepth;
-	   LONG  MediaSpecificCounter1;
-	   LONG  MediaSpecificCounter2;
-	   LONG  MediaSpecificCounter3;
-	   LONG  MediaSpecificCounter4;
-	   LONG  MediaSpecificCounter5;
-	   LONG  MediaSpecificCounter6;
-	   LONG  MediaSpecificCounter7;
-	   LONG  MediaSpecificCounter8;
-	   LONG  MediaSpecificCounter9;
-	   LONG  MediaSpecificCounter10;
-	   LONG  ValidMask1;
-	   LONG  MediaSpecificCounter11;
-	   LONG  MediaSpecificCounter12;
-	   LONG  MediaSpecificCounter13;
-	   LONG  MediaSpecificCounter14;
-	}CommonLANStructure;
+	typedef struct CommonLANStructure {
+		LONG notSupportedMask;
+		LONG TotalTxPacketCount;
+		LONG TotalRxPacketCount;
+		LONG NoECBAvailableCount;
+		LONG PacketTxTooBigCount;
+		LONG PacketTxTooSmallCount;
+		LONG PacketRxOverflowCount;
+		LONG PacketRxTooBigCount;
+		LONG PacketRxTooSmallCount;
+		LONG PacketTxMiscErrorCount;
+		LONG PacketRxMiscErrorCount;
+		LONG RetryTxCount;
+		LONG ChecksumErrorCount;
+		LONG HardwareRxMismatchCount;
+		/* to here */
+		LONG TotalTxOKByteCountLow;
+		LONG TotalTxOKByteCountHigh;
+		LONG TotalRxOKByteCountLow;
+		LONG TotalRxOKByteCountHigh;
+		LONG TotalGroupAddrTxCount;
+		LONG TotalGroupAddrRxCount;
+		LONG AdapterResetCount;
+		LONG AdapterOprTimeStamp;
+		LONG AdapterQueDepth;
+		LONG MediaSpecificCounter1;
+		LONG MediaSpecificCounter2;
+		LONG MediaSpecificCounter3;
+		LONG MediaSpecificCounter4;
+		LONG MediaSpecificCounter5;
+		LONG MediaSpecificCounter6;
+		LONG MediaSpecificCounter7;
+		LONG MediaSpecificCounter8;
+		LONG MediaSpecificCounter9;
+		LONG MediaSpecificCounter10;
+		LONG ValidMask1;
+		LONG MediaSpecificCounter11;
+		LONG MediaSpecificCounter12;
+		LONG MediaSpecificCounter13;
+		LONG MediaSpecificCounter14;
+	} CommonLANStructure;
 
-	typedef struct GetLANCommonCountersStructure
-	{
+	typedef struct GetLANCommonCountersStructure {
 		LONG currentServerTime;
 		BYTE vConsoleVersion;
 		BYTE vConsoleRevision;
@@ -240,155 +228,146 @@
 	} GetLANCommonCountersStructure;
 	GetLANCommonCountersStructure lanInfo;
 
-	for (network_interfaces = 1; network_interfaces < MAX_NUM_INTERFACES; network_interfaces++) 
-	{
+	for (network_interfaces = 1; network_interfaces < MAX_NUM_INTERFACES; network_interfaces++) {
 		blkNumber = 0;
-//		while(1)
-		if ((rc=SSGetLANCommonCounters((LONG)network_interfaces, blkNumber, (BYTE *)&lanInfo, sizeof(GetLANCommonCountersStructure))) == 0)
-		{
+//              while(1)
+		if ((rc =
+		     SSGetLANCommonCounters((LONG) network_interfaces, blkNumber, (BYTE *) & lanInfo,
+					    sizeof(GetLANCommonCountersStructure))) == 0) {
 			raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = lanInfo.info.RetryTxCount;
 
-//			if (lanInfo.nextCntBlock == 0)
-//				break;
-//			else
-//				blkNumber = lanInfo.nextCntBlock;
-		}
-		else
-		{
-  //			cout << "Performance::Get_TCP_Counters: Error (" << rc << ") in getting stats on board " << network_interfaces << endl;
+//                      if (lanInfo.nextCntBlock == 0)
+//                              break;
+//                      else
+//                              blkNumber = lanInfo.nextCntBlock;
+		} else {
+			//                    cout << "Performance::Get_TCP_Counters: Error (" << rc << ") in getting stats on board " << network_interfaces << endl;
 			break;
 		}
-//		if (rc != 0) break;
+//              if (rc != 0) break;
 	}
 }
 
-
-
 //
 // Calculating CPU statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_CPU_Stats( CPU_Results *cpu_results )
+void Performance::Calculate_CPU_Stats(CPU_Results * cpu_results)
 {
-	int		cpu, stat;		// Loop control variables.
+	int cpu, stat;		// Loop control variables.
 
 	// Loop though all CPUs and determine various utilization statistics.
 	cpu_results->count = processor_count;
-	for ( cpu = 0; cpu < processor_count; cpu++ )
-	{
+	for (cpu = 0; cpu < processor_count; cpu++) {
 		// Loop through the counters and calculate performance.
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		{
-			#if PERFORMANCE_DETAILS
-				cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
-			#endif
+		for (stat = 0; stat < CPU_RESULTS; stat++) {
+#if PERFORMANCE_DETAILS
+			cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
+#endif
 
 			double result;
-			if (stat == CPU_IRQ)
-			{
+
+			if (stat == CPU_IRQ) {
 				// we have to calculate Interrupts/sec.
 				// This is similar to calculating Network packets per second
 				// but we are more fortunate here.
 				// See the corresponding Notes at the end of this file for a description.
 				//
-				result = (double) ((raw_cpu_data[cpu][stat][LAST_SNAPSHOT] + raw_cpu_data[cpu][stat][FIRST_SNAPSHOT])/2.0);
+				result =
+				    (double)((raw_cpu_data[cpu][stat][LAST_SNAPSHOT] +
+					      raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / 2.0);
 				cpu_results->CPU_utilization[cpu][stat] = result;
-			}
-			else
-			{
+			} else {
 				// All other CPU statistics.
-				cpu_results->CPU_utilization[cpu][stat] = (double) ((raw_cpu_data[cpu][stat][LAST_SNAPSHOT] + raw_cpu_data[cpu][stat][FIRST_SNAPSHOT])/2);
+				cpu_results->CPU_utilization[cpu][stat] =
+				    (double)((raw_cpu_data[cpu][stat][LAST_SNAPSHOT] +
+					      raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / 2);
 			}
 
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "CPU " << cpu << " recorded stat " << stat << " = " 
-					<< (long long)cpu_results->CPU_utilization[cpu][stat] << endl;
-			#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "CPU " << cpu << " recorded stat " << stat << " = "
+			    << (long long)cpu_results->CPU_utilization[cpu][stat] << endl;
+#endif
 		}
 	}
 }
 
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_TCP_Stats( Net_Results *net_results )
+void Performance::Calculate_TCP_Stats(Net_Results * net_results)
 {
-	int		stat;		// Loop control variable.
+	int stat;		// Loop control variable.
 
 	// Loop through the counters and calculate performance.
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
-	{
+	for (stat = 0; stat < TCP_RESULTS; stat++) {
 		// If we've never set the counter offsets, then we've never successfully retrieved
 		// the performance data.  Set all of the values to 0.
 		double result;
-		result = ((double) raw_tcp_data[stat][LAST_SNAPSHOT] - 
-				raw_tcp_data[stat][FIRST_SNAPSHOT]) * 1000000000.0 / 
-				((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
 
-//		result = ((double) raw_tcp_data[stat][LAST_SNAPSHOT] - raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
-//		result *= clock_tick;		// note that timediff is in CLK_TCKs and not seconds
+		result = ((double)raw_tcp_data[stat][LAST_SNAPSHOT] -
+			  raw_tcp_data[stat][FIRST_SNAPSHOT]) * 1000000000.0 /
+		    ((double)time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
+
+//              result = ((double) raw_tcp_data[stat][LAST_SNAPSHOT] - raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
+//              result *= clock_tick;           // note that timediff is in CLK_TCKs and not seconds
 		net_results->tcp_stats[stat] = result;
 
-		#if PERFORMANCE_DETAILS || _DETAILS
-			cout << "TCP recorded stat " << stat << " = " << net_results->tcp_stats[stat] << endl;
-		#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+		cout << "TCP recorded stat " << stat << " = " << net_results->tcp_stats[stat] << endl;
+#endif
 	}
 }
 
-
 //
 // Extracting counters for NT network interface performance data. This is done
 //////////////////////////////////////////////////////////////////////
 #define NET_IF_TO_IGNORE "ians"
 
-void Performance::Get_NI_Counters(int snapshot) 
+void Performance::Get_NI_Counters(int snapshot)
 {
-	typedef struct CommonLANStructure
-	{
-	   LONG  notSupportedMask;
-	   LONG  TotalTxPacketCount;
-	   LONG  TotalRxPacketCount;
-	   LONG  NoECBAvailableCount;
-	   LONG  PacketTxTooBigCount;
-	   LONG  PacketTxTooSmallCount;
-	   LONG  PacketRxOverflowCount;
-	   LONG  PacketRxTooBigCount;
-	   LONG  PacketRxTooSmallCount;
-	   LONG  PacketTxMiscErrorCount;
-	   LONG  PacketRxMiscErrorCount;
-	   LONG  RetryTxCount;
-	   LONG  ChecksumErrorCount;
-	   LONG  HardwareRxMismatchCount;
-	   /* to here*/
-	   LONG  TotalTxOKByteCountLow;
-	   LONG  TotalTxOKByteCountHigh;
-	   LONG  TotalRxOKByteCountLow;
-	   LONG  TotalRxOKByteCountHigh;
-	   LONG  TotalGroupAddrTxCount;
-	   LONG  TotalGroupAddrRxCount;
-	   LONG  AdapterResetCount;
-	   LONG  AdapterOprTimeStamp;
-	   LONG  AdapterQueDepth;
-	   LONG  MediaSpecificCounter1;
-	   LONG  MediaSpecificCounter2;
-	   LONG  MediaSpecificCounter3;
-	   LONG  MediaSpecificCounter4;
-	   LONG  MediaSpecificCounter5;
-	   LONG  MediaSpecificCounter6;
-	   LONG  MediaSpecificCounter7;
-	   LONG  MediaSpecificCounter8;
-	   LONG  MediaSpecificCounter9;
-	   LONG  MediaSpecificCounter10;
-	   LONG  ValidMask1;
-	   LONG  MediaSpecificCounter11;
-	   LONG  MediaSpecificCounter12;
-	   LONG  MediaSpecificCounter13;
-	   LONG  MediaSpecificCounter14;
-	}CommonLANStructure;
+	typedef struct CommonLANStructure {
+		LONG notSupportedMask;
+		LONG TotalTxPacketCount;
+		LONG TotalRxPacketCount;
+		LONG NoECBAvailableCount;
+		LONG PacketTxTooBigCount;
+		LONG PacketTxTooSmallCount;
+		LONG PacketRxOverflowCount;
+		LONG PacketRxTooBigCount;
+		LONG PacketRxTooSmallCount;
+		LONG PacketTxMiscErrorCount;
+		LONG PacketRxMiscErrorCount;
+		LONG RetryTxCount;
+		LONG ChecksumErrorCount;
+		LONG HardwareRxMismatchCount;
+		/* to here */
+		LONG TotalTxOKByteCountLow;
+		LONG TotalTxOKByteCountHigh;
+		LONG TotalRxOKByteCountLow;
+		LONG TotalRxOKByteCountHigh;
+		LONG TotalGroupAddrTxCount;
+		LONG TotalGroupAddrRxCount;
+		LONG AdapterResetCount;
+		LONG AdapterOprTimeStamp;
+		LONG AdapterQueDepth;
+		LONG MediaSpecificCounter1;
+		LONG MediaSpecificCounter2;
+		LONG MediaSpecificCounter3;
+		LONG MediaSpecificCounter4;
+		LONG MediaSpecificCounter5;
+		LONG MediaSpecificCounter6;
+		LONG MediaSpecificCounter7;
+		LONG MediaSpecificCounter8;
+		LONG MediaSpecificCounter9;
+		LONG MediaSpecificCounter10;
+		LONG ValidMask1;
+		LONG MediaSpecificCounter11;
+		LONG MediaSpecificCounter12;
+		LONG MediaSpecificCounter13;
+		LONG MediaSpecificCounter14;
+	} CommonLANStructure;
 
-	typedef struct GetLANCommonCountersStructure
-	{
+	typedef struct GetLANCommonCountersStructure {
 		LONG currentServerTime;
 		BYTE vConsoleVersion;
 		BYTE vConsoleRevision;
@@ -405,74 +384,70 @@
 	long rc;
 	GetLANCommonCountersStructure lanInfo;
 
-	for (network_interfaces = 1; network_interfaces < MAX_NUM_INTERFACES; network_interfaces++) 
-	{
+	for (network_interfaces = 1; network_interfaces < MAX_NUM_INTERFACES; network_interfaces++) {
 		blkNumber = 0;
-//		while(1)
-		if ((rc=SSGetLANCommonCounters((LONG)network_interfaces, blkNumber, (BYTE *)&lanInfo, sizeof(GetLANCommonCountersStructure))) == 0)
-		{
+//              while(1)
+		if ((rc =
+		     SSGetLANCommonCounters((LONG) network_interfaces, blkNumber, (BYTE *) & lanInfo,
+					    sizeof(GetLANCommonCountersStructure))) == 0) {
 			raw_ni_data[network_interfaces][NI_IN_ERRORS][snapshot] = lanInfo.info.PacketRxMiscErrorCount;
 			raw_ni_data[network_interfaces][NI_OUT_ERRORS][snapshot] = lanInfo.info.PacketTxMiscErrorCount;
-			raw_ni_data[network_interfaces][NI_PACKETS][snapshot] = (lanInfo.info.TotalRxPacketCount + lanInfo.info.TotalTxPacketCount);
+			raw_ni_data[network_interfaces][NI_PACKETS][snapshot] =
+			    (lanInfo.info.TotalRxPacketCount + lanInfo.info.TotalTxPacketCount);
 
-//			printf("\rGet_NI_Counters: blk:%x PacketRxMiscErrorCount:%x, PacketTxMiscErrorCount:%x, TotalRxPacketCount:%x, TotalTxPacketCount:%x\n", 
-//				lanInfo.nextCntBlock,
-//				lanInfo.info.PacketRxMiscErrorCount, lanInfo.info.PacketTxMiscErrorCount,
-//				lanInfo.info.TotalRxPacketCount, lanInfo.info.TotalTxPacketCount);
+//                      printf("\rGet_NI_Counters: blk:%x PacketRxMiscErrorCount:%x, PacketTxMiscErrorCount:%x, TotalRxPacketCount:%x, TotalTxPacketCount:%x\n", 
+//                              lanInfo.nextCntBlock,
+//                              lanInfo.info.PacketRxMiscErrorCount, lanInfo.info.PacketTxMiscErrorCount,
+//                              lanInfo.info.TotalRxPacketCount, lanInfo.info.TotalTxPacketCount);
 
-//			if (lanInfo.nextCntBlock == 0)
-//				break;
-//			else
-//				blkNumber = lanInfo.nextCntBlock;
-		}
-		else
-		{
-//			cout << "Performance::Get_NI_Counters: Error (" << rc << ") in getting stats on board " << network_interfaces << endl;
+//                      if (lanInfo.nextCntBlock == 0)
+//                              break;
+//                      else
+//                              blkNumber = lanInfo.nextCntBlock;
+		} else {
+//                      cout << "Performance::Get_NI_Counters: Error (" << rc << ") in getting stats on board " << network_interfaces << endl;
 			break;
 		}
-//		if (rc != 0) break;
+//              if (rc != 0) break;
 	}
 }
 
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_NI_Stats( Net_Results *net_results )
+void Performance::Calculate_NI_Stats(Net_Results * net_results)
 {
-	int		net, stat;		// Loop control variables.
+	int net, stat;		// Loop control variables.
 
 	// Loop through the counters and calculate performance.
 	net_results->ni_count = network_interfaces;
-	for ( net = 1; net < network_interfaces; net++ )
-	{
-		for ( stat = 0; stat < NI_RESULTS; stat++ )
-		{
+	for (net = 1; net < network_interfaces; net++) {
+		for (stat = 0; stat < NI_RESULTS; stat++) {
 			// If we've never set the counter offsets, then we've never successfully retrieved
 			// the performance data.  Set all of the values to 0.
 			double result;
+
 			//
 			// Note:
-			//		The array time_counter[] stores time in nanoseconds.
+			//              The array time_counter[] stores time in nanoseconds.
 			// Earlier, we used to divide by the calculated value of timediff and then
 			// multiply the result by clock_ticks per second to get the NI_data per
 			// second which was theoretically correct (and mathematically same as what 
 			// we are doing now) but reported wrong values while working with such 
 			// large numbers.
 			//
-			result = ((double) raw_ni_data[net][stat][LAST_SNAPSHOT] - 
-				raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 / 
-				((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
+			result = ((double)raw_ni_data[net][stat][LAST_SNAPSHOT] -
+				  raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 /
+			    ((double)time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
 
 			net_results->ni_stats[net][stat] = result;
 
-//			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "   Network interface " << net << " recorded stat " << stat << " = " 
-					<< (long long)net_results->ni_stats[net][stat] << endl;
-//			#endif
+//                      #if PERFORMANCE_DETAILS || _DETAILS
+			cout << "   Network interface " << net << " recorded stat " << stat << " = "
+			    << (long long)net_results->ni_stats[net][stat] << endl;
+//                      #endif
 		}
 	}
 }
 
-#endif /* NETWARE */
+#endif				/* NETWARE */

Modified: branches/IOMETER-restruct/iometer/src/IOPerformanceOSX.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPerformanceOSX.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPerformanceOSX.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -56,7 +56,7 @@
 /* ##                - Created                                            ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
- 
+
 #if defined(IOMTR_OS_OSX)
 
 #include "IOPerformance.h"
@@ -83,13 +83,12 @@
 	// performance calls succeed.  Then, set the correct number of interfaces.
 	network_interfaces = 0;
 
-	if ( !processor_speed || !processor_count )
-	{
+	if (!processor_speed || !processor_count) {
 		cout << "*** Unable to initialize needed performance data." << endl
-			<< "This error may indicate that you are trying to run on an unsupported" << endl
-			<< "processor or OS.  See the Iometer User's Guide for information on" << endl
-			<< "supported platforms." << endl;
-		exit( 1 );
+		    << "This error may indicate that you are trying to run on an unsupported" << endl
+		    << "processor or OS.  See the Iometer User's Guide for information on" << endl
+		    << "supported platforms." << endl;
+		exit(1);
 	}
 
 	char *sysctlData = NULL, *sysctlDataEnd, *sysctlDataCurrent;
@@ -122,9 +121,9 @@
 		ifmsg = (struct if_msghdr *)sysctlDataCurrent;
 		if (ifmsg->ifm_type == RTM_IFINFO) {
 			if (!(ifmsg->ifm_flags & IFF_LOOPBACK)) {
-				sdl = (struct sockaddr_dl *)(ifmsg+1);
+				sdl = (struct sockaddr_dl *)(ifmsg + 1);
 				if (sdl->sdl_family == AF_LINK && ifmsg->ifm_flags & IFF_UP) {
-					strncpy(nic_names[network_interfaces],sdl->sdl_data,sdl->sdl_nlen);
+					strncpy(nic_names[network_interfaces], sdl->sdl_data, sdl->sdl_nlen);
 					nic_names[network_interfaces][sdl->sdl_nlen] = '\0';
 					network_interfaces++;
 				}
@@ -150,11 +149,11 @@
 {
 	int i;
 	size_t intsize = sizeof(int);
-	sysctlbyname("hw.ncpu",&i,&intsize,NULL,0);
+
+	sysctlbyname("hw.ncpu", &i, &intsize, NULL, 0);
 	return i;
 }
 
-
 #define SPEED_VALUE_COUNT 117
 //
 // Getting the speed of the processors in Hz.
@@ -167,63 +166,55 @@
 		3060, 3000, 2930, 2900, 2800, 2700, 2660, 2600, 2530,
 		2500, 2400, 2300, 2260, 2200, 2000, 1900, 1800, 1700,
 		1600, 1500, 1400, 1300, 1260, 1200, 1130, 1100, 1060,
-		1000,  980,  975,  966,  950,  940,  933,  920,  910,
-	 	 900,  880,  875,  866,  850,  840,  833,  820,  810,
-		 800,  780,  775,  766,  750,  740,  733,  720,  710,
-		 700,  680,  675,  666,  650,  640,  633,  620,  610,
-		 600,  580,  575,  566,  550,  540,  533,  520,  510,
-		 500,  480,  475,  466,  450,  440,  433,  420,  410,
-		 400,  380,  375,  366,  350,  340,  333,  320,  310,
-		 300,  280,  275,  266,  250,  240,  233,  220,  210,
-		 200,  180,  175,  166,  150,  140,  133,  120,  110,
-		 100,   80,   75,   66,   50,   40,   33,   25,   20 };
+		1000, 980, 975, 966, 950, 940, 933, 920, 910,
+		900, 880, 875, 866, 850, 840, 833, 820, 810,
+		800, 780, 775, 766, 750, 740, 733, 720, 710,
+		700, 680, 675, 666, 650, 640, 633, 620, 610,
+		600, 580, 575, 566, 550, 540, 533, 520, 510,
+		500, 480, 475, 466, 450, 440, 433, 420, 410,
+		400, 380, 375, 366, 350, 340, 333, 320, 310,
+		300, 280, 275, 266, 250, 240, 233, 220, 210,
+		200, 180, 175, 166, 150, 140, 133, 120, 110,
+		100, 80, 75, 66, 50, 40, 33, 25, 20
+	};
 	DWORD speed;
 
 	quad_t freq;
 	size_t intsize = sizeof(quad_t);
 
-	sysctlbyname("hw.cpufrequency",&freq,&intsize,NULL,0);
+	sysctlbyname("hw.cpufrequency", &freq, &intsize, NULL, 0);
 
 	// hw.cpufrequency is in Hz, convert to MHz
 	speed = freq / 1000000;
 
-	for ( int i = 0; i < SPEED_VALUE_COUNT; i++ )
-	{
+	for (int i = 0; i < SPEED_VALUE_COUNT; i++) {
 		// Try to match estimated speed with a known one.
-		if ( ( (int)speed > speed_values[i] - 5 ) && ( (int)speed < speed_values[i] + 5 ) )
-		{
+		if (((int)speed > speed_values[i] - 5) && ((int)speed < speed_values[i] + 5)) {
 			speed = speed_values[i];
-			if ( speed < 1000 )
-			{
+			if (speed < 1000) {
 				cout << "Processor speed: " << speed << " MHz." << endl;
-			}
-			else
-			{
+			} else {
 				cout << "Processor speed: " << speed / 1000.0 << " GHz." << endl;
 			}
-			return (double) (speed * 1000000);
+			return (double)(speed * 1000000);
 		}
 	}
 	// Round the registry value to the nearest 10
-	speed = ( ( speed + 5 ) / 10 ) * 10;
-	if ( speed < 1000 )
-	{
+	speed = ((speed + 5) / 10) * 10;
+	if (speed < 1000) {
 		cout << "Processor speed: " << speed << " MHz." << endl;
-	}
-	else
-	{
+	} else {
 		cout << "Processor speed: " << speed / 1000.0 << " GHz." << endl;
 	}
-	return (double) (speed * 1000000);
+	return (double)(speed * 1000000);
 }
 
-
-void Performance::Get_Perf_Data( DWORD perf_data_type, int snapshot )
+void Performance::Get_Perf_Data(DWORD perf_data_type, int snapshot)
 {
 	// Get the performance data stored by the system.
-	#if _DEBUG
-		cout << "   Getting system performance data." << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "   Getting system performance data." << endl << flush;
+#endif
 
 	AbsoluteTime blah;
 	Nanoseconds s;
@@ -238,10 +229,11 @@
 
 	if (snapshot == LAST_SNAPSHOT)
 		// Calculate time diff in clock ticks..
-		timediff = ((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]) * clock_tick / (double) 1000000000;
+		timediff =
+		    ((double)time_counter[LAST_SNAPSHOT] -
+		     time_counter[FIRST_SNAPSHOT]) * clock_tick / (double)1000000000;
 
-	switch(perf_data_type)
-	{
+	switch (perf_data_type) {
 	case PERF_PROCESSOR:
 		Get_CPU_Counters(snapshot);
 		break;
@@ -256,46 +248,39 @@
 	}
 }
 
-
 //
 // Calculating CPU statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_CPU_Stats( CPU_Results *cpu_results )
+void Performance::Calculate_CPU_Stats(CPU_Results * cpu_results)
 {
-	int		cpu, stat;		// Loop control variables.
+	int cpu, stat;		// Loop control variables.
 
 	// Loop though all CPUs and determine various utilization statistics.
 	cpu_results->count = processor_count;
-	for ( cpu = 0; cpu < processor_count; cpu++ )
-	{
+	for (cpu = 0; cpu < processor_count; cpu++) {
 		// Loop through the counters and calculate performance.
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		{
-			#if PERFORMANCE_DETAILS
-				cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
-			#endif
+		for (stat = 0; stat < CPU_RESULTS; stat++) {
+#if PERFORMANCE_DETAILS
+			cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
+#endif
 
 			double result;
-			if (stat == CPU_IRQ)
-			{
+
+			if (stat == CPU_IRQ) {
 				// we have to calculate Interrupts/sec.
 				// This is similar to calculating Network packets per second
 				// but we are more fortunate here.
 				// See the corresponding Notes at the end of this file for a description.
 				//
-				result = ((double) raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
-						 - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) * 
-						 clock_tick / timediff;
-				cpu_results->CPU_utilization[cpu][stat] = result;	
-			}
-			else
-			{
+				result = ((double)raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
+					  - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) * clock_tick / timediff;
+				cpu_results->CPU_utilization[cpu][stat] = result;
+			} else {
 				// All other CPU statistics.
-				result = ((double) raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
-							- raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / timediff;
+				result = ((double)raw_cpu_data[cpu][stat][LAST_SNAPSHOT]
+					  - raw_cpu_data[cpu][stat][FIRST_SNAPSHOT]) / timediff;
 
-				if (result < 0.0) 
-				{
+				if (result < 0.0) {
 					result = 0.0;
 					//
 					// CPU Utilization figures are outside valid range far too often.
@@ -305,96 +290,82 @@
 					//
 					// cout << "***** Error : CPU utilization outside valid range 0% - 100% *****" << endl;
 				}
-				if  (result > 1.0)
-				{
+				if (result > 1.0) {
 					result = 1.0;
 				}
 
 				cpu_results->CPU_utilization[cpu][stat] = (result * 100);
 			}
 
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "CPU " << cpu << " recorded stat " << stat << " = " 
-					<< cpu_results->CPU_utilization[cpu][stat] << endl;
-			#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "CPU " << cpu << " recorded stat " << stat << " = "
+			    << cpu_results->CPU_utilization[cpu][stat] << endl;
+#endif
 		}
 	}
 }
 
-
-
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_TCP_Stats( Net_Results *net_results )
+void Performance::Calculate_TCP_Stats(Net_Results * net_results)
 {
-	int		stat;		// Loop control variable.
+	int stat;		// Loop control variable.
 
 	// Loop through the counters and calculate performance.
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
-	{
+	for (stat = 0; stat < TCP_RESULTS; stat++) {
 		// If we've never set the counter offsets, then we've never successfully retrieved
 		// the performance data.  Set all of the values to 0.
 		double result;
-		result = ((double) raw_tcp_data[stat][LAST_SNAPSHOT] - 
-			raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
-		result *= clock_tick;		// note that timediff is in CLK_TCKs and not seconds
+
+		result = ((double)raw_tcp_data[stat][LAST_SNAPSHOT] - raw_tcp_data[stat][FIRST_SNAPSHOT]) / timediff;
+		result *= clock_tick;	// note that timediff is in CLK_TCKs and not seconds
 		net_results->tcp_stats[stat] = result;
 
-		#if PERFORMANCE_DETAILS || _DETAILS
-			cout << "TCP recorded stat " << stat << " = " 
-				<< net_results->tcp_stats[stat] << endl;
-		#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+		cout << "TCP recorded stat " << stat << " = " << net_results->tcp_stats[stat] << endl;
+#endif
 	}
 }
 
-
-
-
-
 //
 // Calculate network performance statistics based on snapshots of performance counters.
 //
-void Performance::Calculate_NI_Stats( Net_Results *net_results )
+void Performance::Calculate_NI_Stats(Net_Results * net_results)
 {
-	int		net, stat;		// Loop control variables.
+	int net, stat;		// Loop control variables.
 
 	// Loop through the counters and calculate performance.
 	net_results->ni_count = network_interfaces;
-	for ( net = 0; net < network_interfaces; net++ )
-	{
-		for ( stat = 0; stat < NI_RESULTS; stat++ )
-		{
+	for (net = 0; net < network_interfaces; net++) {
+		for (stat = 0; stat < NI_RESULTS; stat++) {
 			// If we've never set the counter offsets, then we've never successfully retrieved
 			// the performance data.  Set all of the values to 0.
 			double result;
+
 			//
 			// Note:
-			//		The array time_counter[] stores time in nanoseconds.
+			//              The array time_counter[] stores time in nanoseconds.
 			// Earlier, we used to divide by the calculated value of timediff and then
 			// multiply the result by clock_ticks per second to get the NI_data per
 			// second which was theoretically correct (and mathematically same as what 
 			// we are doing now) but reported wrong values while working with such 
 			// large numbers.
 			//
-			result = ((double) raw_ni_data[net][stat][LAST_SNAPSHOT] - 
-				raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 / 
-				((double) time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
+			result = ((double)raw_ni_data[net][stat][LAST_SNAPSHOT] -
+				  raw_ni_data[net][stat][FIRST_SNAPSHOT]) * 1000000000.0 /
+			    ((double)time_counter[LAST_SNAPSHOT] - time_counter[FIRST_SNAPSHOT]);
 
 			net_results->ni_stats[net][stat] = result;
 
-			#if PERFORMANCE_DETAILS || _DETAILS
-				cout << "   Network interface " << net << " recorded stat " << stat << " = " 
-					<< net_results->ni_stats[net][stat] << endl;
-			#endif
+#if PERFORMANCE_DETAILS || _DETAILS
+			cout << "   Network interface " << net << " recorded stat " << stat << " = "
+			    << net_results->ni_stats[net][stat] << endl;
+#endif
 		}
 	}
 }
 
-
-
 void Performance::Get_CPU_Counters(int snapshot)
 {
 	unsigned int current_cpu = 0;
@@ -406,7 +377,7 @@
 
 	host = mach_host_self();
 
-	kr = host_processor_info(host, PROCESSOR_CPU_LOAD_INFO, &procs, (processor_info_array_t *)&load, &load_count);
+	kr = host_processor_info(host, PROCESSOR_CPU_LOAD_INFO, &procs, (processor_info_array_t *) & load, &load_count);
 	if (kr != KERN_SUCCESS) {
 		raw_cpu_data[0][CPU_TOTAL_UTILIZATION][snapshot] = 1;
 		raw_cpu_data[0][CPU_USER_UTILIZATION][snapshot] = 1;
@@ -415,19 +386,17 @@
 		raw_cpu_data[0][CPU_IRQ][snapshot] = 1;
 	} else {
 		for (current_cpu = 0; current_cpu < procs; current_cpu++) {
-			raw_cpu_data[current_cpu][CPU_TOTAL_UTILIZATION][snapshot] = 
-					load[current_cpu].cpu_ticks[CPU_STATE_USER] +
-					load[current_cpu].cpu_ticks[CPU_STATE_SYSTEM] +
-					load[current_cpu].cpu_ticks[CPU_STATE_NICE];
+			raw_cpu_data[current_cpu][CPU_TOTAL_UTILIZATION][snapshot] =
+			    load[current_cpu].cpu_ticks[CPU_STATE_USER] +
+			    load[current_cpu].cpu_ticks[CPU_STATE_SYSTEM] + load[current_cpu].cpu_ticks[CPU_STATE_NICE];
 			raw_cpu_data[current_cpu][CPU_USER_UTILIZATION][snapshot] =
-					load[current_cpu].cpu_ticks[CPU_STATE_USER] +
-					load[current_cpu].cpu_ticks[CPU_STATE_NICE];
+			    load[current_cpu].cpu_ticks[CPU_STATE_USER] + load[current_cpu].cpu_ticks[CPU_STATE_NICE];
 			raw_cpu_data[current_cpu][CPU_PRIVILEGED_UTILIZATION][snapshot] =
-					load[current_cpu].cpu_ticks[CPU_STATE_NICE];
+			    load[current_cpu].cpu_ticks[CPU_STATE_NICE];
 			raw_cpu_data[current_cpu][CPU_IRQ_UTILIZATION][snapshot] = 1;
 			raw_cpu_data[current_cpu][CPU_IRQ][snapshot] = 1;
 		}
-		vm_deallocate(mach_task_self(),(vm_address_t)load,(vm_size_t)(load_count * sizeof(*load)));
+		vm_deallocate(mach_task_self(), (vm_address_t) load, (vm_size_t) (load_count * sizeof(*load)));
 	}
 	return;
 }
@@ -459,7 +428,7 @@
 		return;
 	}
 
-	if (sysctl(mib,6,sysctlData,&sysctlExpectedSize,NULL,0) < 0) {
+	if (sysctl(mib, 6, sysctlData, &sysctlExpectedSize, NULL, 0) < 0) {
 		for (current_nic = 0; current_nic < network_interfaces; current_nic++) {
 			raw_ni_data[current_nic][NI_PACKETS][snapshot] = 1;
 			raw_ni_data[current_nic][NI_ERRORS][snapshot] = 1;
@@ -482,8 +451,10 @@
 				for (current_nic = 0; current_nic < network_interfaces; current_nic++) {
 					if (strcmp(ifname, nic_names[current_nic]))
 						continue;
-					raw_ni_data[current_nic][NI_PACKETS][snapshot] = ifmsg->ifm_data.ifi_ipackets + ifmsg->ifm_data.ifi_opackets;
-					raw_ni_data[current_nic][NI_ERRORS][snapshot] = ifmsg->ifm_data.ifi_ierrors + ifmsg->ifm_data.ifi_oerrors;
+					raw_ni_data[current_nic][NI_PACKETS][snapshot] =
+					    ifmsg->ifm_data.ifi_ipackets + ifmsg->ifm_data.ifi_opackets;
+					raw_ni_data[current_nic][NI_ERRORS][snapshot] =
+					    ifmsg->ifm_data.ifi_ierrors + ifmsg->ifm_data.ifi_oerrors;
 					raw_ni_data[current_nic][NI_IN_ERRORS][snapshot] = ifmsg->ifm_data.ifi_ierrors;
 					break;
 				}

Modified: branches/IOMETER-restruct/iometer/src/IOPort.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPort.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPort.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -80,13 +80,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include "GalileoApp.h"
+#include "GalileoApp.h"
 #endif
 #include "IOPort.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -97,19 +95,18 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 //
 // Constructor and destructor.
 //
 
-Port::Port( BOOL synch )
+Port::Port(BOOL synch)
 {
 	synchronous = synch;
 	name[0] = '\0';
@@ -123,40 +120,37 @@
 Port::~Port()
 {
 	delete errmsg;
-	if ( accept_overlapped.hEvent )
-		CloseHandle( accept_overlapped.hEvent );
-	if ( receive_overlapped.hEvent )
-		CloseHandle( receive_overlapped.hEvent );
-	if ( send_overlapped.hEvent )
-		CloseHandle( send_overlapped.hEvent );
+
+	if (accept_overlapped.hEvent)
+		CloseHandle(accept_overlapped.hEvent);
+	if (receive_overlapped.hEvent)
+		CloseHandle(receive_overlapped.hEvent);
+	if (send_overlapped.hEvent)
+		CloseHandle(send_overlapped.hEvent);
 }
 
-
 // 
 // Determine if an asynchronous operation has completed yet (TRUE = yes, FALSE = no).  Does not block.
 // Utility function called by IsAcceptComplete(), IsReceiveComplete(), and IsSendComplete().
 //
-BOOL Port::IsOperationComplete( OVERLAPPED *olap )
+BOOL Port::IsOperationComplete(OVERLAPPED * olap)
 {
-	if ( synchronous )
-	{
+	if (synchronous) {
 		return TRUE;
 	}
 
-	if ( olap->hEvent )
-	{
+	if (olap->hEvent) {
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		cout << "Async Port objects not supported on UNIX or NetWare" << endl;
 		return FALSE;
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		DWORD d = WaitForSingleObject ( olap->hEvent, 0 );
-		return ( d == WAIT_OBJECT_0 );
+		DWORD d = WaitForSingleObject(olap->hEvent, 0);
+
+		return (d == WAIT_OBJECT_0);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	}
-	else
-	{
+	} else {
 		return FALSE;
 	}
 }
@@ -166,7 +160,7 @@
 //
 BOOL Port::IsAcceptComplete()
 {
-	return ( IsOperationComplete( &accept_overlapped ) );
+	return (IsOperationComplete(&accept_overlapped));
 }
 
 // 
@@ -174,7 +168,7 @@
 //
 BOOL Port::IsReceiveComplete()
 {
-	return ( IsOperationComplete( &receive_overlapped ) );
+	return (IsOperationComplete(&receive_overlapped));
 }
 
 // 
@@ -182,7 +176,7 @@
 //
 BOOL Port::IsSendComplete()
 {
-	return ( IsOperationComplete( &send_overlapped ) );
+	return (IsOperationComplete(&send_overlapped));
 }
 
 //
@@ -191,43 +185,39 @@
 // 
 BOOL Port::InitOverlapped(OVERLAPPED * olap)
 {
-	if ( synchronous )
-	{
+	if (synchronous) {
 		return FALSE;
 	}
 
-	if ( olap->hEvent )
-		CloseHandle( olap->hEvent );
+	if (olap->hEvent)
+		CloseHandle(olap->hEvent);
 
 	// specify the file pointer (meaningless for a pipe or socket, but must be set!)
 	olap->Offset = 0;
 	olap->OffsetHigh = 0;
 
 	// create a manual-reset event object for the OVERLAPPED structure
-	olap->hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
+	olap->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
 
-	if ( olap->hEvent == NULL )
+	if (olap->hEvent == NULL)
 		return FALSE;
 	else
 		return TRUE;
 }
 
-
 //
 // Utility function: output the "errmsg" message in an appropriate manner for the
 // current environment (Dynamo or Iometer).
 //
 void Port::OutputErrMsg()
 {
-	if ( !errmsg )
-	{
+	if (!errmsg) {
 		errmsg = new ostringstream;
 		*errmsg << "Port::OutputErrMsg() called with invalid errmsg value!" << ends;
 	}
-
 #if defined(_GALILEO_)
 	// Iometer
-	ErrorMessage( errmsg->str().c_str() );
+	ErrorMessage(errmsg->str().c_str());
 #else
 	// Dynamo
 	cout << errmsg->str() << endl;
@@ -235,12 +225,13 @@
 
 	// str() returns pointer to buffer and freezes it, we must call freeze(FALSE) to 
 	// unfreeze the buffer before we can delete the object
-        // ---
+	// ---
 	// REMARK: freeze() no longer needed because new are now
 	// using ostringstream instead of ostrstream.
 	//
 	// errmsg->rdbuf()->freeze( FALSE );
-	
+
 	delete errmsg;
+
 	errmsg = new ostringstream;
 }

Modified: branches/IOMETER-restruct/iometer/src/IOPort.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPort.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPort.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -75,9 +75,11 @@
 #define PORT_DEFINED
 
 #ifdef IOMTR_OSFAMILY_WINDOWS
-namespace std {}
+namespace std {
+}
 #endif
 using namespace std;
+
 #include <sstream>
 
 #include "IOCommon.h"
@@ -88,7 +90,6 @@
 // still appear.
 #define PORT_DETAILS	0
 
-
 #define PORT_TYPE_INVALID	0
 #define PORT_TYPE_TCP		1
 
@@ -98,59 +99,55 @@
 
 #define PORT_ERROR			(~(DWORDLONG)0)
 
-class Port
-{
-public:
-	// constructor and destructor	
-	Port( BOOL synchronous = TRUE );
-	virtual	~Port();
+class Port {
+      public:
+	// constructor and destructor   
+	Port(BOOL synchronous = TRUE);
+	virtual ~ Port();
 
 	// public functions common to all Ports (pure virtual, not implemented by Port)
-	virtual	BOOL		Create( char* port_name = NULL, char* remote_name = NULL, 
-					DWORD size = MESSAGE_PORT_SIZE, unsigned short port_number = 0 ) = 0;
-	virtual BOOL		Connect( char* port_name = NULL, 
-							unsigned short port_number = WELL_KNOWN_TCP_PORT ) = 0;
-	virtual BOOL		Accept() = 0;
-	virtual BOOL		Disconnect() = 0;
-	virtual BOOL		Close() = 0;
-	virtual DWORDLONG	Receive( LPVOID data, DWORD size = MESSAGE_SIZE ) = 0;
-	virtual DWORDLONG	Send( LPVOID data, DWORD size = MESSAGE_SIZE ) = 0;
-	virtual DWORD		Peek() = 0;
+	virtual BOOL Create(char *port_name = NULL, char *remote_name = NULL,
+			    DWORD size = MESSAGE_PORT_SIZE, unsigned short port_number = 0) = 0;
+	virtual BOOL Connect(char *port_name = NULL, unsigned short port_number = WELL_KNOWN_TCP_PORT) = 0;
+	virtual BOOL Accept() = 0;
+	virtual BOOL Disconnect() = 0;
+	virtual BOOL Close() = 0;
+	virtual DWORDLONG Receive(LPVOID data, DWORD size = MESSAGE_SIZE) = 0;
+	virtual DWORDLONG Send(LPVOID data, DWORD size = MESSAGE_SIZE) = 0;
+	virtual DWORD Peek() = 0;
 
 	// public functions common to all asynchronous Ports
 	//     (implemented by Port)
-	virtual BOOL		IsAcceptComplete();
-	virtual BOOL		IsReceiveComplete();
-	virtual BOOL		IsSendComplete();
+	virtual BOOL IsAcceptComplete();
+	virtual BOOL IsReceiveComplete();
+	virtual BOOL IsSendComplete();
 	//     (pure virtual, not implemented by Port)
-	virtual BOOL		GetAcceptResult() = 0;
-	virtual DWORDLONG	GetReceiveResult() = 0;
-	virtual DWORDLONG	GetSendResult() = 0;
+	virtual BOOL GetAcceptResult() = 0;
+	virtual DWORDLONG GetReceiveResult() = 0;
+	virtual DWORDLONG GetSendResult() = 0;
 
 	// public data members common to all Ports
-	char				network_name[MAX_NETWORK_NAME];
-	unsigned short		network_port;	// used only by PortTCP (was ignored by PortPipe)
-	int					type; // PORT_TYPE_INVALID or PORT_TYPE_TCP
+	char network_name[MAX_NETWORK_NAME];
+	unsigned short network_port;	// used only by PortTCP (was ignored by PortPipe)
+	int type;		// PORT_TYPE_INVALID or PORT_TYPE_TCP
 
-protected:
+      protected:
 	// private data members common to all Ports
-	BOOL				synchronous;
-	char				name[MAX_NETWORK_NAME];
-	ostringstream			*errmsg;
+	 BOOL synchronous;
+	char name[MAX_NETWORK_NAME];
+	ostringstream *errmsg;
 
 	// private functions common to all Ports (implemented by Port)
-	virtual void		OutputErrMsg();
+	virtual void OutputErrMsg();
 
 	// private functions common to all asynchronous Ports (implemented by Port)
-	virtual BOOL		InitOverlapped( OVERLAPPED *olap );
-	virtual BOOL		IsOperationComplete( OVERLAPPED *olap );
+	virtual BOOL InitOverlapped(OVERLAPPED * olap);
+	virtual BOOL IsOperationComplete(OVERLAPPED * olap);
 
 	// private data members common to all asynchronous Ports
-	OVERLAPPED			accept_overlapped;
-	OVERLAPPED			receive_overlapped;
-	OVERLAPPED			send_overlapped;
+	OVERLAPPED accept_overlapped;
+	OVERLAPPED receive_overlapped;
+	OVERLAPPED send_overlapped;
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOPortTCP.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPortTCP.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPortTCP.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -88,33 +88,30 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <afx.h>
+#include <afx.h>
 #endif
 
 #include "IOPortTCP.h"
 
 #if defined(IOMTR_OS_LINUX)
- #include <sys/time.h>
- #include <sys/types.h>
- #include <unistd.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
 #endif
 
 #if defined(IOMTR_OS_NETWARE)
- #include <sys/select.h>
+#include <sys/select.h>
 #endif
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #if defined(USING_DDK)
-  #include "winsock.h"
- #else
-  #include "mswsock.h"
- #endif
+#if defined(USING_DDK)
+#include "winsock.h"
+#else
+#include "mswsock.h"
 #endif
+#endif
 
-
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -125,15 +122,13 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
-
 //////////////////////////////////////////////////////////////////////
 // Static data member initialization.
 //////////////////////////////////////////////////////////////////////
@@ -144,9 +139,8 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-
-PortTCP::PortTCP( BOOL synch )
-: Port( synch )	// call Port constructor
+PortTCP::PortTCP(BOOL synch)
+:  Port(synch)			// call Port constructor
 {
 	type = PORT_TYPE_TCP;
 
@@ -156,192 +150,170 @@
 	// initialize WinSock -- do this only if it has not yet been initialized in this process
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( sockets_in_use++ == 0 )
-	{
-		#if _DEBUG
-			cout << "Initializing WinSock." << endl << flush;
-		#endif
+	if (sockets_in_use++ == 0) {
+#if _DEBUG
+		cout << "Initializing WinSock." << endl << flush;
+#endif
 
 		int retval;
 		WSADATA wd;
 
 		// request WinSock version 2.0
-		retval = WSAStartup( MAKEWORD(2, 0), &wd ); 
+		retval = WSAStartup(MAKEWORD(2, 0), &wd);
 
-		if ( retval != 0 )
-		{
+		if (retval != 0) {
 			*errmsg << "===> ERROR: Could not initialize WinSock." << endl
-				<< "     [PortTCP::PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     retval = " << retval << ends;
+			    << "     [PortTCP::PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     retval = " << retval << ends;
 			OutputErrMsg();
 		}
 	}
-
 	// The accept_ex_buffer is used in PortTCP::Accept().  We need to provide enough space 
 	// for two addresses plus 16 additional bytes per address (see AcceptEx() documentation).
 	// This data will not be used, but we can't tell AcceptEx() not to give it to us, so
 	// we need to provide the buffer anyway.
-	accept_ex_buffer = new char[ sizeof(struct sockaddr_in) + 16 + sizeof(struct sockaddr_in) + 16 + 1 ];
-#endif // IOMTR_OS_WIN32 || IOMTR_OS_WIN64
+	accept_ex_buffer = new char[sizeof(struct sockaddr_in) + 16 + sizeof(struct sockaddr_in) + 16 + 1];
+#endif				// IOMTR_OS_WIN32 || IOMTR_OS_WIN64
 // Note: synch is not used.
 }
 
 PortTCP::~PortTCP()
 {
-	(void) CloseSocket ( &server_socket, "server" );
-	(void) CloseSocket ( &client_socket, "client" );
+	(void)CloseSocket(&server_socket, "server");
+	(void)CloseSocket(&client_socket, "client");
 
 	// clean up WinSock -- do this only if nobody else is using it in this process
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( sockets_in_use-- == 0 ) 
-	{
-		#if PORT_DETAILS || _DETAILS
-			cout << "Cleaning up WinSock." << endl;
-		#endif
+	if (sockets_in_use-- == 0) {
+#if PORT_DETAILS || _DETAILS
+		cout << "Cleaning up WinSock." << endl;
+#endif
 
-		if ( WSACleanup() != 0 )
-		{
+		if (WSACleanup() != 0) {
 			*errmsg << "===> ERROR: Could not clean up WinSock." << endl
-				<< "     [PortTCP::~PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     return code = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::~PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     return code = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 		}
 	}
 
 	delete accept_ex_buffer;
-#endif // IOMTR_OS_WIN32 || IOMTR_OS_WIN64
+#endif				// IOMTR_OS_WIN32 || IOMTR_OS_WIN64
 }
 
-
 //
 // Creates a TCP socket for communication.  Used by server.
 // "size" argument is ignored, but accepted for compatibility with PortPipe.
 // (PortPipe does no longer exists, but one day there might be an successor)
 //
-BOOL PortTCP::Create( char* port_name, char* remote_name, DWORD size, unsigned short port_number )
-{ 
+BOOL PortTCP::Create(char *port_name, char *remote_name, DWORD size, unsigned short port_number)
+{
 	struct sockaddr_in sin;
 	socklen_t buflen;
 
-	network_port = port_number; // listen at specified port (0 = system assigns port number)
+	network_port = port_number;	// listen at specified port (0 = system assigns port number)
 
-	if ( port_name )
-	{
-		strcpy( name, port_name );
-	}
-	else
-	{
+	if (port_name) {
+		strcpy(name, port_name);
+	} else {
 		// get the unqualified local host name
-		if ( gethostname ( name, MAX_NETWORK_NAME ) == SOCKET_ERROR )
-		{
+		if (gethostname(name, MAX_NETWORK_NAME) == SOCKET_ERROR) {
 			*errmsg << "===> ERROR: Getting local host name failed." << endl
-				<< "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return FALSE;
 		}
 	}
 
-	if ( remote_name )
-	{
-		strcpy( network_name, remote_name );
-	}
-	else
-	{
+	if (remote_name) {
+		strcpy(network_name, remote_name);
+	} else {
 		// get the specified host's first network address
-		struct hostent *hostinfo = gethostbyname ( name );
-		if ( hostinfo == NULL )
-		{
+		struct hostent *hostinfo = gethostbyname(name);
+
+		if (hostinfo == NULL) {
 			*errmsg << "===> ERROR: Getting host name for \"" << name << "\" failed." << endl
-				<< "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return FALSE;
 		}
-		memcpy ( &sin.sin_addr.s_addr, hostinfo->h_addr_list[0], hostinfo->h_length );
-		strncpy ( network_name, inet_ntoa(sin.sin_addr), sizeof(network_name) - 1 );
-	
+		memcpy(&sin.sin_addr.s_addr, hostinfo->h_addr_list[0], hostinfo->h_length);
+		strncpy(network_name, inet_ntoa(sin.sin_addr), sizeof(network_name) - 1);
+
 	}
 
 	//
 	// Create socket.
 	//
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Creating socket." << endl;
-		WSASetLastError( 0 );
-	#endif
+#if PORT_DETAILS || _DETAILS
+	cout << "Creating socket." << endl;
+	WSASetLastError(0);
+#endif
 
-	if ( synchronous )
-	{
-		server_socket = socket( AF_INET, SOCK_STREAM, PF_UNSPEC );
+	if (synchronous) {
+		server_socket = socket(AF_INET, SOCK_STREAM, PF_UNSPEC);
 	}
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	else
-	{
-		server_socket = WSASocket( AF_INET, SOCK_STREAM, PF_UNSPEC, NULL, 0, WSA_FLAG_OVERLAPPED );
+	else {
+		server_socket = WSASocket(AF_INET, SOCK_STREAM, PF_UNSPEC, NULL, 0, WSA_FLAG_OVERLAPPED);
 	}
 #endif
 
-	if ( server_socket == (int)INVALID_SOCKET )
-  	{
+	if (server_socket == (int)INVALID_SOCKET) {
 		*errmsg << "===> ERROR: Creating socket failed." << endl
-			<< "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			<< "     errno = " << WSAGetLastError() << ends;
+		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+		    << "     errno = " << WSAGetLastError() << ends;
 		OutputErrMsg();
 		return FALSE;
 	}
-
 	//
 	// Bind to socket.
 	//
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Binding to socket " << name << "." << endl;
-		WSASetLastError( 0 );
-	#endif
+#if PORT_DETAILS || _DETAILS
+	cout << "Binding to socket " << name << "." << endl;
+	WSASetLastError(0);
+#endif
 
-	sin.sin_family = AF_INET; // use Internet Protocol
-	sin.sin_addr.s_addr = htonl(INADDR_ANY); // listen at any available address
-	sin.sin_port = htons ( network_port ); // listen at specified port (0 = system assigns port number)
+	sin.sin_family = AF_INET;	// use Internet Protocol
+	sin.sin_addr.s_addr = htonl(INADDR_ANY);	// listen at any available address
+	sin.sin_port = htons(network_port);	// listen at specified port (0 = system assigns port number)
 
-	if ( bind ( server_socket, (struct sockaddr *) &sin, sizeof(sin) ) != 0 )
-	{
+	if (bind(server_socket, (struct sockaddr *)&sin, sizeof(sin)) != 0) {
 		*errmsg << "===> ERROR: Binding to socket " << name << " failed." << endl
-			<< "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			<< "     errno = " << WSAGetLastError() << ends;
+		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+		    << "     errno = " << WSAGetLastError() << ends;
 		OutputErrMsg();
 		return FALSE;
 	}
-
 	// get actual port number in use
 	buflen = sizeof(sin);
-	if ( getsockname ( server_socket, (struct sockaddr *) &sin, &buflen ) != 0 )
-	{
+	if (getsockname(server_socket, (struct sockaddr *)&sin, &buflen) != 0) {
 		*errmsg << "===> ERROR: Getting information about server socket failed." << endl
-			<< "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			<< "     errno = " << WSAGetLastError() << ends;
+		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+		    << "     errno = " << WSAGetLastError() << ends;
 		OutputErrMsg();
 		return FALSE;
 	}
-	network_port = ntohs ( sin.sin_port );
+	network_port = ntohs(sin.sin_port);
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Bound server socket on port " << network_port << "." << endl;
-	#endif
+#if PORT_DETAILS || _DETAILS
+	cout << "Bound server socket on port " << network_port << "." << endl;
+#endif
 
 	return TRUE;
 }
 
-
-
 //
 // Connects to an existing port waiting to accept a connection.  Used by client.
 //     port_name is a hostname or a string IP address ("xxx.xxx.xxx.xxx").
 //     port_number is the port number to use at that address.
 //
-BOOL PortTCP::Connect( char* port_name, unsigned short port_number )
+BOOL PortTCP::Connect(char *port_name, unsigned short port_number)
 {
 	unsigned long server_address = INADDR_NONE;
 	struct sockaddr_in sin;
@@ -350,114 +322,99 @@
 
 	// get hostname to connect to (default local host name).
 
-	if ( strlen(port_name) )
-	{
-		strcpy( name, port_name );
-	}
-	else
-	{
-		if ( gethostname ( name, MAX_NETWORK_NAME ) == SOCKET_ERROR )
-		{
+	if (strlen(port_name)) {
+		strcpy(name, port_name);
+	} else {
+		if (gethostname(name, MAX_NETWORK_NAME) == SOCKET_ERROR) {
 			*errmsg << "===> ERROR: Getting local host name failed." << endl
-				<< "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return FALSE;
 		}
 	}
 
-	if ( atoi( name ) > 0 )
-	{
+	if (atoi(name) > 0) {
 		// looks like a numeric IP address was specified
 		// if this is not an IP address (e.g., a name starting with a digit),
-		//	INADDR_NONE (0xffffffff) will be returned.
-		server_address = inet_addr( name );
+		//      INADDR_NONE (0xffffffff) will be returned.
+		server_address = inet_addr(name);
 	}
 
-	
-	if (server_address == INADDR_NONE)
-	{
+	if (server_address == INADDR_NONE) {
 		// treat it as a hostname
-		hostinfo = gethostbyname ( name );
-		if ( hostinfo == NULL )
-		{
+		hostinfo = gethostbyname(name);
+		if (hostinfo == NULL) {
 			*errmsg << "===> ERROR: Getting host information for \"" << name << "\" failed." << endl
-				<< "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return FALSE;
 		}
 
-		memcpy ( &server_address, hostinfo->h_addr, hostinfo->h_length );
+		memcpy(&server_address, hostinfo->h_addr, hostinfo->h_length);
 	}
-
 	// create socket for the connnection.
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Creating socket " << name << "." << endl;
-		WSASetLastError( 0 );
-	#endif
+#if PORT_DETAILS || _DETAILS
+	cout << "Creating socket " << name << "." << endl;
+	WSASetLastError(0);
+#endif
 
-	if ( synchronous )
-	{
-		client_socket = socket( AF_INET, SOCK_STREAM, PF_UNSPEC );
+	if (synchronous) {
+		client_socket = socket(AF_INET, SOCK_STREAM, PF_UNSPEC);
 	}
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	else
-	{
-		client_socket = WSASocket( AF_INET, SOCK_STREAM, PF_UNSPEC, NULL, 0, WSA_FLAG_OVERLAPPED );
+	else {
+		client_socket = WSASocket(AF_INET, SOCK_STREAM, PF_UNSPEC, NULL, 0, WSA_FLAG_OVERLAPPED);
 	}
 #endif
 
-	if ( client_socket == (int)INVALID_SOCKET )
-	{
+	if (client_socket == (int)INVALID_SOCKET) {
 		*errmsg << "===> ERROR: Creating socket failed." << endl
-			<< "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			<< "     errno = " << WSAGetLastError() << ends;
+		    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+		    << "     errno = " << WSAGetLastError() << ends;
 		OutputErrMsg();
 		return FALSE;
 	}
-
 	// specify protocol, port, and address to connect to.
-	
-	sin.sin_family = AF_INET; // use Internet Protocol
-	sin.sin_port = htons(port_number); // connect to this port
-	sin.sin_addr.s_addr = server_address; // connect to this server
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Host address: " << inet_ntoa(sin.sin_addr) << endl;
-	#endif
+	sin.sin_family = AF_INET;	// use Internet Protocol
+	sin.sin_port = htons(port_number);	// connect to this port
+	sin.sin_addr.s_addr = server_address;	// connect to this server
 
+#if PORT_DETAILS || _DETAILS
+	cout << "Host address: " << inet_ntoa(sin.sin_addr) << endl;
+#endif
+
 	// attempt to connect (keep trying forever if necessary).
 
-	do
-	{
-		#if PORT_DETAILS || _DETAILS
-			cout << "Attempting to connect to socket " << name << "." << endl;
-			WSASetLastError( 0 );
-		#endif
+	do {
+#if PORT_DETAILS || _DETAILS
+		cout << "Attempting to connect to socket " << name << "." << endl;
+		WSASetLastError(0);
+#endif
 
-		retval = connect ( client_socket, (struct sockaddr *)&sin, sizeof(sin) );
+		retval = connect(client_socket, (struct sockaddr *)&sin, sizeof(sin));
 
-		if ( retval != 0 )
-		{
-			#if PORT_DETAILS || _DETAILS
-				// WSAECONNREFUSED means the server isn't up yet or is busy,
-				// don't print an error message
+		if (retval != 0) {
+#if PORT_DETAILS || _DETAILS
+			// WSAECONNREFUSED means the server isn't up yet or is busy,
+			// don't print an error message
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-				if ( errno != ECONNREFUSED ) 
+			if (errno != ECONNREFUSED)
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-				if ( WSAGetLastError() != WSAECONNREFUSED ) 
+			if (WSAGetLastError() != WSAECONNREFUSED)
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-				{
-					*errmsg << "===> ERROR: Connecting to socket " << name << " failed." << endl
-						<< "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-						<< "     errno = " << WSAGetLastError() << ends;
-					OutputErrMsg();
-				}
-			#endif
+			{
+				*errmsg << "===> ERROR: Connecting to socket " << name << " failed." << endl
+				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+				    << "     errno = " << WSAGetLastError() << ends;
+				OutputErrMsg();
+			}
+#endif
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 			// According to connect(3XN):
 			//      If connect() fails, the state of the socket
@@ -466,40 +423,36 @@
 			//      create a new socket before attempting to
 			//      reconnect.
 
-			#if PORT_DETAILS || _DETAILS
-				cout << "Re-creating socket " << name << "." << endl;
-				WSASetLastError( 0 );
-			#endif
+#if PORT_DETAILS || _DETAILS
+			cout << "Re-creating socket " << name << "." << endl;
+			WSASetLastError(0);
+#endif
 
-			if ( close ( client_socket ) < 0 )
-			{
+			if (close(client_socket) < 0) {
 				*errmsg << "===> ERROR: Closing socket " << name << " failed." << endl
-					<< "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-					<< "     errno = " << WSAGetLastError() << ends;
+				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+				    << "     errno = " << WSAGetLastError() << ends;
 				OutputErrMsg();
 				return FALSE;
 			}
 
-			if ( (client_socket = socket( AF_INET, SOCK_STREAM, PF_UNSPEC )) 
-				== (int)INVALID_SOCKET )
-			{
+			if ((client_socket = socket(AF_INET, SOCK_STREAM, PF_UNSPEC))
+			    == (int)INVALID_SOCKET) {
 				*errmsg << "===> ERROR: Recreating socket " << name << " failed." << endl
-					<< "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-					<< "     errno = " << WSAGetLastError() << ends;
+				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+				    << "     errno = " << WSAGetLastError() << ends;
 				OutputErrMsg();
 				return FALSE;
 			}
-#endif // IOMTR_OSFAMILY_UNIX
-			Sleep( RETRY_DELAY );
+#endif				// IOMTR_OSFAMILY_UNIX
+			Sleep(RETRY_DELAY);
 		}
 	}
-	while ( retval != 0 );
+	while (retval != 0);
 
 	return TRUE;
 }
 
-
-
 //
 // Begin accepting a connection to an existing port.  Used by server.
 // For synchronous port, blocks until a connection is made (returns TRUE) or an error occurs (returns FALSE).
@@ -512,105 +465,89 @@
 	// Listen to socket.
 	//
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Listening to socket " << name << "." << endl;
-		WSASetLastError( 0 );
-	#endif
+#if PORT_DETAILS || _DETAILS
+	cout << "Listening to socket " << name << "." << endl;
+	WSASetLastError(0);
+#endif
 
-	if ( listen ( server_socket, 0 ) != 0 ) // allow at most one connection at a time
+	if (listen(server_socket, 0) != 0)	// allow at most one connection at a time
 	{
 		*errmsg << "===> ERROR: Listening to socket " << name << " failed." << endl
-			<< "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			<< "     errno = " << WSAGetLastError() << ends;
+		    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+		    << "     errno = " << WSAGetLastError() << ends;
 		OutputErrMsg();
 		return FALSE;
 	}
-
 	//
 	// Accept connections to socket.
 	//
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Accepting connections to socket " << name << "." << endl;
-		WSASetLastError( 0 );
-	#endif
+#if PORT_DETAILS || _DETAILS
+	cout << "Accepting connections to socket " << name << "." << endl;
+	WSASetLastError(0);
+#endif
 
-	if ( synchronous )
-	{
+	if (synchronous) {
 		// don't need any info about who we're talking to
-		client_socket = accept ( server_socket, NULL, NULL ); 
+		client_socket = accept(server_socket, NULL, NULL);
 
-		if ( client_socket == (int)INVALID_SOCKET )
-		{
+		if (client_socket == (int)INVALID_SOCKET) {
 			*errmsg << "===> ERROR: Accepting connection to socket " << name << " failed." << endl
-				<< "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return FALSE;
-		}
-		else
-		{
+		} else {
 			return TRUE;
 		}
 	}
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	else
-	{ 
+	else {
 		DWORD bytes_received;
 
-		if ( !InitOverlapped( &accept_overlapped ) )
-		{
+		if (!InitOverlapped(&accept_overlapped)) {
 			*errmsg << "===> ERROR: Creating OVERLAPPED structure for socket " << name << " failed." << endl
-				<< "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 			OutputErrMsg();
 			return FALSE;
 		}
 
-
 		//
 		// Create client socket.
 		//
 
-		#if PORT_DETAILS || _DETAILS
-			cout << "Creating client socket for " << name << "." << endl;
-			WSASetLastError( 0 );
-		#endif
+#if PORT_DETAILS || _DETAILS
+		cout << "Creating client socket for " << name << "." << endl;
+		WSASetLastError(0);
+#endif
 
-		client_socket = WSASocket( AF_INET, SOCK_STREAM, PF_UNSPEC, NULL, 0, WSA_FLAG_OVERLAPPED );
+		client_socket = WSASocket(AF_INET, SOCK_STREAM, PF_UNSPEC, NULL, 0, WSA_FLAG_OVERLAPPED);
 
-		if ( client_socket == INVALID_SOCKET )
-		{
+		if (client_socket == INVALID_SOCKET) {
 			*errmsg << "===> ERROR: Creating client socket for " << name << " failed." << endl
-				<< "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return FALSE;
 		}
-
 		//
 		// Accept connections to socket.
 		//
-		if ( AcceptEx ( server_socket, client_socket, 
-				accept_ex_buffer, 0, // read no data, only the two addresses, into accept_ex_buffer
-				sizeof(struct sockaddr_in) + 16, sizeof(struct sockaddr_in) + 16,
-				&bytes_received, &accept_overlapped ) )
-		{
-			#if PORT_DETAILS || _DETAILS
-				cout << "Connection accepted." << endl;
-			#endif
+		if (AcceptEx(server_socket, client_socket, accept_ex_buffer, 0,	// read no data, only the two addresses, into accept_ex_buffer
+			     sizeof(struct sockaddr_in) + 16, sizeof(struct sockaddr_in) + 16,
+			     &bytes_received, &accept_overlapped)) {
+#if PORT_DETAILS || _DETAILS
+			cout << "Connection accepted." << endl;
+#endif
 
 			return TRUE;
-		}
-		else
-		{
-			if ( WSAGetLastError() == WSA_IO_PENDING ) // Read started OK...
+		} else {
+			if (WSAGetLastError() == WSA_IO_PENDING)	// Read started OK...
 			{
 				return TRUE;
-			}
-			else
-			{
+			} else {
 				*errmsg << "===> ERROR: AcceptEx() failed." << endl
-					<< "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+				    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 				OutputErrMsg();
 				return FALSE;
 			}
@@ -619,56 +556,50 @@
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
 		*errmsg << "===> ERROR: Attempting asynchronous connection in Unix." << endl
-			<< "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 		OutputErrMsg();
-		return(FALSE);
+		return (FALSE);
 	}
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
-#endif   // (asynch code)
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif				// (asynch code)
 }
 
-
-
 //
 // Called from the "server" side of a port to disconnect a "client" from
 // its port.
 //
 BOOL PortTCP::Disconnect()
 {
-	return CloseSocket ( &client_socket, "client" );
+	return CloseSocket(&client_socket, "client");
 }
 
-
 //
 // Get result of completed asynchronous Accept().  Be sure that IsAcceptComplete() has returned TRUE
 // before calling this function.  Does not block.
 //
 BOOL PortTCP::GetAcceptResult()
 {
-	if ( synchronous )
-	{
-		return ( client_socket != (int)INVALID_SOCKET );
+	if (synchronous) {
+		return (client_socket != (int)INVALID_SOCKET);
 	}
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	DWORD bytes_read;
 	BOOL result;
 
-	result = GetOverlappedResult( (HANDLE)client_socket, &accept_overlapped, &bytes_read, FALSE );
+	result = GetOverlappedResult((HANDLE) client_socket, &accept_overlapped, &bytes_read, FALSE);
 
 	return result;
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	*errmsg << "===> ERROR: Asynchronous socket accept attempted under Unix." << endl
-		<< "     [PortTCP::GetAcceptResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+	    << "     [PortTCP::GetAcceptResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 	OutputErrMsg();
-	return(FALSE);
+	return (FALSE);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
 //
 // Closes connections to a port.  Called from either "client" or "server" side.
 //
@@ -677,50 +608,43 @@
 	BOOL client_close_state, server_close_state;
 
 	// make two separate calls to make sure both are closed
-	client_close_state = CloseSocket ( &client_socket, "client" );
-	server_close_state = CloseSocket ( &server_socket, "server" );
+	client_close_state = CloseSocket(&client_socket, "client");
+	server_close_state = CloseSocket(&server_socket, "server");
 
-	return ( client_close_state && server_close_state );
+	return (client_close_state && server_close_state);
 }
 
-
-
 //
 // Call which receives data from a connected port.  Blocking call for synchronous port; non-blocking
 // call for asynchronous port.  Note that a receive call will not receive data from itself.
 //
-DWORDLONG PortTCP::Receive( LPVOID msg, DWORD size )
+DWORDLONG PortTCP::Receive(LPVOID msg, DWORD size)
 {
-	if ( synchronous )
-	{
-		return SynchReceive( msg, size );
+	if (synchronous) {
+		return SynchReceive(msg, size);
 	}
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	else
-	{
-		return AsynchReceive( msg, size );
+	else {
+		return AsynchReceive(msg, size);
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
 		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-			<< "     [PortTCP::Receive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		    << "     [PortTCP::Receive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 		OutputErrMsg();
-		return(0);
+		return (0);
 	}
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
 //
 // Synchronous implementation of Receive().
 //
-DWORDLONG PortTCP::SynchReceive( LPVOID msg, DWORD size )
+DWORDLONG PortTCP::SynchReceive(LPVOID msg, DWORD size)
 {
-	if ( !synchronous )
-	{
+	if (!synchronous) {
 		return PORT_ERROR;
 	}
 
@@ -728,65 +652,52 @@
 	DWORD total_bytes_read = 0;
 	DWORD total_size = size;
 
-	while ( total_bytes_read < total_size )
-	{
-		bytes_read = recv ( client_socket, (char *) msg, size, 0 );
-		if ( bytes_read == 0 || bytes_read == SOCKET_ERROR )
-		{
+	while (total_bytes_read < total_size) {
+		bytes_read = recv(client_socket, (char *)msg, size, 0);
+		if (bytes_read == 0 || bytes_read == SOCKET_ERROR) {
 			// socket has been closed, return error
 			cerr << "Get port error in SynchReceive." << endl;
 			return PORT_ERROR;
 		}
+#if PORT_DETAILS || _DETAILS
+		cout << "Received " << bytes_read << " of " << size << " bytes from socket " << name << "." << endl;
+#endif
 
-		#if PORT_DETAILS || _DETAILS
-			cout << "Received " << bytes_read << " of " << size 
-				 << " bytes from socket " << name << "." << endl;
-		#endif
-
-		total_bytes_read += bytes_read;		// add bytes read so far to total
-		msg = ((char *) msg) + bytes_read;	// move pointer to end of bytes read so far
-		size -= bytes_read;					// decrease number of bytes to read in next recv()
+		total_bytes_read += bytes_read;	// add bytes read so far to total
+		msg = ((char *)msg) + bytes_read;	// move pointer to end of bytes read so far
+		size -= bytes_read;	// decrease number of bytes to read in next recv()
 	}
 
 	return (DWORDLONG) total_bytes_read;
 }
 
-
-
 //
 // Asynchronous implementation of Receive().
 //
-DWORDLONG PortTCP::AsynchReceive( LPVOID msg, DWORD size )
+DWORDLONG PortTCP::AsynchReceive(LPVOID msg, DWORD size)
 {
-	if ( synchronous )
-	{
+	if (synchronous) {
 		return PORT_ERROR;
 	}
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 
 	DWORD bytes_read;
 
-	if ( !InitOverlapped( &receive_overlapped ) )
-	{
+	if (!InitOverlapped(&receive_overlapped)) {
 		*errmsg << "===> ERROR: Creating OVERLAPPED structure for socket " << name << " failed." << endl
-			<< "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		    << "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 		OutputErrMsg();
 		return PORT_ERROR;
 	}
-	
-	if ( ReadFile( (HANDLE)client_socket, msg, size, &bytes_read, 
-		&receive_overlapped ) )
-	{
-		#if PORT_DETAILS || _DETAILS
-			cout << "Received " << bytes_read << " of " << size 
-			     << " bytes from socket " << name << "." << endl;
-		#endif
 
+	if (ReadFile((HANDLE) client_socket, msg, size, &bytes_read, &receive_overlapped)) {
+#if PORT_DETAILS || _DETAILS
+		cout << "Received " << bytes_read << " of " << size << " bytes from socket " << name << "." << endl;
+#endif
+
 		return (DWORDLONG) bytes_read;
-	}
-	else
-	{
-		if ( GetLastError() == ERROR_IO_PENDING ) // Read started OK...
+	} else {
+		if (GetLastError() == ERROR_IO_PENDING)	// Read started OK...
 		{
 			return 0;	// not an error code, but no bytes read yet
 		}
@@ -795,17 +706,15 @@
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
 		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-			<< "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		    << "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 		OutputErrMsg();
-		return(PORT_ERROR);
+		return (PORT_ERROR);
 	}
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
 //
 // Get result of completed asynchronous Receive() (number of bytes read, -1 for any error).  Be sure that 
 // IsReceiveComplete() has returned TRUE before calling this function.  Does not block.
@@ -817,130 +726,103 @@
 //
 DWORDLONG PortTCP::GetReceiveResult()
 {
-	if ( synchronous )
-	{
+	if (synchronous) {
 		return PORT_ERROR;
 	}
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	DWORD bytes_read;
 
-	if ( GetOverlappedResult( (HANDLE)client_socket, &receive_overlapped, &bytes_read, FALSE ) )
-	{
+	if (GetOverlappedResult((HANDLE) client_socket, &receive_overlapped, &bytes_read, FALSE)) {
 		return (DWORDLONG) bytes_read;
-	}
-	else
-	{
+	} else {
 		return PORT_ERROR;
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
 		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-			<< "     [PortTCP::GetReceiveResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		    << "     [PortTCP::GetReceiveResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 		OutputErrMsg();
-		return(PORT_ERROR);
+		return (PORT_ERROR);
 	}
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
 //
 // Call which sends data to a connected port.  Blocking call for synchronous port; non-blocking
 // call for asynchronous port.  Note that a process will not send data to itself.
 //
-DWORDLONG PortTCP::Send( LPVOID msg, DWORD size )
+DWORDLONG PortTCP::Send(LPVOID msg, DWORD size)
 {
-	if ( synchronous )
-	{
-		return SynchSend( msg, size );
+	if (synchronous) {
+		return SynchSend(msg, size);
+	} else {
+		return AsynchSend(msg, size);
 	}
-	else
-	{
-		return AsynchSend( msg, size );
-	}
 }
 
-
-
 //
 // Synchronous implementation of Send().
 //
-DWORDLONG PortTCP::SynchSend( LPVOID msg, DWORD size )
+DWORDLONG PortTCP::SynchSend(LPVOID msg, DWORD size)
 {
-	if ( !synchronous )
-	{
+	if (!synchronous) {
 		return PORT_ERROR;
 	}
 
 	int bytes_written;
 	DWORD total_bytes_written = 0;
 	DWORD total_size = size;
-	
+
 #ifdef _DEBUG
 	cout << "in SynchSend " << endl;
 #endif
-	while ( total_bytes_written < total_size )
-	{
-		bytes_written = send ( client_socket, (char *) msg, size, 0 );
+	while (total_bytes_written < total_size) {
+		bytes_written = send(client_socket, (char *)msg, size, 0);
 
-		if ( bytes_written == 0 || bytes_written == SOCKET_ERROR )
-		{
+		if (bytes_written == 0 || bytes_written == SOCKET_ERROR) {
 			// socket has been closed, return error
 			*errmsg << "===> ERROR: Send failed." << endl
-				<< "     [PortTCP::SynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::SynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return PORT_ERROR;
 		}
+#if PORT_DETAILS || _DETAILS
+		cout << "Sent " << bytes_written << " of " << size << " bytes to socket " << name << "." << endl;
+#endif
 
-		#if PORT_DETAILS || _DETAILS
-			cout << "Sent " << bytes_written << " of " << size 
-			     << " bytes to socket " << name << "." << endl;
-		#endif
-
 		total_bytes_written += bytes_written;	// add bytes written so far to total
-		msg = ((char *) msg) + bytes_written;	// move pointer to end of bytes written so far
-		size -= bytes_written;					// decrease number of bytes to write in next send()
+		msg = ((char *)msg) + bytes_written;	// move pointer to end of bytes written so far
+		size -= bytes_written;	// decrease number of bytes to write in next send()
 	}
 
 	return (DWORDLONG) total_bytes_written;
 }
 
-
-
 //
 // Asynchronous implementation of Send().
 //
-DWORDLONG PortTCP::AsynchSend( LPVOID msg, DWORD size )
+DWORDLONG PortTCP::AsynchSend(LPVOID msg, DWORD size)
 {
-	if ( synchronous )
-	{
+	if (synchronous) {
 		return PORT_ERROR;
 	}
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	DWORD bytes_written;
 
-	if ( !InitOverlapped( &send_overlapped ) )
-	{
+	if (!InitOverlapped(&send_overlapped)) {
 		return PORT_ERROR;
 	}
-	
-	if ( WriteFile( (HANDLE)client_socket, msg, size, &bytes_written,
-		&send_overlapped ) )
-	{
-		#if PORT_DETAILS || _DETAILS
-			cout << "Sent " << bytes_written << " of " << size 
-			     << " bytes to socket " << name << "." << endl;
-		#endif
+
+	if (WriteFile((HANDLE) client_socket, msg, size, &bytes_written, &send_overlapped)) {
+#if PORT_DETAILS || _DETAILS
+		cout << "Sent " << bytes_written << " of " << size << " bytes to socket " << name << "." << endl;
+#endif
 		return (DWORDLONG) bytes_written;
-	}
-	else
-	{
-		if ( GetLastError() == ERROR_IO_PENDING ) // Write started OK...
+	} else {
+		if (GetLastError() == ERROR_IO_PENDING)	// Write started OK...
 		{
 			return 0;	// not an error code, but no bytes read yet
 		}
@@ -949,51 +831,44 @@
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
 		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-			<< "     [PortTCP::AsynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		    << "     [PortTCP::AsynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 		OutputErrMsg();
-		return(PORT_ERROR);
+		return (PORT_ERROR);
 	}
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
 //
 // Get result of completed asynchronous Send() (number of bytes read, -1 for any error).  Be sure that 
 // IsSendComplete() has returned TRUE before calling this function.  Does not block.
 //
 DWORDLONG PortTCP::GetSendResult()
 {
-	if ( synchronous )
-	{
+	if (synchronous) {
 		return PORT_ERROR;
 	}
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	DWORD bytes_written;
 
-	if ( GetOverlappedResult( (HANDLE)client_socket, &send_overlapped, &bytes_written, FALSE ) )
-	{
+	if (GetOverlappedResult((HANDLE) client_socket, &send_overlapped, &bytes_written, FALSE)) {
 		return (DWORDLONG) bytes_written;
-	}
-	else
-	{
+	} else {
 		return PORT_ERROR;
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
 		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-			<< "     [PortTCP::GetSendResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		    << "     [PortTCP::GetSendResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
 		OutputErrMsg();
-		return(PORT_ERROR);
+		return (PORT_ERROR);
 	}
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
 //
 // Non blocking call which reads data from a connected port without
 // removing it.  Note that a process does not receive data from itself.
@@ -1001,61 +876,55 @@
 DWORD PortTCP::Peek()
 {
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE)
-	int		bytes_available = 0;
+	int bytes_available = 0;
 #elif defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	DWORD           bytes_available = 0;
+	DWORD bytes_available = 0;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	BOOL		success = FALSE;
-	fd_set		sock_set;        //For use with select
-	timeval		timeout={0,0};   //For use with select, initialized to zero for instaneous return
-	char buf[1];	// we have to provide a buffer, so we provide just one character of buffer
+	BOOL success = FALSE;
+	fd_set sock_set;	//For use with select
+	timeval timeout = { 0, 0 };	//For use with select, initialized to zero for instaneous return
+	char buf[1];		// we have to provide a buffer, so we provide just one character of buffer
 
-	if ( synchronous )
-	{
-		FD_ZERO( &sock_set );				// clear the fd_set structure.
-		FD_SET( client_socket, &sock_set ); // Add the one and only socket to it.
+	if (synchronous) {
+		FD_ZERO(&sock_set);	// clear the fd_set structure.
+		FD_SET(client_socket, &sock_set);	// Add the one and only socket to it.
 		if (select(client_socket + 1, &sock_set, NULL, NULL, &timeout)) {
 			//if there is data available or select returns an error, 
 			//we want bytes_available to set by the result of recv().
-			bytes_available = recv ( client_socket, buf, sizeof(buf), MSG_PEEK );
+			bytes_available = recv(client_socket, buf, sizeof(buf), MSG_PEEK);
 		} else {
 			//otherwise, there are no bytes available, this prevents recv() from blocking
 			bytes_available = 0;
 		}
-		success = ( (long)bytes_available != SOCKET_ERROR );
+		success = ((long)bytes_available != SOCKET_ERROR);
 	}
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	else
-	{
+	else {
 		DWORD flags;	// flags must be provided as a (DWORD *), so we need to have a DWORD variable
 		WSABUF wsabuf[1];
-		
+
 		flags = MSG_PEEK;
 		wsabuf[0].buf = buf;
 		wsabuf[0].len = sizeof(buf);
 
-		success = ( WSARecv ( client_socket, wsabuf, 1, &bytes_available, &flags, NULL, NULL ) == 0 );
+		success = (WSARecv(client_socket, wsabuf, 1, &bytes_available, &flags, NULL, NULL) == 0);
 	}
 #endif
 
-	if ( success )
-	{
-		#if PORT_DETAILS || _DETAILS
-			cout << "Peeked " << bytes_available << " bytes from socket " 
-			     << name << "." << endl;
-		#endif
+	if (success) {
+#if PORT_DETAILS || _DETAILS
+		cout << "Peeked " << bytes_available << " bytes from socket " << name << "." << endl;
+#endif
 		return (DWORD) bytes_available;
-	}
-	else
-	{
-		#if PORT_DETAILS || _DETAILS
-			*errmsg << "===> ERROR: Peeking from socket " << name << " failed." << endl
-				<< "     [PortTCP::Peek() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
-			OutputErrMsg();
-		#endif
+	} else {
+#if PORT_DETAILS || _DETAILS
+		*errmsg << "===> ERROR: Peeking from socket " << name << " failed." << endl
+		    << "     [PortTCP::Peek() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+		    << "     errno = " << WSAGetLastError() << ends;
+		OutputErrMsg();
+#endif
 		return 0;	// no data available at this time, maybe later
 	}
 }
@@ -1063,54 +932,49 @@
 //
 // Utility function to close a socket.  socket_name parameter is used only for debugging outputs.
 //
-BOOL PortTCP::CloseSocket( SOCKET *s, char *socket_name )
+BOOL PortTCP::CloseSocket(SOCKET * s, char *socket_name)
 {
-	if ( *s == (int)INVALID_SOCKET )
-	{
-		#if PORT_DETAILS || _DETAILS
-			cout << socket_name << " socket is already closed." << endl;
-		#endif
+	if (*s == (int)INVALID_SOCKET) {
+#if PORT_DETAILS || _DETAILS
+		cout << socket_name << " socket is already closed." << endl;
+#endif
 		return TRUE;
 	}
+#if PORT_DETAILS || _DETAILS
+	cout << "Shutting down " << socket_name << " socket." << endl;
+#endif
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Shutting down " << socket_name << " socket." << endl;
-	#endif
-
-	if ( shutdown ( *s, SD_BOTH ) != 0 )
-	{
+	if (shutdown(*s, SD_BOTH) != 0) {
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 		// WSAENOTCONN = "socket is not connected", which occurs on the server side if the socket is
 		// closed with no Accept() active -- this is no problem since we're just closing it anyway
-		if ( WSAGetLastError() != WSAENOTCONN ) 
-		{
+		if (WSAGetLastError() != WSAENOTCONN) {
 			*errmsg << "===> ERROR: Shutting down socket " << socket_name << " failed." << endl
-				<< "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				<< "     errno = " << WSAGetLastError() << ends;
+			    << "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+			    << "     errno = " << WSAGetLastError() << ends;
 			OutputErrMsg();
 			return FALSE;
 		}
 #endif
-		#if PORT_DETAILS || _DETAILS
-			cout << socket_name << " socket is already shut down." << endl;
-		#endif
+#if PORT_DETAILS || _DETAILS
+		cout << socket_name << " socket is already shut down." << endl;
+#endif
 	}
+#if PORT_DETAILS || _DETAILS
+	cout << "Closing " << socket_name << " socket." << endl;
+#endif
 
-	#if PORT_DETAILS || _DETAILS
-		cout << "Closing " << socket_name << " socket." << endl;
-	#endif
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( closesocket ( *s ) != 0 )
+	if (closesocket(*s) != 0)
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	if ( close ( *s ) != 0 )
+	if (close(*s) != 0)
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		*errmsg << "===> ERROR: Closing socket " << socket_name << " failed." << endl
-			<< "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			<< "     errno = " << WSAGetLastError() << ends;
+		    << "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << endl
+		    << "     errno = " << WSAGetLastError() << ends;
 		OutputErrMsg();
 		return FALSE;
 	}

Modified: branches/IOMETER-restruct/iometer/src/IOPortTCP.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPortTCP.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOPortTCP.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -83,89 +83,84 @@
 #ifndef PORTTCP_DEFINED
 #define PORTTCP_DEFINED
 
-
 #if _MSC_VER >= 1000
 #pragma once
-#endif // _MSC_VER >= 1000
+#endif				// _MSC_VER >= 1000
 
 #include "IOPort.h"
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- #include <sys/socket.h>
- #include <netinet/in.h>
- #include <netdb.h>
- #include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <arpa/inet.h>
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
- #include "winsock2.h"
+#include "winsock2.h"
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- #define SOCKET	int
+#define SOCKET	int
 #endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
  // nop
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #define socklen_t int  
+#define socklen_t int
 #elif defined(IOMTR_OS_NETWARE)
- #define socklen_t unsigned int
+#define socklen_t unsigned int
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
+class PortTCP:public Port {
+      public:
+	// constructor and destructor   
+	PortTCP(BOOL synchronous = TRUE);
+	virtual ~ PortTCP();
 
-
-class PortTCP : public Port  
-{
-public:
-	// constructor and destructor	
-	PortTCP( BOOL synchronous = TRUE );
-	virtual	~PortTCP();
-
 	// public functions common to all Ports (implemented here, pure virtual in Port)
-	virtual	BOOL		Create( char* port_name = NULL, char* remote_name = NULL, 
-							DWORD size = MESSAGE_PORT_SIZE, unsigned short port_number = 0 );
-	virtual BOOL		Connect( char* port_name = NULL, 
-							unsigned short port_number = WELL_KNOWN_TCP_PORT );
-	virtual BOOL		Accept();
-	virtual BOOL		Disconnect();
-	virtual BOOL		Close();
-	virtual DWORDLONG	Receive( LPVOID data, DWORD size = MESSAGE_SIZE );
-	virtual DWORDLONG	Send( LPVOID data, DWORD size = MESSAGE_SIZE );
-	virtual DWORD		Peek();
+	virtual BOOL Create(char *port_name = NULL, char *remote_name = NULL,
+			    DWORD size = MESSAGE_PORT_SIZE, unsigned short port_number = 0);
+	virtual BOOL Connect(char *port_name = NULL, unsigned short port_number = WELL_KNOWN_TCP_PORT);
+	virtual BOOL Accept();
+	virtual BOOL Disconnect();
+	virtual BOOL Close();
+	virtual DWORDLONG Receive(LPVOID data, DWORD size = MESSAGE_SIZE);
+	virtual DWORDLONG Send(LPVOID data, DWORD size = MESSAGE_SIZE);
+	virtual DWORD Peek();
 
 	// public functions common to all asynchronous Ports (implemented here, pure virtual in Port)
-	virtual BOOL		GetAcceptResult();
-	virtual DWORDLONG	GetReceiveResult();
-	virtual DWORDLONG	GetSendResult();
+	virtual BOOL GetAcceptResult();
+	virtual DWORDLONG GetReceiveResult();
+	virtual DWORDLONG GetSendResult();
 
-protected:
+      protected:
 	// private data members used only by PortTCP
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	int 				server_socket;
-	int 				client_socket;
+	int server_socket;
+	int client_socket;
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-	SOCKET				server_socket;
-	SOCKET				client_socket;
+	 SOCKET server_socket;
+	SOCKET client_socket;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 	// private data members used only by asynchronous PortTCP's
-	char				*accept_ex_buffer;
+	char *accept_ex_buffer;
 
 	// static private data members shared by all PortTCP's
-	static unsigned int		sockets_in_use;
+	static unsigned int sockets_in_use;
 
 	// private functions used only by PortTCP
-	BOOL				CloseSocket( SOCKET *s, char *socket_name ); // utility function
-	DWORDLONG			SynchReceive( LPVOID data, DWORD size = MESSAGE_SIZE );
-	DWORDLONG			SynchSend( LPVOID data, DWORD size = MESSAGE_SIZE );
+	BOOL CloseSocket(SOCKET * s, char *socket_name);	// utility function
+	DWORDLONG SynchReceive(LPVOID data, DWORD size = MESSAGE_SIZE);
+	DWORDLONG SynchSend(LPVOID data, DWORD size = MESSAGE_SIZE);
 
 	// private functions used only by asynchronous PortTCP's
-	DWORDLONG			AsynchReceive( LPVOID data, DWORD size = MESSAGE_SIZE );
-	DWORDLONG			AsynchSend( LPVOID data, DWORD size = MESSAGE_SIZE );
+	DWORDLONG AsynchReceive(LPVOID data, DWORD size = MESSAGE_SIZE);
+	DWORDLONG AsynchSend(LPVOID data, DWORD size = MESSAGE_SIZE);
 };
 
 #if defined(USING_DDK)
@@ -183,23 +178,16 @@
 extern "C" {
 #endif
 
-BOOL
-PASCAL FAR
-AcceptEx (
-    IN SOCKET sListenSocket,
-    IN SOCKET sAcceptSocket,
-    IN PVOID lpOutputBuffer,
-    IN DWORD dwReceiveDataLength,
-    IN DWORD dwLocalAddressLength,
-    IN DWORD dwRemoteAddressLength,
-    OUT LPDWORD lpdwBytesReceived,
-    IN LPOVERLAPPED lpOverlapped
-    );
+	BOOL PASCAL FAR
+	    AcceptEx(IN SOCKET sListenSocket,
+		     IN SOCKET sAcceptSocket,
+		     IN PVOID lpOutputBuffer,
+		     IN DWORD dwReceiveDataLength,
+		     IN DWORD dwLocalAddressLength,
+		     IN DWORD dwRemoteAddressLength, OUT LPDWORD lpdwBytesReceived, IN LPOVERLAPPED lpOverlapped);
 
 #ifdef __cplusplus
 }
 #endif
-
 #endif
-
-#endif // PORTTCP_DEFINED
+#endif				// PORTTCP_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/IOTarget.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTarget.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTarget.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -66,7 +66,6 @@
 
 #include "IOTarget.h"
 
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -86,8 +85,6 @@
 
 }
 
-
-
 //
 // Return a 64-bit random number, using the following random function and conditions.
 //
@@ -98,16 +95,16 @@
 // b is odd
 //
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
- #define A 136204069LL		// 3x7x11x13x17x23x29x4 + 1
- #define B 28500701229LL	// 3x7x11x13x17x23x27x29x31
+#define A 136204069LL		// 3x7x11x13x17x23x29x4 + 1
+#define B 28500701229LL		// 3x7x11x13x17x23x27x29x31
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #define A 136204069		// 3x7x11x13x17x23x29x4 + 1
- #define B 28500701229		// 3x7x11x13x17x23x27x29x31
+#define A 136204069		// 3x7x11x13x17x23x29x4 + 1
+#define B 28500701229		// 3x7x11x13x17x23x27x29x31
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-DWORDLONG Target::Rand( void )
+DWORDLONG Target::Rand(void)
 {
-	return( spec.random = A * spec.random + B );
+	return (spec.random = A * spec.random + B);
 }

Modified: branches/IOMETER-restruct/iometer/src/IOTarget.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTarget.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTarget.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,10 +64,9 @@
 #ifndef TARGET_DEFINED
 #define TARGET_DEFINED
 
-
 #if _MSC_VER >= 1000
 #pragma once
-#endif // _MSC_VER >= 1000
+#endif				// _MSC_VER >= 1000
 
 // Set TARGET_DETAILS to 1 to enable target related debug messages, 0 to disable them.
 // If _DETAILS  is defined and TARGET_DETAILS is set to 0, some messages will
@@ -82,32 +81,31 @@
 #include "IOTest.h"
 #include "IOCQ.h"
 
-class Target  
-{
-public:
+class Target {
+      public:
 
 	Target();
-	virtual ~Target();
+	virtual ~ Target();
 
-	virtual	BOOL	Initialize( Target_Spec *target_info, CQ *cq ) = 0;
-	virtual BOOL	Open( volatile TestState *test_state, int open_flag = 0 ) = 0;
-	virtual BOOL	Close( volatile TestState *test_state ) = 0;
+	virtual BOOL Initialize(Target_Spec * target_info, CQ * cq) = 0;
+	virtual BOOL Open(volatile TestState * test_state, int open_flag = 0) = 0;
+	virtual BOOL Close(volatile TestState * test_state) = 0;
 
-	virtual ReturnVal	Read( LPVOID buffer, Transaction *trans ) = 0;
-	virtual ReturnVal	Write( LPVOID buffer, Transaction *trans ) = 0;
+	virtual ReturnVal Read(LPVOID buffer, Transaction * trans) = 0;
+	virtual ReturnVal Write(LPVOID buffer, Transaction * trans) = 0;
 
-	virtual DWORDLONG	Rand();
+	virtual DWORDLONG Rand();
 
-	Target_Spec	spec;
+	Target_Spec spec;
 
 	// Variables used to control connection rate testing.
-	int			trans_left_in_conn;
-	DWORDLONG	conn_start_time;
-	int			outstanding_ios;
-	BOOL		is_closing;
+	int trans_left_in_conn;
+	DWORDLONG conn_start_time;
+	int outstanding_ios;
+	BOOL is_closing;
 
-private:
+      private:
 
 };
 
-#endif // !defined(TARGET_DEFINED)
+#endif				// !defined(TARGET_DEFINED)

Modified: branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -62,7 +62,7 @@
 /* ##               - Correct the size of data stored through pointers.   ## */
 /* ##               2004-08-21 (mingz at ele.uri.edu)                        ## */
 /* ##               - Changed "/dev" to RAW_DEVICE_DIR in                 ## */
-/* ##                 getSectorSizeOfPhysDisk() and getSizeOfPhysDisk()   ## */ 
+/* ##                 getSectorSizeOfPhysDisk() and getSizeOfPhysDisk()   ## */
 /* ##               2004-05-27 (lamontcranston41 at yahoo.com)               ## */
 /* ##               - Close files in getSizeOfPhysDisk and                ## */
 /* ##                 getSectorSizeOfPhysDisk for linux                   ## */
@@ -114,53 +114,48 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOCommon.h"
 #include "IOTargetDisk.h"
 #include "IOAccess.h"
 
-
 #define _DISK_MSGS 0
 
-
 #if defined(IOMTR_OSFAMILY_NETWARE)
-  #include <assert.h>
-  #include <math.h>
-  #include <monitor.h>
-  #include <library.h>
-  #include <netware.h>
+#include <assert.h>
+#include <math.h>
+#include <monitor.h>
+#include <library.h>
+#include <netware.h>
 #elif defined(IOMTR_OSFAMILY_UNIX)
- #ifdef WORKAROUND_MOD_BUG
-  #include <math.h>
- #endif // WORKAROUND_MOD_BUG
+#ifdef WORKAROUND_MOD_BUG
+#include <math.h>
+#endif				// WORKAROUND_MOD_BUG
 
- #if defined(IOMTR_OS_SOLARIS)
-  #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64)
+#if defined(IOMTR_OS_SOLARIS)
+#if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64)
    // highly specific to Solaris on Intel
-   #include <sys/dktp/fdisk.h>
-  #endif
-  #include <sys/statvfs.h>
-  #include <sys/stat.h>
-  #include <sys/dkio.h>
-  #include <sys/vtoc.h>
- #endif
+#include <sys/dktp/fdisk.h>
+#endif
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/dkio.h>
+#include <sys/vtoc.h>
+#endif
 
- #if defined(IOMTR_OS_LINUX)
-  #include <assert.h>
-  #include <sys/vfs.h>
- #endif
+#if defined(IOMTR_OS_LINUX)
+#include <assert.h>
+#include <sys/vfs.h>
+#endif
 
- #if defined(IOMTR_OS_OSX)
-  #include <sys/types.h>
-  #include <sys/stat.h>
-  #include <sys/mount.h>
-  #include <sys/ioctl.h>
-  #include <sys/disk.h>
- #endif
+#if defined(IOMTR_OS_OSX)
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/ioctl.h>
+#include <sys/disk.h>
 #endif
+#endif
 
-
-
 /**********************************************************************
  * Forward Declarations
  **********************************************************************/
@@ -169,10 +164,6 @@
 static unsigned long long getSizeOfPhysDisk(const char *devName);
 #endif
 
-
-
-
-
 //
 // Constructor.
 //
@@ -184,134 +175,116 @@
 	sector_align_mask = NOT_POWER_OF_TWO;
 
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	disk_file = (HANDLE)&file_handle;
+	disk_file = (HANDLE) & file_handle;
 #if defined(IOMTR_SETTING_GCC_M64) || defined(IOMTR_OS_OSX)
 	file_handle.iocq = NULL;
 #endif
 #endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
-   	mmAppTag = (LONG)AllocateResourceTag(getnlmhandle(), "dynamo", (LONG)MM_APPLICATION_SIGNATURE);
+	mmAppTag = (LONG) AllocateResourceTag(getnlmhandle(), "dynamo", (LONG) MM_APPLICATION_SIGNATURE);
 	appDef.classobjectsignature = MM_APPLICATION_SIGNATURE;
 	appDef.controlroutine = NULL;
-	appDef.name	= (unsigned char *)"mmDynamo";
+	appDef.name = (unsigned char *)"mmDynamo";
 	appDef.type = MM_GENERAL_STORAGE_APPLICATION;
 	appDef.identifier = 0xEEDDCCBB;
 
-	if((rc=MM_RegisterObject(&applicationHandle, MM_APPLICATION_CLASS, &appDef, NULL, mmAppTag)) != MM_OK)
-   {
-    	printf("Failed MM_RegisterObject (0x%X)\n", rc);
-    	exit(1);
-   }
+	if ((rc = MM_RegisterObject(&applicationHandle, MM_APPLICATION_CLASS, &appDef, NULL, mmAppTag)) != MM_OK) {
+		printf("Failed MM_RegisterObject (0x%X)\n", rc);
+		exit(1);
+	}
 #endif
 }
 
-
-
-
 TargetDisk::~TargetDisk()
-{ 
+{
 #if defined(IOMTR_OS_NETWARE)
 	MM_UnregisterObject(applicationHandle, 0);
 #endif
 };
 
-
-
-
-
 //
 // Initializing the disk based on the specified target information.
 //
-BOOL TargetDisk::Initialize( Target_Spec *target_info, CQ *cq )
+BOOL TargetDisk::Initialize(Target_Spec * target_info, CQ * cq)
 {
 	BOOL retval;
 
-	io_cq = (CQAIO*)cq;
+	io_cq = (CQAIO *) cq;
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	file_handle.iocq = (IOCQ*)io_cq->completion_queue;
+	file_handle.iocq = (IOCQ *) io_cq->completion_queue;
 #endif
-	memcpy( &spec, target_info, sizeof( Target_Spec ) );
+	memcpy(&spec, target_info, sizeof(Target_Spec));
 
 	// Initializing logical disks.
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( IsType( target_info->type, LogicalDiskType ) )
-		retval = Init_Logical( spec.name[0] );
-	else if ( IsType( target_info->type, PhysicalDiskType ) )
-		retval = Init_Physical( atoi( spec.name + 14 ) );
+	if (IsType(target_info->type, LogicalDiskType))
+		retval = Init_Logical(spec.name[0]);
+	else if (IsType(target_info->type, PhysicalDiskType))
+		retval = Init_Physical(atoi(spec.name + 14));
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	if ( IsType( target_info->type, LogicalDiskType ) )
-		retval = Init_Logical( spec.name );
-	else if ( IsType( target_info->type, PhysicalDiskType ) )
-		retval = Init_Physical( spec.name );
+	if (IsType(target_info->type, LogicalDiskType))
+		retval = Init_Logical(spec.name);
+	else if (IsType(target_info->type, PhysicalDiskType))
+		retval = Init_Physical(spec.name);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	else
-	{
+	else {
 		cout << "*** Invalid disk type in TargetDisk::Initialize()." << endl;
 		retval = FALSE;
 	}
 
-	if ( retval )
-	{
+	if (retval) {
 		// Setting size of disk, if it was successfully initialized
-		Set_Size( spec.disk_info.maximum_size );
+		Set_Size(spec.disk_info.maximum_size);
 
 #if defined(IOMTR_CPU_SPARC)
- // To tell the truth, I have no idear, if this is
- // a.) Only specific to the Sparc systems (so Linux on Sparc has to do the same)
- // b.) Only specific to the Solaris operating system (so Solaris on i386 has to do the same)
- // c.) Specific to the Sparc system / Solaris operating system combination (current implementation)
- #if defined(IOMTR_OS_SOLARIS)
+		// To tell the truth, I have no idear, if this is
+		// a.) Only specific to the Sparc systems (so Linux on Sparc has to do the same)
+		// b.) Only specific to the Solaris operating system (so Solaris on i386 has to do the same)
+		// c.) Specific to the Sparc system / Solaris operating system combination (current implementation)
+#if defined(IOMTR_OS_SOLARIS)
 		if (spec.disk_info.starting_sector)
-			Set_Starting_Sector( spec.disk_info.starting_sector);
-		else
-			if ( IsType( target_info->type, PhysicalDiskType ) )
-			{
-				// always skip sector 0 for non-i386 || IA64 platform (only for raw disks).
-				// We need it to avoid destroying the vtoc table which is
-				// not protected on these (sparc) platforms.
-				//
-				// But this is serious performance implications.
-				// Can slow down access quite a bit.
-				//
-				Set_Starting_Sector( 1 );
-			}
- #else    			
-  #error ===> ERROR: Broken port, advice needed!
- #endif
+			Set_Starting_Sector(spec.disk_info.starting_sector);
+		else if (IsType(target_info->type, PhysicalDiskType)) {
+			// always skip sector 0 for non-i386 || IA64 platform (only for raw disks).
+			// We need it to avoid destroying the vtoc table which is
+			// not protected on these (sparc) platforms.
+			//
+			// But this is serious performance implications.
+			// Can slow down access quite a bit.
+			//
+			Set_Starting_Sector(1);
+		}
+#else
+#error ===> ERROR: Broken port, advice needed!
+#endif
 #elif defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64) || defined(IOMTR_CPU_PPC) || defined(IOMTR_CPU_X86_64)
-		Set_Starting_Sector( spec.disk_info.starting_sector );
+		Set_Starting_Sector(spec.disk_info.starting_sector);
 #elif defined(IOMTR_CPU_XSCALE)
 		// TODO: Need to double check if this is correct for xscale
 		cout << spec.disk_info.starting_sector << endl;
-		Set_Starting_Sector( spec.disk_info.starting_sector );
+		Set_Starting_Sector(spec.disk_info.starting_sector);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	}
 
 	return retval;
-} 
+}
 
-
-
-
-
 #if defined(IOMTR_OS_NETWARE)
 // NetWare logical drives are accessed through path names.
-BOOL TargetDisk::Init_Logical( char *drive )
+BOOL TargetDisk::Init_Logical(char *drive)
 {
 	// Setting spec.name of the drive.
-	sprintf( spec.name, "%s", drive );
+	sprintf(spec.name, "%s", drive);
 
-	if (spec.name[strlen(spec.name) - 1] == ':') 
-	{
+	if (spec.name[strlen(spec.name) - 1] == ':') {
 		sprintf(file_name, "%s%s", spec.name, TEST_FILE);
-	} else 
-	{
+	} else {
 		sprintf(file_name, "%s:%s", spec.name, TEST_FILE);
 	}
 
@@ -322,24 +295,23 @@
 	bytes_transferred = 0;
 
 	// Getting size information about the drive.
-	return( Set_Sizes() );
+	return (Set_Sizes());
 }
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 // UNIX logical drives are accessed through path names.
-BOOL TargetDisk::Init_Logical( char *drive )
+BOOL TargetDisk::Init_Logical(char *drive)
 {
 	// Strip off file system Information about the logical drives.
 	char *p;
+
 	// check for this pattern is also in Manager::Report_Disks()
 	p = strstr(drive, " [");
-	if (p)
-	{
+	if (p) {
 		strncpy(spec.name, drive, p - drive);
 		spec.name[p - drive] = 0;
-	}
-	else
+	} else
 		// Setting spec.name of the drive.
-		sprintf( spec.name, "%s", drive );
+		sprintf(spec.name, "%s", drive);
 
 	if (spec.name[strlen(spec.name) - 1] == '/') {
 		sprintf(file_name, "%s%s", spec.name, TEST_FILE);
@@ -354,18 +326,18 @@
 	bytes_transferred = 0;
 
 	// Getting size information about the drive.
-	return( Set_Sizes() );
+	return (Set_Sizes());
 }
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 //
 // Initialize a logical disk drive.  Logical drives are accessed through
 // a drive letter and may be local or remote.
 //
-BOOL TargetDisk::Init_Logical( char drive )
+BOOL TargetDisk::Init_Logical(char drive)
 {
 	// Setting spec.name of the drive.
-	sprintf( spec.name, "%c%s", drive, LOGICAL_DISK );
-	sprintf( file_name, "%s%s", spec.name, TEST_FILE );
+	sprintf(spec.name, "%c%s", drive, LOGICAL_DISK);
+	sprintf(file_name, "%s%s", spec.name, TEST_FILE);
 
 	spec.type = LogicalDiskType;
 	size = 0;
@@ -374,28 +346,24 @@
 	bytes_transferred = 0;
 
 	// Getting size information about the drive.
-	return( Set_Sizes() );
+	return (Set_Sizes());
 }
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
-
-
 #if defined(IOMTR_OS_NETWARE)
-BOOL TargetDisk::Init_Physical( char *drive )
+BOOL TargetDisk::Init_Physical(char *drive)
 {
 	struct IOObjectGenericInfoDef info;
-	int drive1 = atoi(drive+1);
+	int drive1 = atoi(drive + 1);
 
 	// Setting the spec.name of the drive.
-	printf("TargetDisk::Init_Physical: name=%s, mmID=%X\n",drive,drive1);
+	printf("TargetDisk::Init_Physical: name=%s, mmID=%X\n", drive, drive1);
 	MM_ReturnObjectGenericInfo(drive1, sizeof(struct IOObjectGenericInfoDef), &info);
-	sprintf( spec.name, "[%d] %s", drive1, info.name );
+	sprintf(spec.name, "[%d] %s", drive1, info.name);
 
-	sprintf(file_name,"%d",drive1);
+	sprintf(file_name, "%d", drive1);
 
 	spec.type = PhysicalDiskType;
 	size = 0;
@@ -404,33 +372,31 @@
 	bytes_transferred = 0;
 
 	// Getting information about the size of the drive.
-	return( Set_Sizes() );
+	return (Set_Sizes());
 }
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS) 
-BOOL TargetDisk::Init_Physical( char *drive )
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
+BOOL TargetDisk::Init_Physical(char *drive)
 {
 	// Setting the spec.name of the drive.
 	// Strip off any extra information in the drive name.
 	char *p;
+
 	// check for this pattern is also in Manager::Report_Disks()
 	// and Manager::Reported_As_Logical().
 	p = strstr(drive, " [");
-	if (p)
-	{
+	if (p) {
 		strncpy(spec.name, drive, p - drive);
 		spec.name[p - drive] = 0;
-	}
-	else
-	{
+	} else {
 		// Setting spec.name of the drive.
-		sprintf( spec.name, "%s", drive );
+		sprintf(spec.name, "%s", drive);
 	}
 
 	if (!strstr(spec.name, RAW_DEVICE_DIR))
-		sprintf( file_name, "%s/%s", RAW_DEVICE_DIR, spec.name );
+		sprintf(file_name, "%s/%s", RAW_DEVICE_DIR, spec.name);
 	else
-		sprintf( file_name, "%s", spec.name );
-		
+		sprintf(file_name, "%s", spec.name);
+
 	spec.type = PhysicalDiskType;
 	size = 0;
 	starting_position = 0;
@@ -438,7 +404,7 @@
 	bytes_transferred = 0;
 
 	// Getting information about the size of the drive.
-	return( Set_Sizes() );
+	return (Set_Sizes());
 }
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 //
@@ -447,11 +413,11 @@
 // occur.  To prevent this, only drives which contain nothing but free space
 // are accessible.
 //
-BOOL TargetDisk::Init_Physical( int drive )
+BOOL TargetDisk::Init_Physical(int drive)
 {
 	// Setting the spec.name of the drive.
-	sprintf( spec.name, "%s%i", PHYSICAL_DISK, drive );
-	strcpy( file_name, spec.name );
+	sprintf(spec.name, "%s%i", PHYSICAL_DISK, drive);
+	strcpy(file_name, spec.name);
 
 	spec.type = PhysicalDiskType;
 	size = 0;
@@ -460,82 +426,65 @@
 	bytes_transferred = 0;
 
 	// Getting information about the size of the drive.
-	return( Set_Sizes() );
+	return (Set_Sizes());
 }
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
-
-
 //
 // Setting the maximum amount of disk space to access during testing.
 //
-void TargetDisk::Set_Size( int maximum_size )
+void TargetDisk::Set_Size(int maximum_size)
 {
-	DWORDLONG	new_size;
+	DWORDLONG new_size;
 
 	// Getting the actual size of the disk.
 	Set_Sizes();
-	new_size = (DWORDLONG) maximum_size * (DWORDLONG) spec.disk_info.sector_size;
+	new_size = (DWORDLONG) maximum_size *(DWORDLONG) spec.disk_info.sector_size;
 
 	// If the specified maximum size is not 0 and is smaller than the actual disk,
 	// reset the disk size.
-	if ( new_size && ( new_size < size ) )
-	{
+	if (new_size && (new_size < size)) {
 		size = new_size;
-		#if _DEBUG
-			cout << "Resetting accessible size of disk " << spec.name << " to " << 
-				maximum_size << " sectors." << endl << "   " << spec.name <<
-				" size = " << size << endl;
-		#endif
+#if _DEBUG
+		cout << "Resetting accessible size of disk " << spec.name << " to " <<
+		    maximum_size << " sectors." << endl << "   " << spec.name << " size = " << size << endl;
+#endif
 	}
 }
 
-
-
-
-
 //
 // Setting the starting sector of the disk where accesses should begin.
 // This needs to be called after setting the size of the disk (call to Set_Size).
 //
-void TargetDisk::Set_Starting_Sector( int starting_sector )
+void TargetDisk::Set_Starting_Sector(int starting_sector)
 {
-	DWORDLONG	current_size;
+	DWORDLONG current_size;
 
-	starting_position = (DWORDLONG) starting_sector * (DWORDLONG) spec.disk_info.sector_size;
-	#if _DEBUG
-		cout << "Moving starting sector of disk " << spec.name << " to " << 
-			starting_position << "." << endl;
-	#endif
+	starting_position = (DWORDLONG) starting_sector *(DWORDLONG) spec.disk_info.sector_size;
 
+#if _DEBUG
+	cout << "Moving starting sector of disk " << spec.name << " to " << starting_position << "." << endl;
+#endif
+
 	// Moving the starting disk sector may have shrunk the accessible size of the disk.
 	current_size = size;	// record the currently assigned size to use
-	Set_Size();				// getting the actual disk size
+	Set_Size();		// getting the actual disk size
 
-	if ( starting_position + current_size > size )
-	{
+	if (starting_position + current_size > size) {
 		// Re-adjust the accessible size of the disk to reflect the new starting sector.
 		size -= starting_position;
-		#if _DEBUG
-			cout << "Starting sector size has shrunk the effective size of the disk." << endl;
-		#endif
-	}
-	else
-	{
+#if _DEBUG
+		cout << "Starting sector size has shrunk the effective size of the disk." << endl;
+#endif
+	} else {
 		// The new starting sector did not affect the accessible disk size.
 		size = current_size;
 	}
 	ending_position = (DWORDLONG) starting_position + size;
 }
 
-
-
-
-
 //
 // Setting information about the physical size of the drive.  This is
 // used in order to guarantee that accesses to the drive are permitted,
@@ -546,7 +495,7 @@
 //
 // Performs same function as the win32 || _WIN64 version.
 //
-BOOL TargetDisk::Set_Sizes( BOOL open_disk )
+BOOL TargetDisk::Set_Sizes(BOOL open_disk)
 {
 	struct stat fileInfo;
 	struct statfs fsInfo;
@@ -558,9 +507,9 @@
 		if (!Open(NULL)) {
 #ifdef _DEBUG
 			cout << __FUNCTION__ << ": Open on \"" << file_name <<
-				"\" failed (error " << strerror(errno) << ").\n";
-#endif			
-			return(FALSE);
+			    "\" failed (error " << strerror(errno) << ").\n";
+#endif
+			return (FALSE);
 		}
 		fd = ((struct File *)disk_file)->fd;
 	}
@@ -582,10 +531,10 @@
 			if (open_disk) {
 				Close(NULL);
 			}
-			return(FALSE);
+			return (FALSE);
 		}
 		spec.disk_info.sector_size = fsInfo.f_bsize;
-		sector_align_mask = ~((DWORDLONG)fsInfo.f_bsize - 1);
+		sector_align_mask = ~((DWORDLONG) fsInfo.f_bsize - 1);
 		/* Free blocks is "f_bfree". */
 		if (open_disk) {
 			statResult = fstat(fd, &fileInfo);
@@ -593,12 +542,11 @@
 			statResult = stat(file_name, &fileInfo);
 		}
 		if (statResult < 0) {
-			cerr << __FUNCTION__ << ": Error " << strerror(errno) <<
-				"statting file " << file_name << "\n";
+			cerr << __FUNCTION__ << ": Error " << strerror(errno) << "statting file " << file_name << "\n";
 			if (open_disk) {
 				Close(NULL);
 			}
-			return(FALSE);
+			return (FALSE);
 		}
 		size = fileInfo.st_size;
 		if (size == 0) {
@@ -607,27 +555,26 @@
 				Close(NULL);
 			}
 			unlink(file_name);
-			return(TRUE);
+			return (TRUE);
 		}
 		ending_position = size;
 		spec.disk_info.ready = TRUE;
 		if (open_disk) {
 			Close(NULL);
 		}
-		return(TRUE);
+		return (TRUE);
 	} else {
 		spec.disk_info.sector_size = getSectorSizeOfPhysDisk(file_name);
 		if (spec.disk_info.sector_size == 0) {
-			cerr << __FUNCTION__ << ": Failed to get sector size. Aborting " <<
-				"target.\n";
+			cerr << __FUNCTION__ << ": Failed to get sector size. Aborting " << "target.\n";
 			if (open_disk) {
 				Close(NULL);
 			}
-			return(FALSE);
+			return (FALSE);
 		}
 		size = getSizeOfPhysDisk(file_name);
 		alignment = 0;
-		sector_align_mask = ~((DWORDLONG)spec.disk_info.sector_size - 1);
+		sector_align_mask = ~((DWORDLONG) spec.disk_info.sector_size - 1);
 		ending_position = size;
 		offset = 0;
 		bytes_transferred = 0;
@@ -635,14 +582,14 @@
 		if (open_disk) {
 			Close(NULL);
 		}
-		return(TRUE);
+		return (TRUE);
 	}
 }
 #elif defined(IOMTR_OS_NETWARE)
 //
 // Performs same function as the win32 || _WIN64 version.
 //
-BOOL TargetDisk::Set_Sizes( BOOL open_disk )
+BOOL TargetDisk::Set_Sizes(BOOL open_disk)
 {
 	struct stat fileInfo;
 	struct stat fsInfo;
@@ -652,187 +599,163 @@
 	struct volume_info spaceInfo;
 	struct IOObjectGenericInfoDef info;
 
-	if (open_disk) 
-	{
-		if (!Open(NULL)) 
-		{
+	if (open_disk) {
+		if (!Open(NULL)) {
 #ifdef _DEBUG
 			cout << __FUNCTION__ << ": Open on \"" << file_name <<
-				"\" failed (error " << strerror(errno) << ").\n";
-#endif			
-			return(FALSE);
+			    "\" failed (error " << strerror(errno) << ").\n";
+#endif
+			return (FALSE);
 		}
 		fd = ((struct File *)disk_file)->fd;
 	}
-	if (IsType(spec.type, LogicalDiskType)) 
-	{
+	if (IsType(spec.type, LogicalDiskType)) {
 		/*
 		 * For logical disks, we use statfs and stat to find the size of the
 		 * file system, the size of the test file, the sector size for the
 		 * file system, etc. Pretty straightforward, standard Unix stuff.
 		 */
 		strcpy(filesysName, file_name);
-		filesysName[strlen(filesysName) - (strlen(TEST_FILE)+1)] = '\0'; //and the colon
-		if (open_disk) 
-		{
+		filesysName[strlen(filesysName) - (strlen(TEST_FILE) + 1)] = '\0';	//and the colon
+		if (open_disk) {
 			statResult = fstat(fd, &fsInfo);
-		} else 
-		{
+		} else {
 			statResult = stat(filesysName, &fsInfo);
 		}
-		
+
 		netware_vol_info(&spaceInfo, (int *)&fsInfo.st_dev);
 
-		if (statResult < 0) 
-		{
+		if (statResult < 0) {
 			printf("%s: Couldn't stat logical disk file!\n", __FUNCTION__);
-			if (open_disk) 
-			{
+			if (open_disk) {
 				Close(NULL);
 			}
-			return(FALSE);
+			return (FALSE);
 		}
 		spec.disk_info.sector_size = spaceInfo.SectorsPerCluster;
-		sector_align_mask = ~((DWORDLONG)spaceInfo.SectorsPerCluster - 1);
+		sector_align_mask = ~((DWORDLONG) spaceInfo.SectorsPerCluster - 1);
 		/* Free blocks is "f_bfree". */
-		if (open_disk) 
-		{
+		if (open_disk) {
 			statResult = fstat(fd, &fileInfo);
-		} else 
-		{
+		} else {
 			statResult = stat(file_name, &fileInfo);
 		}
-		if (statResult < 0) 
-		{
+		if (statResult < 0) {
 			printf("%s: Error %s statting file %s\n", __FUNCTION__, strerror(errno), file_name);
-			if (open_disk) 
-			{
+			if (open_disk) {
 				Close(NULL);
 			}
-			return(FALSE);
+			return (FALSE);
 		}
-//		size = fileInfo.st_size;
+//              size = fileInfo.st_size;
 		size = spaceInfo.FreedClusters;
-		if (size == 0) 
-		{
+		if (size == 0) {
 			spec.disk_info.ready = FALSE;
-			if (open_disk) 
-			{
+			if (open_disk) {
 				Close(NULL);
 			}
 			unlink(file_name);
-			return(TRUE);
+			return (TRUE);
 		}
 		ending_position = size;
 		spec.disk_info.ready = TRUE;
-		if (open_disk) 
-		{
+		if (open_disk) {
 			Close(NULL);
 		}
-		return(TRUE);
-	} else if ( IsType( spec.type, PhysicalDiskType ) ) // physical
+		return (TRUE);
+	} else if (IsType(spec.type, PhysicalDiskType))	// physical
 	{
 		MM_ReturnObjectGenericInfo(atoi(file_name), sizeof(struct IOObjectGenericInfoDef), &info);
 		spec.disk_info.sector_size = info.unitsize;
-		if (spec.disk_info.sector_size == 0) 
-		{
+		if (spec.disk_info.sector_size == 0) {
 			cout << __FUNCTION__ << ": Failed to get sector size. Aborting target." << endl;
-			return(FALSE);
+			return (FALSE);
 		}
 		size = info.capacity;
 		alignment = 0;
-		sector_align_mask = ~((DWORDLONG)spec.disk_info.sector_size - 1);
+		sector_align_mask = ~((DWORDLONG) spec.disk_info.sector_size - 1);
 		ending_position = size;
 		offset = 0;
 		bytes_transferred = 0;
 		spec.disk_info.ready = TRUE;
-		if ( open_disk )
-			Close( NULL );
-		return(TRUE);
-	}
-	else
-	{
+		if (open_disk)
+			Close(NULL);
+		return (TRUE);
+	} else {
 		cout << "*** Unexpected drive type in Disk::SetSizes()" << endl << flush;
-		if ( open_disk )
-			Close( NULL );
-		return ( FALSE );
-	}		
+		if (open_disk)
+			Close(NULL);
+		return (FALSE);
+	}
 }
 #elif defined(IOMTR_OS_SOLARIS)
-int TargetDisk::Set_Sizes( BOOL open_disk )
+int TargetDisk::Set_Sizes(BOOL open_disk)
 {
-	DWORD			fd;
-// 	DWORD       		i;
-//	DWORD			low_size, high_size;
-//	DWORD			sectors_per_cluster, free_clusters, total_clusters;
-//	BOOL			foundPartitions = FALSE;
-//	DWORD			disk_info_size;
-	struct statvfs		st;
-	struct dk_geom		disk_geo_info;
-	struct vtoc		disk_vtoc;
+	DWORD fd;
 
+//      DWORD                   i;
+//      DWORD                   low_size, high_size;
+//      DWORD                   sectors_per_cluster, free_clusters, total_clusters;
+//      BOOL                    foundPartitions = FALSE;
+//      DWORD                   disk_info_size;
+	struct statvfs st;
+	struct dk_geom disk_geo_info;
+	struct vtoc disk_vtoc;
+
 	// Logical and physical drives are treated differently.
-	if ( open_disk )
-	{
-		if (!Open( NULL ) )
-			return( FALSE );
+	if (open_disk) {
+		if (!Open(NULL))
+			return (FALSE);
 	}
 
-	if ( IsType( spec.type, LogicalDiskType ) )
-	{
+	if (IsType(spec.type, LogicalDiskType)) {
 		// Getting physical information about the drive. All we need is the sector size. !!!!
-		if ( statvfs(file_name, &st) < 0)
-		{
+		if (statvfs(file_name, &st) < 0) {
 			cout << "statvfs error " << errno << ". Cannot get sector size" << endl;
-			if ( open_disk )
-				Close( NULL );
-			return(FALSE);
+			if (open_disk)
+				Close(NULL);
+			return (FALSE);
 		}
 		// Which one of these two do we take as the sector size ?
-		spec.disk_info.sector_size = (int) st.f_bsize;
+		spec.disk_info.sector_size = (int)st.f_bsize;
 		//           or
 		// spec.disk_info.sector_size = SECTOR_SIZE;
 
 		// Ok move on to the file size
 		struct stat64 stbuf64;
-		if (stat64(file_name, &stbuf64) < 0)
-		{
+
+		if (stat64(file_name, &stbuf64) < 0) {
 			cout << "unable to get file size. stat64() failed with error " << errno << endl;
-			if ( open_disk )
-				Close ( NULL );
-			return(FALSE);
+			if (open_disk)
+				Close(NULL);
+			return (FALSE);
 		}
 		size = stbuf64.st_size;
 
 		Set_Sector_Info();
-		#if _DEBUG
-			cout << "   " << spec.name << " size = " << size << endl << flush;
-		#endif
-		if ( open_disk )
-			Close( NULL );
+#if _DEBUG
+		cout << "   " << spec.name << " size = " << size << endl << flush;
+#endif
+		if (open_disk)
+			Close(NULL);
 
 		// If test file exists, the drive is ready for access.
-		if ( size )
-		{
+		if (size) {
 			ending_position = size;
 			spec.disk_info.ready = TRUE;
-			return( TRUE );
+			return (TRUE);
 		}
-
 		// Assuming that unlink always succeeds and never fails. how clever! #@$#%
-		unlink( file_name );
+		unlink(file_name);
 		spec.disk_info.ready = FALSE;
-		return( TRUE );
-	}
-	else if ( IsType( spec.type, PhysicalDiskType ) )
-	{
+		return (TRUE);
+	} else if (IsType(spec.type, PhysicalDiskType)) {
 		// Dealing with a physical drive.
 		// Checking for a partition to exist on the physical drive.
 		// If one is there, then disallowing access to the drive.
-		SetLastError( 0 );
-			
-		if (! strstr(file_name, "p0"))
-		{
+		SetLastError(0);
+
+		if (!strstr(file_name, "p0")) {
 			// We are probably working with a slice.
 			int length;
 			int part;
@@ -840,196 +763,173 @@
 
 			strcpy(part_name, spec.name);
 			length = strlen(spec.name);
-			part = atoi((char *)(part_name + length-1));
+			part = atoi((char *)(part_name + length - 1));
 			spec.disk_info.sector_size = SECTOR_SIZE;
 
-			if ((char)part_name[length-2] == 's')
-			{
+			if ((char)part_name[length - 2] == 's') {
 				// We are dealing with a slice
 				size = Get_Slice_Size(part_name, part);
 #ifdef _DEBUG
 				cout << " slice size : " << size << endl;
 #endif
-				if (size <= 0)
-				{
-					if ( open_disk )
-						Close( NULL );
-					return(FALSE);
+				if (size <= 0) {
+					if (open_disk)
+						Close(NULL);
+					return (FALSE);
 				}
 			}
 #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64) || defined(IOMTR_CPU_PPC)
-			else
-			{
+			else {
 				// We are dealing with an fdisk partition.
 				size = Get_Partition_Size(part_name, part);
 #ifdef _DEBUG
 				cout << " partn size : " << size << endl;
 #endif
-				if (size <= 0)
-				{
-					if ( open_disk )
-						Close( NULL );
-					return(FALSE);
+				if (size <= 0) {
+					if (open_disk)
+						Close(NULL);
+					return (FALSE);
 				}
 			}
-#endif // __i386 || _IA64 || _PPC
+#endif				// __i386 || _IA64 || _PPC
 #ifdef _DEBUG
 			cout << "spec name : " << spec.name
-				<< " part_name : " << part_name << " part : " << part <<  endl;
+			    << " part_name : " << part_name << " part : " << part << endl;
 #endif
-		}
-		else
-		{			
+		} else {
 			// Getting information on the size of the drive.
 			fd = ((struct File *)disk_file)->fd;
-			if (ioctl( fd, DKIOCG_PHYGEOM, &disk_geo_info) < 0)
-			{
+			if (ioctl(fd, DKIOCG_PHYGEOM, &disk_geo_info) < 0) {
 				// unable to get disk geometry. Report disk as NO_DRIVE
 				if (open_disk)
-					Close( NULL );
-				return(FALSE);
+					Close(NULL);
+				return (FALSE);
 			}
-
 			// Getting sector size of the disk.
 			// First try to get the sector size from the dkio(vtoc). 
 			// If that fails, then return the default.
-		
+
 			// NOTE: NOTE: NOTE:
 			// We do this because of a problem with ioctl(DKIOCGVTOC). It fails for a
 			// freshly formatted disk. But once u create something on it and then 
 			// even if you clean it all up, the call still succeeds.
 			//
-			if (ioctl( fd, DKIOCGVTOC, &disk_vtoc) < 0)
+			if (ioctl(fd, DKIOCGVTOC, &disk_vtoc) < 0)
 				spec.disk_info.sector_size = SECTOR_SIZE;
 			else
 				spec.disk_info.sector_size = disk_vtoc.v_sectorsz;
 
 			// Calculating the size of the physical drive..
-			size = ((DWORDLONG) disk_geo_info.dkg_ncyl * disk_geo_info.dkg_nhead * 
-					disk_geo_info.dkg_nsect * spec.disk_info.sector_size);
+			size = ((DWORDLONG) disk_geo_info.dkg_ncyl * disk_geo_info.dkg_nhead *
+				disk_geo_info.dkg_nsect * spec.disk_info.sector_size);
 		}
 
 		Set_Sector_Info();
 
-		#if _DEBUG
-			cout << "   " << spec.name << " size = " << size << endl << flush;
-		#endif
+#if _DEBUG
+		cout << "   " << spec.name << " size = " << size << endl << flush;
+#endif
 
-		if ( open_disk )
-			Close( NULL );
+		if (open_disk)
+			Close(NULL);
 
 		ending_position = size;
 		spec.disk_info.ready = TRUE;
-		return( TRUE );
-	}
-	else
-	{
+		return (TRUE);
+	} else {
 		cout << "*** Unexpected drive type in Disk::SetSizes()" << endl << flush;
-		if ( open_disk )
-			Close( NULL );
-		return ( FALSE );
-	}		
+		if (open_disk)
+			Close(NULL);
+		return (FALSE);
+	}
 }
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-BOOL TargetDisk::Set_Sizes( BOOL open_disk )
+BOOL TargetDisk::Set_Sizes(BOOL open_disk)
 {
-	DWORD		i;
-	DWORD		low_size, high_size;
-	DWORD		sectors_per_cluster, free_clusters, total_clusters;
-	DWORD		sector_size;
-	DRIVE_LAYOUT_INFORMATION	disk_layout_info[MAX_PARTITIONS];
-	DISK_GEOMETRY				disk_geo_info;
-	DWORD						disk_info_size;
+	DWORD i;
+	DWORD low_size, high_size;
+	DWORD sectors_per_cluster, free_clusters, total_clusters;
+	DWORD sector_size;
+	DRIVE_LAYOUT_INFORMATION disk_layout_info[MAX_PARTITIONS];
+	DISK_GEOMETRY disk_geo_info;
+	DWORD disk_info_size;
 
 	// Logical and physical drives are treated differently.
-	if ( open_disk )
-	{
-		if ( !Open( NULL ) )
+	if (open_disk) {
+		if (!Open(NULL))
 			return FALSE;
 	}
 
-	if ( IsType( spec.type, LogicalDiskType ) )
-	{
+	if (IsType(spec.type, LogicalDiskType)) {
 		// Getting physical information about the drive.
-		if ( !GetDiskFreeSpace( spec.name, &sectors_per_cluster, &sector_size,
-			&free_clusters, &total_clusters) )
-		{
-			cout << "Error getting sector size of drive " << spec.name 
-				<< "." << endl;
-			if ( open_disk )
-				Close( NULL );
+		if (!GetDiskFreeSpace(spec.name, &sectors_per_cluster, &sector_size, &free_clusters, &total_clusters)) {
+			cout << "Error getting sector size of drive " << spec.name << "." << endl;
+			if (open_disk)
+				Close(NULL);
 			return FALSE;
 		}
-		spec.disk_info.sector_size = (int) sector_size;
+		spec.disk_info.sector_size = (int)sector_size;
 
 		// Determining if the test file exists or needs to be made.
-		low_size = GetFileSize( disk_file, &high_size );
-		size = ( ( (DWORDLONG) high_size ) << 32 ) | (DWORDLONG) low_size;
+		low_size = GetFileSize(disk_file, &high_size);
+		size = (((DWORDLONG) high_size) << 32) | (DWORDLONG) low_size;
 		Set_Sector_Info();
-		#if _DEBUG
-			cout << "   " << spec.name << " size = " << size << endl;
-		#endif
-		if ( open_disk )
-			Close( NULL );
+#if _DEBUG
+		cout << "   " << spec.name << " size = " << size << endl;
+#endif
+		if (open_disk)
+			Close(NULL);
 
 		// If test file exists, the drive is ready for access.
-		if ( size )
-		{
+		if (size) {
 			ending_position = size;
 			spec.disk_info.ready = TRUE;
 			return TRUE;
 		}
 
-		DeleteFile( file_name );
+		DeleteFile(file_name);
 		spec.disk_info.ready = FALSE;
 		return TRUE;
-	}
-	else if ( IsType( spec.type, PhysicalDiskType ) )
-	{
+	} else if (IsType(spec.type, PhysicalDiskType)) {
 		// Dealing with a physical drive.
 		// Checking for a partition to exist on the physical drive.
 		// If one is there, then disallowing access to the drive.
-		SetLastError( 0 );
- 		DeviceIoControl( disk_file, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0,
-			disk_layout_info, sizeof( disk_layout_info ), &disk_info_size, NULL );
+		SetLastError(0);
+		DeviceIoControl(disk_file, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0,
+				disk_layout_info, sizeof(disk_layout_info), &disk_info_size, NULL);
 
 		// Checking that drive contains nothing but free space.
-		for ( i = 0; i < disk_layout_info[0].PartitionCount; i++ )
-		{
-			if ( disk_layout_info[0].PartitionEntry[i].PartitionLength.HighPart ||
-				disk_layout_info[0].PartitionEntry[i].PartitionLength.LowPart )
-			{
-				if ( open_disk )
-					Close( NULL );
-			        cout << "Physical disk \'" << spec.name << "\' contains partition information." << endl;
+		for (i = 0; i < disk_layout_info[0].PartitionCount; i++) {
+			if (disk_layout_info[0].PartitionEntry[i].PartitionLength.HighPart ||
+			    disk_layout_info[0].PartitionEntry[i].PartitionLength.LowPart) {
+				if (open_disk)
+					Close(NULL);
+				cout << "Physical disk \'" << spec.name << "\' contains partition information." << endl;
 				return FALSE;
 			}
 		}
 		// Getting information on the size of the drive.
-		DeviceIoControl( disk_file, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
-			&disk_geo_info, sizeof( disk_geo_info ), &disk_info_size, NULL );
+		DeviceIoControl(disk_file, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,
+				&disk_geo_info, sizeof(disk_geo_info), &disk_info_size, NULL);
 
 		// Calculating the size of the physical drive..
-		size = ( ( (DWORDLONG) disk_geo_info.Cylinders.HighPart ) << 32 ) | 
-			( (DWORDLONG) disk_geo_info.Cylinders.LowPart );
-		size *= (_int64) disk_geo_info.TracksPerCylinder * 
-			(_int64) disk_geo_info.SectorsPerTrack * 
-			(_int64) disk_geo_info.BytesPerSector;
+		size = (((DWORDLONG) disk_geo_info.Cylinders.HighPart) << 32) |
+		    ((DWORDLONG) disk_geo_info.Cylinders.LowPart);
+		size *= (_int64) disk_geo_info.TracksPerCylinder *
+		    (_int64) disk_geo_info.SectorsPerTrack * (_int64) disk_geo_info.BytesPerSector;
 		spec.disk_info.sector_size = disk_geo_info.BytesPerSector;
 		Set_Sector_Info();
 
-		#if _DEBUG
-			cout << "   " << spec.name << " size = " << size << endl;
-		#endif
+#if _DEBUG
+		cout << "   " << spec.name << " size = " << size << endl;
+#endif
 
-		if ( open_disk )
-			Close( NULL );
+		if (open_disk)
+			Close(NULL);
 		ending_position = size;
 		spec.disk_info.ready = TRUE;
 		return TRUE;
-	}
-	else
-	{
+	} else {
 		cout << "*** Unexpected drive type in TargetDisk::SetSizes()" << endl;
 		return FALSE;
 	}
@@ -1037,66 +937,61 @@
 #elif defined(IOMTR_OS_OSX)
 int TargetDisk::Set_Sizes(BOOL open_disk)
 {
-	struct statfs		st;
-	DWORD			fd;
+	struct statfs st;
+	DWORD fd;
 
-	if ( open_disk )
-	{
+	if (open_disk) {
 		if (!Open(NULL))
-			return( FALSE );
+			return (FALSE);
 	}
 
-	if ( IsType( spec.type, LogicalDiskType) )
-	{
-		if (statfs(file_name, &st) < 0)
-		{
+	if (IsType(spec.type, LogicalDiskType)) {
+		if (statfs(file_name, &st) < 0) {
 			cout << "statfs error " << errno << ". Cannot get sector size" << endl;
-			if ( open_disk )
-				Close( NULL );
-			return( FALSE);
+			if (open_disk)
+				Close(NULL);
+			return (FALSE);
 		}
-		spec.disk_info.sector_size = (int) st.f_bsize;
+		spec.disk_info.sector_size = (int)st.f_bsize;
 
 		// Ok move on the file size
 		struct stat stbuf64;
-		if (stat(file_name, &stbuf64) < 0)
-		{
+
+		if (stat(file_name, &stbuf64) < 0) {
 			cout << "unable to get file size. stat failed with error " << errno << endl;
-			if ( open_disk )
-				Close( NULL );
+			if (open_disk)
+				Close(NULL);
 			return (FALSE);
 		}
 		size = stbuf64.st_size;
 
 		Set_Sector_Info();
-		#if _DEBUG
-			cout << "    " << spec.name << " size = " << size << endl << flush;
-		#endif
-		if ( open_disk)
-			Close( NULL );
-	
+#if _DEBUG
+		cout << "    " << spec.name << " size = " << size << endl << flush;
+#endif
+		if (open_disk)
+			Close(NULL);
+
 		// If test file exists, the drive is ready for access.
-		if (size)
-		{
+		if (size) {
 			ending_position = size;
 			spec.disk_info.ready = TRUE;
 			return (TRUE);
 		}
-
 		// Assuming that unlink always succeeds and never fails
-		unlink( file_name );
+		unlink(file_name);
 		spec.disk_info.ready = FALSE;
 		return (TRUE);
-	} else if ( IsType( spec.type, PhysicalDiskType ) ) {
+	} else if (IsType(spec.type, PhysicalDiskType)) {
 		SetLastError(0);
 
 		fd = ((struct File *)disk_file)->fd;
 
-		if (ioctl(fd,DKIOCGETBLOCKSIZE, &spec.disk_info.sector_size) < 0) {
+		if (ioctl(fd, DKIOCGETBLOCKSIZE, &spec.disk_info.sector_size) < 0) {
 			spec.disk_info.sector_size = 0;
 		}
 
-		if (ioctl(fd,DKIOCGETBLOCKCOUNT, &size) < 0) {
+		if (ioctl(fd, DKIOCGETBLOCKCOUNT, &size) < 0) {
 			size = 0;
 		}
 
@@ -1104,46 +999,40 @@
 
 		Set_Sector_Info();
 
-		#if _DEBUG
-			cout << "    " << spec.name << " size = " << size << endl << flush;
-		#endif
+#if _DEBUG
+		cout << "    " << spec.name << " size = " << size << endl << flush;
+#endif
 
-		if ( open_disk )
-			Close( NULL );
+		if (open_disk)
+			Close(NULL);
 
 		ending_position = size;
 		spec.disk_info.ready = TRUE;
-		return( TRUE );
+		return (TRUE);
 	} else {
 		cout << "*** Unexpected drive type in Disk::SetSizes()" << endl << flush;
-		if ( open_disk )
+		if (open_disk)
 			Close(NULL);
-		return( FALSE );
+		return (FALSE);
 	}
 }
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
-
-
 //
 // Setting additional information about the drive's sector size.
 // The sector size of the drive needs to be known before calling this function.
 //
 void TargetDisk::Set_Sector_Info()
 {
-	DWORD	temp_sector;
+	DWORD temp_sector;
 
 	// Check if sector size is a power of 2, by repeatedly dividing the sector size by 2 
 	// (until we get to 1) and checking to see if the result is odd at any point.
 	temp_sector = spec.disk_info.sector_size;
-	while ( temp_sector > 1 )
-	{
-		if ( temp_sector % 2 )
-		{
+	while (temp_sector > 1) {
+		if (temp_sector % 2) {
 			sector_align_mask = NOT_POWER_OF_TWO;
 			return;
 		}
@@ -1159,13 +1048,9 @@
 	//           (DWORDLONG)spec.disk_info.sector_size      = 0x0000000000000200
 	//          ((DWORDLONG)spec.disk_info.sector_size - 1) = 0x00000000000001FF
 	//         ~((DWORDLONG)spec.disk_info.sector_size - 1) = 0xFFFFFFFFFFFFFE00
-	sector_align_mask = ~( (DWORDLONG)spec.disk_info.sector_size - 1 );
+	sector_align_mask = ~((DWORDLONG) spec.disk_info.sector_size - 1);
 }
 
-
-
-
-
 #define PREPARE_QDEPTH	16
 
 //
@@ -1178,15 +1063,15 @@
 // returns only when all queued I/Os have completed.  
 // Return value is TRUE for success, FALSE if any error occurred.
 //
-BOOL TargetDisk::Prepare( void* buffer, DWORDLONG *prepare_offset, DWORD bytes, volatile TestState *test_state )
+BOOL TargetDisk::Prepare(void *buffer, DWORDLONG * prepare_offset, DWORD bytes, volatile TestState * test_state)
 {
-	BOOL			write_ok;
-	int				num_outstanding;
-	DWORD			bytes_written;
-	OVERLAPPED		olap[PREPARE_QDEPTH];
-	BOOL			busy[PREPARE_QDEPTH];
-	BOOL			retval;
-	int				i;
+	BOOL write_ok;
+	int num_outstanding;
+	DWORD bytes_written;
+	OVERLAPPED olap[PREPARE_QDEPTH];
+	BOOL busy[PREPARE_QDEPTH];
+	BOOL retval;
+	int i;
 
 #ifdef _DEBUG
 	cout << "into function TargetDisk::Prepare()" << endl;
@@ -1197,28 +1082,25 @@
 	retval = TRUE;
 
 	// Initialize the OVERLAPPED structures.
-	for ( i = 0; i < PREPARE_QDEPTH; i++ )
-	{
+	for (i = 0; i < PREPARE_QDEPTH; i++) {
 		// Create an event.
-		olap[i].hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
+		olap[i].hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
 
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 		SetQueueSize(olap[i].hEvent, 1);
-#elif defined(IOMTR_OSFAMILY_WINDOWS) 
+#elif defined(IOMTR_OSFAMILY_WINDOWS)
 		// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 		// Was the event created successfully?
-		if ( olap[i].hEvent == NULL )
-		{
-			cerr << "*** CreateEvent() failed in TargetDisk::Prepare()" << endl; 
+		if (olap[i].hEvent == NULL) {
+			cerr << "*** CreateEvent() failed in TargetDisk::Prepare()" << endl;
 			write_ok = FALSE;	// don't perform any I/O
-			retval = FALSE;		// return failure status
-			break;				// break out of initialization loop
+			retval = FALSE;	// return failure status
+			break;	// break out of initialization loop
 		}
-
 		// Set the low-order bit of the event handle to prevent it from being
 		// picked up by a later call to GetQueuedCompletionStatus() (e.g. in
 		// Grunt::Asynchronous_IOs).
@@ -1233,120 +1115,98 @@
 		//     queued to the completion port. 
 		//
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		olap[i].hEvent = (HANDLE) ( (UINT_PTR) olap[i].hEvent | 0x0000000000000001 );
+		olap[i].hEvent = (HANDLE) ((UINT_PTR) olap[i].hEvent | 0x0000000000000001);
 #else
-		olap[i].hEvent = (HANDLE) ( (unsigned long) olap[i].hEvent | 0x00000001 );
+		olap[i].hEvent = (HANDLE) ((unsigned long)olap[i].hEvent | 0x00000001);
 #endif
 
-
 		// Mark the slot's initial state as idle.
 		busy[i] = FALSE;
 	}
 
-	do
-	{
+	do {
 		// If we're still writing and there are any available slots, queue up some
 		// writes.
-		if ((*test_state == TestPreparing) &&
-				write_ok &&
-				(num_outstanding < PREPARE_QDEPTH))
-		{
+		if ((*test_state == TestPreparing) && write_ok && (num_outstanding < PREPARE_QDEPTH)) {
 			// Loop through the I/O queue looking for idle slots.
-			for ( i = 0; i < PREPARE_QDEPTH; i++ )
-			{
+			for (i = 0; i < PREPARE_QDEPTH; i++) {
 				// Check to see if we've reached the end of the disk
 				if (spec.disk_info.maximum_size &&
-				    ((*prepare_offset + bytes) > ((spec.disk_info.starting_sector + (DWORDLONG)spec.disk_info.maximum_size) * spec.disk_info.sector_size)))
-				{
+				    ((*prepare_offset + bytes) >
+				     ((spec.disk_info.starting_sector +
+				       (DWORDLONG) spec.disk_info.maximum_size) * spec.disk_info.sector_size))) {
 					// A maximum disk size was specified by the user, and the next write 
 					// would go past the specified maximum size.  
-					#if _DEBUG
-						cout << "User-specified maximum size reached!" << endl;
-					#endif
+#if _DEBUG
+					cout << "User-specified maximum size reached!" << endl;
+#endif
 					// Stop writing and break out of the write loop.
 					write_ok = FALSE;
 					break;
 				}
-
 				// If we are still writing and the slot is not busy, start an I/O for
 				// this slot.
-				if ( (*test_state == TestPreparing) && write_ok && !busy[i] )
-				{
+				if ((*test_state == TestPreparing) && write_ok && !busy[i]) {
 					// Set its address.
-					olap[i].Offset = (DWORD) *prepare_offset;
-					olap[i].OffsetHigh = (DWORD) ( *prepare_offset >> 32 );
+					olap[i].Offset = (DWORD) * prepare_offset;
+					olap[i].OffsetHigh = (DWORD) (*prepare_offset >> 32);
 					// Do the asynchronous write.
-					if ( WriteFile( disk_file, (char*) buffer, bytes, &bytes_written,
-													&(olap[i]) ) )
-					{
+					if (WriteFile(disk_file, (char *)buffer, bytes, &bytes_written, &(olap[i]))) {
 						// It succeeded immediately!
 #if _DEBUG
 						cout << "Wrote (immediately) " << bytes_written << " of "
-								 << bytes << " bytes to disk " 
-								 << spec.name << "." << endl;
+						    << bytes << " bytes to disk " << spec.name << "." << endl;
 #endif
 						// Advance the file pointer, but do not mark the slot as busy.
 						*prepare_offset += bytes;
-					}
-					else
-					{
+					} else {
 						// It did not succeed immediately... did it start OK?
-						if ( GetLastError() == ERROR_IO_PENDING )
-						{
+						if (GetLastError() == ERROR_IO_PENDING) {
 							// It started OK.
 #if _DETAILS
-							cout << "I/O started successfully for slot #" << i 
-									 << " for " << bytes << " bytes at address " 
-									 << *prepare_offset << endl;
+							cout << "I/O started successfully for slot #" << i
+							    << " for " << bytes << " bytes at address "
+							    << *prepare_offset << endl;
 #endif
 							// Advance the file pointer and mark the slot as busy.
 							*prepare_offset += bytes;
 							busy[i] = TRUE;
 							num_outstanding++;
-						}
-						else if ( GetLastError() == ERROR_DISK_FULL )
-						{
+						} else if (GetLastError() == ERROR_DISK_FULL) {
 							// The disk filled up -- this is an expected error.
 #if _DEBUG
 							cout << "Disk full (immediately) while writing "
-									 <<	bytes_written << " of " << bytes << " bytes to disk "
-									 <<	spec.name << "." << endl;
+							    << bytes_written << " of " << bytes << " bytes to disk "
+							    << spec.name << "." << endl;
 #endif
 							// Stop writing and break out of the write loop.
 							write_ok = FALSE;
 							break;
-						}
-						else
-						{
+						} else {
 							// It didn't start OK!  Bail out.
 							cout << "***Error (immediately) writing " << bytes_written <<
-								" of " << bytes << " bytes to disk " << spec.name << 
-								", error=" << GetLastError() << endl;
+							    " of " << bytes << " bytes to disk " << spec.name <<
+							    ", error=" << GetLastError() << endl;
 							write_ok = FALSE;	// don't perform any more I/O
-							retval = FALSE;		// return failure status
-							break;				// break out of write loop
+							retval = FALSE;	// return failure status
+							break;	// break out of write loop
 						}
 					}
 				}
 			}
-		} // Done queueing up new writes.
+		}		// Done queueing up new writes.
 
 		// If there are any outstanding I/Os, check to see if any have completed.
-		if ( num_outstanding > 0 )
-		{
+		if (num_outstanding > 0) {
 			// Check all the busy I/O's to see if any have completed
-			for ( i = 0; i < PREPARE_QDEPTH; i++ )
-			{
-				if ( busy[i] )
-				{
+			for (i = 0; i < PREPARE_QDEPTH; i++) {
+				if (busy[i]) {
 					// Check to see if it has completed
-					if ( GetOverlappedResult( disk_file, &(olap[i]), &bytes_written,
-																		FALSE ) )
-					{
+					if (GetOverlappedResult(disk_file, &(olap[i]), &bytes_written, FALSE)) {
 						// It completed successfully!
 #if _DEBUG
 						cout << "Wrote (eventually) " << bytes_written << " of " << bytes
-								 << " bytes to disk "  << spec.name << "." << endl;
+						    << " bytes to disk " << spec.name << "." << endl;
 #endif
 						// Mark the slot as idle.
 						busy[i] = FALSE;
@@ -1354,38 +1214,34 @@
 
 						if (bytes_written != bytes) {
 							cout << "***Error (eventually); wrote only " << bytes_written
-									 << " of " << bytes << " bytes!\n";
+							    << " of " << bytes << " bytes!\n";
 							retval = FALSE;
 							write_ok = FALSE;
 							break;
 						}
-					}
-					else if ( GetLastError() == ERROR_IO_INCOMPLETE )
-					{
+					} else if (GetLastError() == ERROR_IO_INCOMPLETE) {
 						// The I/O has not yet completed -- this is an expected error.
-						#if _DETAILS
-							cout << "I/O not yet complete for slot #" << i << endl;
-						#endif
-						; // Do nothing.
-					}
-					else if ( GetLastError() == ERROR_DISK_FULL )
-					{
+#if _DETAILS
+						cout << "I/O not yet complete for slot #" << i << endl;
+#endif
+						;	// Do nothing.
+					} else if (GetLastError() == ERROR_DISK_FULL) {
 						// The disk filled up -- this is an expected error.
-						#if _DEBUG
-							cout << "Disk full (eventually) while writing " << bytes_written << " of " << bytes << " bytes to disk " << spec.name << "." << endl;
-						#endif
+#if _DEBUG
+						cout << "Disk full (eventually) while writing " << bytes_written <<
+						    " of " << bytes << " bytes to disk " << spec.name << "." << endl;
+#endif
 						// Since the write did not actually succeed, decrement the file pointer.
 						*prepare_offset -= bytes;
 						// Stop writing and mark the slot as idle.
 						write_ok = FALSE;
 						busy[i] = FALSE;
 						num_outstanding--;
-					}
-					else
-					{
+					} else {
 						// The I/O failed!  Bail out.
-						cout << "***Error (eventually) writing " << bytes_written << " of " << bytes << " bytes to disk " << spec.name << 
-								", error=" << GetLastError() << endl;
+						cout << "***Error (eventually) writing " << bytes_written << " of " <<
+						    bytes << " bytes to disk " << spec.
+						    name << ", error=" << GetLastError() << endl;
 						// Stop writing and mark the slot as idle.
 						write_ok = FALSE;
 						busy[i] = FALSE;
@@ -1395,22 +1251,21 @@
 					}
 				}
 			}
-		} // Done checking for I/O completions.
+		}		// Done checking for I/O completions.
 	}
-	while ( (*test_state == TestPreparing) && (write_ok || (num_outstanding > 0)) );
+	while ((*test_state == TestPreparing) && (write_ok || (num_outstanding > 0)));
 	// Keep looping until (the user tells us to stop) OR 
 	// (we're done writing AND we've accumulated all the results).
 
-	Set_Sizes( FALSE );
+	Set_Sizes(FALSE);
 
 	// Destroy the events.
-	for ( i = 0; i < PREPARE_QDEPTH; i++ )
-	{
+	for (i = 0; i < PREPARE_QDEPTH; i++) {
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 		// Reset the handles.
-		olap[i].hEvent = (HANDLE)((ULONG_PTR) olap[i].hEvent ^ 0x1);
+		olap[i].hEvent = (HANDLE) ((ULONG_PTR) olap[i].hEvent ^ 0x1);
 #endif
-		CloseHandle( olap[i].hEvent );
+		CloseHandle(olap[i].hEvent);
 	}
 
 #ifdef _DEBUG
@@ -1419,141 +1274,127 @@
 	return retval;
 }
 
-
-
-
-
 //
 // Opening a disk for low-level access.
 //
-BOOL TargetDisk::Open( volatile TestState *test_state, int open_flag )
+BOOL TargetDisk::Open(volatile TestState * test_state, int open_flag)
 {
 	// open_flag is a 
-	if ( IsType( spec.type, LogicalDiskType ) )
-	{
+	if (IsType(spec.type, LogicalDiskType)) {
 		// Ignore errors that occur if trying to open a floppy or CD-ROM with
 		// nothing in the drive.
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-		((struct File *)disk_file)->fd = open(file_name, O_RDWR|O_CREAT|O_LARGEFILE|open_flag, S_IRUSR|S_IWUSR);
+		((struct File *)disk_file)->fd =
+		    open(file_name, O_RDWR | O_CREAT | O_LARGEFILE | open_flag, S_IRUSR | S_IWUSR);
 #elif defined(IOMTR_OS_NETWARE)
-		NXFileOpen(0, (void *)file_name, (NXMode_t)(NX_O_RDWR|NX_O_CREAT|open_flag), &((struct File *)disk_file)->fd);
-	 	((struct File *)disk_file)->type = LogicalDiskType;
+		NXFileOpen(0, (void *)file_name, (NXMode_t) (NX_O_RDWR | NX_O_CREAT | open_flag),
+			   &((struct File *)disk_file)->fd);
+		((struct File *)disk_file)->type = LogicalDiskType;
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		SetErrorMode( SEM_FAILCRITICALERRORS );
-		disk_file = CreateFile( file_name, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | 
-			FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, NULL );
-		SetErrorMode( 0 );
+		SetErrorMode(SEM_FAILCRITICALERRORS);
+		disk_file = CreateFile(file_name, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |
+				       FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
+				       FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, NULL);
+		SetErrorMode(0);
 #elif defined(IOMTR_OS_OSX)
-		((struct File *)disk_file)->fd = open(file_name, O_RDWR|O_CREAT|open_flag, S_IRUSR|S_IWUSR);
+		((struct File *)disk_file)->fd = open(file_name, O_RDWR | O_CREAT | open_flag, S_IRUSR | S_IWUSR);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	}
-	else if ( IsType( spec.type, PhysicalDiskType ) )
-	{
+	} else if (IsType(spec.type, PhysicalDiskType)) {
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-		((struct File *)disk_file)->fd = open(file_name, O_RDWR|O_LARGEFILE, S_IRUSR|S_IWUSR);
+		((struct File *)disk_file)->fd = open(file_name, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
 #elif defined(IOMTR_OS_NETWARE)
 		((struct File *)disk_file)->fd = NWOpenDevice(atoi(file_name), 0);
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		SetErrorMode( SEM_FAILCRITICALERRORS );
+		SetErrorMode(SEM_FAILCRITICALERRORS);
 		disk_file = CreateFile(file_name, GENERIC_READ | GENERIC_WRITE,
-													 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
-													 OPEN_EXISTING,
-													 FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
-													 NULL );
-		SetErrorMode( 0 );
+				       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+				       OPEN_EXISTING, FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED, NULL);
+		SetErrorMode(0);
 #elif defined(IOMTR_OS_OSX)
-		((struct File *)disk_file)->fd = open(file_name, O_RDWR, S_IRUSR|S_IWUSR);
+		((struct File *)disk_file)->fd = open(file_name, O_RDWR, S_IRUSR | S_IWUSR);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	}
-	else
-	{
+	} else {
 		cout << "*** Unexpected drive type in TargetDisk::Open()" << endl;
 	}
 
 	offset = starting_position;
-	#if _DISK_MSGS
-		cout << "Opening disk " << spec.name << endl;
-	#endif
+#if _DISK_MSGS
+	cout << "Opening disk " << spec.name << endl;
+#endif
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( disk_file == INVALID_HANDLE_VALUE )
+	if (disk_file == INVALID_HANDLE_VALUE)
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	if ( ((struct File *)disk_file)->fd == (int)INVALID_SOCKET )
+	if (((struct File *)disk_file)->fd == (int)INVALID_SOCKET)
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-		return FALSE;
+	return FALSE;
 
 	// Cludgy hack used to control reporting drives.  This will go away when
 	// the TargetDisk class is divided into a disk Target subclass and a
 	// Disk interface class.
-	if ( !test_state )
+	if (!test_state)
 		return TRUE;
 
 	// Indicating where completed asynchronous transfers should be queued.
-	return ( CreateIoCompletionPort( disk_file, io_cq->completion_queue, 0, 1 ) 
-		!= NULL );
+	return (CreateIoCompletionPort(disk_file, io_cq->completion_queue, 0, 1)
+		!= NULL);
 }
 
-
-
 //
 // Closing the disk handle.
 //
-BOOL TargetDisk::Close( volatile TestState *test_state )
+BOOL TargetDisk::Close(volatile TestState * test_state)
 {
 	// Note that test_state is not used.  It IS used by network targets.
 
 	// If testing connection rate, the disk may already be closed.
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	if ( ((struct File *)disk_file)->fd == (int)INVALID_SOCKET )
+	if (((struct File *)disk_file)->fd == (int)INVALID_SOCKET)
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( disk_file == INVALID_HANDLE_VALUE )
+	if (disk_file == INVALID_HANDLE_VALUE)
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		#if _DISK_MSGS
-			cout << "Disk is already closed." << endl;
-		#endif
+#if _DISK_MSGS
+		cout << "Disk is already closed." << endl;
+#endif
 		return TRUE;
 	}
 
-	#if _DISK_MSGS
-		cout << "Closing disk " << spec.name << endl;
-	#endif
+#if _DISK_MSGS
+	cout << "Closing disk " << spec.name << endl;
+#endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	if ( !CloseHandle( disk_file, FILE_ELEMENT) )
+	if (!CloseHandle(disk_file, FILE_ELEMENT))
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( !CloseHandle( disk_file ) )
+	if (!CloseHandle(disk_file))
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		cout << "*** Error " << GetLastError() 
-			 << " closing disk in TargetDisk::Close()." << endl;
-		SetLastError( 0 );
+		cout << "*** Error " << GetLastError()
+		    << " closing disk in TargetDisk::Close()." << endl;
+		SetLastError(0);
 		return FALSE;
 	}
-	
+
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	((struct File *)disk_file)->fd = (int)INVALID_SOCKET;
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	disk_file = INVALID_HANDLE_VALUE;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	return TRUE;
 }
 
-
-
-
-
 //
 // Seek to another position on the disk.  Whether this is a random seek or a sequential
 // seek will be determined by the value of the first parameter.  This does not actually
@@ -1562,198 +1403,166 @@
 // Calling instructions:
 //
 // 1) If user enters an alignment which is a power of two, pass in the user_alignment
-//		the user specified and the precalculated user_align_mask.
-//		This uses fast byte alignment code.
+//              the user specified and the precalculated user_align_mask.
+//              This uses fast byte alignment code.
 // 2) If user enters an alignment which is NOT a power of two, pass in the user_alignment
-//		the user specified and NOT_POWER_OF_TWO for user_align_mask.
-//		This uses slower byte alignment code.
+//              the user specified and NOT_POWER_OF_TWO for user_align_mask.
+//              This uses slower byte alignment code.
 // 3) If user enters an alignment of 0 (zero), sector alignment is assumed.  Pass in
-//		zeroes for both byte_alignment and user_align_mask.
-//		This uses fast byte alignment code as long as the sector size is a power
-//		of two, otherwise it reverts to slower code.
+//              zeroes for both byte_alignment and user_align_mask.
+//              This uses fast byte alignment code as long as the sector size is a power
+//              of two, otherwise it reverts to slower code.
 //
-void TargetDisk::Seek( BOOL random, DWORD request_size, DWORD user_alignment,
-	DWORDLONG user_align_mask )
+void TargetDisk::Seek(BOOL random, DWORD request_size, DWORD user_alignment, DWORDLONG user_align_mask)
 {
 	static DWORDLONG remainder;	// static for performance reasons
 
 	// Find out if this is a random seek.
-	if ( random )
-	{
+	if (random) {
 		// Set the offset to a random location on the disk.
 #if defined(IOMTR_OSFAMILY_UNIX) && defined(WORKAROUND_MOD_BUG)
-		offset = starting_position + (DWORDLONG)fmod(Rand(), size);
+		offset = starting_position + (DWORDLONG) fmod(Rand(), size);
 #else
 		offset = starting_position + Rand() % size;
 #endif
-	}
-	else
-	{
+	} else {
 		// Adjusting the offset pointer by the last number of bytes successfully transferred.
 		offset += (DWORDLONG) bytes_transferred;
 	}
 
-	switch (user_align_mask)
-	{
+	switch (user_align_mask) {
 	case NOT_POWER_OF_TWO:
 		// If not at a user_alignment boundary, move offset ahead to next one.
 		if ((remainder = offset % user_alignment))
 			offset += user_alignment - remainder;
 
 		// See if we're near the end of the file and need to return to the start.
-		if ( (offset + (DWORDLONG) request_size) > ending_position )
-		{
+		if ((offset + (DWORDLONG) request_size) > ending_position) {
 			offset = starting_position;
 
 			// starting_position won't necessarily be byte-aligned.
-			if ((remainder = offset % user_alignment))
-			{
+			if ((remainder = offset % user_alignment)) {
 				offset += user_alignment - remainder;
 
 				// If we went beyond the end of the disk again, report an error.
-				#if _DEBUG
-					if ( (offset + (DWORDLONG) request_size) > ending_position )
-					{
-						cout << "*** Can't align on " << user_alignment
-							 << " byte boundaries" << endl;
+#if _DEBUG
+				if ((offset + (DWORDLONG) request_size) > ending_position) {
+					cout << "*** Can't align on " << user_alignment << " byte boundaries" << endl;
 
-						offset = starting_position;
-					}
-				#endif
+					offset = starting_position;
+				}
+#endif
 			}
 		}
 		break;
 
 	case 0:
 		// Assume sector alignment.
-		if ( sector_align_mask == NOT_POWER_OF_TWO )
-		{
+		if (sector_align_mask == NOT_POWER_OF_TWO) {
 			if ((remainder = offset % spec.disk_info.sector_size))
 				offset += spec.disk_info.sector_size - remainder;
-		}
-		else
-		{
-			if ( offset != (offset & sector_align_mask) )
+		} else {
+			if (offset != (offset & sector_align_mask))
 				offset = (offset + spec.disk_info.sector_size) & sector_align_mask;
 		}
 
 		// See if we're near the end of the file and need to return to the start.
-		if ( (offset + (DWORDLONG) request_size) > ending_position )
-		{
+		if ((offset + (DWORDLONG) request_size) > ending_position) {
 			offset = starting_position;
 
 			// starting_position won't necessarily be sector-aligned.
-			if ( sector_align_mask == NOT_POWER_OF_TWO )
-			{
-				if ((remainder = offset % spec.disk_info.sector_size))
-				{
+			if (sector_align_mask == NOT_POWER_OF_TWO) {
+				if ((remainder = offset % spec.disk_info.sector_size)) {
 					offset += spec.disk_info.sector_size - remainder;
 
 					// If we went beyond the end of the disk again, report an error.
-					#if _DEBUG
-						if ( (offset + (DWORDLONG) request_size) > ending_position )
-						{
-							cout << "*** Can't align on " << spec.disk_info.sector_size
-								 << " byte boundaries" << endl;
+#if _DEBUG
+					if ((offset + (DWORDLONG) request_size) > ending_position) {
+						cout << "*** Can't align on " << spec.disk_info.sector_size
+						    << " byte boundaries" << endl;
 
-							offset = starting_position;
-						}
-					#endif
+						offset = starting_position;
+					}
+#endif
 				}
-			}
-			else
-			{
-				if ( offset != (offset & sector_align_mask) )
-				{
+			} else {
+				if (offset != (offset & sector_align_mask)) {
 					offset = (offset + spec.disk_info.sector_size) & sector_align_mask;
 
 					// If we went beyond the end of the disk again, report an error.
-					#if _DEBUG
-						if ( (offset + (DWORDLONG) request_size) > ending_position )
-						{
-							cout << "*** ERROR: Can't align on " << spec.disk_info.sector_size
-								 << " byte boundaries" << endl;
+#if _DEBUG
+					if ((offset + (DWORDLONG) request_size) > ending_position) {
+						cout << "*** ERROR: Can't align on " << spec.disk_info.sector_size
+						    << " byte boundaries" << endl;
 
-							offset = starting_position;
-						}
-					#endif
+						offset = starting_position;
+					}
+#endif
 				}
 			}
 		}
 		break;
-	
+
 	default:
 		// If not at a user_alignment boundary, move offset ahead to next one.
-		if ( offset != (offset & user_align_mask) )
+		if (offset != (offset & user_align_mask))
 			offset = (offset + user_alignment) & user_align_mask;
 
 		// See if we're near the end of the file and need to return to the start.
-		if ( (offset + (DWORDLONG) request_size) > ending_position )
-		{
+		if ((offset + (DWORDLONG) request_size) > ending_position) {
 			offset = starting_position;
 
 			// starting_position won't necessarily be byte-aligned.
-			if ( offset != (offset & user_align_mask) )
-			{
+			if (offset != (offset & user_align_mask)) {
 				offset = (offset + user_alignment) & sector_align_mask;
 
 				// If we went beyond the end of the disk again, report an error.
-				#if _DEBUG
-					if ( (offset + (DWORDLONG) request_size) > ending_position )
-					{
-						cout << "*** Can't align on " << alignment
-							 << " byte boundaries" << endl;
+#if _DEBUG
+				if ((offset + (DWORDLONG) request_size) > ending_position) {
+					cout << "*** Can't align on " << alignment << " byte boundaries" << endl;
 
-						offset = starting_position;
-					}
-				#endif
+					offset = starting_position;
+				}
+#endif
 			}
 		}
 	}
 }
 
-
-
-
-
 //
 // Reading a user specified amount of data from the drive and returning it.
 // This does not check the request size to be a multiple of the sector size 
 // (except in debug).  For performance reasons, Iometer ensures that the 
 // values are correct.
 //
-ReturnVal TargetDisk::Read( LPVOID buffer, Transaction *trans )
+ReturnVal TargetDisk::Read(LPVOID buffer, Transaction * trans)
 {
-	DWORD	error_no;
+	DWORD error_no;
 
-	#if _DEBUG
-		// Checking for the access to be a multiple of the sector size.
-		// Avoiding this check during actual testing for performance reasons.
-		if ( offset % spec.disk_info.sector_size )
-		{
-			cout << "Invalid offset.  Not aligned with disk sector size for : " << spec.name << endl;
-			return( ReturnError );
-		}
-		if ( trans->size % spec.disk_info.sector_size )
-		{
-			cout << "Invalid transfer size.  Not aligned with disk sector size for : " << spec.name << endl;
-			return( ReturnError );
-		}
-	#endif
+#if _DEBUG
+	// Checking for the access to be a multiple of the sector size.
+	// Avoiding this check during actual testing for performance reasons.
+	if (offset % spec.disk_info.sector_size) {
+		cout << "Invalid offset.  Not aligned with disk sector size for : " << spec.name << endl;
+		return (ReturnError);
+	}
+	if (trans->size % spec.disk_info.sector_size) {
+		cout << "Invalid transfer size.  Not aligned with disk sector size for : " << spec.name << endl;
+		return (ReturnError);
+	}
+#endif
 
-	#if _DETAILS
-		cout << "Reading " << trans->size << " bytes from disk : " 
-			<< spec.name << endl << "   Accessing : " << offset << endl;
-	#endif
-	
+#if _DETAILS
+	cout << "Reading " << trans->size << " bytes from disk : "
+	    << spec.name << endl << "   Accessing : " << offset << endl;
+#endif
+
 	// Determining location of read to disk.
 	trans->asynchronous_io.Offset = (DWORD) offset;
-	trans->asynchronous_io.OffsetHigh = (DWORD) ( offset >> 32 );
+	trans->asynchronous_io.OffsetHigh = (DWORD) (offset >> 32);
 
 	// Reading information from the disk.
-	if ( ReadFile( disk_file, buffer, trans->size, &bytes_transferred, 
-		&trans->asynchronous_io ) )
-	{
+	if (ReadFile(disk_file, buffer, trans->size, &bytes_transferred, &trans->asynchronous_io)) {
 		// Read succeeded immediately, but completion is pending.  It will
 		// still go to the completion queue.
 #if (defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)) && defined(IMMEDIATE_AIO_COMPLETION)
@@ -1762,83 +1571,68 @@
 		// this is for the next sequential I/O.
 		bytes_transferred = trans->size;
 		return ReturnSuccess;
-#else // All other cases UNIX, NT, etc.
+#else				// All other cases UNIX, NT, etc.
 		error_no = ERROR_IO_PENDING;
 #endif
-	}
-	else
-	{
+	} else {
 		error_no = GetLastError();
 	}
 
 	// See if read failed.
-	if ( error_no != ERROR_IO_PENDING )
-	{
+	if (error_no != ERROR_IO_PENDING) {
 		// Record that no bytes were read.
 		bytes_transferred = 0;
-		
+
 		// Return error.
-		cout << "*** Error " << error_no << " reading " << trans->size 
-			<< " bytes from disk " << spec.name << "." << endl;
+		cout << "*** Error " << error_no << " reading " << trans->size
+		    << " bytes from disk " << spec.name << "." << endl;
 		return ReturnError;
 	}
-
 	// An asynchronous read was successfully initiated!
 
 	// Record number of bytes *to be* transferred (ReadFile() set this to 0).
 	// This value will be used to determine location of next sequential I/O.
 	bytes_transferred = trans->size;
 
-	#if _DETAILS
-		cout << "Queued read for " << trans->size << " bytes from disk " 
-			<< spec.name << "." << endl;
-	#endif
+#if _DETAILS
+	cout << "Queued read for " << trans->size << " bytes from disk " << spec.name << "." << endl;
+#endif
 	return ReturnPending;
 }
 
-
-
-
-
 //
 // Writing a user defined buffer to the drive.  This does not check the request size 
 // to be a multiple of the sector size (except in debug).  For performance reasons,
 // Iometer ensures that the values are correct.
 //
-ReturnVal TargetDisk::Write( LPVOID buffer, Transaction *trans )
+ReturnVal TargetDisk::Write(LPVOID buffer, Transaction * trans)
 {
-	DWORD	error_no;
+	DWORD error_no;
 
-	#if _DEBUG
-		// Verifying that the amount to be written is a multiple of the sector size.
-		// Avoiding this check during actual testing for performance reasons.
-		if ( offset % spec.disk_info.sector_size )
-		{
-			cout << "Invalid offset.  Not aligned with disk sector size for : " 
-				<< spec.name << endl;
-			return( ReturnError );
-		}
-		if ( trans->size % spec.disk_info.sector_size )
-		{
-			cout << "Invalid transfer size.  Not aligned with disk sector size for : " 
-				<< spec.name << endl;
-			return( ReturnError );
-		}
-	#endif
+#if _DEBUG
+	// Verifying that the amount to be written is a multiple of the sector size.
+	// Avoiding this check during actual testing for performance reasons.
+	if (offset % spec.disk_info.sector_size) {
+		cout << "Invalid offset.  Not aligned with disk sector size for : " << spec.name << endl;
+		return (ReturnError);
+	}
+	if (trans->size % spec.disk_info.sector_size) {
+		cout << "Invalid transfer size.  Not aligned with disk sector size for : " << spec.name << endl;
+		return (ReturnError);
+	}
+#endif
 
-	#if _DETAILS
-		cout << "Writing " << trans->size << " bytes to disk : " << spec.name 
-			<< endl << "   Accessing : " << offset << endl;
-	#endif
+#if _DETAILS
+	cout << "Writing " << trans->size << " bytes to disk : " << spec.name
+	    << endl << "   Accessing : " << offset << endl;
+#endif
 
 	// Determining location of write to disk.
 	trans->asynchronous_io.Offset = (DWORD) offset;
-	trans->asynchronous_io.OffsetHigh = (DWORD) ( offset >> 32 );
+	trans->asynchronous_io.OffsetHigh = (DWORD) (offset >> 32);
 
 	// Writing information from the disk.
-	if ( WriteFile( disk_file, buffer, trans->size, &bytes_transferred, 
-		&trans->asynchronous_io ) )
-	{
+	if (WriteFile(disk_file, buffer, trans->size, &bytes_transferred, &trans->asynchronous_io)) {
 		// Write succeeded immediately, but completion is pending.  It will
 		// still go to the completion queue.
 #if (defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)) && defined(IMMEDIATE_AIO_COMPLETION)
@@ -1847,44 +1641,35 @@
 		// this is for the next sequential I/O.
 		bytes_transferred = trans->size;
 		return ReturnSuccess;
-#else // All other cases UNIX, NT, etc.
+#else				// All other cases UNIX, NT, etc.
 		error_no = ERROR_IO_PENDING;
 #endif
-	}
-	else
-	{
+	} else {
 		error_no = GetLastError();
 	}
 
 	// See if write failed.
-	if ( error_no != ERROR_IO_PENDING )
-	{
+	if (error_no != ERROR_IO_PENDING) {
 		// Record that no bytes were written.
 		bytes_transferred = 0;
-		
+
 		// Return error code.
-		cout << "*** Error " << error_no << " writing " << trans->size 
-			<< " bytes to disk " << spec.name << "." << endl;
+		cout << "*** Error " << error_no << " writing " << trans->size
+		    << " bytes to disk " << spec.name << "." << endl;
 		return ReturnError;
 	}
-
 	// An asynchronous write was successfully initiated!  
-	
+
 	// Record number of bytes *to be* transferred (WriteFile() set this to 0).
 	// This value will be used to determine location of next sequential I/O.
 	bytes_transferred = trans->size;
 
-	#if _DETAILS
-		cout << "Queued write for " << trans->size << " bytes to disk " 
-			<< spec.name << "." << endl;
-	#endif
+#if _DETAILS
+	cout << "Queued write for " << trans->size << " bytes to disk " << spec.name << "." << endl;
+#endif
 	return ReturnPending;
 }
 
-
-
-
-
 #if defined(IOMTR_OSFAMILY_UNIX)
 #if defined(IOMTR_OS_SOLARIS)
 #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64)
@@ -1895,16 +1680,14 @@
 	int bytes_read, i;
 	struct mboot *mb;
 	struct ipart *ip;
-	struct File		*fp;
+	struct File *fp;
 
 	fp = (struct File *)disk_file;
-	if ((bytes_read = read(fp->fd, buffer, SECTOR_SIZE)) < SECTOR_SIZE)
-	{
+	if ((bytes_read = read(fp->fd, buffer, SECTOR_SIZE)) < SECTOR_SIZE) {
 		// cannot read from the disk. So we should try to use it.
 		// simply return (TRUE) indicating that it has partitions.
-		return(TRUE);
+		return (TRUE);
 	}
-
 	//
 	// We have read 512 bytes of the first cylinder, first sector.
 	// It contains the master boot record, the partition table and mboot signature (viz 0xAA55)
@@ -1912,18 +1695,16 @@
 	mb = (struct mboot *)buffer;
 	if (mb->signature != MBB_MAGIC)
 		// Hmmm... This drive appears to be freshly formatted. guess we can report it.!
-		return(FALSE);
-	else
-	{
+		return (FALSE);
+	else {
 		// well, we did have a valid signature in the mboot. Look for valid partitions.
-		for (i = 0; i < FD_NUMPART; i++)
-		{
-			ip = (struct ipart *) (buffer + BOOTSZ + (i * sizeof(struct ipart)));
+		for (i = 0; i < FD_NUMPART; i++) {
+			ip = (struct ipart *)(buffer + BOOTSZ + (i * sizeof(struct ipart)));
 			if (ip->numsect || ip->relsect)
-				return(TRUE);
+				return (TRUE);
 		}
 	}
-	return(FALSE);
+	return (FALSE);
 }
 
 DWORDLONG TargetDisk::Get_Partition_Size(char *part_name, int part)
@@ -1935,91 +1716,87 @@
 	int length;
 
 	length = strlen(part_name);
-	part_name[length-1] = '0'; 		// Converting cXtXdXpX to cXtXdXp0
+	part_name[length - 1] = '0';	// Converting cXtXdXpX to cXtXdXp0
 	sprintf(disk_name, "%s/%s", RAW_DEVICE_DIR, part_name);
 	fd = open(disk_name, O_RDONLY);
-	if (fd < 0)
-	{
-		return(0);
+	if (fd < 0) {
+		return (0);
 	}
 
-	if ((bytes_read = read(fd, buffer, SECTOR_SIZE)) < SECTOR_SIZE)
-	{
+	if ((bytes_read = read(fd, buffer, SECTOR_SIZE)) < SECTOR_SIZE) {
 		close(fd);
-		return(0);
+		return (0);
 	}
-
 	//
 	// We have read 512 bytes of the first cylinder, first sector.
 	// It contains the master boot record, the partition table and mboot signature (viz 0xAA55)
 	//
 	close(fd);
-	ip = (struct ipart *) (buffer + BOOTSZ + ((part-1) * sizeof(struct ipart)));
-	return((DWORDLONG)ip->numsect * SECTOR_SIZE);
+	ip = (struct ipart *)(buffer + BOOTSZ + ((part - 1) * sizeof(struct ipart)));
+	return ((DWORDLONG) ip->numsect * SECTOR_SIZE);
 }
-#endif // __i386 || _IA64
+#endif				// __i386 || _IA64
 
 DWORDLONG TargetDisk::Get_Slice_Size(char *part_name, int part)
 {
 	char disk_name[MAX_NAME];
-//	int bytes_read;
-  int fd;
+
+//      int bytes_read;
+	int fd;
 	struct vtoc this_vtoc;
 	int length;
 
 	length = strlen(part_name);
-	part_name[length-1] = '2'; 		// Converting cXtXdXsX to cXtXdXs2
+	part_name[length - 1] = '2';	// Converting cXtXdXsX to cXtXdXs2
 	sprintf(disk_name, "%s/%s", RAW_DEVICE_DIR, part_name);
 	fd = open(disk_name, O_RDONLY);
-	if (fd < 0)
-	{
-		return(0);
+	if (fd < 0) {
+		return (0);
 	}
 
-	if (ioctl(fd, DKIOCGVTOC, &this_vtoc) < 0)
-	{
+	if (ioctl(fd, DKIOCGVTOC, &this_vtoc) < 0) {
 		close(fd);
-		return(0);
+		return (0);
 	}
 	//
 	// We have the vtoc.
 	// It contains the slice info (including size).
 	//
 	close(fd);
-	return((DWORDLONG)this_vtoc.v_part[part].p_size * this_vtoc.v_sectorsz);
+	return ((DWORDLONG) this_vtoc.v_part[part].p_size * this_vtoc.v_sectorsz);
 }
-#endif // SOLARIS
+#endif				// SOLARIS
 
 #if defined(IOMTR_OS_LINUX)
 
-static int getSectorSizeOfPhysDisk(const char *devName) {
-	char        devNameBuf[40];
+static int getSectorSizeOfPhysDisk(const char *devName)
+{
+	char devNameBuf[40];
 	const char *fullDevName;
-	int         fd, ssz;
+	int fd, ssz;
 
-	if( devName[0] == '/' ) {
+	if (devName[0] == '/') {
 		fullDevName = devName;
 	} else {
-		sprintf( devNameBuf, "%s/%s", RAW_DEVICE_DIR, devName );
+		sprintf(devNameBuf, "%s/%s", RAW_DEVICE_DIR, devName);
 		fullDevName = devNameBuf;
 	}
-	if( (fd = open( fullDevName, O_RDWR )) < 0 ) {
+	if ((fd = open(fullDevName, O_RDWR)) < 0) {
 		cerr << "Fail to open device" << endl;
 		return 0;
 	}
+	// Use BLKBSZGET here as opposed to BLKSSZGET.  BLKSSZGET returns the
+	// true sector size of the physical disk which should be what we want.
+	// However, Linux will always use the potential cluster size of the 
+	// file system even for raw devices with no file system.  So we use 
+	// BLKBSZGET which returns the (potential) file system cluster size.
 
-        // Use BLKBSZGET here as opposed to BLKSSZGET.  BLKSSZGET returns the
-        // true sector size of the physical disk which should be what we want.
-        // However, Linux will always use the potential cluster size of the 
-        // file system even for raw devices with no file system.  So we use 
-        // BLKBSZGET which returns the (potential) file system cluster size.
-
-	if( ioctl( fd, BLKBSZGET, &ssz ) < 0 ) {
+	if (ioctl(fd, BLKBSZGET, &ssz) < 0) {
 		cerr << "Fail to get sector size for " << fullDevName << endl;
-	        close( fd );	
-		return 0; 
+		close(fd);
+		return 0;
 	}
-	close( fd );	
+	close(fd);
 	return ssz;
 }
 
@@ -2031,43 +1808,42 @@
 // Return value:
 //   The size (in bytes) of the named device.
 //
-static unsigned long long getSizeOfPhysDisk(const char *devName) {
-	char               devNameBuf[MAX_NAME];
-	const char         *fullDevName;
-	int                fd;
+static unsigned long long getSizeOfPhysDisk(const char *devName)
+{
+	char devNameBuf[MAX_NAME];
+	const char *fullDevName;
+	int fd;
 	unsigned long long sz64;
 	unsigned long sz32;
 
-	if( devName[0] == '/' ) {
+	if (devName[0] == '/') {
 		fullDevName = devName;
 	} else {
 		sprintf(devNameBuf, "%s/%s", RAW_DEVICE_DIR, devName);
 		fullDevName = devNameBuf;
 	}
-	if( (fd = open(fullDevName, O_RDWR)) < 0 ) {
+	if ((fd = open(fullDevName, O_RDWR)) < 0) {
 		cerr << "Fail to open device" << endl;
 		return 0;
 	}
-	if( ioctl(fd, BLKGETSIZE64, &sz64) < 0 ) {
-		cerr << "Fail to get size for " << fullDevName << " by BLKGETSIZE64"<< endl;
-		if( ioctl(fd, BLKGETSIZE, &sz32) < 0 ) {
+	if (ioctl(fd, BLKGETSIZE64, &sz64) < 0) {
+		cerr << "Fail to get size for " << fullDevName << " by BLKGETSIZE64" << endl;
+		if (ioctl(fd, BLKGETSIZE, &sz32) < 0) {
 			cerr << "Fail to get size for " << fullDevName << "by BLKGETSIZE" << endl;
-				close( fd );
-			return 0; 
-		}
-		else {
+			close(fd);
+			return 0;
+		} else {
 			sz64 = sz32;
 			sz64 <<= 9;
 		}
 	}
+#ifdef _DEBUG
+	cout << "Device " << fullDevName << " size:" << sz64 << "Bytes." << endl;
+#endif
 
-	#ifdef _DEBUG
-		cout << "Device " << fullDevName << " size:" << sz64 << "Bytes." << endl;
-	#endif
-
-	close( fd );
+	close(fd);
 	return sz64;
 }
 
-#endif // Linux
-#endif // UNIX
+#endif				// Linux
+#endif				// UNIX

Modified: branches/IOMETER-restruct/iometer/src/IOTargetDisk.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTargetDisk.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTargetDisk.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -67,26 +67,24 @@
 #ifndef TARGET_DISK_DEFINED
 #define TARGET_DISK_DEFINED
 
-
 #include "IOCommon.h"
 #include "IOTarget.h"
 #include "IOTest.h"
 #include "IOCQAIO.h"
 
-
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- #ifndef _LP64
- #define _LP64 /* to get at the 64 bit max long. */
- #define _LP64_DEFINED
- #endif /* _LP64 */
- #define MAX_DISK_SIZE	LONG_MAX
- #ifdef _LP64_DEFINED
- #undef _LP64
- #endif /* _LP64_DEFINED */
+#ifndef _LP64
+#define _LP64			/* to get at the 64 bit max long. */
+#define _LP64_DEFINED
+#endif				/* _LP64 */
+#define MAX_DISK_SIZE	LONG_MAX
+#ifdef _LP64_DEFINED
+#undef _LP64
+#endif				/* _LP64_DEFINED */
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
- #define MAX_DISK_SIZE	_I64_MAX
+#define MAX_DISK_SIZE	_I64_MAX
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 #define MAX_PARTITIONS	26
@@ -97,114 +95,110 @@
 #define TEST_FILE		"iobw.tst"
 
 #if defined(IOMTR_OSFAMILY_UNIX)
- #define ERROR_DISK_FULL					ENOSPC
- #define SECTOR_SIZE						512
- #if defined(IOMTR_OS_SOLARIS)
-  #define RAW_DEVICE_DIR					"/dev/rdsk"
- #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX)
-  #define RAW_DEVICE_DIR					"/dev"
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
- #endif
+#define ERROR_DISK_FULL					ENOSPC
+#define SECTOR_SIZE						512
+#if defined(IOMTR_OS_SOLARIS)
+#define RAW_DEVICE_DIR					"/dev/rdsk"
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX)
+#define RAW_DEVICE_DIR					"/dev"
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 #elif defined(IOMTR_OSFAMILY_NETWARE)
- #define ERROR_DISK_FULL					1
- #define SECTOR_SIZE						512
- LONG NWalertroutine(unsigned long, unsigned long, unsigned long, unsigned long);
+#define ERROR_DISK_FULL					1
+#define SECTOR_SIZE						512
+LONG NWalertroutine(unsigned long, unsigned long, unsigned long, unsigned long);
 #endif
 
-
 //
 // Logical or physical disk drives.
 //
-class TargetDisk : public Target
-{
-public:
-	
+class TargetDisk:public Target {
+      public:
+
 	TargetDisk();
 	~TargetDisk();
 
-	BOOL		Initialize( Target_Spec *target_info, CQ *cq );
+	BOOL Initialize(Target_Spec * target_info, CQ * cq);
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	// Initialize logical disks (e.g. C:, D:, E:, etc.).
-	BOOL		Init_Logical( char drive );
+	BOOL Init_Logical(char drive);
 	// Initialize physical (system) disks (e.g. physicaldisk0, physicaldisk1, etc.).
-	BOOL		Init_Physical( int drive );
+	BOOL Init_Physical(int drive);
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	BOOL		Init_Logical( char *drive );
-	BOOL		Init_Physical( char *drive );
+	BOOL Init_Logical(char *drive);
+	BOOL Init_Physical(char *drive);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	void		Set_Size( int maximum_size = 0 );
-	void		Set_Starting_Sector( int starting_sector = 0 );
+	void Set_Size(int maximum_size = 0);
+	void Set_Starting_Sector(int starting_sector = 0);
 
-	BOOL		Prepare( void *buffer, DWORDLONG *prepare_offset, DWORD bytes, volatile TestState *test_state );
+	BOOL Prepare(void *buffer, DWORDLONG * prepare_offset, DWORD bytes, volatile TestState * test_state);
 
-	BOOL		Open( volatile TestState *test_state, int open_flag = 0 );
-	BOOL		Close( volatile TestState *test_state );
+	BOOL Open(volatile TestState * test_state, int open_flag = 0);
+	BOOL Close(volatile TestState * test_state);
 
-	ReturnVal	Read( LPVOID buffer, Transaction *trans );
-	ReturnVal	Write( LPVOID buffer, Transaction *trans );
+	ReturnVal Read(LPVOID buffer, Transaction * trans);
+	ReturnVal Write(LPVOID buffer, Transaction * trans);
 
 	// Set the offset to the next position on the disk (random or sequential).
-	void		Seek( BOOL random, DWORD request_size, DWORD user_alignment, DWORDLONG user_align_mask );
+	void Seek(BOOL random, DWORD request_size, DWORD user_alignment, DWORDLONG user_align_mask);
 
-	char		file_name[MAX_NAME];
+	char file_name[MAX_NAME];
 
-protected:
+      protected:
 
-	BOOL		Set_Sizes( BOOL open_disk = TRUE );	// Get physical drive dimensions.
-	void		Set_Sector_Info();
+	 BOOL Set_Sizes(BOOL open_disk = TRUE);	// Get physical drive dimensions.
+	void Set_Sector_Info();
 
-private:
+      private:
 
-	CQAIO		*io_cq;
-	HANDLE		disk_file;
+	 CQAIO * io_cq;
+	HANDLE disk_file;
 
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	struct File	file_handle;
+	struct File file_handle;
 #endif
 
-	DWORDLONG	size;				// Size of the disk in bytes.
-	DWORD		alignment;			// Alignment I/Os on this address.
-	DWORDLONG	sector_align_mask;		// Bit mask to align requests to sector sizes.
-							// This only works for sectors a power of 2.
-							// Set to NOT_POWER_OF_TWO otherwise.
-	DWORDLONG	starting_position;		// First bytes where transfers occur.
-	DWORDLONG	ending_position;		// Last byte where transfers can occur.
-	DWORDLONG	offset;
-	DWORD		bytes_transferred;		// Number of bytes successfully transferred to the disk.
+	DWORDLONG size;		// Size of the disk in bytes.
+	DWORD alignment;	// Alignment I/Os on this address.
+	DWORDLONG sector_align_mask;	// Bit mask to align requests to sector sizes.
+	// This only works for sectors a power of 2.
+	// Set to NOT_POWER_OF_TWO otherwise.
+	DWORDLONG starting_position;	// First bytes where transfers occur.
+	DWORDLONG ending_position;	// Last byte where transfers can occur.
+	DWORDLONG offset;
+	DWORD bytes_transferred;	// Number of bytes successfully transferred to the disk.
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
- 	LONG mmAppTag;
- 	HNDL reservationHandle;
+	LONG mmAppTag;
+	HNDL reservationHandle;
 	HNDL applicationHandle;
 	OBID objectid;
 	LONG reservationmode;
 	LONG alerttoken;
-	struct ApplicationRegistrationDef1
-	{															
-	   	LONG   classobjectsignature;
-   		BYTE  *name;
-	   	LONG (*controlroutine)(LONG token,LONG _function,LONG p1,LONG p2,LONG p3,LONG bufferlength,void *buffer );
-	   	LONG   privilegedapplicationkey;
-	   	LONG   type;
-	   	LONG   token;
-	   	LONG   identifier;
+	struct ApplicationRegistrationDef1 {
+		LONG classobjectsignature;
+		BYTE *name;
+		 LONG(*controlroutine) (LONG token, LONG _function, LONG p1, LONG p2, LONG p3, LONG bufferlength,
+					void *buffer);
+		LONG privilegedapplicationkey;
+		LONG type;
+		LONG token;
+		LONG identifier;
 	} appDef;
-public:
+      public:
 	int NWOpenDevice(LONG device, LONG mode);
 	int NWCloseDevice(HNDL handle);
 #endif
 #if defined(IOMTR_OS_SOLARIS)
-	BOOL		Look_For_Partitions();			// private member function to look for partitions on disk.
-	DWORDLONG	Get_Partition_Size(char *, int);	// private member function to get the partition size.
-	DWORDLONG	Get_Slice_Size(char *, int);		// private member function to get the slice size.
+	BOOL Look_For_Partitions();	// private member function to look for partitions on disk.
+	DWORDLONG Get_Partition_Size(char *, int);	// private member function to get the partition size.
+	DWORDLONG Get_Slice_Size(char *, int);	// private member function to get the slice size.
 #endif
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOTargetTCP.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTargetTCP.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTargetTCP.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,7 +61,6 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOTargetTCP.h"
 
 //////////////////////////////////////////////////////////////////////
@@ -74,155 +73,130 @@
 	is_server = CLIENT;
 }
 
-
-
 //
 // Initializes the local side of a TCP connection depending on whether
 // the remote side is a TCP server or client.
 //
-BOOL TargetTCP::Initialize( Target_Spec *target_info, CQ *cq )
+BOOL TargetTCP::Initialize(Target_Spec * target_info, CQ * cq)
 {
 	// Record completion queue.
-	io_cq = (CQAIO*)cq;
+	io_cq = (CQAIO *) cq;
 
-	if ( IsType( target_info->type, TCPClientType ) )
-	{
+	if (IsType(target_info->type, TCPClientType)) {
 		// Target is a client - local connection is a server.
-		return InitServer( target_info );
-	}
-	else if ( IsType( target_info->type, TCPServerType ) )
-	{
+		return InitServer(target_info);
+	} else if (IsType(target_info->type, TCPServerType)) {
 		// Target is a server - local connection is a client.
-		return InitClient( target_info );
-	}
-	else
-	{
+		return InitClient(target_info);
+	} else {
 		cout << "***Invalid target type in TargetTCP::Initialize()." << endl;
 		return FALSE;
 	}
 }
 
-
-
 //
 // Initialize a TCP server at a specific IP address, specified as a string.  
 // Returns the server's port number in *server_port_out (USHRT_MAX in 
 // case of error).
 //
-BOOL TargetTCP::InitServer( Target_Spec *target_info )
+BOOL TargetTCP::InitServer(Target_Spec * target_info)
 {
 	is_server = SERVER;
-	memcpy( &spec, target_info, sizeof( Target_Spec ) );
+	memcpy(&spec, target_info, sizeof(Target_Spec));
 
 	// Initialize lastIO with opposite values for server and client
 	// to avoid hang on Close() if no I/Os are performed.
 	lastIO = READ;
 
 	// Set the address of the server socket.
-	tcp_socket.SetAddress( SERVER, spec.name );
+	tcp_socket.SetAddress(SERVER, spec.name);
 	// Create and bind the server socket.
-	if ( tcp_socket.Create( SERVER ) != ReturnSuccess )
-	{
+	if (tcp_socket.Create(SERVER) != ReturnSuccess) {
 		cout << "*** Failed to create a TCP server port." << endl;
 		target_info->tcp_info.local_port = USHRT_MAX;
 		return FALSE;
 	}
-	
 	// Record the assigned port number (in host byte order).
-	target_info->tcp_info.local_port = ntohs( tcp_socket.server_address.sin_port );
+	target_info->tcp_info.local_port = ntohs(tcp_socket.server_address.sin_port);
 	return TRUE;
 }
 
-
-
 //
 // Initialize a TCP client, given the server's IP address (specified as 
 // a string) and port number. Returns the client's port number in 
 // *client_port_out (USHRT_MAX in case of error).
 //
-BOOL TargetTCP::InitClient(  Target_Spec *target_info )
+BOOL TargetTCP::InitClient(Target_Spec * target_info)
 {
 	is_server = CLIENT;
-	memcpy( &spec, target_info, sizeof( Target_Spec ) );
-	
+	memcpy(&spec, target_info, sizeof(Target_Spec));
+
 	// Initialize lastIO with opposite values for server and client
 	// to avoid hang on Close() if no I/Os are performed.
 	lastIO = WRITE;
 
 	// Set the address of the client socket.
-	tcp_socket.SetAddress( CLIENT, spec.name );
+	tcp_socket.SetAddress(CLIENT, spec.name);
 
 	// Create and bind the client socket.
-	#if _DEBUG
-		cout << "Creating socket " << spec.name << "." << endl << flush;
-	#endif
+#if _DEBUG
+	cout << "Creating socket " << spec.name << "." << endl << flush;
+#endif
 
 	// Make sure we can create the socket.
-	if ( tcp_socket.Create( CLIENT ) != ReturnSuccess )
-	{
+	if (tcp_socket.Create(CLIENT) != ReturnSuccess) {
 		cout << "*** Failed to create TCP client socket." << endl;
 		spec.tcp_info.local_port = USHRT_MAX;
 		return FALSE;
 	}
 	// Record the assigned port number (in host byte order).
-	spec.tcp_info.local_port = ntohs( tcp_socket.client_address.sin_port );
+	spec.tcp_info.local_port = ntohs(tcp_socket.client_address.sin_port);
 
 	// Socket will be re-created in Open() with the same
 	// address and port number, so close it now to prevent
 	// binding error WSAEADDRINUSE.
-	tcp_socket.Close( CLIENT );
+	tcp_socket.Close(CLIENT);
 
 	// Store the ip_address for the remote connection.
 	// we will connect to specified address
-	tcp_socket.SetAddress( SERVER, spec.tcp_info.remote_address,
-		spec.tcp_info.remote_port );
+	tcp_socket.SetAddress(SERVER, spec.tcp_info.remote_address, spec.tcp_info.remote_port);
 	return TRUE;
 }
 
-
-
 //
 // Open a socket.  Blocking call: does not return until connection is established.
 //
-BOOL TargetTCP::Open( volatile TestState *test_state, int open_flag )
+BOOL TargetTCP::Open(volatile TestState * test_state, int open_flag)
 {
-	ReturnVal	result;
+	ReturnVal result;
 
-	if ( is_server ) 
-	{
+	if (is_server) {
 		// Accept an incomming connection on the server socket
 		// until either the accept completes successfully or
 		// the test state changes.
-		tcp_socket.SetTimeout( 1, 0 );
-		
-		do 
-		{
+		tcp_socket.SetTimeout(1, 0);
+
+		do {
 			result = tcp_socket.Accept();
-		} 
-		while ( result == ReturnRetry && *test_state != TestIdle );
+		}
+		while (result == ReturnRetry && *test_state != TestIdle);
 
-		if ( result == ReturnError )
-		{
-			cout << "*** Unable to accept connection opening TCP target."
-				 << endl;
+		if (result == ReturnError) {
+			cout << "*** Unable to accept connection opening TCP target." << endl;
 			return FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		// Create and bind the client socket.
 		// We cannot re-use the same port number.  Set it to 0 so that the system
 		// will assign a new port.
-		tcp_socket.client_address.sin_port = htons( 0 );
-		tcp_socket.Create( CLIENT );
-		
+		tcp_socket.client_address.sin_port = htons(0);
+		tcp_socket.Create(CLIENT);
+
 		// Connect to the server address specified in InitClient()
-		do 
-		{
-			result = tcp_socket.ConnectSocket( &tcp_socket.server_address );
+		do {
+			result = tcp_socket.ConnectSocket(&tcp_socket.server_address);
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-			if ( result != ReturnSuccess )
-			{
+			if (result != ReturnSuccess) {
 				// According to connect(3XN):
 				//      If connect() fails, the state of the socket
 				//      is unspecified.  Portable applications
@@ -230,79 +204,63 @@
 				//      create a new socket before attempting to
 				//      reconnect.
 
-				tcp_socket.Close( CLIENT );
-				if ( tcp_socket.Create( CLIENT ) != ReturnSuccess )
-				{
+				tcp_socket.Close(CLIENT);
+				if (tcp_socket.Create(CLIENT) != ReturnSuccess) {
 					cout << "*** Failed to re-create TCP client socket." << endl;
 					return FALSE;
 				}
 			}
-#endif // UNIX
-		} 
-		while ( result == ReturnRetry && *test_state != TestIdle );
+#endif				// UNIX
+		}
+		while (result == ReturnRetry && *test_state != TestIdle);
 
-		if ( result == ReturnError )
-		{
-			cout << "*** Unable to connect to server opening TCP target."
-				 << endl;
+		if (result == ReturnError) {
+			cout << "*** Unable to connect to server opening TCP target." << endl;
 			return FALSE;
 		}
 	}
 
 	// Indicating where completed asynchronous transfers should be queued.
-	return ( CreateIoCompletionPort( (HANDLE)tcp_socket.client_socket, 
-		io_cq->completion_queue, 0, 1 ) != NULL );
+	return (CreateIoCompletionPort((HANDLE) tcp_socket.client_socket, io_cq->completion_queue, 0, 1) != NULL);
 }
 
-
-
 //
 // Close a socket.
 //
-BOOL TargetTCP::Close( volatile TestState *test_state )
+BOOL TargetTCP::Close(volatile TestState * test_state)
 {
 	// Allow the receiving side to disconnect first.
-	if ( lastIO == WRITE )
-	{
-		while ( tcp_socket.WaitForDisconnect() == ReturnRetry && 
-			*test_state != TestIdle )
-			;
+	if (lastIO == WRITE) {
+		while (tcp_socket.WaitForDisconnect() == ReturnRetry && *test_state != TestIdle) ;
 	}
 
-	return ( tcp_socket.Close( CLIENT ) == ReturnSuccess );
+	return (tcp_socket.Close(CLIENT) == ReturnSuccess);
 }
 
-
-
 //
 // Perform receive operation.  NOTE: Direction of call is reversed for client!
 //
-ReturnVal TargetTCP::Read( LPVOID buffer, Transaction *trans )
+ReturnVal TargetTCP::Read(LPVOID buffer, Transaction * trans)
 {
-	DWORD	bytes_read;
-	int		retval;
+	DWORD bytes_read;
+	int retval;
 
-	if ( is_server ) 
-	{
+	if (is_server) {
 		// Keep track of whether the last I/O performed by the target was a read or a write.
 		// This is used to determine which side closes first.
 		lastIO = READ;
 
-		if ( (retval = tcp_socket.Receive( buffer, trans->size, &bytes_read, 
-			&trans->asynchronous_io )) == ReturnError )
-		{
+		if ((retval = tcp_socket.Receive(buffer, trans->size, &bytes_read,
+						 &trans->asynchronous_io)) == ReturnError) {
 			return ReturnError;
 		}
-	}
-	else
-	{
+	} else {
 		// Keep track of whether the last I/O performed by the target was a read or a write.
 		// This is used to determine which side closes first.
 		lastIO = WRITE;
 
-		if ( (retval = tcp_socket.Send( buffer, trans->size, &bytes_read, 
-			&trans->asynchronous_io )) == ReturnError )
-		{
+		if ((retval = tcp_socket.Send(buffer, trans->size, &bytes_read,
+					      &trans->asynchronous_io)) == ReturnError) {
 			return ReturnError;
 		}
 	}
@@ -312,41 +270,34 @@
 	// This prevents the code from looking in the completionQ for immediately completed IOs.
 	if (retval == ReturnSuccess)
 		return ReturnSuccess;
-#endif // UNIX && IMMEDIATE_AIO_COMPLETION
+#endif				// UNIX && IMMEDIATE_AIO_COMPLETION
 	return ReturnPending;
 }
 
-
-
 //
 // Perform send operation.  NOTE: Direction of call is reversed for client!
 //
-ReturnVal TargetTCP::Write( LPVOID buffer, Transaction *trans )
+ReturnVal TargetTCP::Write(LPVOID buffer, Transaction * trans)
 {
-	DWORD	bytes_sent;
-	int		retval;
+	DWORD bytes_sent;
+	int retval;
 
-	if ( is_server ) 
-	{
+	if (is_server) {
 		// Keep track of whether the last I/O performed by the target was a read or a write.
 		// This is used to determine which side closes first.
 		lastIO = WRITE;
 
-		if ( (retval = tcp_socket.Send( buffer, trans->size, &bytes_sent, 
-			&trans->asynchronous_io )) == ReturnError )
-		{
+		if ((retval = tcp_socket.Send(buffer, trans->size, &bytes_sent,
+					      &trans->asynchronous_io)) == ReturnError) {
 			return ReturnError;
 		}
-	}
-	else
-	{
+	} else {
 		// Keep track of whether the last I/O performed by the target was a read or a write.
 		// This is used to determine which side closes first.
 		lastIO = READ;
 
-		if ( (retval = tcp_socket.Receive( buffer, trans->size, &bytes_sent, 
-			&trans->asynchronous_io )) == ReturnError )
-		{
+		if ((retval = tcp_socket.Receive(buffer, trans->size, &bytes_sent,
+						 &trans->asynchronous_io)) == ReturnError) {
 			return ReturnError;
 		}
 	}
@@ -356,6 +307,6 @@
 	// This prevents the code from looking in the completionQ for immediately completed IOs.
 	if (retval == ReturnSuccess)
 		return ReturnSuccess;
-#endif // UNIX && IMMEDIATE_AIO_COMPLETION
+#endif				// UNIX && IMMEDIATE_AIO_COMPLETION
 	return ReturnPending;
 }

Modified: branches/IOMETER-restruct/iometer/src/IOTargetTCP.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTargetTCP.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTargetTCP.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,51 +59,46 @@
 #ifndef TCPTARGET_DEFINED
 #define TCPTARGET_DEFINED
 
-
 #include "IOCommon.h"
 #include "IOTarget.h"
 #include "NetTCP.h"
 #include "IOCQAIO.h"
 
-
-
 //
 // TCP/IP socket class.
 //
-class TargetTCP : public Target
-{
-public:
-	
+class TargetTCP:public Target {
+      public:
+
 	TargetTCP();
-	~TargetTCP() {};
+	~TargetTCP() {
+	};
 
-	BOOL	Initialize( Target_Spec *target_info, CQ *cq );
+	BOOL Initialize(Target_Spec * target_info, CQ * cq);
 
 	// Tells the socket what kind of socket it is (call only one of these)
 	// and who to talk to.
-	BOOL	InitServer( Target_Spec *target_info );
-	BOOL	InitClient( Target_Spec *target_info );
+	BOOL InitServer(Target_Spec * target_info);
+	BOOL InitClient(Target_Spec * target_info);
 
 	// Opens/closes socket (actual action depends on whether the socket 
 	// is a client or server).
-	BOOL	Open( volatile TestState *test_state, int open_flag = 0 );
-	BOOL	Close( volatile TestState *test_state );
+	BOOL Open(volatile TestState * test_state, int open_flag = 0);
+	BOOL Close(volatile TestState * test_state);
 
 	// Performs send/receive operations.  (Reversed for client!!)
-	ReturnVal	Read( LPVOID buffer, Transaction *trans );
-	ReturnVal	Write( LPVOID buffer, Transaction *trans );
+	ReturnVal Read(LPVOID buffer, Transaction * trans);
+	ReturnVal Write(LPVOID buffer, Transaction * trans);
 
 	// Is this socket a TCP server or a client?
-	BOOL			is_server;
+	BOOL is_server;
 
-protected:
+      protected:
 	// Location where completion information should be sent in the case 
 	// of asynchronous I/O.
-	CQAIO			*io_cq;
-	NetAsyncTCP		tcp_socket;
-	ReadWriteType	lastIO;		// Was the last I/O a read or write?
+	CQAIO * io_cq;
+	NetAsyncTCP tcp_socket;
+	ReadWriteType lastIO;	// Was the last I/O a read or write?
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOTargetVI.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTargetVI.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTargetVI.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -57,14 +57,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOTargetVI.h"
 
+#define TARGETVI_DETAILS 0	// Set to 1 for debug messages.
 
-#define TARGETVI_DETAILS 0 // Set to 1 for debug messages.
-
-
-
 //
 // Initializing member variables.
 //
@@ -85,79 +81,71 @@
 	data_buffer_handle = 0;
 }
 
-
-
 //
 // Cleaning up VI target memory.
 //
 TargetVI::~TargetVI()
 {
 	// Release resources registered with VI NIC.
-	if ( descriptors && descriptor_handle )
-		vi_nic.DeregisterMemory( descriptors, descriptor_handle );
+	if (descriptors && descriptor_handle)
+		vi_nic.DeregisterMemory(descriptors, descriptor_handle);
 
-	if ( data_buffer && data_buffer_handle )
-		vi_nic.DeregisterMemory( data_buffer, data_buffer_handle );
+	if (data_buffer && data_buffer_handle)
+		vi_nic.DeregisterMemory(data_buffer, data_buffer_handle);
 
 	// Release descriptor memory.
-	if ( descriptors )
+	if (descriptors)
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		VirtualFree( descriptors, 0, MEM_RELEASE );
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS) 
+		VirtualFree(descriptors, 0, MEM_RELEASE);
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
 		free(descriptors);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	// Close the VI NIC.
-	vi_nic.Close();
+		// Close the VI NIC.
+		vi_nic.Close();
 }
 
-
-
 //
 // Initialize a VI target.  This allocates and registers the descriptors,
 // opens the VI NIC, and associates the completion queue with the NIC.
 //
-BOOL TargetVI::Initialize( Target_Spec *target_info, CQ *completion_queue )
+BOOL TargetVI::Initialize(Target_Spec * target_info, CQ * completion_queue)
 {
-	#if _DEBUG
-		cout << "Initializing VI target on NIC " << target_info->name << endl;
-	#endif
+#if _DEBUG
+	cout << "Initializing VI target on NIC " << target_info->name << endl;
+#endif
 
 	// Open the VI NIC.
-	if ( !vi_nic.Open( target_info->name ) )
-	{
+	if (!vi_nic.Open(target_info->name)) {
 		cout << "*** VI target unable to open VI NIC." << endl;
 		return FALSE;
 	}
-
 	// Allocate I/O descriptors for VI requests and align them on a page
 	// boundary.
 
 	// First free the descriptors.
-	if ( descriptors )
+	if (descriptors)
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-		VirtualFree( descriptors, 0, MEM_RELEASE );
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS) 
+		VirtualFree(descriptors, 0, MEM_RELEASE);
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
 		free(descriptors);
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	// Allocate enough descriptors to meet requested queue depth setting.
-	// We need the requested number of receives, plus one send and two for
-	// control for each queue depth specified
-	descriptor_count = (target_info->vi_info.outstanding_ios + 1) * 
-		target_info->queue_depth + 2;
+		// Allocate enough descriptors to meet requested queue depth setting.
+		// We need the requested number of receives, plus one send and two for
+		// control for each queue depth specified
+		descriptor_count = (target_info->vi_info.outstanding_ios + 1) * target_info->queue_depth + 2;
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	if ( !(descriptors = (VIP_DESCRIPTOR*) VirtualAlloc( NULL, descriptor_count * 
-		sizeof( VIP_DESCRIPTOR ), MEM_COMMIT, PAGE_READWRITE )) )
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS) 
-	if ( !(descriptors = (VIP_DESCRIPTOR*) valloc( descriptor_count * 
-		sizeof( VIP_DESCRIPTOR ) )) )
+	if (!(descriptors = (VIP_DESCRIPTOR *) VirtualAlloc(NULL, descriptor_count *
+							    sizeof(VIP_DESCRIPTOR), MEM_COMMIT, PAGE_READWRITE)))
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+	if (!(descriptors = (VIP_DESCRIPTOR *) valloc(descriptor_count * sizeof(VIP_DESCRIPTOR))))
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
 		// Could not allocate descriptors.  Signal failure.
@@ -170,13 +158,10 @@
 	}
 
 	// Register descriptors with VI NIC.
-	if ( !vi_nic.RegisterMemory( descriptors, descriptor_count *
-		sizeof( VIP_DESCRIPTOR ), &descriptor_handle ) )
-	{
+	if (!vi_nic.RegisterMemory(descriptors, descriptor_count * sizeof(VIP_DESCRIPTOR), &descriptor_handle)) {
 		cout << "*** VI target unable to register descriptors with VI NIC." << endl;
 		return FALSE;
 	}
-
 	// Allocate descriptors for sends and receives.
 	send_count = target_info->queue_depth + 1;
 	recv_count = descriptor_count - send_count;
@@ -194,53 +179,45 @@
 	outstanding_ios = descriptor_count;
 
 	// Register data buffer with VI NIC.
-	if ( !vi_nic.RegisterMemory( data_buffer, data_buffer_size, 
-		&data_buffer_handle ) )
-	{
+	if (!vi_nic.RegisterMemory(data_buffer, data_buffer_size, &data_buffer_handle)) {
 		cout << "*** Unable to register data buffer with VI NIC." << endl;
 		return FALSE;
 	}
-
 	// Return a pointer to the VI completion queue used by this VI connection.
 	completion_queue = &(vi.vi_cq);
-	memcpy( &spec, target_info, sizeof( Target_Spec ) );
+	memcpy(&spec, target_info, sizeof(Target_Spec));
 
 	// Record whether this is the server or client side of the connection.
 	// It is the opposite of what the target is!
-	if ((is_server = IsType( target_info->type, VIClientType)))
-	{
+	if ((is_server = IsType(target_info->type, VIClientType))) {
 		// If this is the server side of the connection, initialize the last
 		// I/O to be a read.  This way, if no I/Os are ever done, the server
 		// will be the one who initializes the close and does not need to
 		// wait on the client.
 		lastIO = READ;
-		#if TARGETVI_DETAILS
-			cout << "Initialized VI server." << endl;
-		#endif
-	}
-	else
-	{
+#if TARGETVI_DETAILS
+		cout << "Initialized VI server." << endl;
+#endif
+	} else {
 		lastIO = WRITE;
-		#if TARGETVI_DETAILS
-			cout << "Initialized VI client." << endl;
-		#endif
+#if TARGETVI_DETAILS
+		cout << "Initialized VI client." << endl;
+#endif
 	}
 
-	return TRUE; 
+	return TRUE;
 }
 
-
-
 //
 // Opening a VI connection using the pre-specified NIC interface.  This is a
 // blocking call.  Note data buffer to use for transfers and data buffer 
 // handle returned from registering the data buffer with the VI NIC must have 
 // been set before making this call.
 //
-BOOL TargetVI::Open( volatile TestState *test_state, int open_flag )
+BOOL TargetVI::Open(volatile TestState * test_state, int open_flag)
 {
-	int			i;
-	ReturnVal	result;
+	int i;
+	ReturnVal result;
 
 	// Initialize information needed to maintain connection management.  See
 	// VI specification for pre-posting requirements.
@@ -252,90 +229,83 @@
 	next_send_index = 0;
 	next_recv_index = 0;
 
-	if ( vi.Create( &vi_nic, this ) != ReturnSuccess )
-	{
+	if (vi.Create(&vi_nic, this) != ReturnSuccess) {
 		cout << "*** Unable to create VI on opened nic." << endl;
 		return FALSE;
 	}
-
 	// Pre-post enough receives to ensure remote side can send immediately
 	// after making the connection.
-	for ( i = 0; i < recv_count; i++ )
-	{
-		if ( PostRecv() != ReturnSuccess )
-		{
+	for (i = 0; i < recv_count; i++) {
+		if (PostRecv() != ReturnSuccess) {
 			cout << "*** Unable to pre-post receives while opening VI." << endl;
 			return FALSE;
 		}
 	}
 
-	#if TARGETVI_DETAILS
-		int ii;
-		cout << "In TargetVI::Open():" << endl;
-		cout << "    is_server = " << is_server << endl;
+#if TARGETVI_DETAILS
+	int ii;
 
-		cout << "    spec.vi_info.local_address.HostAddressLen = " << spec.vi_info.local_address.HostAddressLen << endl;
-		cout << "    spec.vi_info.local_address.HostAddress[0.." << spec.vi_info.local_address.HostAddressLen - 1 << "] = ";
-		for ( ii = 0; ii < spec.vi_info.local_address.HostAddressLen; ii++ )
-		{
-			cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
-		}
-		cout << endl;
-		cout << "    spec.vi_info.local_address.DiscriminatorLen = " << spec.vi_info.local_address.DiscriminatorLen << endl;
-		cout << "    spec.vi_info.local_address.HostAddress[" << spec.vi_info.local_address.HostAddressLen << ".." 
-			<< spec.vi_info.local_address.HostAddressLen + spec.vi_info.local_address.DiscriminatorLen - 1 << "] = ";
-		for ( ii = spec.vi_info.local_address.HostAddressLen; 
-			ii < spec.vi_info.local_address.HostAddressLen + spec.vi_info.local_address.DiscriminatorLen; 
-			ii++ )
-		{
-			cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
-		}
-		cout << endl;
+	cout << "In TargetVI::Open():" << endl;
+	cout << "    is_server = " << is_server << endl;
 
-		cout << "    spec.vi_info.remote_address.HostAddressLen = " << spec.vi_info.remote_address.HostAddressLen << endl;
-		cout << "    spec.vi_info.remote_address.HostAddress[0.." << spec.vi_info.remote_address.HostAddressLen - 1 << "] = ";
-		for ( ii = 0; ii < spec.vi_info.remote_address.HostAddressLen; ii++ )
-		{
-			cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
-		}
-		cout << endl;
-		cout << "    spec.vi_info.remote_address.DiscriminatorLen = " << spec.vi_info.remote_address.DiscriminatorLen << endl;
-		cout << "    spec.vi_info.remote_address.HostAddress[" << spec.vi_info.remote_address.HostAddressLen << ".." 
-			<< spec.vi_info.remote_address.HostAddressLen + spec.vi_info.remote_address.DiscriminatorLen - 1 << "] = ";
-		for ( ii = spec.vi_info.remote_address.HostAddressLen; 
-			ii < spec.vi_info.remote_address.HostAddressLen + spec.vi_info.remote_address.DiscriminatorLen; 
-			ii++ )
-		{
-			cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
-		}
-		cout << endl;
-	#endif
+	cout << "    spec.vi_info.local_address.HostAddressLen = " << spec.vi_info.local_address.HostAddressLen << endl;
+	cout << "    spec.vi_info.local_address.HostAddress[0.." << spec.vi_info.local_address.HostAddressLen -
+	    1 << "] = ";
+	for (ii = 0; ii < spec.vi_info.local_address.HostAddressLen; ii++) {
+		cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
+	}
+	cout << endl;
+	cout << "    spec.vi_info.local_address.DiscriminatorLen = " << spec.vi_info.local_address.
+	    DiscriminatorLen << endl;
+	cout << "    spec.vi_info.local_address.HostAddress[" << spec.vi_info.local_address.
+	    HostAddressLen << ".." << spec.vi_info.local_address.HostAddressLen +
+	    spec.vi_info.local_address.DiscriminatorLen - 1 << "] = ";
+	for (ii = spec.vi_info.local_address.HostAddressLen;
+	     ii < spec.vi_info.local_address.HostAddressLen + spec.vi_info.local_address.DiscriminatorLen; ii++) {
+		cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
+	}
+	cout << endl;
 
+	cout << "    spec.vi_info.remote_address.HostAddressLen = " << spec.vi_info.remote_address.
+	    HostAddressLen << endl;
+	cout << "    spec.vi_info.remote_address.HostAddress[0.." << spec.vi_info.remote_address.HostAddressLen -
+	    1 << "] = ";
+	for (ii = 0; ii < spec.vi_info.remote_address.HostAddressLen; ii++) {
+		cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
+	}
+	cout << endl;
+	cout << "    spec.vi_info.remote_address.DiscriminatorLen = " << spec.vi_info.remote_address.
+	    DiscriminatorLen << endl;
+	cout << "    spec.vi_info.remote_address.HostAddress[" << spec.vi_info.remote_address.
+	    HostAddressLen << ".." << spec.vi_info.remote_address.HostAddressLen +
+	    spec.vi_info.remote_address.DiscriminatorLen - 1 << "] = ";
+	for (ii = spec.vi_info.remote_address.HostAddressLen;
+	     ii < spec.vi_info.remote_address.HostAddressLen + spec.vi_info.remote_address.DiscriminatorLen; ii++) {
+		cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
+	}
+	cout << endl;
+#endif
+
 	// Open VI connection depending on whether this is the client or server
 	// side of the connection.
-	if ( is_server ) 
-	{
+	if (is_server) {
 		// Accept an incomming connection until either the accept completes 
 		// successfully or the test state is idle.
 		do {
-			result = vi.Accept( &spec.vi_info.local_address );
-		} while ( result == ReturnRetry && *test_state != TestIdle );
+			result = vi.Accept(&spec.vi_info.local_address);
+		} while (result == ReturnRetry && *test_state != TestIdle);
 
-		if ( result == ReturnError )
-		{
+		if (result == ReturnError) {
 			cout << "*** Unable to accept connection opening VI target." << endl;
 			return FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		// Connect to the specified VI connection on the server.
 		do {
-			result = vi.Connect( &spec.vi_info.local_address, &spec.vi_info.remote_address );
-		} while ( result == ReturnRetry && *test_state != TestIdle );
+			result = vi.Connect(&spec.vi_info.local_address, &spec.vi_info.remote_address);
+		} while (result == ReturnRetry && *test_state != TestIdle);
 
-		if ( result == ReturnError )
-		{
+		if (result == ReturnError) {
 			cout << "*** Unable to connect to server opening VI target." << endl;
 			return FALSE;
 		}
@@ -343,60 +313,48 @@
 	return TRUE;
 }
 
-
-
 //
 // Closing a VI connection.
 //
-BOOL TargetVI::Close( volatile TestState *test_state )
+BOOL TargetVI::Close(volatile TestState * test_state)
 {
 	// Allow the receiving side to disconnect first.
-	if ( lastIO == WRITE )
-	{
-		while ( vi.CheckForDisconnect() == ReturnRetry && 
-			*test_state != TestIdle )
-			;
+	if (lastIO == WRITE) {
+		while (vi.CheckForDisconnect() == ReturnRetry && *test_state != TestIdle) ;
 	}
 
-	return ( vi.Close() == ReturnSuccess );
+	return (vi.Close() == ReturnSuccess);
 }
 
-
-
 //
 // Performing read operation.  Note that for clients, the call is actually a 
 // write.  The data buffer to use for I/O transfers has already been set, so
 // we ignore the buffer passed in.
 //
-ReturnVal TargetVI::Read( LPVOID buffer, Transaction *trans )
+ReturnVal TargetVI::Read(LPVOID buffer, Transaction * trans)
 {
 	// Clients perform a write.
-	if ( !is_server )
-		return Send( trans );
+	if (!is_server)
+		return Send(trans);
 
 	// Servers perform a read.
-	return Receive( trans );
+	return Receive(trans);
 }
 
-
-
 //
 // Performing an actual receive (read) from the VI connection.
 //
-ReturnVal TargetVI::Receive( Transaction *trans )
+ReturnVal TargetVI::Receive(Transaction * trans)
 {
 	lastIO = READ;
-	#if TARGETVI_DETAILS
-		cout << "Performing I/O read request for transaction " 
-			<< trans->request_number << endl;
-	#endif
+#if TARGETVI_DETAILS
+	cout << "Performing I/O read request for transaction " << trans->request_number << endl;
+#endif
 
 	// If any receives are available, pre-post one.
-	if ( available_receives )
-	{
+	if (available_receives) {
 		// Posting an additional receive.
-		if ( PostRecv() != ReturnSuccess )
-		{
+		if (PostRecv() != ReturnSuccess) {
 			cout << "*** Failed to pre-post a receive over VI." << endl;
 			return ReturnError;
 		}
@@ -404,58 +362,49 @@
 
 		// See if we should send notification to remote side that we have posted 
 		// additional receives.
-		if ( --control_countdown <= 0 )
-		{
-			if ( SendControl() != ReturnSuccess )
-			{
+		if (--control_countdown <= 0) {
+			if (SendControl() != ReturnSuccess) {
 				cout << "*** Failed to send control message over VI." << endl;
 				return ReturnError;
 			}
 			control_countdown = control_countdown_start;
 		}
 	}
-
 	// We need to check on the read that we entered this function to 
 	// actually perform.  Due to pre-posting requirements, we need to see 
 	// if the remote side has already sent the data before we called this.  
 	// If so, then the receive could have been processed by the completion 
 	// queue *before* we requested it.  The completion queue will have 
 	// trapped this and modified the number of requested receives.
-	if ( requested_receives++ < 0 )
-	{
+	if (requested_receives++ < 0) {
 		// Receive is already done and has already posted to the completion
 		// queue.  Return immediate success to signal that the I/O should be
 		// processed immediately and will not appear in the completion queue.
-		#if TARGETVI_DETAILS
-			cout << "Receive was already done." << endl;
-		#endif
+#if TARGETVI_DETAILS
+		cout << "Receive was already done." << endl;
+#endif
 		return ReturnSuccess;
 	}
-
 	// Receive has not yet completed, and its completion will still go to the
 	// completion queue.
 	return ReturnPending;
 }
 
-
-
 //
 // Performing write operation.  Note that for clients, the call is actually a
 // read.  The data buffer to use for I/O transfers has already been set, so
 // we ignore the buffer passed in.
 //
-ReturnVal TargetVI::Write( LPVOID buffer, Transaction *trans )
+ReturnVal TargetVI::Write(LPVOID buffer, Transaction * trans)
 {
 	// Servers perform a write.
-	if ( is_server )
-		return Send( trans );
+	if (is_server)
+		return Send(trans);
 
 	// Clients perform a read.
-	return Receive( trans );
+	return Receive(trans);
 }
 
-
-
 //
 // Post a receive.
 //
@@ -464,8 +413,7 @@
 	// Format the receive descriptor for the maximum transfer size possible.
 	// Not all of this formatting may be necessary.
 	recv_descriptors[next_recv_index].CS.SegCount = 1;
-	recv_descriptors[next_recv_index].CS.Control = VIP_CONTROL_OP_SENDRECV &
-		VIP_CONTROL_IMMEDIATE;
+	recv_descriptors[next_recv_index].CS.Control = VIP_CONTROL_OP_SENDRECV & VIP_CONTROL_IMMEDIATE;
 	recv_descriptors[next_recv_index].CS.Reserved = 0;
 	recv_descriptors[next_recv_index].CS.ImmediateData = 0;
 	recv_descriptors[next_recv_index].CS.Length = data_buffer_size;
@@ -475,60 +423,51 @@
 	recv_descriptors[next_recv_index].DS[0].Local.Handle = data_buffer_handle;
 	recv_descriptors[next_recv_index].DS[0].Local.Length = data_buffer_size;
 
-	if ( vi.Receive( &recv_descriptors[next_recv_index], descriptor_handle )
-		!= ReturnSuccess )
-	{
+	if (vi.Receive(&recv_descriptors[next_recv_index], descriptor_handle)
+	    != ReturnSuccess) {
 		cout << "*** Failed to post a receive for VI connection." << endl;
 		return ReturnError;
 	}
-
 	// Receives complete in the order posted, so update index of next one
 	// available using a circular queue.
-	if ( ++next_recv_index >= recv_count )
+	if (++next_recv_index >= recv_count)
 		next_recv_index = 0;
 
 	return ReturnSuccess;
 }
 
-
-
 //
 // Performing an actual write (send) over a VI connection.
 //
-ReturnVal TargetVI::Send( Transaction *trans )
+ReturnVal TargetVI::Send(Transaction * trans)
 {
 	lastIO = WRITE;
-	#if TARGETVI_DETAILS
-		cout << "Performing I/O write request for transaction " 
-			<< trans->request_number << endl;
-	#endif
+#if TARGETVI_DETAILS
+	cout << "Performing I/O write request for transaction " << trans->request_number << endl;
+#endif
 
 	// Check to see if the completion queue has marked that more sends are
 	// available for requesting.
-	if ( more_sends_available )
-	{
-		#if TARGETVI_DETAILS
-			cout << "Updating number of sends available." << endl;
-		#endif
+	if (more_sends_available) {
+#if TARGETVI_DETAILS
+		cout << "Updating number of sends available." << endl;
+#endif
 
 		more_sends_available = FALSE;
 		available_sends += control_countdown_start;
 
 		// We need to repost the receive needed for control flow.
-		if ( PostRecv() != ReturnSuccess )
-		{
+		if (PostRecv() != ReturnSuccess) {
 			cout << "*** Unable to post send for control flow." << endl;
 			return ReturnError;
 		}
 	}
-
 	// We cannot perform the send unless the remote side has pre-posted the
 	// receive.  Checking to make sure that remote side is ready.
-	if ( !available_sends )
-	{
-		#if TARGETVI_DETAILS
-			cout << "No sends are available." << endl;
-		#endif
+	if (!available_sends) {
+#if TARGETVI_DETAILS
+		cout << "No sends are available." << endl;
+#endif
 
 		// Remote side is not ready.  Abort the operation to signal that the
 		// send failed and should be retried.
@@ -539,8 +478,7 @@
 
 	// Format descriptor.  Not all of this formatting may be necessary.
 	send_descriptors[next_send_index].CS.SegCount = 1;
-	send_descriptors[next_send_index].CS.Control = VIP_CONTROL_OP_SENDRECV &
-		VIP_CONTROL_IMMEDIATE;
+	send_descriptors[next_send_index].CS.Control = VIP_CONTROL_OP_SENDRECV & VIP_CONTROL_IMMEDIATE;
 	send_descriptors[next_send_index].CS.Reserved = 0;
 	send_descriptors[next_send_index].CS.ImmediateData = trans->request_number;
 	send_descriptors[next_send_index].CS.Length = trans->size;
@@ -550,23 +488,19 @@
 	send_descriptors[next_send_index].DS[0].Local.Handle = data_buffer_handle;
 	send_descriptors[next_send_index].DS[0].Local.Length = trans->size;
 
-	if ( vi.Send( &send_descriptors[next_send_index], descriptor_handle )
-		!= ReturnSuccess )
-	{
+	if (vi.Send(&send_descriptors[next_send_index], descriptor_handle)
+	    != ReturnSuccess) {
 		cout << "*** VI send failed to remote VI target." << endl;
 		return ReturnError;
 	}
-
 	// Sends complete in the order posted, so update index of next
 	// available using a circular queue.
-	if ( ++next_send_index >= send_count )
+	if (++next_send_index >= send_count)
 		next_send_index = 0;
 
 	return ReturnPending;
 }
 
-
-
 //
 // Send a control message to the remote side informing it that additional
 // receives are now available.
@@ -576,8 +510,7 @@
 	// Format the descriptor to send with the control information.
 	// Not all of this formatting may be necessary.
 	send_descriptors[next_send_index].CS.SegCount = 1;
-	send_descriptors[next_send_index].CS.Control = VIP_CONTROL_OP_SENDRECV
-		| VIP_CONTROL_IMMEDIATE;
+	send_descriptors[next_send_index].CS.Control = VIP_CONTROL_OP_SENDRECV | VIP_CONTROL_IMMEDIATE;
 	send_descriptors[next_send_index].CS.Reserved = 0;
 	send_descriptors[next_send_index].CS.ImmediateData = CONTROL_MESSAGE;
 	send_descriptors[next_send_index].CS.Length = 0;
@@ -587,20 +520,18 @@
 	send_descriptors[next_send_index].DS[0].Local.Handle = data_buffer_handle;
 	send_descriptors[next_send_index].DS[0].Local.Length = 0;
 
-	#if TARGETVI_DETAILS
-		cout << "Sending control message to remote VI connection." << endl;
-	#endif
+#if TARGETVI_DETAILS
+	cout << "Sending control message to remote VI connection." << endl;
+#endif
 
-	if ( vi.Send( &send_descriptors[next_send_index], descriptor_handle )
-		!= ReturnSuccess )
-	{
+	if (vi.Send(&send_descriptors[next_send_index], descriptor_handle)
+	    != ReturnSuccess) {
 		cout << "*** Failed to send VI control message." << endl;
 		return ReturnError;
 	}
-
 	// Sends complete in the order posted, so update index of next
 	// available using a circular queue.
-	if ( ++next_send_index >= send_count )
+	if (++next_send_index >= send_count)
 		next_send_index = 0;
 
 	return ReturnSuccess;

Modified: branches/IOMETER-restruct/iometer/src/IOTargetVI.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTargetVI.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTargetVI.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,22 +59,17 @@
 #ifndef	TARGETVI_DEFINED
 #define	TARGETVI_DEFINED
 
-
-
 #include "IOTarget.h"
 #include "NetVI.h"
 #include "IOCQVI.h"
 #include "Network.h"
 
-
 ///////////////////////////////////////////////////////////////////////////////
 // Used to indicate that immediate data contains information used
 // to maintain control flow.
 #define CONTROL_MESSAGE 0xFFFFFFFF
 ///////////////////////////////////////////////////////////////////////////////
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // Abstracts VI connections used as targets of I/O requests.
 //
@@ -82,34 +77,31 @@
 // this class.
 //
 ///////////////////////////////////////////////////////////////////////////////
-class TargetVI : public Target
-{
-public:
+class TargetVI:public Target {
+      public:
 
 	TargetVI();
 	~TargetVI();
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Public functions used to manage a VI target.
 	//
-	BOOL		Initialize( Target_Spec *target_info, CQ *completion_queue );
+	BOOL Initialize(Target_Spec * target_info, CQ * completion_queue);
 	//
-	BOOL		Open( volatile TestState *test_state, int open_flag = 0 );
-	BOOL		Close( volatile TestState *test_state );
+	BOOL Open(volatile TestState * test_state, int open_flag = 0);
+	BOOL Close(volatile TestState * test_state);
 	//
-	ReturnVal	Read( LPVOID buffer, Transaction *trans );
-	ReturnVal	Write( LPVOID buffer, Transaction *trans );
-private:
-	ReturnVal	Send( Transaction *trans );
-	ReturnVal	Receive( Transaction *trans );
-	ReturnVal	SendControl();
+	ReturnVal Read(LPVOID buffer, Transaction * trans);
+	ReturnVal Write(LPVOID buffer, Transaction * trans);
+      private:
+	 ReturnVal Send(Transaction * trans);
+	ReturnVal Receive(Transaction * trans);
+	ReturnVal SendControl();
 	//
-	ReturnVal	PostRecv();
+	ReturnVal PostRecv();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Pointers to descriptors to use for I/O requests and related information.
 	//
@@ -117,34 +109,32 @@
 	// for sends and receives.  Both VI sends and receives complete in the
 	// order that they are posted with respect to other sends/receives.
 	//
-	VIP_DESCRIPTOR	*descriptors;
-	VIP_MEM_HANDLE	descriptor_handle;
-	int				descriptor_count;
-	int				send_count;
-	int				recv_count;
+	VIP_DESCRIPTOR *descriptors;
+	VIP_MEM_HANDLE descriptor_handle;
+	int descriptor_count;
+	int send_count;
+	int recv_count;
 	//
 	// First half of descriptors are allocated for sends.
-	VIP_DESCRIPTOR	*send_descriptors;
-	int				next_send_index;
+	VIP_DESCRIPTOR *send_descriptors;
+	int next_send_index;
 	//
 	// Second half of descriptors are allocated for receives.
-	VIP_DESCRIPTOR	*recv_descriptors;
-	int				next_recv_index;
+	VIP_DESCRIPTOR *recv_descriptors;
+	int next_recv_index;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	// Is this the client or server side of the connection.  Note that this is
 	// independent of VI client/server or peer-to-peer connections.
-	BOOL			is_server;
-	ReadWriteType	lastIO;		// Was the last I/O a read or write?
+	BOOL is_server;
+	ReadWriteType lastIO;	// Was the last I/O a read or write?
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Resouces used to perform I/O to a VI target.
 	//
-public:
-	NetVI		vi;
+      public:
+	 NetVI vi;
 	// Information needed to maintain connection information over a VI.  Due to VI
 	// pre-posting requirements, the VI completion queue needs to intercept and
 	// process control flow messages.  When this occurs, it updates the following
@@ -152,50 +142,47 @@
 	//
 	// Number of receives that may be posted.  Due to pre-posting requirements
 	// all receives may be outstanding when we go to post another.
-	int		available_receives;
+	int available_receives;
 	//
 	// Number of receives that have been posted, but have not yet completed.
 	// This number will be negative if receives complete *before* being 
 	// requested.  (This can happen due to pre-posting requirements.)
-	int		requested_receives;
+	int requested_receives;
 	//
 	// Indicates that a control message was received signalling that additional
 	// receives have been posted on the remote side.  When set, this (local) 
 	// side of the connection updates the number of available sends.
-	BOOL	more_sends_available;
+	BOOL more_sends_available;
 	//
 	// Total number of I/Os that can be outstanding at any one time, including
 	// sends, receives, and any control messages.
-	int		outstanding_ios;
+	int outstanding_ios;
 	//
-private:
+      private:
 	// The total number of sends that are available to be sent.  If more than
 	// this number are sent, we cannot guarantee that the remote side has pre-
 	// posted enough receives to get them all.
-	int		available_sends;
+	int available_sends;
 	//
 	// Manage the number of receives that can be posted before we need to send
 	// notification to the remote side that additional receives have been pre-
 	// posted.
-	int		control_countdown;
-	int		control_countdown_start;
+	int control_countdown;
+	int control_countdown_start;
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// VI buffer and handle to buffer memory must be set before the target is
 	// initialized.
-public:
-	VINic	vi_nic;
+      public:
+	 VINic vi_nic;
 	//
-	char	*data_buffer;
-	int		data_buffer_size;
-private:
-	VIP_MEM_HANDLE	data_buffer_handle;
+	char *data_buffer;
+	int data_buffer_size;
+      private:
+	 VIP_MEM_HANDLE data_buffer_handle;
 	//
 	///////////////////////////////////////////////////////////////////////////
 };
 
-
-
-#endif // TARGETVI_DEFINED
+#endif				// TARGETVI_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/IOTest.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTest.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTest.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -71,103 +71,86 @@
 #ifndef TEST_SPEC_DEFINED
 #define TEST_SPEC_DEFINED
 
-
-
 #include "IOAccess.h"
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- #include "IOCommon.h"
+#include "IOCommon.h"
 #endif
 #include "vipl.h"
 
-
 #define PHYSICAL_DRIVE_PREFIX	"PHYSICALDRIVE:"
 
-
 //
 // Specifications for a single test for one worker.
 //
-struct Test_Spec
-{
-	char			name[MAX_WORKER_NAME];
-	int 			default_assignment;
-	Access_Spec		access[MAX_ACCESS_SPECS];
+struct Test_Spec {
+	char name[MAX_WORKER_NAME];
+	int default_assignment;
+	Access_Spec access[MAX_ACCESS_SPECS];
 };
 
-
-
 //
 // Different type of I/O targets and workers.
 //
-enum TargetType
-{
-	// Valid...		0xX0000000
-	GenericType =		0x80000000,
-	ActiveType =		0x40000000,
+enum TargetType {
+	// Valid...             0xX0000000
+	GenericType = 0x80000000,
+	ActiveType = 0x40000000,
 
-	// Disk...		0x-X000000
-	GenericDiskType =	0x88000000,
-	PhysicalDiskType =	0x8C000000,
-	LogicalDiskType =	0x8A000000,
+	// Disk...              0x-X000000
+	GenericDiskType = 0x88000000,
+	PhysicalDiskType = 0x8C000000,
+	LogicalDiskType = 0x8A000000,
 
-	// Network...		0x-00X0000
-	GenericNetType =	0x80080000,
-	GenericServerType =	0x800C0000,
-	GenericClientType =	0x800A0000,
+	// Network...           0x-00X0000
+	GenericNetType = 0x80080000,
+	GenericServerType = 0x800C0000,
+	GenericClientType = 0x800A0000,
 
-	// TCP...		0x-00-X000
-	GenericTCPType =	0x80088000,
-	TCPServerType =		0x800C8000,
-	TCPClientType =		0x800A8000,
+	// TCP...               0x-00-X000
+	GenericTCPType = 0x80088000,
+	TCPServerType = 0x800C8000,
+	TCPClientType = 0x800A8000,
 
-	// VI...		0x-00-0X00
-	GenericVIType =		0x80080800,
-	VIServerType =		0x800C0800,
-	VIClientType =		0x800A0800,
+	// VI...                0x-00-0X00
+	GenericVIType = 0x80080800,
+	VIServerType = 0x800C0800,
+	VIClientType = 0x800A0800,
 
-	// Invalid...		0xX0000000
-	InvalidType =		0x00000000
+	// Invalid...           0xX0000000
+	InvalidType = 0x00000000
 };
 
-
 #define IsType(src, chk) ((src & chk) == chk)
 
 // Allows comparing two types for worker compatibility.
-const int WORKER_COMPATIBILITY_MASK
-		= GenericDiskType | GenericServerType | GenericClientType;
+const int WORKER_COMPATIBILITY_MASK = GenericDiskType | GenericServerType | GenericClientType;
 
 // Allows comparing a server/client pair for compatibility.
-const int NETWORK_COMPATIBILITY_MASK
-		= GenericTCPType | GenericVIType;
+const int NETWORK_COMPATIBILITY_MASK = GenericTCPType | GenericVIType;
 
 //
 // Disk specific specifications for drives accessed during a test.
 //
-struct Disk_Spec
-{
-	BOOL		ready;
-	
-	int		sector_size;
-	int		maximum_size;
+struct Disk_Spec {
+	BOOL ready;
 
-	int		starting_sector;
+	int sector_size;
+	int maximum_size;
+
+	int starting_sector;
 };
 
-
-
 //
 // TCP specific specifications for TCP networks accessed during a test.
 //
-struct TCP_Spec
-{
+struct TCP_Spec {
 	// Address of local and remote TCP connection.
-	unsigned short	local_port;
+	unsigned short local_port;
 
-	char		remote_address[MAX_NAME];
-	unsigned short	remote_port;
+	char remote_address[MAX_NAME];
+	unsigned short remote_port;
 };
 
-
-
 #define VI_ADDRESS_SIZE				16
 // (Note that current VI hardware only supports a 4 byte 
 // discriminator.  - 08/24/1998 - SH)
@@ -176,61 +159,54 @@
 //
 // VI specific specifications for VI networks accessed during a test.
 //
-struct VI_Spec
-{
+struct VI_Spec {
 	// Name and address of local and remote VI NICs to connect.
 	// Since the VIP_NET_ADDRESS can be variable length, we use fill bytes to ensure
 	// that there's enough room to store the entire address.  The total number of bytes
 	// available for the address and discriminator is VI_ADDRESS_SIZE + VI_DISCRIMINATOR_SIZE.
-	VIP_NET_ADDRESS	local_address;
-	char			local_address_fill_bytes[VI_ADDRESS_SIZE + VI_DISCRIMINATOR_SIZE - 1];
+	VIP_NET_ADDRESS local_address;
+	char local_address_fill_bytes[VI_ADDRESS_SIZE + VI_DISCRIMINATOR_SIZE - 1];
 
-	char			remote_nic_name[MAX_NAME];
-	VIP_NET_ADDRESS	remote_address;
-	char			remote_address_fill_bytes[VI_ADDRESS_SIZE + VI_DISCRIMINATOR_SIZE - 1];
+	char remote_nic_name[MAX_NAME];
+	VIP_NET_ADDRESS remote_address;
+	char remote_address_fill_bytes[VI_ADDRESS_SIZE + VI_DISCRIMINATOR_SIZE - 1];
 
 	// VI specific limitations.
-	int			max_transfer_size;
-	int			max_connections;
-	int			outstanding_ios;
-	#if defined(IOMTR_OSFAMILY_NETWARE)
-	 char padnw[2]; // this has to keep changing and I do not know why
-	 				// orginally it was none, had to make it 4 to work with NetWare now 2??
-	 				// somebodies data size is changing on me and I don't know whose  or why
-	#endif
+	int max_transfer_size;
+	int max_connections;
+	int outstanding_ios;
+#if defined(IOMTR_OSFAMILY_NETWARE)
+	char padnw[2];		// this has to keep changing and I do not know why
+	// orginally it was none, had to make it 4 to work with NetWare now 2??
+	// somebodies data size is changing on me and I don't know whose  or why
+#endif
 
 };
 
-
-
 //
 // Possible specifications for a generic target to have.
 //
-struct Target_Spec
-{
+struct Target_Spec {
 	// Name and type of target.
-	char		name[MAX_NAME];
-	TargetType	type;
+	char name[MAX_NAME];
+	TargetType type;
 
 	// Target type specific specifications.
-	union
-	{
-		Disk_Spec	disk_info;
-		TCP_Spec	tcp_info;
-		VI_Spec		vi_info;
+	union {
+		Disk_Spec disk_info;
+		TCP_Spec tcp_info;
+		VI_Spec vi_info;
 	};
 
 	// Target independent test specifications.
-	int		queue_depth;
-	BOOL		test_connection_rate;
-	int		trans_per_conn;
+	int queue_depth;
+	BOOL test_connection_rate;
+	int trans_per_conn;
 
-	char		padding[4];	// xscale and ia32 arch difference. need this padding.
-	
+	char padding[4];	// xscale and ia32 arch difference. need this padding.
+
 	// Random value used to keep connections in synch.
-	DWORDLONG	random;
+	DWORDLONG random;
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOTime.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTime.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTime.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -89,38 +89,33 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
-
 // Include our central headerfile
 #include "IOCommon.h"
 
 #if defined(IOMTR_OS_LINUX)
- #include "iomtr_kstat/iomtr_kstat.h"
+#include "iomtr_kstat/iomtr_kstat.h"
 
- extern int kstatfd;
- extern int procstatstyle;
+extern int kstatfd;
+extern int procstatstyle;
 #endif
 
-
-
-
 #if defined(IOMTR_CPU_PPC)
 #endif
 
-
-
 // Implements the time measurment functions
 // for / in the different plattforms
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_LINUX)
- DWORDLONG jiffies(void) {
-	DWORDLONG jiffies_user, jiffies_nice, jiffies_system, jiffies_idle, jiffies_iowait, jiffies_irq, jiffies_softirq;
+DWORDLONG jiffies(void)
+{
+	DWORDLONG jiffies_user, jiffies_nice, jiffies_system, jiffies_idle, jiffies_iowait, jiffies_irq,
+	    jiffies_softirq;
 	FILE *fp;
 	unsigned long long jf;
-	
+
 	if (kstatfd > 0 && ioctl(kstatfd, IM_IOC_GETCURJIFFIES, &jf) >= 0) {
 		//printf("JIFFIE: %llu\n", jf);
-		return (DWORDLONG)jf;
+		return (DWORDLONG) jf;
 	}
 
 	switch (procstatstyle) {
@@ -129,150 +124,156 @@
 		fscanf(fp, "cpu %*s %*s %*s %*s\n");
 		fscanf(fp, "cpu0 %lld %lld %lld %lld\n", &jiffies_user, &jiffies_nice, &jiffies_system, &jiffies_idle);
 		fclose(fp);
-		return(jiffies_user + jiffies_nice + jiffies_system + jiffies_idle);
+		return (jiffies_user + jiffies_nice + jiffies_system + jiffies_idle);
 	case PROCSTAT26STYLE:
 		fp = fopen("/proc/stat", "r");
 		fscanf(fp, "cpu %*s %*s %*s %*s %*s %*s %*s\n");
-		fscanf(fp, "cpu0 %lld %lld %lld %lld %lld %lld %lld\n", &jiffies_user, &jiffies_nice, &jiffies_system, &jiffies_idle,
-			&jiffies_iowait, &jiffies_irq, &jiffies_softirq);
+		fscanf(fp, "cpu0 %lld %lld %lld %lld %lld %lld %lld\n", &jiffies_user, &jiffies_nice, &jiffies_system,
+		       &jiffies_idle, &jiffies_iowait, &jiffies_irq, &jiffies_softirq);
 		fclose(fp);
-		return(jiffies_user + jiffies_nice + jiffies_system + jiffies_idle + jiffies_iowait + jiffies_irq + jiffies_softirq);
+		return (jiffies_user + jiffies_nice + jiffies_system + jiffies_idle + jiffies_iowait + jiffies_irq +
+			jiffies_softirq);
 	default:
 		// should never be here
 		cerr << "Can not get jiffies value!" << endl;
 	}
 	return 0;
- }
- #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_X86_64)
-  DWORDLONG rdtsc(void) {
-        // Original code (returning the cpu cycle counter)
+}
+
+#if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_X86_64)
+DWORDLONG rdtsc(void)
+{
+	// Original code (returning the cpu cycle counter)
 	unsigned int lo, hi;
-	__asm__ __volatile__("rdtsc" : "=a" (lo), "=d" (hi));
-	return(lo | ((DWORDLONG)hi << 32));
-        // Alternative code (returning the cpu cycle counter too)
-        //	unsigned long long int x;
-        //	__asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
-        //	return(x);
-  }
- #elif defined(IOMTR_CPU_PPC)
-	#define CPU_FTR_601                     0x00000100
+	__asm__ __volatile__("rdtsc":"=a"(lo), "=d"(hi));
 
-	DWORD get_tbl() {
-	        DWORD ccc;
-	        __asm__ __volatile__(
-	                "98:    mftb %0\n"
-	                "99:\n"
-	                ".section __ftr_fixup,\"a\"\n"
-	                "       .long %1\n"
-	                "       .long 0\n"
-	                "       .long 98b\n"
-	                "       .long 99b\n"
-	                ".previous"
-	                : "=r" (ccc) : "i" (CPU_FTR_601));
-		return ccc;
-	}
-	DWORD get_tbu()	{
-	      DWORD ccc;
-	        __asm__ __volatile__(
-	                "98:    mftbu %0\n"
-	                "99:\n"
-	                ".section __ftr_fixup,\"a\"\n"
-	                "       .long %1\n"
-	                "       .long 0\n"
-	                "       .long 98b\n"
-	                "       .long 99b\n"
-	                ".previous"
-	                : "=r" (ccc) : "i" (CPU_FTR_601));
-	        return ccc;
-	}
-	DWORDLONG rdtsc(void) {
-	        // Original code (returning the cpu cycle counter)
+	return (lo | ((DWORDLONG) hi << 32));
+	// Alternative code (returning the cpu cycle counter too)
+	//      unsigned long long int x;
+	//      __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
+	//      return(x);
+}
+#elif defined(IOMTR_CPU_PPC)
+#define CPU_FTR_601                     0x00000100
 
-		// read 64 bit tbl (time base) using motorola example 
-		DWORD lo,hi1,hi2; 
-		do {
-			hi1=get_tbu();
-			lo=get_tbl();
-			hi2=get_tbu();
-		} while (hi1 != hi2);
-		
-		return ((DWORDLONG) hi1)<<32 | (DWORDLONG) lo;
-	}
- #elif defined(IOMTR_CPU_XSCALE)
+DWORD get_tbl()
+{
+	DWORD ccc;
+	__asm__ __volatile__("98:    mftb %0\n"
+			     "99:\n"
+			     ".section __ftr_fixup,\"a\"\n"
+			     "       .long %1\n"
+			     "       .long 0\n"
+			     "       .long 98b\n" "       .long 99b\n" ".previous":"=r"(ccc):"i"(CPU_FTR_601));
+	return ccc;
+}
 
-	#define CCNT_IOC_MAGIC		0xAC
-	#define CCNT_IOC_GETCCNT	_IOR(CCNT_IOC_MAGIC, 1, unsigned long long)
-	extern int ccntfd;
+DWORD get_tbu()
+{
+	DWORD ccc;
+	__asm__ __volatile__("98:    mftbu %0\n"
+			     "99:\n"
+			     ".section __ftr_fixup,\"a\"\n"
+			     "       .long %1\n"
+			     "       .long 0\n"
+			     "       .long 98b\n" "       .long 99b\n" ".previous":"=r"(ccc):"i"(CPU_FTR_601));
+	return ccc;
+}
 
-	DWORDLONG rdtsc(void) {
-		unsigned long long ccnt;
-		if (ioctl(ccntfd, CCNT_IOC_GETCCNT, &ccnt) < 0 ) {
-			ccnt = 0;
-		}
-		return(ccnt);
+DWORDLONG rdtsc(void)
+{
+	// Original code (returning the cpu cycle counter)
+
+	// read 64 bit tbl (time base) using motorola example 
+	DWORD lo, hi1, hi2;
+
+	do {
+		hi1 = get_tbu();
+		lo = get_tbl();
+		hi2 = get_tbu();
+	} while (hi1 != hi2);
+
+	return ((DWORDLONG) hi1) << 32 | (DWORDLONG) lo;
+}
+#elif defined(IOMTR_CPU_XSCALE)
+
+#define CCNT_IOC_MAGIC		0xAC
+#define CCNT_IOC_GETCCNT	_IOR(CCNT_IOC_MAGIC, 1, unsigned long long)
+extern int ccntfd;
+
+DWORDLONG rdtsc(void)
+{
+	unsigned long long ccnt;
+
+	if (ioctl(ccntfd, CCNT_IOC_GETCCNT, &ccnt) < 0) {
+		ccnt = 0;
 	}
- #elif defined(IOMTR_CPU_IA64)
-	DWORDLONG rdtsc(void) {
-		unsigned long temp;
-		/* TODO: If you are going to use the Intel compiler */
-		/*       you need a different line of code. */
-		__asm__ __volatile__("mov %0=ar.itc" : "=r"(temp) :: "memory");
-		return temp;
-	}
- #else
+	return (ccnt);
+}
+#elif defined(IOMTR_CPU_IA64)
+DWORDLONG rdtsc(void)
+{
+	unsigned long temp;
+
+	/* TODO: If you are going to use the Intel compiler */
+	/*       you need a different line of code. */
+	__asm__ __volatile__("mov %0=ar.itc":"=r"(temp)::"memory");
+
+	return temp;
+}
+#else
   // Was the following 2 lines in before, but for which CPU (nevertheless it is useless!)?
-  //	/* Totally cheesy rewrite of rdtsc! */
-  //	return((DWORDLONG)time(NULL) * 200);
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif
+  //    /* Totally cheesy rewrite of rdtsc! */
+  //    return((DWORDLONG)time(NULL) * 200);
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 // ----------------------------------------------------------------------------
 #elif defined(IOMTR_OSFAMILY_NETWARE)
- #if defined(IOMTR_CPU_I386)
- __declspec ( naked ) extern DWORDLONG rdtsc()
- {
-	__asm__
-	{
-		_emit 0Fh	// Store low  32-bits of counter in EAX.
-		_emit 31h	// Store high 32-bits of counter in EDX.
-		ret
-	}
- }
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif
+#if defined(IOMTR_CPU_I386)
+__declspec(naked)
+extern DWORDLONG rdtsc()
+{
+	__asm__ {
+		_emit 0F h	// Store low  32-bits of counter in EAX.
+		    _emit 31 h	// Store high 32-bits of counter in EDX.
+	ret}
+}
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 // ----------------------------------------------------------------------------
 #elif defined(IOMTR_OS_SOLARIS)
- #if defined(IOMTR_CPU_I386)
-  unsigned long long rdtsc()
-  {
+#if defined(IOMTR_CPU_I386)
+unsigned long long rdtsc()
+{
 	asm(".byte 0x0f, 0x31");
-  }
- #elif defined(IOMTR_CPU_SPARC)
-  #include <sys/types.h>
-  #include <sys/time.h>
-  double processor_speed_to_nsecs;
-  unsigned long long rdtsc()
-  {
-	return (DWORDLONG)((double)gethrtime() * (double)processor_speed_to_nsecs);
-  }
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif 
+}
+#elif defined(IOMTR_CPU_SPARC)
+#include <sys/types.h>
+#include <sys/time.h>
+double processor_speed_to_nsecs;
+unsigned long long rdtsc()
+{
+	return (DWORDLONG) ((double)gethrtime() * (double)processor_speed_to_nsecs);
+}
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 // ----------------------------------------------------------------------------
 #elif defined(IOMTR_OS_WIN32) && defined(IOMTR_CPU_I386)
  //
  // In WIN32 to read the IA32 Time Stamp Counter (TSC)
  // Use the opcode since MSFT compiler doesn't recognize the RDTSC instruction.
  //
- __declspec ( naked ) extern DWORDLONG rdtsc()
- {
-	_asm
-	{
-		_emit 0Fh	// Store low  32-bits of counter in EAX.
-		_emit 31h	// Store high 32-bits of counter in EDX.
-		ret
-	}
- }
+__declspec(naked)
+extern DWORDLONG rdtsc()
+{
+	_asm {
+		_emit 0F h	// Store low  32-bits of counter in EAX.
+		    _emit 31 h	// Store high 32-bits of counter in EDX.
+	ret}
+}
+
 // ----------------------------------------------------------------------------
 #elif defined(IOMTR_OS_WIN64) && defined(IOMTR_CPU_IA64)
  //
@@ -286,12 +287,12 @@
  // Either way, including a kernel mode header in user mode is not possible. Therefore, 
  // we wish to use the !USING_DDK path here for all cases, even though USING_DDK 
  // will really be defined in the ddk env. Get it?!?
- 
- //#ifdef USING_DDK	// Driver
- //#include <ia64reg.h>	// from IA64 DDK
- //#include <wdm.h>	// from IA64 DDK
+
+ //#ifdef USING_DDK     // Driver
+ //#include <ia64reg.h> // from IA64 DDK
+ //#include <wdm.h>     // from IA64 DDK
  //#endif // USING_DDK
- 
+
  //#ifndef USING_DDK    // Application
 
  //
@@ -303,43 +304,32 @@
  //
  // Register set for Intel IA64
  //
- typedef enum IA64_REG_INDEX {
+typedef enum IA64_REG_INDEX {
 	// ... Bunch of registers deleted here...
 	CV_IA64_ApITC = 3116,	// Interval Time Counter (ITC, AR-44)
 	// ... Bunch of registers deleted here...
- } IA64_REG_INDEX;
+} IA64_REG_INDEX;
 
  //
  // Including the defn that I need from DDK 'wdm.h' here so that we don't have to
  // include the DDK in the build path.
  //
- #ifdef __cplusplus
- extern "C" {
- #endif
+#ifdef __cplusplus
+extern "C" {
+#endif
 
- unsigned __int64 __getReg (int);
+	unsigned __int64 __getReg(int);
 
- #if defined(IOMTR_CPU_IA64)
- #pragma intrinsic (__getReg)
- #endif // _M_IA64
+#if defined(IOMTR_CPU_IA64)
+#pragma intrinsic (__getReg)
+#endif				// _M_IA64
 
- #ifdef __cplusplus
- }
- #endif
- //#endif //!USING_DDK
-
- ////////////////////////////////////////////////////////////////////////////////////
- //  Name:	 readITC
- //  Purpose: 	 To read the IA64 Itanium's Interval Time Counter (ITC, AR-44).  The
- //		 ITC is equivalent to the IA32 Time Stamp Counter (TSC).  The IA32
- //		 TSC can be read using the IA32 RDTSC instruction (opcode 0F 31h) but
- //		 there is no equivalent IA64 instruction to read the ITC.
- //  Returns:	 The value of the ITC
- //  Parameters: None.
- ///////////////////////////////////////////////////////////////////////////////////
- //
- DWORDLONG rdtsc() 
- {
+#ifdef __cplusplus
+}
+#endif
+ //#endif //!USING_DDK//////////////////////////////////////////////////////////////////////////////////////  Name:       readITC//  Purpose:    To read the IA64 Itanium's Interval Time Counter (ITC, AR-44).  The//              ITC is equivalent to the IA32 Time Stamp Counter (TSC).  The IA32//              TSC can be read using the IA32 RDTSC instruction (opcode 0F 31h) but//              there is no equivalent IA64 instruction to read the ITC.//  Returns:    The value of the ITC//  Parameters: None./////////////////////////////////////////////////////////////////////////////////////
+    DWORDLONG rdtsc()
+{
 	// *** Removed ***
 	// GetTickCount() is a temporary function used to get a number for getting Time
 	// Metrics for IA64 until a better function is found that works.  Unfortunately
@@ -362,31 +352,33 @@
 	// __getReg is a compiler intrinsic defined in 'wdm.h' of the DDK.
 	// defined.  CV_IA64_ApITC is defined in 'ia64reg.h' in the DDK.
 	//
-	return __getReg( CV_IA64_ApITC );
+	return __getReg(CV_IA64_ApITC);
 
- }
+}
+
 // ----------------------------------------------------------------------------
 #elif defined(IOMTR_OS_WIN64) && defined(IOMTR_CPU_X86_64)
 
  // Same as above, but less comments. Same story; defs are from the ddk.
 
- unsigned __int64 __rdtsc (void);
+unsigned __int64 __rdtsc(void);
 
- #pragma intrinsic(__rdtsc)
+#pragma intrinsic(__rdtsc)
 
- DWORDLONG rdtsc() 
- {
+DWORDLONG rdtsc()
+{
 	return __rdtsc();
- }
+}
+
 // ----------------------------------------------------------------------------
 #elif defined(IOMTR_OS_OSX)
- #if defined(IOMTR_CPU_PPC)
-  #include <Carbon/Carbon.h>
-  double processor_speed_to_nsecs; // declared as extern double in IOCommon.h
-  DWORDLONG rdtsc()
-  {
- 	DWORDLONG temp;
- 	AbsoluteTime now;
+#if defined(IOMTR_CPU_PPC)
+#include <Carbon/Carbon.h>
+double processor_speed_to_nsecs;	// declared as extern double in IOCommon.h
+DWORDLONG rdtsc()
+{
+	DWORDLONG temp;
+	AbsoluteTime now;
 	Nanoseconds s;
 
 	now = UpTime();
@@ -397,17 +389,13 @@
 
 	// temp contains timestamp in nanosecs
 	// temp * processor_speed_to_nsecs = timestamp in cpu cycles
-	return (DWORDLONG)(temp * processor_speed_to_nsecs);
-  }
- #else
-  #error ===> ERROR: You have to do some coding here to get the port done!
- #endif
+	return (DWORDLONG) (temp * processor_speed_to_nsecs);
+}
+#else
+#error ===> ERROR: You have to do some coding here to get the port done!
+#endif
 // ----------------------------------------------------------------------------
 #else
- #error ===> ERROR: You have to do some coding here to get the port done!
+#error ===> ERROR: You have to do some coding here to get the port done!
 #endif
 // ----------------------------------------------------------------------------
-
-
-
-

Modified: branches/IOMETER-restruct/iometer/src/IOTransfers.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTransfers.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOTransfers.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,60 +64,51 @@
 #ifndef IO_TRANSFERS_DEFINED
 #define IO_TRANSFERS_DEFINED
 
-
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- #include "IOCommon.h"
+#include "IOCommon.h"
 #endif
 #include "vipl.h"
 
-
-
 //
 // Generic structure to hold information that may be passed to a thread.
 //
-struct Thread_Info
-{
-	int		id;			// Thread's identification.  Used by thread to
-						// determine what work it is to do, such as which disk to access.
-	void*	parent;		// Pointer used to get parent object.
+struct Thread_Info {
+	int id;			// Thread's identification.  Used by thread to
+	// determine what work it is to do, such as which disk to access.
+	void *parent;		// Pointer used to get parent object.
 };
 
-
-
 //
 // Information about a single transaction performed by a thread.  Note that a 
 // worker has at most one I/O outstanding at a time for a given transaction.
 //
-struct Transaction
-{
+struct Transaction {
 	// NOTE!  This must be the first member of this structure!
-	OVERLAPPED		asynchronous_io;
+	OVERLAPPED asynchronous_io;
 
 	// Target to use for current transaction.
-	int				target_id;
+	int target_id;
 	//
-	int				request_number;		// each trans. holds its own index in the Transaction array
+	int request_number;	// each trans. holds its own index in the Transaction array
 	//
 	// these are set when a new transaction is started in a transaction slot
-	DWORD			request_size;		// size of request posting
-	DWORD			reply_size;			// size of reply posting
-	DWORDLONG		start_transaction;	// starting time of entire transaction
+	DWORD request_size;	// size of request posting
+	DWORD reply_size;	// size of reply posting
+	DWORDLONG start_transaction;	// starting time of entire transaction
 	//
 	// these are changed when the transaction's REQUESTs have
 	// all been completed and replies are about to be queued
-	BOOL			is_read;			// is this I/O a read (TRUE) or a write (FALSE)?
+	BOOL is_read;		// is this I/O a read (TRUE) or a write (FALSE)?
 	//
 	// these change per I/O within the transaction
 	// ("size" must also be changed in the event of a partial I/O)
-	DWORD			size;				// number of bytes to be transferred in the current request
-	DWORDLONG		start_IO;			// time I/O request was made
+	DWORD size;		// number of bytes to be transferred in the current request
+	DWORDLONG start_IO;	// time I/O request was made
 	//
 	// these two values are decremented when a request or reply I/O is completed,
 	// not when it is queued
-	int				remaining_requests;	// PING (number of requests remaining in this transaction)
-	int				remaining_replies;	// PONG (number of replies remaining in this transaction)
+	int remaining_requests;	// PING (number of requests remaining in this transaction)
+	int remaining_replies;	// PONG (number of replies remaining in this transaction)
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/IOVIPL.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOVIPL.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOVIPL.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,20 +61,17 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOVIPL.h"
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <iostream>
- using namespace std;
+#include <iostream>
+using namespace std;
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
- #include <iostream.h>
+#include <iostream.h>
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // Initial declarations for static variables.
 //
@@ -134,11 +131,10 @@
 fVipNSGetHostByName VIPL::VipNSGetHostByName = NULL;
 fVipNSGetHostByAddr VIPL::VipNSGetHostByAddr = NULL;
 fVipNSShutdown VIPL::VipNSShutdown = NULL;
+
 //
 ///////////////////////////////////////////////////////////////////////////////
 
-
-
 //
 // Loading vipl.dll and dynamically linking all VI functions.  Setting 
 // vipl_loaded if the library loaded successfully.
@@ -146,7 +142,7 @@
 //
 // UNIX/SOLARIS NOTE
 // -----------------
-//		The UNIX code should work straightaway as soon as a VI shared object is
+//              The UNIX code should work straightaway as soon as a VI shared object is
 // available. The dlopen(3), dlsym(3) and dlclose(3) calls setup the VI shared
 // libraries and make the symbols available for access by dynamo.
 //
@@ -171,184 +167,178 @@
 {
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	// Load vipl.dll.
-	if ( !(vipl_dll = LoadLibrary( "vipl.dll" )) )
-	{
-		#if _DEBUG
-			cout << "Unable to load vipl.dll" << endl;
-		#endif
+	if (!(vipl_dll = LoadLibrary("vipl.dll"))) {
+#if _DEBUG
+		cout << "Unable to load vipl.dll" << endl;
+#endif
 		return;
 	}
-
 	// Dynamically linking VI functions.
 
 	// NIC
-	VipOpenNic = (fVipOpenNic)GetProcAddress( vipl_dll, "VipOpenNic" );
-	VipCloseNic = (fVipCloseNic)GetProcAddress( vipl_dll, "VipCloseNic" );
+	VipOpenNic = (fVipOpenNic) GetProcAddress(vipl_dll, "VipOpenNic");
+	VipCloseNic = (fVipCloseNic) GetProcAddress(vipl_dll, "VipCloseNic");
 
 	// VI
-	VipCreateVi = (fVipCreateVi)GetProcAddress( vipl_dll, "VipCreateVi" );
-	VipDestroyVi = (fVipDestroyVi)GetProcAddress( vipl_dll, "VipDestroyVi" );
-	
+	VipCreateVi = (fVipCreateVi) GetProcAddress(vipl_dll, "VipCreateVi");
+	VipDestroyVi = (fVipDestroyVi) GetProcAddress(vipl_dll, "VipDestroyVi");
+
 	// Client/server connection
 	VipConnectWait = (fVipConnectWait)
-		GetProcAddress( vipl_dll, "VipConnectWait" );
+	    GetProcAddress(vipl_dll, "VipConnectWait");
 	VipConnectAccept = (fVipConnectAccept)
-		GetProcAddress( vipl_dll, "VipConnectAccept" );
+	    GetProcAddress(vipl_dll, "VipConnectAccept");
 	VipConnectReject = (fVipConnectReject)
-		GetProcAddress( vipl_dll, "VipConnectReject" );
+	    GetProcAddress(vipl_dll, "VipConnectReject");
 	VipConnectRequest = (fVipConnectRequest)
-		GetProcAddress( vipl_dll, "VipConnectRequest" );
+	    GetProcAddress(vipl_dll, "VipConnectRequest");
 	VipDisconnect = (fVipDisconnect)
-		GetProcAddress( vipl_dll, "VipDisconnect" );
-	
+	    GetProcAddress(vipl_dll, "VipDisconnect");
+
 	// Ptag
 	VipCreatePtag = (fVipCreatePtag)
-		GetProcAddress( vipl_dll, "VipCreatePtag" );
+	    GetProcAddress(vipl_dll, "VipCreatePtag");
 	VipDestroyPtag = (fVipDestroyPtag)
-		GetProcAddress( vipl_dll, "VipDestroyPtag" );
-	
+	    GetProcAddress(vipl_dll, "VipDestroyPtag");
+
 	// Memory
 	VipRegisterMem = (fVipRegisterMem)
-		GetProcAddress( vipl_dll, "VipRegisterMem" );
+	    GetProcAddress(vipl_dll, "VipRegisterMem");
 	VipDeregisterMem = (fVipDeregisterMem)
-		GetProcAddress( vipl_dll, "VipDeregisterMem" );
-	
+	    GetProcAddress(vipl_dll, "VipDeregisterMem");
+
 	// Send/receive
-	VipPostSend = (fVipPostSend)GetProcAddress( vipl_dll, "VipPostSend" );
-	VipSendDone = (fVipSendDone)GetProcAddress( vipl_dll, "VipSendDone" );
-	VipSendWait = (fVipSendWait)GetProcAddress( vipl_dll, "VipSendWait" );
-	VipPostRecv = (fVipPostRecv)GetProcAddress( vipl_dll, "VipPostRecv" );
-	VipRecvDone = (fVipRecvDone)GetProcAddress( vipl_dll, "VipRecvDone" );
-	VipRecvWait = (fVipRecvWait)GetProcAddress( vipl_dll, "VipRecvWait" );
-	
+	VipPostSend = (fVipPostSend) GetProcAddress(vipl_dll, "VipPostSend");
+	VipSendDone = (fVipSendDone) GetProcAddress(vipl_dll, "VipSendDone");
+	VipSendWait = (fVipSendWait) GetProcAddress(vipl_dll, "VipSendWait");
+	VipPostRecv = (fVipPostRecv) GetProcAddress(vipl_dll, "VipPostRecv");
+	VipRecvDone = (fVipRecvDone) GetProcAddress(vipl_dll, "VipRecvDone");
+	VipRecvWait = (fVipRecvWait) GetProcAddress(vipl_dll, "VipRecvWait");
+
 	// Completion queues
-	VipCQDone = (fVipCQDone)GetProcAddress( vipl_dll, "VipCQDone" );
-	VipCQWait = (fVipCQWait)GetProcAddress( vipl_dll, "VipCQWait" );
-	VipCreateCQ = (fVipCreateCQ)GetProcAddress( vipl_dll, "VipCreateCQ" );
-	VipDestroyCQ = (fVipDestroyCQ)GetProcAddress( vipl_dll, "VipDestroyCQ" );
-	VipResizeCQ = (fVipResizeCQ)GetProcAddress( vipl_dll, "VipResizeCQ" );
-	
+	VipCQDone = (fVipCQDone) GetProcAddress(vipl_dll, "VipCQDone");
+	VipCQWait = (fVipCQWait) GetProcAddress(vipl_dll, "VipCQWait");
+	VipCreateCQ = (fVipCreateCQ) GetProcAddress(vipl_dll, "VipCreateCQ");
+	VipDestroyCQ = (fVipDestroyCQ) GetProcAddress(vipl_dll, "VipDestroyCQ");
+	VipResizeCQ = (fVipResizeCQ) GetProcAddress(vipl_dll, "VipResizeCQ");
+
 	// Information
-	VipQueryNic = (fVipQueryNic)GetProcAddress( vipl_dll, "VipQueryNic" );
+	VipQueryNic = (fVipQueryNic) GetProcAddress(vipl_dll, "VipQueryNic");
 	VipSetViAttributes = (fVipSetViAttributes)
-		GetProcAddress( vipl_dll, "VipSetViAttributes" );
-	VipQueryVi = (fVipQueryVi)GetProcAddress( vipl_dll, "VipQueryVi" );
+	    GetProcAddress(vipl_dll, "VipSetViAttributes");
+	VipQueryVi = (fVipQueryVi) GetProcAddress(vipl_dll, "VipQueryVi");
 	VipSetMemAttributes = (fVipSetMemAttributes)
-		GetProcAddress( vipl_dll, "VipSetMemAttributes" );
-	VipQueryMem = (fVipQueryMem)GetProcAddress( vipl_dll, "VipQueryMem" );
+	    GetProcAddress(vipl_dll, "VipSetMemAttributes");
+	VipQueryMem = (fVipQueryMem) GetProcAddress(vipl_dll, "VipQueryMem");
 	VipQuerySystemManagementInfo = (fVipQuerySystemManagementInfo)
-		GetProcAddress( vipl_dll, "VipQuerySystemManagementInfo" );
-	
+	    GetProcAddress(vipl_dll, "VipQuerySystemManagementInfo");
+
 	// Peer-to-peer connection
 	VipConnectPeerRequest = (fVipConnectPeerRequest)
-		GetProcAddress( vipl_dll, "VipConnectPeerRequest" );
+	    GetProcAddress(vipl_dll, "VipConnectPeerRequest");
 	VipConnectPeerDone = (fVipConnectPeerDone)
-		GetProcAddress( vipl_dll, "VipConnectPeerDone" );
+	    GetProcAddress(vipl_dll, "VipConnectPeerDone");
 	VipConnectPeerWait = (fVipConnectPeerWait)
-		GetProcAddress( vipl_dll, "VipConnectPeerWait" );
-	
+	    GetProcAddress(vipl_dll, "VipConnectPeerWait");
+
 	// Name service
-	VipNSInit = (fVipNSInit)GetProcAddress( vipl_dll, "VipNSInit" );
+	VipNSInit = (fVipNSInit) GetProcAddress(vipl_dll, "VipNSInit");
 	VipNSGetHostByName = (fVipNSGetHostByName)
-		GetProcAddress( vipl_dll, "VipNSGetHostByName" );
+	    GetProcAddress(vipl_dll, "VipNSGetHostByName");
 	VipNSGetHostByAddr = (fVipNSGetHostByAddr)
-		GetProcAddress( vipl_dll, "VipNSGetHostByAddr" );
+	    GetProcAddress(vipl_dll, "VipNSGetHostByAddr");
 	VipNSShutdown = (fVipNSShutdown)
-		GetProcAddress( vipl_dll, "VipNSShutdown" );
+	    GetProcAddress(vipl_dll, "VipNSShutdown");
 #elif defined(IOMTR_OS_SOLARIS)
 	// When VI library becomes available on Solaris, this should work
-	if ( (vipl_dll = dlopen( "vipl.so", RTLD_NOW|RTLD_GLOBAL|RTLD_PARENT )) == NULL )
-	{
-		#ifdef _DEBUG
+	if ((vipl_dll = dlopen("vipl.so", RTLD_NOW | RTLD_GLOBAL | RTLD_PARENT)) == NULL) {
+#ifdef _DEBUG
 		cout << "unable to load VI shared library" << endl;
-		#endif
+#endif
 		return;
 	}
-
 	// Link all the VI functions.
 	// NIC
-	VipOpenNic = (fVipOpenNic)dlsym( vipl_dll, "VipOpenNic" );
-	VipCloseNic = (fVipCloseNic)dlsym( vipl_dll, "VipCloseNic" );
+	VipOpenNic = (fVipOpenNic) dlsym(vipl_dll, "VipOpenNic");
+	VipCloseNic = (fVipCloseNic) dlsym(vipl_dll, "VipCloseNic");
 
 	// VI
-	VipCreateVi = (fVipCreateVi)dlsym( vipl_dll, "VipCreateVi" );
-	VipDestroyVi = (fVipDestroyVi)dlsym( vipl_dll, "VipDestroyVi" );
-	
+	VipCreateVi = (fVipCreateVi) dlsym(vipl_dll, "VipCreateVi");
+	VipDestroyVi = (fVipDestroyVi) dlsym(vipl_dll, "VipDestroyVi");
+
 	// Client/server connection
 	VipConnectWait = (fVipConnectWait)
-		dlsym( vipl_dll, "VipConnectWait" );
+	    dlsym(vipl_dll, "VipConnectWait");
 	VipConnectAccept = (fVipConnectAccept)
-		dlsym( vipl_dll, "VipConnectAccept" );
+	    dlsym(vipl_dll, "VipConnectAccept");
 	VipConnectReject = (fVipConnectReject)
-		dlsym( vipl_dll, "VipConnectReject" );
+	    dlsym(vipl_dll, "VipConnectReject");
 	VipConnectRequest = (fVipConnectRequest)
-		dlsym( vipl_dll, "VipConnectRequest" );
+	    dlsym(vipl_dll, "VipConnectRequest");
 	VipDisconnect = (fVipDisconnect)
-		dlsym( vipl_dll, "VipDisconnect" );
-	
+	    dlsym(vipl_dll, "VipDisconnect");
+
 	// Ptag
 	VipCreatePtag = (fVipCreatePtag)
-		dlsym( vipl_dll, "VipCreatePtag" );
+	    dlsym(vipl_dll, "VipCreatePtag");
 	VipDestroyPtag = (fVipDestroyPtag)
-		dlsym( vipl_dll, "VipDestroyPtag" );
-	
+	    dlsym(vipl_dll, "VipDestroyPtag");
+
 	// Memory
 	VipRegisterMem = (fVipRegisterMem)
-		dlsym( vipl_dll, "VipRegisterMem" );
+	    dlsym(vipl_dll, "VipRegisterMem");
 	VipDeregisterMem = (fVipDeregisterMem)
-		dlsym( vipl_dll, "VipDeregisterMem" );
-	
+	    dlsym(vipl_dll, "VipDeregisterMem");
+
 	// Send/receive
-	VipPostSend = (fVipPostSend)dlsym( vipl_dll, "VipPostSend" );
-	VipSendDone = (fVipSendDone)dlsym( vipl_dll, "VipSendDone" );
-	VipSendWait = (fVipSendWait)dlsym( vipl_dll, "VipSendWait" );
-	VipPostRecv = (fVipPostRecv)dlsym( vipl_dll, "VipPostRecv" );
-	VipRecvDone = (fVipRecvDone)dlsym( vipl_dll, "VipRecvDone" );
-	VipRecvWait = (fVipRecvWait)dlsym( vipl_dll, "VipRecvWait" );
-	
+	VipPostSend = (fVipPostSend) dlsym(vipl_dll, "VipPostSend");
+	VipSendDone = (fVipSendDone) dlsym(vipl_dll, "VipSendDone");
+	VipSendWait = (fVipSendWait) dlsym(vipl_dll, "VipSendWait");
+	VipPostRecv = (fVipPostRecv) dlsym(vipl_dll, "VipPostRecv");
+	VipRecvDone = (fVipRecvDone) dlsym(vipl_dll, "VipRecvDone");
+	VipRecvWait = (fVipRecvWait) dlsym(vipl_dll, "VipRecvWait");
+
 	// Completion queues
-	VipCQDone = (fVipCQDone)dlsym( vipl_dll, "VipCQDone" );
-	VipCQWait = (fVipCQWait)dlsym( vipl_dll, "VipCQWait" );
-	VipCreateCQ = (fVipCreateCQ)dlsym( vipl_dll, "VipCreateCQ" );
-	VipDestroyCQ = (fVipDestroyCQ)dlsym( vipl_dll, "VipDestroyCQ" );
-	VipResizeCQ = (fVipResizeCQ)dlsym( vipl_dll, "VipResizeCQ" );
-	
+	VipCQDone = (fVipCQDone) dlsym(vipl_dll, "VipCQDone");
+	VipCQWait = (fVipCQWait) dlsym(vipl_dll, "VipCQWait");
+	VipCreateCQ = (fVipCreateCQ) dlsym(vipl_dll, "VipCreateCQ");
+	VipDestroyCQ = (fVipDestroyCQ) dlsym(vipl_dll, "VipDestroyCQ");
+	VipResizeCQ = (fVipResizeCQ) dlsym(vipl_dll, "VipResizeCQ");
+
 	// Information
-	VipQueryNic = (fVipQueryNic)dlsym( vipl_dll, "VipQueryNic" );
+	VipQueryNic = (fVipQueryNic) dlsym(vipl_dll, "VipQueryNic");
 	VipSetViAttributes = (fVipSetViAttributes)
-		dlsym( vipl_dll, "VipSetViAttributes" );
-	VipQueryVi = (fVipQueryVi)dlsym( vipl_dll, "VipQueryVi" );
+	    dlsym(vipl_dll, "VipSetViAttributes");
+	VipQueryVi = (fVipQueryVi) dlsym(vipl_dll, "VipQueryVi");
 	VipSetMemAttributes = (fVipSetMemAttributes)
-		dlsym( vipl_dll, "VipSetMemAttributes" );
-	VipQueryMem = (fVipQueryMem)dlsym( vipl_dll, "VipQueryMem" );
+	    dlsym(vipl_dll, "VipSetMemAttributes");
+	VipQueryMem = (fVipQueryMem) dlsym(vipl_dll, "VipQueryMem");
 	VipQuerySystemManagementInfo = (fVipQuerySystemManagementInfo)
-		dlsym( vipl_dll, "VipQuerySystemManagementInfo" );
-	
+	    dlsym(vipl_dll, "VipQuerySystemManagementInfo");
+
 	// Peer-to-peer connection
 	VipConnectPeerRequest = (fVipConnectPeerRequest)
-		dlsym( vipl_dll, "VipConnectPeerRequest" );
+	    dlsym(vipl_dll, "VipConnectPeerRequest");
 	VipConnectPeerDone = (fVipConnectPeerDone)
-		dlsym( vipl_dll, "VipConnectPeerDone" );
+	    dlsym(vipl_dll, "VipConnectPeerDone");
 	VipConnectPeerWait = (fVipConnectPeerWait)
-		dlsym( vipl_dll, "VipConnectPeerWait" );
-	
+	    dlsym(vipl_dll, "VipConnectPeerWait");
+
 	// Name service
-	VipNSInit = (fVipNSInit)dlsym( vipl_dll, "VipNSInit" );
+	VipNSInit = (fVipNSInit) dlsym(vipl_dll, "VipNSInit");
 	VipNSGetHostByName = (fVipNSGetHostByName)
-		dlsym( vipl_dll, "VipNSGetHostByName" );
+	    dlsym(vipl_dll, "VipNSGetHostByName");
 	VipNSGetHostByAddr = (fVipNSGetHostByAddr)
-		dlsym( vipl_dll, "VipNSGetHostByAddr" );
+	    dlsym(vipl_dll, "VipNSGetHostByAddr");
 	VipNSShutdown = (fVipNSShutdown)
-		dlsym( vipl_dll, "VipNSShutdown" );
+	    dlsym(vipl_dll, "VipNSShutdown");
 #elif defined(IOMTR_OS_LINUX)
- // nop
+	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
 //
 // Freeing the dynamically linked vipl.dll
 //
@@ -356,89 +346,76 @@
 {
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	// If library had previously been loaded, free it.
-	if ( vipl_dll )
-		FreeLibrary( vipl_dll );
+	if (vipl_dll)
+		FreeLibrary(vipl_dll);
 #elif defined(IOMTR_OS_SOLARIS)
-	if ( vipl_dll )
-		dlclose( vipl_dll );
+	if (vipl_dll)
+		dlclose(vipl_dll);
 	return;
 #elif defined(IOMTR_OS_LINUX)
- // nop
+	// nop
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 }
 
-
-
 //
 // Handy debugger function.  Call like so:
 //
 // cout << "*** Error: " << vipl.Error( result ) << endl;
 //
-char *VIPL::Error( VIP_RETURN result )
+char *VIPL::Error(VIP_RETURN result)
 {
 	static char errmsg[2048];
 
-	switch ( result )
-	{
+	switch (result) {
 	case VIP_NOT_DONE:
-		strcpy( errmsg, "VIP_NOT_DONE - The operation is still in"
-			" progress." );
+		strcpy(errmsg, "VIP_NOT_DONE - The operation is still in" " progress.");
 		break;
 	case VIP_INVALID_PARAMETER:
-		strcpy( errmsg, "VIP_INVALID_PARAMETER - One of the input"
-			" parameters was invalid." );
+		strcpy(errmsg, "VIP_INVALID_PARAMETER - One of the input" " parameters was invalid.");
 		break;
 	case VIP_ERROR_RESOURCE:
-		strcpy( errmsg, "VIP_ERROR_RESOURCE - The operation failed due"
-			" to insufficient resources." );
+		strcpy(errmsg, "VIP_ERROR_RESOURCE - The operation failed due" " to insufficient resources.");
 		break;
 	case VIP_TIMEOUT:
-		strcpy( errmsg, "VIP_TIMEOUT - The operation timed out." );
+		strcpy(errmsg, "VIP_TIMEOUT - The operation timed out.");
 		break;
 	case VIP_REJECT:
-		strcpy( errmsg, "VIP_REJECT - The connection was rejected." );
+		strcpy(errmsg, "VIP_REJECT - The connection was rejected.");
 		break;
 	case VIP_INVALID_RELIABILITY_LEVEL:
-		strcpy( errmsg, "VIP_INVALID_RELIABILITY_LEVEL - The requested"
-			" reliability level attribute was invalid or not supported." );
+		strcpy(errmsg, "VIP_INVALID_RELIABILITY_LEVEL - The requested"
+		       " reliability level attribute was invalid or not supported.");
 		break;
 	case VIP_INVALID_MTU:
-		strcpy( errmsg, "VIP_INVALID_MTU - The maximum transfer size"
-			" attribute was invalid or not supported." );
+		strcpy(errmsg, "VIP_INVALID_MTU - The maximum transfer size"
+		       " attribute was invalid or not supported.");
 		break;
 	case VIP_INVALID_QOS:
-		strcpy( errmsg, "VIP_INVALID_QOS - The quality of service"
-			" attribute was invalid or not supported." );
+		strcpy(errmsg, "VIP_INVALID_QOS - The quality of service" " attribute was invalid or not supported.");
 		break;
 	case VIP_INVALID_PTAG:
-		strcpy( errmsg, "VIP_INVALID_PTAG - The protection tag"
-			" attribute was invalid." );
+		strcpy(errmsg, "VIP_INVALID_PTAG - The protection tag" " attribute was invalid.");
 		break;
 	case VIP_INVALID_RDMAREAD:
-		strcpy( errmsg, "VIP_INVALID_RDMAREAD - The attributes"
-			" requested support for RDMA Read, but the VI Provider"
-			" does not support it." );
+		strcpy(errmsg, "VIP_INVALID_RDMAREAD - The attributes"
+		       " requested support for RDMA Read, but the VI Provider" " does not support it.");
 		break;
 	case VIP_DESCRIPTOR_ERROR:
-		strcpy( errmsg, "VIP_DESCRIPTOR_ERROR - The operation returned"
-			" a null Descriptor pointer." );
+		strcpy(errmsg, "VIP_DESCRIPTOR_ERROR - The operation returned" " a null Descriptor pointer.");
 		break;
 	case VIP_INVALID_STATE:
-		strcpy( errmsg, "VIP_INVALID_STATE - The VI is not in the"
-			" appropriate state for the operation." );
+		strcpy(errmsg, "VIP_INVALID_STATE - The VI is not in the" " appropriate state for the operation.");
 		break;
 	case VIP_ERROR_NAMESERVICE:
-		strcpy( errmsg, "VIP_ERROR_NAMESERVICE - There was an error"
-			" contacting the Name Service." );
+		strcpy(errmsg, "VIP_ERROR_NAMESERVICE - There was an error" " contacting the Name Service.");
 		break;
 	case VIP_NO_MATCH:
-		strcpy( errmsg, "VIP_NO_MATCH - The specified discriminator"
-			" was not matched." );
+		strcpy(errmsg, "VIP_NO_MATCH - The specified discriminator" " was not matched.");
 		break;
 	default:
-		sprintf( errmsg, "Unknown VI error: %d.", result );
+		sprintf(errmsg, "Unknown VI error: %d.", result);
 		break;
 	}
 

Modified: branches/IOMETER-restruct/iometer/src/IOVIPL.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOVIPL.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOVIPL.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -66,25 +66,22 @@
 #ifndef	VIPL_DEFINED
 #define	VIPL_DEFINED
 
-
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
- #define HINSTANCE HANDLE
+#define HINSTANCE HANDLE
 #endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
- #include "IOCommon.h"
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-  #include <dlfcn.h>
- #endif
+#include "IOCommon.h"
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
+#include <dlfcn.h>
+#endif
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <afxwin.h>
+#include <afxwin.h>
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 #include "vipl.h"
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // The VIPL, Virtual Interface Programmer's Library, class dynamically links
 // to vipl.dll.  This library may or may not be loaded on a system.
@@ -95,205 +92,191 @@
 //
 ///////////////////////////////////////////////////////////////////////////////
 
-
 ///////////////////////////////////////////////////////////////////////////////
 // Type definitions for dynamically linked functions.  Actual definitions are
 // located in vipl.h, and these should match accordingly.
 //
 // NIC
-typedef VIP_RETURN (*fVipOpenNic)
-	(const VIP_CHAR *DeviceName, VIP_NIC_HANDLE *NicHandle);
-typedef VIP_RETURN (*fVipCloseNic)
-	(VIP_NIC_HANDLE NicHandle);
+typedef VIP_RETURN(*fVipOpenNic)
+ (const VIP_CHAR * DeviceName, VIP_NIC_HANDLE * NicHandle);
+typedef VIP_RETURN(*fVipCloseNic)
+ (VIP_NIC_HANDLE NicHandle);
+
 //
 // VI
-typedef VIP_RETURN (*fVipCreateVi)
-	(VIP_NIC_HANDLE NicHandle, VIP_VI_ATTRIBUTES *ViAttribs, 
-	VIP_CQ_HANDLE SendCQHandle, VIP_CQ_HANDLE RecvCQHandle,
-	VIP_VI_HANDLE *ViHandle);
-typedef VIP_RETURN (*fVipDestroyVi)
-	(VIP_VI_HANDLE ViHandle);
+typedef VIP_RETURN(*fVipCreateVi)
+ (VIP_NIC_HANDLE NicHandle, VIP_VI_ATTRIBUTES * ViAttribs,
+  VIP_CQ_HANDLE SendCQHandle, VIP_CQ_HANDLE RecvCQHandle, VIP_VI_HANDLE * ViHandle);
+typedef VIP_RETURN(*fVipDestroyVi)
+ (VIP_VI_HANDLE ViHandle);
+
 //
 // Client/server connection
-typedef VIP_RETURN (*fVipConnectWait)
-	(VIP_NIC_HANDLE NicHandle, VIP_NET_ADDRESS *LocalAddr,
-	VIP_ULONG Timeout, VIP_NET_ADDRESS *RemoteAddr, 
-	VIP_VI_ATTRIBUTES *RemoteViAttribs,VIP_CONN_HANDLE *ConnHandle);
-typedef VIP_RETURN (*fVipConnectAccept)
-	(VIP_CONN_HANDLE ConnHandle, VIP_VI_HANDLE ViHandle);
-typedef VIP_RETURN (*fVipConnectReject)
-	(VIP_CONN_HANDLE ConnHandle);
-typedef VIP_RETURN (*fVipConnectRequest)
-	(VIP_VI_HANDLE ViHandle, VIP_NET_ADDRESS *LocalAddr, 
-	VIP_NET_ADDRESS *RemoteAddr, VIP_ULONG Timeout,
-	VIP_VI_ATTRIBUTES *RemoteViAttribs);
-typedef VIP_RETURN (*fVipDisconnect)
-	(VIP_VI_HANDLE ViHandle);
+typedef VIP_RETURN(*fVipConnectWait)
+ (VIP_NIC_HANDLE NicHandle, VIP_NET_ADDRESS * LocalAddr,
+  VIP_ULONG Timeout, VIP_NET_ADDRESS * RemoteAddr, VIP_VI_ATTRIBUTES * RemoteViAttribs, VIP_CONN_HANDLE * ConnHandle);
+typedef VIP_RETURN(*fVipConnectAccept)
+ (VIP_CONN_HANDLE ConnHandle, VIP_VI_HANDLE ViHandle);
+typedef VIP_RETURN(*fVipConnectReject)
+ (VIP_CONN_HANDLE ConnHandle);
+typedef VIP_RETURN(*fVipConnectRequest)
+ (VIP_VI_HANDLE ViHandle, VIP_NET_ADDRESS * LocalAddr,
+  VIP_NET_ADDRESS * RemoteAddr, VIP_ULONG Timeout, VIP_VI_ATTRIBUTES * RemoteViAttribs);
+typedef VIP_RETURN(*fVipDisconnect)
+ (VIP_VI_HANDLE ViHandle);
+
 //
 // Ptag
-typedef VIP_RETURN (*fVipCreatePtag)
-	(VIP_NIC_HANDLE NicHandle, VIP_PROTECTION_HANDLE *Ptag);
-typedef VIP_RETURN (*fVipDestroyPtag)
-	(VIP_NIC_HANDLE NicHandle, VIP_PROTECTION_HANDLE Ptag);
+typedef VIP_RETURN(*fVipCreatePtag)
+ (VIP_NIC_HANDLE NicHandle, VIP_PROTECTION_HANDLE * Ptag);
+typedef VIP_RETURN(*fVipDestroyPtag)
+ (VIP_NIC_HANDLE NicHandle, VIP_PROTECTION_HANDLE Ptag);
+
 //
 // Memory
-typedef VIP_RETURN (*fVipRegisterMem)
-	(VIP_NIC_HANDLE NicHandle, VIP_PVOID VirtualAddress,
-	VIP_ULONG Length, VIP_MEM_ATTRIBUTES *MemAttribs,
-	VIP_MEM_HANDLE *MemoryHandle);
-typedef VIP_RETURN (*fVipDeregisterMem)
-	(VIP_NIC_HANDLE NicHandle, VIP_PVOID VirtualAddress,
-	VIP_MEM_HANDLE MemoryHandle);
+typedef VIP_RETURN(*fVipRegisterMem)
+ (VIP_NIC_HANDLE NicHandle, VIP_PVOID VirtualAddress,
+  VIP_ULONG Length, VIP_MEM_ATTRIBUTES * MemAttribs, VIP_MEM_HANDLE * MemoryHandle);
+typedef VIP_RETURN(*fVipDeregisterMem)
+ (VIP_NIC_HANDLE NicHandle, VIP_PVOID VirtualAddress, VIP_MEM_HANDLE MemoryHandle);
+
 //
 // Send/receive
-typedef VIP_RETURN (*fVipPostSend)
-	(VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR *DescriptorPtr,
-	VIP_MEM_HANDLE MemoryHandle);
-typedef VIP_RETURN (*fVipSendDone)
-	(VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR **DescriptorPtr);
-typedef VIP_RETURN (*fVipSendWait)
-	(VIP_VI_HANDLE ViHandle, VIP_ULONG Timeout,
-	VIP_DESCRIPTOR **DescriptorPtr);
-typedef VIP_RETURN (*fVipPostRecv)
-	(VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR *DescriptorPtr, 
-	VIP_MEM_HANDLE MemoryHandle);
-typedef VIP_RETURN (*fVipRecvDone)
-	(VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR **DescriptorPtr);
-typedef VIP_RETURN (*fVipRecvWait)
-	(VIP_VI_HANDLE ViHandle, VIP_ULONG Timeout,
-	VIP_DESCRIPTOR **DescriptorPtr);
+typedef VIP_RETURN(*fVipPostSend)
+ (VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR * DescriptorPtr, VIP_MEM_HANDLE MemoryHandle);
+typedef VIP_RETURN(*fVipSendDone)
+ (VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR ** DescriptorPtr);
+typedef VIP_RETURN(*fVipSendWait)
+ (VIP_VI_HANDLE ViHandle, VIP_ULONG Timeout, VIP_DESCRIPTOR ** DescriptorPtr);
+typedef VIP_RETURN(*fVipPostRecv)
+ (VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR * DescriptorPtr, VIP_MEM_HANDLE MemoryHandle);
+typedef VIP_RETURN(*fVipRecvDone)
+ (VIP_VI_HANDLE ViHandle, VIP_DESCRIPTOR ** DescriptorPtr);
+typedef VIP_RETURN(*fVipRecvWait)
+ (VIP_VI_HANDLE ViHandle, VIP_ULONG Timeout, VIP_DESCRIPTOR ** DescriptorPtr);
+
 //
 // Completion queues
-typedef VIP_RETURN (*fVipCQDone)
-	(VIP_CQ_HANDLE CQHandle, VIP_VI_HANDLE *ViHandle,
-	VIP_BOOLEAN *RecvQueue);
-typedef VIP_RETURN (*fVipCQWait)
-	(VIP_CQ_HANDLE CQHandle, VIP_ULONG Timeout,
-	VIP_VI_HANDLE *ViHandle, VIP_BOOLEAN *RecvQueue);
-typedef VIP_RETURN (*fVipCreateCQ)
-	(VIP_NIC_HANDLE NicHandle, VIP_ULONG EntryCount,
-	VIP_CQ_HANDLE *CQHandle);
-typedef VIP_RETURN (*fVipDestroyCQ)
-	(VIP_CQ_HANDLE CQHandle);
-typedef VIP_RETURN (*fVipResizeCQ)
-	(VIP_CQ_HANDLE CQHandle, VIP_ULONG EntryCount);
+typedef VIP_RETURN(*fVipCQDone)
+ (VIP_CQ_HANDLE CQHandle, VIP_VI_HANDLE * ViHandle, VIP_BOOLEAN * RecvQueue);
+typedef VIP_RETURN(*fVipCQWait)
+ (VIP_CQ_HANDLE CQHandle, VIP_ULONG Timeout, VIP_VI_HANDLE * ViHandle, VIP_BOOLEAN * RecvQueue);
+typedef VIP_RETURN(*fVipCreateCQ)
+ (VIP_NIC_HANDLE NicHandle, VIP_ULONG EntryCount, VIP_CQ_HANDLE * CQHandle);
+typedef VIP_RETURN(*fVipDestroyCQ)
+ (VIP_CQ_HANDLE CQHandle);
+typedef VIP_RETURN(*fVipResizeCQ)
+ (VIP_CQ_HANDLE CQHandle, VIP_ULONG EntryCount);
+
 //
 // Information
-typedef VIP_RETURN (*fVipQueryNic)
-	(VIP_NIC_HANDLE NicHandle, VIP_NIC_ATTRIBUTES *NicAttribs);
-typedef VIP_RETURN (*fVipSetViAttributes)
-	(VIP_VI_HANDLE ViHandle, VIP_VI_ATTRIBUTES *ViAttribs);
-typedef VIP_RETURN (*fVipQueryVi)
-	(VIP_VI_HANDLE ViHandle, VIP_VI_STATE *State,
-	VIP_VI_ATTRIBUTES *ViAttribs, VIP_BOOLEAN *ViSendQEmpty,
-	VIP_BOOLEAN *ViRecvQEmpty);
-typedef VIP_RETURN (*fVipSetMemAttributes)
-	(VIP_NIC_HANDLE NicHandle, VIP_PVOID Address,
-	VIP_MEM_HANDLE MemHandle, VIP_MEM_ATTRIBUTES *MemAttribs);
-typedef VIP_RETURN (*fVipQueryMem)
-	(VIP_NIC_HANDLE NicHandle, VIP_PVOID Address,
-	VIP_MEM_HANDLE MemHandle, VIP_MEM_ATTRIBUTES *MemAttribs);
-typedef VIP_RETURN (*fVipQuerySystemManagementInfo)
-	(VIP_NIC_HANDLE NicHandle, VIP_ULONG InfoType,
-	VIP_PVOID SysManInfo);
+typedef VIP_RETURN(*fVipQueryNic)
+ (VIP_NIC_HANDLE NicHandle, VIP_NIC_ATTRIBUTES * NicAttribs);
+typedef VIP_RETURN(*fVipSetViAttributes)
+ (VIP_VI_HANDLE ViHandle, VIP_VI_ATTRIBUTES * ViAttribs);
+typedef VIP_RETURN(*fVipQueryVi)
+ (VIP_VI_HANDLE ViHandle, VIP_VI_STATE * State,
+  VIP_VI_ATTRIBUTES * ViAttribs, VIP_BOOLEAN * ViSendQEmpty, VIP_BOOLEAN * ViRecvQEmpty);
+typedef VIP_RETURN(*fVipSetMemAttributes)
+ (VIP_NIC_HANDLE NicHandle, VIP_PVOID Address, VIP_MEM_HANDLE MemHandle, VIP_MEM_ATTRIBUTES * MemAttribs);
+typedef VIP_RETURN(*fVipQueryMem)
+ (VIP_NIC_HANDLE NicHandle, VIP_PVOID Address, VIP_MEM_HANDLE MemHandle, VIP_MEM_ATTRIBUTES * MemAttribs);
+typedef VIP_RETURN(*fVipQuerySystemManagementInfo)
+ (VIP_NIC_HANDLE NicHandle, VIP_ULONG InfoType, VIP_PVOID SysManInfo);
+
 //
 // Peer-to-peer connection
-typedef VIP_RETURN (*fVipConnectPeerRequest)
-	(VIP_VI_HANDLE ViHandle, VIP_NET_ADDRESS *LocalAddr,
-	VIP_NET_ADDRESS *RemoteAddr, VIP_ULONG Timeout);
-typedef VIP_RETURN (*fVipConnectPeerDone)
-	(VIP_VI_HANDLE ViHandle, VIP_VI_ATTRIBUTES *RemoteViAttribs);
-typedef VIP_RETURN (*fVipConnectPeerWait)
-	(VIP_VI_HANDLE ViHandle, VIP_VI_ATTRIBUTES *RemoteViAttribs);
-typedef VIP_RETURN (*fVipNSInit)
-	(VIP_NIC_HANDLE NicHandle, VIP_PVOID NSInitInfo);
+typedef VIP_RETURN(*fVipConnectPeerRequest)
+ (VIP_VI_HANDLE ViHandle, VIP_NET_ADDRESS * LocalAddr, VIP_NET_ADDRESS * RemoteAddr, VIP_ULONG Timeout);
+typedef VIP_RETURN(*fVipConnectPeerDone)
+ (VIP_VI_HANDLE ViHandle, VIP_VI_ATTRIBUTES * RemoteViAttribs);
+typedef VIP_RETURN(*fVipConnectPeerWait)
+ (VIP_VI_HANDLE ViHandle, VIP_VI_ATTRIBUTES * RemoteViAttribs);
+typedef VIP_RETURN(*fVipNSInit)
+ (VIP_NIC_HANDLE NicHandle, VIP_PVOID NSInitInfo);
+
 //
 // Name service
-typedef VIP_RETURN (*fVipNSGetHostByName)
-	(VIP_NIC_HANDLE NicHandle, VIP_CHAR *Name, 
-	VIP_NET_ADDRESS *Address, VIP_ULONG NameIndex);
-typedef VIP_RETURN (*fVipNSGetHostByAddr)
-	(VIP_NIC_HANDLE NicHandle, VIP_NET_ADDRESS *Address,
-	VIP_CHAR *Name, VIP_ULONG *NameLen);
-typedef VIP_RETURN (*fVipNSShutdown)
-	(VIP_NIC_HANDLE NicHandle);
+typedef VIP_RETURN(*fVipNSGetHostByName)
+ (VIP_NIC_HANDLE NicHandle, VIP_CHAR * Name, VIP_NET_ADDRESS * Address, VIP_ULONG NameIndex);
+typedef VIP_RETURN(*fVipNSGetHostByAddr)
+ (VIP_NIC_HANDLE NicHandle, VIP_NET_ADDRESS * Address, VIP_CHAR * Name, VIP_ULONG * NameLen);
+typedef VIP_RETURN(*fVipNSShutdown)
+ (VIP_NIC_HANDLE NicHandle);
+
 //
 ///////////////////////////////////////////////////////////////////////////////
 
-
-
-class VIPL
-{
-public:
+class VIPL {
+      public:
 	VIPL();
 	~VIPL();
-	char *Error( VIP_RETURN result );
+	char *Error(VIP_RETURN result);
 
 	// Handle to vipl.dll library.  Set to NULL if the library is not loaded.
-	static HINSTANCE	vipl_dll;
+	static HINSTANCE vipl_dll;
 
 	///////////////////////////////////////////////////////////////////////////
 	// Dynamic linked functions.
 
 	// NIC
-	static fVipOpenNic		VipOpenNic;
-	static fVipCloseNic		VipCloseNic;
+	static fVipOpenNic VipOpenNic;
+	static fVipCloseNic VipCloseNic;
 
 	// VI
-	static fVipCreateVi		VipCreateVi;
-	static fVipDestroyVi		VipDestroyVi;
+	static fVipCreateVi VipCreateVi;
+	static fVipDestroyVi VipDestroyVi;
 
 	// Client/server connection
-	static fVipConnectWait		VipConnectWait;
-	static fVipConnectAccept	VipConnectAccept;
-	static fVipConnectReject	VipConnectReject;
-	static fVipConnectRequest	VipConnectRequest;
-	static fVipDisconnect		VipDisconnect;
+	static fVipConnectWait VipConnectWait;
+	static fVipConnectAccept VipConnectAccept;
+	static fVipConnectReject VipConnectReject;
+	static fVipConnectRequest VipConnectRequest;
+	static fVipDisconnect VipDisconnect;
 
 	// Ptag
-	static fVipCreatePtag		VipCreatePtag;
-	static fVipDestroyPtag		VipDestroyPtag;
+	static fVipCreatePtag VipCreatePtag;
+	static fVipDestroyPtag VipDestroyPtag;
 
 	// Memory
-	static fVipRegisterMem		VipRegisterMem;
-	static fVipDeregisterMem	VipDeregisterMem;
+	static fVipRegisterMem VipRegisterMem;
+	static fVipDeregisterMem VipDeregisterMem;
 
 	// Send/receive
-	static fVipPostSend		VipPostSend;
-	static fVipSendDone		VipSendDone;
-	static fVipSendWait		VipSendWait;
-	static fVipPostRecv		VipPostRecv;
-	static fVipRecvDone		VipRecvDone;
-	static fVipRecvWait		VipRecvWait;
+	static fVipPostSend VipPostSend;
+	static fVipSendDone VipSendDone;
+	static fVipSendWait VipSendWait;
+	static fVipPostRecv VipPostRecv;
+	static fVipRecvDone VipRecvDone;
+	static fVipRecvWait VipRecvWait;
 
 	// Completion queues
-	static fVipCQDone		VipCQDone;
-	static fVipCQWait		VipCQWait;
-	static fVipCreateCQ		VipCreateCQ;
-	static fVipDestroyCQ		VipDestroyCQ;
-	static fVipResizeCQ		VipResizeCQ;
+	static fVipCQDone VipCQDone;
+	static fVipCQWait VipCQWait;
+	static fVipCreateCQ VipCreateCQ;
+	static fVipDestroyCQ VipDestroyCQ;
+	static fVipResizeCQ VipResizeCQ;
 
 	// Information
-	static fVipQueryNic			VipQueryNic;
-	static fVipSetViAttributes		VipSetViAttributes;
-	static fVipQueryVi			VipQueryVi;
-	static fVipSetMemAttributes		VipSetMemAttributes;
-	static fVipQueryMem			VipQueryMem;
-	static fVipQuerySystemManagementInfo	VipQuerySystemManagementInfo;
+	static fVipQueryNic VipQueryNic;
+	static fVipSetViAttributes VipSetViAttributes;
+	static fVipQueryVi VipQueryVi;
+	static fVipSetMemAttributes VipSetMemAttributes;
+	static fVipQueryMem VipQueryMem;
+	static fVipQuerySystemManagementInfo VipQuerySystemManagementInfo;
 
 	// Peer-to-peer connection
-	static fVipConnectPeerRequest		VipConnectPeerRequest;
-	static fVipConnectPeerDone		VipConnectPeerDone;
-	static fVipConnectPeerWait		VipConnectPeerWait;
+	static fVipConnectPeerRequest VipConnectPeerRequest;
+	static fVipConnectPeerDone VipConnectPeerDone;
+	static fVipConnectPeerWait VipConnectPeerWait;
 
 	// Name service
-	static fVipNSInit			VipNSInit;
-	static fVipNSGetHostByName		VipNSGetHostByName;
-	static fVipNSGetHostByAddr		VipNSGetHostByAddr;
-	static fVipNSShutdown			VipNSShutdown;
+	static fVipNSInit VipNSInit;
+	static fVipNSGetHostByName VipNSGetHostByName;
+	static fVipNSGetHostByAddr VipNSGetHostByAddr;
+	static fVipNSShutdown VipNSShutdown;
 	//
 	///////////////////////////////////////////////////////////////////////////
 };
 
-
-#endif // VIPL_DEFINED
+#endif				// VIPL_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/IOVersion.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOVersion.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/IOVersion.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -76,16 +76,13 @@
 #ifndef _IOVERSION
 #define _IOVERSION
 
-
 #if defined(IOMTR_OSFAMILY_WINDOWS)
- #include <winver.h>
-#endif /* !UNIX */
+#include <winver.h>
+#endif				/* !UNIX */
 
-
 // The maximum size allowed for the version string.
 #define MAX_VERSION_LENGTH 80
 
-
 // Note that the DEBUG version should have an identical version string as the release version,
 // with an added " DEBUG" - the Dynamo/Iometer version comparison in CGalileoApp::OnIdle() ignores
 // the " DEBUG" qualifier when verifying that the two programs are the same version.
@@ -95,10 +92,8 @@
 #define		VERSION_DEBUG	""
 #endif
 
-
 #if defined (__cplusplus)
-extern "C"
-{
+extern "C" {
 #endif
 
 // Iometer has been using date stamps as the version strings, and currently
@@ -106,44 +101,42 @@
 // The last "official" version was "2001.07.19", which is the version
 // you will find in iometer-initial.tar.gz at the Sourceforge page
 // (http://sourceforge.net/projects/iometer).
-//#define IOVER_FILEVERSION				"2003.02.15\0"
-//#define IOVER_FILEVERSION				"2003.02.15-post\0"
-//#define IOVER_FILEVERSION				"2003.05.10\0"
-//#define IOVER_FILEVERSION				"2003.05.10-post\0"
-//#define IOVER_FILEVERSION				"2003.12.16\0"
-//#define IOVER_FILEVERSION				"2003.12.16-post\0"
-//#define IOVER_FILEVERSION				"2004.07.30-RC1\0"
-//#define IOVER_FILEVERSION				"2004.07.30\0"
-//#define IOVER_FILEVERSION				"2003.12.16-post\0"
-//#define IOVER_FILEVERSION				"2004.07.30\0"   // => Has never been active; see IOMETER1 branch!
+//#define IOVER_FILEVERSION                             "2003.02.15\0"
+//#define IOVER_FILEVERSION                             "2003.02.15-post\0"
+//#define IOVER_FILEVERSION                             "2003.05.10\0"
+//#define IOVER_FILEVERSION                             "2003.05.10-post\0"
+//#define IOVER_FILEVERSION                             "2003.12.16\0"
+//#define IOVER_FILEVERSION                             "2003.12.16-post\0"
+//#define IOVER_FILEVERSION                             "2004.07.30-RC1\0"
+//#define IOVER_FILEVERSION                             "2004.07.30\0"
+//#define IOVER_FILEVERSION                             "2003.12.16-post\0"
+//#define IOVER_FILEVERSION                             "2004.07.30\0"   // => Has never been active; see IOMETER1 branch!
 #define IOVER_FILEVERSION				"2004.07.30-post\0"
 #define IOVER_PRODUCTVERSION				IOVER_FILEVERSION
 
-
-
 #if defined(IOMTR_OSFAMILY_WINDOWS)
 
-#define IOVER_LEGALCOPYRIGHT			"Copyright ? 1996-2001 Intel Corporation\0"
+
 #define IOVER_LEGALTRADEMARKS			"\0"
 #define IOVER_COMPANYNAME			"Intel Corporation\0"
 
 #ifdef _DEBUG
- #if defined(IOMTR_OS_WIN64)
-  #define IOVER_PRODUCT_NAME			"Iometer 64-bit (DEBUG)\0"
- #elif defined(IOMTR_OS_WIN32)
-  #define IOVER_PRODUCT_NAME			"Iometer (DEBUG)\0"
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
- #endif
+#if defined(IOMTR_OS_WIN64)
+#define IOVER_PRODUCT_NAME			"Iometer 64-bit (DEBUG)\0"
+#elif defined(IOMTR_OS_WIN32)
+#define IOVER_PRODUCT_NAME			"Iometer (DEBUG)\0"
 #else
- #if defined(IOMTR_OS_WIN64)
-  #define IOVER_PRODUCT_NAME			"Iometer 64-bit\0"
- #elif defined(IOMTR_OS_WIN32)
-  #define IOVER_PRODUCT_NAME			"Iometer\0"
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done! 
- #endif
-#endif // _DEBUG
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
+#else
+#if defined(IOMTR_OS_WIN64)
+#define IOVER_PRODUCT_NAME			"Iometer 64-bit\0"
+#elif defined(IOMTR_OS_WIN32)
+#define IOVER_PRODUCT_NAME			"Iometer\0"
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
+#endif				// _DEBUG
 
 ////////
 // The following are based on unique (for each component) resource variables
@@ -155,11 +148,11 @@
 #define IOVER_INTERNAL_NAME		"Galileo\0"
 #define IOVER_ORIGINAL_FILE_NAME	"Iometer.exe\0"
 #if defined(IOMTR_OS_WIN64)
- #define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI (64-bit)\0"
+#define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI (64-bit)\0"
 #elif defined(IOMTR_OS_WIN32)
- #define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI\0"
+#define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI\0"
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 #define IOVER_COMMENTS			"\0"
 #endif
@@ -169,23 +162,18 @@
 #define IOVER_INTERNAL_NAME		"Pulsar\0"
 #define IOVER_ORIGINAL_FILE_NAME	"Dynamo.exe\0"
 #if defined(IOMTR_OS_WIN64)
- #define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator (64-bit)\0"
+#define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator (64-bit)\0"
 #elif defined(IOMTR_OS_WIN32)
- #define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator\0"
+#define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator\0"
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 #define IOVER_COMMENTS			"\0"
 #endif
 
 #endif
 
-
 #if defined (__cplusplus)
 }
 #endif
-
-
-#endif // _IOVERSION
-
-
+#endif				// _IOVERSION

Modified: branches/IOMETER-restruct/iometer/src/LegalBox.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/LegalBox.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/LegalBox.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -57,7 +57,7 @@
 /* ##                 under which the Source Code and Binaries are        ## */
 /* ##                 distributed.                                        ## */
 /* ##                 EULA sections which are obsolet or stays in         ## */
-/* ##                 contrast to that (namely LIMITED MEDIA WARRANTY,    ## */         
+/* ##                 contrast to that (namely LIMITED MEDIA WARRANTY,    ## */
 /* ##                 TERMINATION OF THIS LICENSE and U.S. GOVERNMENT     ## */
 /* ##                 RESTRICTED RIGHTS) has been blanked out.            ## */
 /* ##               - Integrated the License Statement into this header.  ## */
@@ -68,13 +68,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoApp.h"
 #include "LegalBox.h"
 
-
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -85,20 +82,18 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CLegalBox dialog
 
-
-CLegalBox::CLegalBox(CWnd* pParent /*=NULL*/)
-	: CDialog(CLegalBox::IDD, pParent)
+CLegalBox::CLegalBox(CWnd * pParent /*=NULL*/ )
+:  CDialog(CLegalBox::IDD, pParent)
 {
 	running = FALSE;
 	//{{AFX_DATA_INIT(CLegalBox)
@@ -106,8 +101,7 @@
 	//}}AFX_DATA_INIT
 }
 
-
-void CLegalBox::DoDataExchange(CDataExchange* pDX)
+void CLegalBox::DoDataExchange(CDataExchange * pDX)
 {
 	CDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CLegalBox)
@@ -117,16 +111,13 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CLegalBox, CDialog)
-	//{{AFX_MSG_MAP(CLegalBox)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CLegalBox)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CLegalBox message handlers
-
-BOOL CLegalBox::OnInitDialog() 
+BOOL CLegalBox::OnInitDialog()
 {
 	CDialog::OnInitDialog();
 
@@ -182,7 +173,7 @@
 	legal += "   Neither the name of the Intel Corporation nor the names of its contributors \
    may be used to endorse or promote products derived from this software \
    without specific prior written permission.\x0d\x0a \x0d\x0a";
- 
+
 	legal += "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' \
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \
@@ -239,14 +230,13 @@
 unless they are in writing and signed by an authorized representative of \
 Intel.";
 
-	m_ELegal.SetWindowText( legal );
+	m_ELegal.SetWindowText(legal);
 
-	if ( running )
-	{
-		GetDlgItem( IDCANCEL )->ModifyStyle( WS_VISIBLE, WS_DISABLED );
-		GetDlgItem( IDOK )->SetWindowText( "OK" );
+	if (running) {
+		GetDlgItem(IDCANCEL)->ModifyStyle(WS_VISIBLE, WS_DISABLED);
+		GetDlgItem(IDOK)->SetWindowText("OK");
 	}
 
-	return TRUE;  // return TRUE unless you set the focus to a control
-	              // EXCEPTION: OCX Property Pages should return FALSE
+	return TRUE;		// return TRUE unless you set the focus to a control
+	// EXCEPTION: OCX Property Pages should return FALSE
 }

Modified: branches/IOMETER-restruct/iometer/src/LegalBox.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/LegalBox.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/LegalBox.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -58,54 +58,50 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #ifndef LEGALBOX_DEFINED
 #define LEGALBOX_DEFINED
 
 #if _MSC_VER >= 1000
 #pragma once
-#endif // _MSC_VER >= 1000
+#endif				// _MSC_VER >= 1000
 // LegalBox.h : header file
 //
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CLegalBox dialog
 
-class CLegalBox : public CDialog
-{
+class CLegalBox:public CDialog {
 // Construction
-public:
-	CLegalBox(CWnd* pParent = NULL);   // standard constructor
+      public:
+	CLegalBox(CWnd * pParent = NULL);	// standard constructor
 
 	BOOL running;
 
 // Dialog Data
 	//{{AFX_DATA(CLegalBox)
 	enum { IDD = IDD_LEGAL };
-	CEdit	m_ELegal;
-	CString	m_test;
+	CEdit m_ELegal;
+	CString m_test;
 	//}}AFX_DATA
 
-
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CLegalBox)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 
 	// Generated message map functions
 	//{{AFX_MSG(CLegalBox)
-	virtual BOOL OnInitDialog();
+	 virtual BOOL OnInitDialog();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
 //{{AFX_INSERT_LOCATION}}
 // Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 
-#endif // #ifndef LEGALBOX_DEFINED
+#endif				// #ifndef LEGALBOX_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/MainFrm.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/MainFrm.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/MainFrm.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,13 +61,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "GalileoApp.h"
 #include "GalileoView.h"
 #include "MainFrm.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -78,29 +76,26 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CMainFrame
 
 IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)
 
-BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
-	//{{AFX_MSG_MAP(CMainFrame)
-	ON_WM_CREATE()
-	//}}AFX_MSG_MAP
-END_MESSAGE_MAP()
-
+    BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
+    //{{AFX_MSG_MAP(CMainFrame)
+    ON_WM_CREATE()
+    //}}AFX_MSG_MAP
+    END_MESSAGE_MAP()
 /////////////////////////////////////////////////////////////////////////////
 // CMainFrame construction/destruction
-
-CMainFrame::CMainFrame()
+    CMainFrame::CMainFrame()
 {
 	// CG: The following block was inserted by 'Status Bar' component.
 	{
@@ -119,39 +114,34 @@
 		return -1;
 
 	// Disable the maximize button.
-	ModifyStyle( WS_MAXIMIZEBOX, NULL );
+	ModifyStyle(WS_MAXIMIZEBOX, NULL);
 	// Remove the document title from before the application title.
-	ModifyStyle( FWS_ADDTOTITLE, NULL );
+	ModifyStyle(FWS_ADDTOTITLE, NULL);
 
 	// Create a toolbar.
-	if ( !(theApp.m_wndToolBar.Create(this)) ||
-		 !(theApp.m_wndToolBar.LoadToolBar(IDR_MAINFRAME)) )
-	{
+	if (!(theApp.m_wndToolBar.Create(this)) || !(theApp.m_wndToolBar.LoadToolBar(IDR_MAINFRAME))) {
 		TRACE0("Failed to create toolbar\n");
-		return -1;      // fail to create
+		return -1;	// fail to create
 	}
-
 	// Create a stus bar at the bottom of the window.
-	if ( !(theApp.m_wndStatusBar.Create(this)) )
-	{
+	if (!(theApp.m_wndStatusBar.Create(this))) {
 		TRACE0("Failed to create statusbar\n");
-		return -1;      // fail to create
+		return -1;	// fail to create
 	}
-
 	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
 	theApp.m_wndToolBar.SetBarStyle(theApp.m_wndToolBar.GetBarStyle() |
-		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
+					CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
 
 	// TODO: Delete these three lines if you don't want the toolbar to
 	//  be dockable
-//	theApp.m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
-//	EnableDocking(CBRS_ALIGN_ANY);
-//	DockControlBar(&(theApp.m_wndToolBar));
+//      theApp.m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
+//      EnableDocking(CBRS_ALIGN_ANY);
+//      DockControlBar(&(theApp.m_wndToolBar));
 
 	return 0;
 }
 
-BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
+BOOL CMainFrame::PreCreateWindow(CREATESTRUCT & cs)
 {
 	// TODO: Modify the Window class or styles here by modifying
 	//  the CREATESTRUCT cs
@@ -159,28 +149,25 @@
 	return CFrameWnd::PreCreateWindow(cs);
 }
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CMainFrame diagnostics
 
 #ifdef _DEBUG
-void CMainFrame::AssertValid() const
+void CMainFrame::AssertValid() const const
 {
 	CFrameWnd::AssertValid();
 }
 
-void CMainFrame::Dump(CDumpContext& dc) const
+void CMainFrame::Dump(CDumpContext & dc) const const
 {
 	CFrameWnd::Dump(dc);
 }
 
-#endif //_DEBUG
+#endif				//_DEBUG
 
-
-LRESULT CMainFrame::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
+LRESULT CMainFrame::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam)
 {
-	if ( message == WM_EXITMENULOOP )
-	{
+	if (message == WM_EXITMENULOOP) {
 		// Popup is being destroyed.  Uncheck any checked buttons on the
 		// display page.
 		theApp.pView->m_pPageDisplay->ClearCheckButton();

Modified: branches/IOMETER-restruct/iometer/src/MainFrm.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/MainFrm.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/MainFrm.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,61 +59,56 @@
 #ifndef FRAME_DEFINED
 #define FRAME_DEFINED
 
-
 #include "IOCommon.h"
 
-
-class CMainFrame : public CFrameWnd
-{
-protected: // create from serialization only
+class CMainFrame:public CFrameWnd {
+      protected:		// create from serialization only
 	CMainFrame();
 	DECLARE_DYNCREATE(CMainFrame)
-
 // Attributes
-public:
+      public:
 
 // Operations
-public:
+      public:
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CMainFrame)
-	public:
-	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
-	protected:
+      public:
+	virtual BOOL PreCreateWindow(CREATESTRUCT & cs);
+      protected:
 	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);
 	//}}AFX_VIRTUAL
 
 // Implementation
-public:
-	virtual ~CMainFrame();
+      public:
+	virtual ~ CMainFrame();
 #ifdef _DEBUG
 	virtual void AssertValid() const;
-	virtual void Dump(CDumpContext& dc) const;
+	virtual void Dump(CDumpContext & dc) const;
 #endif
 
 //protected:  // control bar embedded members
-public:
+      public:
 
-//	CToolBar    m_wndToolBar;
+//      CToolBar    m_wndToolBar;
 
 // Generated message map functions
-protected:
+      protected:
 	//{{AFX_MSG(CMainFrame)
-	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
+	 afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
-private:
-	UINT m_nStatusPane1ID;
-private:
-	UINT m_nStatusPane1Style;
-private:
-	INT  m_nStatusPane1Width;
-private:
-	BOOL m_bMenuSelect;
+	 DECLARE_MESSAGE_MAP()
+      private:
+	 UINT m_nStatusPane1ID;
+      private:
+	 UINT m_nStatusPane1Style;
+      private:
+	 INT m_nStatusPane1Width;
+      private:
+	 BOOL m_bMenuSelect;
 };
 
 /////////////////////////////////////////////////////////////////////////////
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/Manager.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/Manager.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/Manager.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -67,14 +67,12 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "Manager.h"
 #include "ManagerList.h"
 #include "GalileoApp.h"
 #include "GalileoView.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -85,34 +83,32 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 Manager::Manager()
 {
 	id = IOERROR;
-	ResetResults( WHOLE_TEST_PERF );
-	ResetResults( LAST_UPDATE_PERF );
-	tcps.SetSize( INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP );
-	vis.SetSize( INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP );
-	disks.SetSize( INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP );
-	workers.SetSize( INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP );
+	ResetResults(WHOLE_TEST_PERF);
+	ResetResults(LAST_UPDATE_PERF);
+	tcps.SetSize(INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP);
+	vis.SetSize(INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP);
+	disks.SetSize(INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP);
+	workers.SetSize(INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP);
 	port = NULL;
 }
 
-
 Manager::~Manager()
 {
 	// Removing all worker, disk info, and net info from the manager.
-	while ( WorkerCount() )
-	{
-		delete GetWorker( 0 );
-		workers.RemoveAt( 0 );
+	while (WorkerCount()) {
+		delete GetWorker(0);
+
+		workers.RemoveAt(0);
 	}
 	RemoveDiskInfo();
 	RemoveNetInfo();
@@ -122,92 +118,78 @@
 	delete port;
 }
 
-
 //
 // Returns the index of the manager.
 //
 int Manager::GetIndex()
 {
-	for ( int m = 0; m < theApp.manager_list.ManagerCount(); m++ )
-	{
-		if ( this == theApp.manager_list.GetManager( m ) )
+	for (int m = 0; m < theApp.manager_list.ManagerCount(); m++) {
+		if (this == theApp.manager_list.GetManager(m))
 			return m;
 	}
 	return IOERROR;
 }
 
-
-
 //
 // Returns an indication of all types of workers that a manager has.
 //
 TargetType Manager::Type()
 {
-	int			i, worker_count;
-	TargetType	type = GenericType;
+	int i, worker_count;
+	TargetType type = GenericType;
 
 	worker_count = WorkerCount();
-	for ( i = 0; i < worker_count; i++ )
-		type = (TargetType)( type | workers[i]->Type() );
+	for (i = 0; i < worker_count; i++)
+		type = (TargetType) (type | workers[i]->Type());
 
 	// See if the manager is active.
 	// (A manager may be active even if none of its workers are.)
-	if ( ActiveInCurrentTest() )
-		type = (TargetType)( type | ActiveType );
+	if (ActiveInCurrentTest())
+		type = (TargetType) (type | ActiveType);
 
 	return type;
 }
 
-
-
 //
 // Get information about a given worker.  This returns the nth worker of the
 // specified type.
 //
-Worker* Manager::GetWorker( int index, TargetType type )
+Worker *Manager::GetWorker(int index, TargetType type)
 {
 	int i, worker_count;
 
 	// Make sure the desired worker exists.
-	if ( index < 0 || index >= WorkerCount( type ) )
+	if (index < 0 || index >= WorkerCount(type))
 		return NULL;
 
 	// Find the worker.
 	worker_count = WorkerCount();
-	for ( i = 0; i < worker_count; i++ )
-	{
-		if ( IsType( workers[i]->Type(), type ) )
-		{
-			if ( !index-- )
+	for (i = 0; i < worker_count; i++) {
+		if (IsType(workers[i]->Type(), type)) {
+			if (!index--)
 				return workers[i];
 		}
 	}
 
-	ASSERT( 0 );	// requested worker not found - should not happen
+	ASSERT(0);		// requested worker not found - should not happen
 	return NULL;
 }
 
-
-
 //
 // Get the first worker having the specified name, if any.
 //
-Worker* Manager::GetWorkerByName( const char *wkr_name, const int wkr_id )
+Worker *Manager::GetWorkerByName(const char *wkr_name, const int wkr_id)
 {
-	int	i, worker_count;
+	int i, worker_count;
 
-	if ( !wkr_name )
-	{
-		ErrorMessage("Invalid string in Manager::GetWorkerByName()" );
+	if (!wkr_name) {
+		ErrorMessage("Invalid string in Manager::GetWorkerByName()");
 		return NULL;
 	}
 
 	worker_count = WorkerCount();
-	for ( i = 0; i < worker_count; i++ )
-	{
-		if ( strcmp( workers[i]->name, wkr_name ) == 0
-			&& workers[i]->id == wkr_id )
-		{
+	for (i = 0; i < worker_count; i++) {
+		if (strcmp(workers[i]->name, wkr_name) == 0 && workers[i]->id == wkr_id) {
 			return workers[i];
 		}
 	}
@@ -216,59 +198,54 @@
 	return NULL;
 }
 
-
 //
 // Adding a new worker to the worker list.  The new worker is always added to 
 // the end of the list.  A connection to the worker is also made
 //  * May use a given worker as a template.
 //  * May specify the new worker's name.  (Ignored if src_worker is defined.)
 //
-Worker* Manager::AddWorker( TargetType type,
-							Worker *src_worker, const CString& in_name )
+Worker *Manager::AddWorker(TargetType type, Worker * src_worker, const CString & in_name)
 {
 	Message msg;
-	Worker	*new_worker;
+	Worker *new_worker;
 
 	// Adding the new worker to the manager.
-	if ( WorkerCount() >= MAX_WORKERS )
-		return( NULL );
+	if (WorkerCount() >= MAX_WORKERS)
+		return (NULL);
 
 	// Request that a new worker be spawned.
 	// The data of the message is the number of workers to spawn.
 	msg.purpose = ADD_WORKERS;
 	msg.data = 1;
-	if (Send( &msg ) != MESSAGE_SIZE)
+	if (Send(&msg) != MESSAGE_SIZE)
 		ErrorMessage("Message may not be sent correctly in Manager::AddWorker().");
-	if (Receive( &msg ) != MESSAGE_SIZE)
+	if (Receive(&msg) != MESSAGE_SIZE)
 		ErrorMessage("Message may not be received correctly in Manager::AddWorker().");
 
 	// Verifying that the worker was created.
-	if ( !msg.data )
-		return ( NULL );
+	if (!msg.data)
+		return (NULL);
 
 	// Allocating space for the new worker under the manager.
-	new_worker = new Worker( this, type );
+	new_worker = new Worker(this, type);
 
 	// Adding worker to end of the worker list.
-	workers.Add( new_worker );
+	workers.Add(new_worker);
 
-	if ( !src_worker )
-	{
+	if (!src_worker) {
 		// Set the name of the worker based on the number of workers for 
 		// this manager
 		CString worker_name;
 
-		if ( in_name.IsEmpty() )
-			worker_name.Format("Worker %d", WorkerCount() );
+		if (in_name.IsEmpty())
+			worker_name.Format("Worker %d", WorkerCount());
 		else
 			worker_name = in_name;
 
-		strcpy( new_worker->name, worker_name );
-	}
-	else
-	{
+		strcpy(new_worker->name, worker_name);
+	} else {
 		// Copy the template's name and other information.
-		new_worker->Clone( src_worker );
+		new_worker->Clone(src_worker);
 	}
 
 	// Reassign the disambiguating IDs this manager's workers.
@@ -277,74 +254,64 @@
 	return new_worker;
 }
 
-
-
 //
 // Removing a worker from the list.  Return FALSE if all workers have
 // been removed.
 //
-BOOL Manager::RemoveWorker( int index, TargetType type )
+BOOL Manager::RemoveWorker(int index, TargetType type)
 {
-	Worker	*worker;
-	int		main_index;
+	Worker *worker;
+	int main_index;
 
 	// Get the desired worker.
-	if ( !(worker = GetWorker( index, type )) )
-	{
-		ErrorMessage( "Invalid worker in Manager::RemoveWorker()." );
+	if (!(worker = GetWorker(index, type))) {
+		ErrorMessage("Invalid worker in Manager::RemoveWorker().");
 		return FALSE;
 	}
 	main_index = worker->GetIndex();
 
 	// Informing Dynamo to remove the worker.
 	// The data of the message is the index of the worker to remove.
-	Send( main_index, EXIT );
+	Send(main_index, EXIT);
 
 	// Remove the worker from memory.
-	workers.RemoveAt( main_index );
+	workers.RemoveAt(main_index);
 	delete worker;
 
 	// Reassign the disambiguating IDs this manager's workers.
 	IndexWorkers();
 
-	return WorkerCount( type );
+	return WorkerCount(type);
 }
 
-
-
 //
 // Returns the number of workers in the worker list.
 //
-int Manager::WorkerCount( TargetType type )
+int Manager::WorkerCount(TargetType type)
 {
 	int i, count = 0, worker_count;
 
 	worker_count = workers.GetSize();
-	for ( i = 0; i < worker_count; i++ )
-	{
-		if ( IsType( workers[i]->Type(), type ) )
+	for (i = 0; i < worker_count; i++) {
+		if (IsType(workers[i]->Type(), type))
 			count++;
 	}
 	return count;
 }
 
-
-
 //
 // Number of targets for all workers under this manager.
 //
-int Manager::TargetCount( TargetType type )
+int Manager::TargetCount(TargetType type)
 {
-	int	w, count = 0, wkr_count = WorkerCount();
+	int w, count = 0, wkr_count = WorkerCount();
 
-	for ( w = 0; w < wkr_count; w++ )
-		count += GetWorker( w )->TargetCount( type );
+	for (w = 0; w < wkr_count; w++)
+		count += GetWorker(w)->TargetCount(type);
 
 	return count;
 }
 
-
-
 //
 // Removing all cached disk information for manager and all its workers.
 //
@@ -353,20 +320,18 @@
 	int i, wkr_count;
 
 	// Deleting Disk_Info objects held in "disks" array
-	for ( i = 0; i < InterfaceCount( GenericDiskType ); i++ )
-		delete disks[ i ];
+	for (i = 0; i < InterfaceCount(GenericDiskType); i++)
+		delete disks[i];
 
 	// Deleting memory used by "disks" array itself
 	disks.RemoveAll();
 
 	// Removing all disk targets assigned to the manager's workers.
 	wkr_count = WorkerCount();
-	for ( i = 0; i < wkr_count; i++ )
-		GetWorker( i )->RemoveTargets( GenericDiskType );
+	for (i = 0; i < wkr_count; i++)
+		GetWorker(i)->RemoveTargets(GenericDiskType);
 }
 
-
-
 //
 // Removing all cached network information for manager and all its workers.
 //
@@ -376,51 +341,48 @@
 
 	// Deleting network information referenced by "tcp" array
 	net_count = tcps.GetSize();
-	for ( i = 0; i < net_count; i++ )
-		delete tcps[ i ];
+	for (i = 0; i < net_count; i++)
+		delete tcps[i];
+
 	tcps.RemoveAll();
 
 	net_count = vis.GetSize();
-	for ( i = 0; i < net_count; i++ )
+	for (i = 0; i < net_count; i++)
 		delete vis[i];
+
 	vis.RemoveAll();
 
 	// Removing all network targets assigned to the manager's workers.
 	wkr_count = WorkerCount();
-	for ( i = 0; i < wkr_count; i++ )
-		GetWorker( i )->RemoveTargets( GenericNetType );
+	for (i = 0; i < wkr_count; i++)
+		GetWorker(i)->RemoveTargets(GenericNetType);
 }
 
-
-
 //
 // Setting the test specifications for all workers.
 //
-BOOL Manager::SetAccess( int access_index )
+BOOL Manager::SetAccess(int access_index)
 {
-	int	w, wkr_count = WorkerCount();
+	int w, wkr_count = WorkerCount();
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		if ( !GetWorker( w )->SetAccess( access_index ) )
+	for (w = 0; w < wkr_count; w++) {
+		if (!GetWorker(w)->SetAccess(access_index))
 			return FALSE;
 	}
 	return TRUE;
 }
 
-
 //
 // Initializing results for the manager.
 //
-void Manager::ResetResults( int which_perf )
+void Manager::ResetResults(int which_perf)
 {
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF))
 		return;
 
-	memset( &(results[which_perf]), 0, sizeof( Results ) );
+	memset(&(results[which_perf]), 0, sizeof(Results));
 }
 
-
 //
 // Resetting all results related to the manager.  This includes resetting all results
 // for its workers and whatever results a worker relies on.
@@ -429,114 +391,98 @@
 {
 	int w, wkr_count = WorkerCount();
 
-	ResetResults( WHOLE_TEST_PERF );
-	ResetResults( LAST_UPDATE_PERF );
-	
+	ResetResults(WHOLE_TEST_PERF);
+	ResetResults(LAST_UPDATE_PERF);
+
 	// Resetting results for all worker threads as well.
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w )->ResetAllResults();
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w)->ResetAllResults();
 }
 
-
-
 //
 // Removing all targets from manager's workers.
 //
-void Manager::RemoveTargets( TargetType type )
+void Manager::RemoveTargets(TargetType type)
 {
-	int	w;
+	int w;
 
 	// A target might be a network client, so always check against the current
 	// worker count (WorkerCount()) and not a saved value.
-	for ( w = 0; w < WorkerCount(); w++ )
-		GetWorker( w )->RemoveTargets( type );
+	for (w = 0; w < WorkerCount(); w++)
+		GetWorker(w)->RemoveTargets(type);
 }
 
-
-
 //
 // Resets a worker's drives to indicate that they are not running.
 //
 void Manager::ClearActiveTargets()
 {
-	int	w, wkr_count = WorkerCount();
+	int w, wkr_count = WorkerCount();
 
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w )->ClearActiveTargets();
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w)->ClearActiveTargets();
 }
 
-
-
 //
 // Marks which targets accessible by a worker are to run, and sending the
 // worker the list.  Returns number of targets actually set (IOERROR in case of error).
 //
-int Manager::SetActiveTargets( int worker_index, int targets_to_set )
+int Manager::SetActiveTargets(int worker_index, int targets_to_set)
 {
-	return GetWorker( worker_index )->SetActiveTargets( targets_to_set );
+	return GetWorker(worker_index)->SetActiveTargets(targets_to_set);
 }
 
-
-
 //
 // Peeking to see if a given worker has sent back a message that's waiting 
 // in its message queue.
 //
-DWORD Manager::Peek( int worker_index )
+DWORD Manager::Peek(int worker_index)
 {
 	return port->Peek();
 }
 
-
-
 //
 // Sending a message to Dynamo.
 //
-DWORDLONG Manager::Send( Message* msg )
+DWORDLONG Manager::Send(Message * msg)
 {
-	return port->Send( msg );
+	return port->Send(msg);
 }
 
-
-DWORDLONG Manager::SendData( Data_Message* data_msg )
+DWORDLONG Manager::SendData(Data_Message * data_msg)
 {
-	return port->Send( data_msg, DATA_MESSAGE_SIZE );
+	return port->Send(data_msg, DATA_MESSAGE_SIZE);
 }
 
-
-DWORDLONG Manager::Send( int data, int purpose )
+DWORDLONG Manager::Send(int data, int purpose)
 {
 	Message msg;
+
 	msg.purpose = purpose;
 	msg.data = data;
-	return Send( &msg );
+	return Send(&msg);
 }
 
-
-
 //
 // Getting a message from Dynamo.
 //
-DWORDLONG Manager::Receive( Message* msg )
+DWORDLONG Manager::Receive(Message * msg)
 {
-	return port->Receive( msg );
+	return port->Receive(msg);
 }
 
-
-DWORDLONG Manager::ReceiveData( Data_Message* data_msg )
+DWORDLONG Manager::ReceiveData(Data_Message * data_msg)
 {
-	return port->Receive( data_msg, DATA_MESSAGE_SIZE );
+	return port->Receive(data_msg, DATA_MESSAGE_SIZE);
 }
 
-
 DWORDLONG Manager::Receive()
 {
 	Message msg;
-	return Receive( &msg );
+
+	return Receive(&msg);
 }
 
-
-
 //
 // Updating the list of targets known by a manager.  This retrieves the
 // target information from Dynamo.
@@ -544,105 +490,90 @@
 void Manager::UpdateTargetLists()
 {
 	// Query worker for list of available targets.
-	Send( MANAGER, REPORT_TARGETS );
+	Send(MANAGER, REPORT_TARGETS);
 
 	// Reset information about currently stored targets.
 	RemoveDiskInfo();
 	RemoveNetInfo();
 
 	// Get the reply containing the target information and initialize the lists.
-	InitTargetList( &disks );
-	InitTargetList( &tcps );
-	InitTargetList( &vis );
+	InitTargetList(&disks);
+	InitTargetList(&tcps);
+	InitTargetList(&vis);
 }
 
-
-
 //
 // Initialize the specified target list using the target specifications
 // given in the data message.
 //
-void Manager::InitTargetList( CTypedPtrArray<CPtrArray, Target_Spec*> *targets )
+void Manager::InitTargetList(CTypedPtrArray < CPtrArray, Target_Spec * >*targets)
 {
-	int				i;
-	Data_Message	data_msg;
-	Target_Spec		*target_spec;
+	int i;
+	Data_Message data_msg;
+	Target_Spec *target_spec;
 
 	// Receive the target specifications in a data message.
-	ReceiveData( &data_msg );
+	ReceiveData(&data_msg);
 
 	// Add the targets to the specified array.
-	for ( i = 0; i < data_msg.count; i++ )
-	{
+	for (i = 0; i < data_msg.count; i++) {
 		target_spec = new Target_Spec;
-		memcpy( target_spec, &data_msg.data.targets[i], sizeof( Target_Spec ) );
+		memcpy(target_spec, &data_msg.data.targets[i], sizeof(Target_Spec));
 
 		// Initialize the target specs to the default settings.
 		target_spec->queue_depth = 1;
 		target_spec->test_connection_rate = FALSE;
 		target_spec->trans_per_conn = 1;
 
-		targets->Add( target_spec );
+		targets->Add(target_spec);
 	}
 }
 
-
-
-
 //
 // Sets each workers targets to run for the next test.  This call will result
 // in each worker sending their active target list to Dynamo.
 //
 BOOL Manager::SetTargets()
 {
-	int	w, wkr_count = WorkerCount();
+	int w, wkr_count = WorkerCount();
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		if ( !GetWorker( w )->SetTargets() )
+	for (w = 0; w < wkr_count; w++) {
+		if (!GetWorker(w)->SetTargets())
 			return FALSE;
 	}
 	return TRUE;
 }
 
-
-
 //
 // Setting targets that need to be prepared for the specified worker.
 //
-void Manager::SetTargetsToPrepare( int worker_index )
+void Manager::SetTargetsToPrepare(int worker_index)
 {
-	GetWorker( worker_index )->SetTargetsToPrepare();
+	GetWorker(worker_index)->SetTargetsToPrepare();
 }
 
-
-
 //
 // Receives the answer to a prepare command.
 //
-BOOL Manager::PreparedAnswer( int worker_index )
+BOOL Manager::PreparedAnswer(int worker_index)
 {
-	Message	msg;
-	int		t, i;
-	Worker	*wkr = GetWorker(worker_index);
+	Message msg;
+	int t, i;
+	Worker *wkr = GetWorker(worker_index);
 
 	// Get the notification message that the prepare is done.
-	Receive( &msg );
+	Receive(&msg);
 
 	// Verify that all targets were successfully prepared.
-	if ( !msg.data )
+	if (!msg.data)
 		return FALSE;
 
 	// Update the ready status of all disk targets that the worker prepared.
-	for ( t = 0; t < wkr->TargetCount(); t++ )
-	{
+	for (t = 0; t < wkr->TargetCount(); t++) {
 		// Find the worker's corresponding disk in the manager's disk list.
-		for ( i = 0; i < InterfaceCount( GenericDiskType ); i++ )
-		{
-			if ( !strcmp( wkr->GetTarget(t)->spec.name, 
-				GetInterface( i, GenericDiskType )->name ) )
-			{
-				GetInterface( i, GenericDiskType )->disk_info.ready = TRUE;
+		for (i = 0; i < InterfaceCount(GenericDiskType); i++) {
+			if (!strcmp(wkr->GetTarget(t)->spec.name, GetInterface(i, GenericDiskType)->name)) {
+				GetInterface(i, GenericDiskType)->disk_info.ready = TRUE;
 			}
 		}
 	}
@@ -654,154 +585,138 @@
 	return TRUE;
 }
 
-
-
 //
 // Saving the manager's results to a file along with all of its workers and
 // their targets.
 //
-void Manager::SaveResults( ostream* file, int access_index, int result_type )
+void Manager::SaveResults(ostream * file, int access_index, int result_type)
 {
 	int stat;
 	char specname[MAX_WORKER_NAME];
 
-	if( !ActiveInCurrentTest() )
+	if (!ActiveInCurrentTest())
 		return;
 
 	// Save manager's results.
-	(*file)	<< "MANAGER" 
-			<< "," << name
-			<< "," << GetCommonAccessSpec( access_index, specname ) 
-			<< "," // Space for managers running.
-			<< "," << WorkerCount( ActiveType )
-			<< "," << TargetCount( ActiveType ) + WorkerCount( 
-						(TargetType)(GenericClientType | ActiveType) )
-			<< "," << results[WHOLE_TEST_PERF].IOps  
-			<< "," << results[WHOLE_TEST_PERF].read_IOps 
-			<< "," << results[WHOLE_TEST_PERF].write_IOps 
-			<< "," << results[WHOLE_TEST_PERF].MBps 
-			<< "," << results[WHOLE_TEST_PERF].read_MBps 
-			<< "," << results[WHOLE_TEST_PERF].write_MBps 
-			<< "," << results[WHOLE_TEST_PERF].transactions_per_second 
-			<< "," << results[WHOLE_TEST_PERF].connections_per_second 
-			<< "," << results[WHOLE_TEST_PERF].ave_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_write_latency
-			<< "," << results[WHOLE_TEST_PERF].ave_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_write_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].total_errors 
-			<< "," << results[WHOLE_TEST_PERF].raw.read_errors 
-			<< "," << results[WHOLE_TEST_PERF].raw.write_errors 
+	(*file) << "MANAGER" << "," << name << "," << GetCommonAccessSpec(access_index, specname)
+	    << ","		// Space for managers running.
+	    << "," << WorkerCount(ActiveType)
+	    << "," << TargetCount(ActiveType) + WorkerCount((TargetType) (GenericClientType | ActiveType))
+	    << "," << results[WHOLE_TEST_PERF].IOps
+	    << "," << results[WHOLE_TEST_PERF].read_IOps
+	    << "," << results[WHOLE_TEST_PERF].write_IOps
+	    << "," << results[WHOLE_TEST_PERF].MBps
+	    << "," << results[WHOLE_TEST_PERF].read_MBps
+	    << "," << results[WHOLE_TEST_PERF].write_MBps
+	    << "," << results[WHOLE_TEST_PERF].transactions_per_second
+	    << "," << results[WHOLE_TEST_PERF].connections_per_second
+	    << "," << results[WHOLE_TEST_PERF].ave_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_read_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_write_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].max_latency
+	    << "," << results[WHOLE_TEST_PERF].max_read_latency
+	    << "," << results[WHOLE_TEST_PERF].max_write_latency
+	    << "," << results[WHOLE_TEST_PERF].max_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].max_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].total_errors
+	    << "," << results[WHOLE_TEST_PERF].raw.read_errors << "," << results[WHOLE_TEST_PERF].raw.write_errors
+	    // Save raw result information as well.
+	    << "," << results[WHOLE_TEST_PERF].raw.bytes_read
+	    << "," << results[WHOLE_TEST_PERF].raw.bytes_written
+	    << "," << results[WHOLE_TEST_PERF].raw.read_count
+	    << "," << results[WHOLE_TEST_PERF].raw.write_count
+	    << "," << results[WHOLE_TEST_PERF].raw.connection_count << ",";
 
-			// Save raw result information as well.
-			<< "," << results[WHOLE_TEST_PERF].raw.bytes_read
-			<< "," << results[WHOLE_TEST_PERF].raw.bytes_written
-			<< "," << results[WHOLE_TEST_PERF].raw.read_count
-			<< "," << results[WHOLE_TEST_PERF].raw.write_count
-			<< "," << results[WHOLE_TEST_PERF].raw.connection_count << ",";
-
-	if ( GetConnectionRate( ActiveType ) == ENABLED_VALUE )
-		(*file) << GetTransPerConn( ActiveType );
+	if (GetConnectionRate(ActiveType) == ENABLED_VALUE)
+		(*file) << GetTransPerConn(ActiveType);
 	else
 		(*file) << AMBIGUOUS_VALUE;
 
-	(*file) << "," << results[WHOLE_TEST_PERF].raw.read_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.write_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.transaction_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.connection_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_write_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.counter_time;
+	(*file) << "," << results[WHOLE_TEST_PERF].raw.read_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.write_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.transaction_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.connection_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_read_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_write_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.counter_time;
 
-	(*file) << "," << GetDiskStart( (TargetType)(GenericDiskType | ActiveType) )
-			<< "," << GetDiskSize( (TargetType)(GenericDiskType | ActiveType) )
-			<< "," << GetQueueDepth( ActiveType );
+	(*file) << "," << GetDiskStart((TargetType) (GenericDiskType | ActiveType))
+	    << "," << GetDiskSize((TargetType) (GenericDiskType | ActiveType))
+	    << "," << GetQueueDepth(ActiveType);
 
-	for ( stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++ )
+	for (stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++)
 		(*file) << "," << results[WHOLE_TEST_PERF].CPU_utilization[stat];
 
-	(*file) << "," << processor_speed  
-			<< "," << results[WHOLE_TEST_PERF].CPU_utilization[CPU_IRQ]
-			<< "," << results[WHOLE_TEST_PERF].CPU_effectiveness;
+	(*file) << "," << processor_speed << "," << results[WHOLE_TEST_PERF].CPU_utilization[CPU_IRQ]
+	    << "," << results[WHOLE_TEST_PERF].CPU_effectiveness;
 
-	for ( stat = 0; stat < NI_COMBINE_RESULTS; stat++ )
+	for (stat = 0; stat < NI_COMBINE_RESULTS; stat++)
 		(*file) << "," << results[WHOLE_TEST_PERF].ni_statistics[stat];
 
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
+	for (stat = 0; stat < TCP_RESULTS; stat++)
 		(*file) << "," << results[WHOLE_TEST_PERF].tcp_statistics[stat];
 
 	(*file) << endl;
 
 	// Save individual CPU results.
-	for ( int cpu = 0; cpu < processors; cpu++ )
-	{
-		(*file) << "PROCESSOR" 
-				<< "," << "CPU " << cpu
-				<< ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,";
+	for (int cpu = 0; cpu < processors; cpu++) {
+		(*file) << "PROCESSOR" << "," << "CPU " << cpu << ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,";
 
-		for ( stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++ )
+		for (stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++)
 			(*file) << "," << results[WHOLE_TEST_PERF].individual_CPU_utilization[cpu][stat];
 
 		(*file) << "," << processor_speed
-				<< "," << results[WHOLE_TEST_PERF].individual_CPU_utilization[cpu][CPU_IRQ]
-				<< ",";	// Space for CPU_effectiveness (no way to calculate IOs per processor)
+		    << "," << results[WHOLE_TEST_PERF].individual_CPU_utilization[cpu][CPU_IRQ]
+		    << ",";	// Space for CPU_effectiveness (no way to calculate IOs per processor)
 
-		for ( stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++ )
-			(*file) << ","; // space for network results
+		for (stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++)
+			(*file) << ",";	// space for network results
 
 		(*file) << endl;
 	}
 
-
 	// If requested, save workers' results.
-	if ( result_type == RecordAll || result_type == RecordNoTargets )
-	{
-		for ( int i = 0; i < WorkerCount(); i++ )
-			GetWorker( i )->SaveResults( file, access_index, result_type );
+	if (result_type == RecordAll || result_type == RecordNoTargets) {
+		for (int i = 0; i < WorkerCount(); i++)
+			GetWorker(i)->SaveResults(file, access_index, result_type);
 	}
 }
 
-
 //
 // Updating the results stored with the manager.
 //
-void Manager::UpdateResults( int which_perf )
+void Manager::UpdateResults(int which_perf)
 {
-	Worker*			worker;
-	Data_Message	data_msg;
-	CPU_Results*	cpu_results;
-	Net_Results*	net_results;
-	_int64			start_perf_time, end_perf_time;
-	int				i, stat;		// loop control variables
+	Worker *worker;
+	Data_Message data_msg;
+	CPU_Results *cpu_results;
+	Net_Results *net_results;
+	_int64 start_perf_time, end_perf_time;
+	int i, stat;		// loop control variables
 
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF))
 		return;
 
-	ResetResults( which_perf );
+	ResetResults(which_perf);
 
 	// Dynamo will send one reply for itself and one for every worker running.
 
 	// Send appropriate request for results to manager.
-	if ( which_perf == WHOLE_TEST_PERF )
-	{
-		if ( Send( MANAGER, REPORT_RESULTS ) == PORT_ERROR )
+	if (which_perf == WHOLE_TEST_PERF) {
+		if (Send(MANAGER, REPORT_RESULTS) == PORT_ERROR)
 			return;
-	}
-	else // which_perf == LAST_UPDATE_PERF
+	} else			// which_perf == LAST_UPDATE_PERF
 	{
-		if ( Send( MANAGER, REPORT_UPDATE ) == PORT_ERROR )
+		if (Send(MANAGER, REPORT_UPDATE) == PORT_ERROR)
 			return;
 	}
 
 	// Get results from manager.
-	if ( ReceiveData( &data_msg ) == PORT_ERROR )
+	if (ReceiveData(&data_msg) == PORT_ERROR)
 		return;
 
 	cpu_results = &(data_msg.data.manager_results.cpu_results);
@@ -810,35 +725,30 @@
 	end_perf_time = data_msg.data.manager_results.time_counter[LAST_SNAPSHOT];
 
 	// Reset aggregate related utilizations.
-	for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		results[which_perf].CPU_utilization[stat] = (double) 0;
-	for ( stat = 0; stat < NI_COMBINE_RESULTS; stat++ )
-		results[which_perf].ni_statistics[stat] = (double) 0;
+	for (stat = 0; stat < CPU_RESULTS; stat++)
+		results[which_perf].CPU_utilization[stat] = (double)0;
+	for (stat = 0; stat < NI_COMBINE_RESULTS; stat++)
+		results[which_perf].ni_statistics[stat] = (double)0;
 
 	// Loop though all CPUs.
-	for ( i = 0; i < processors; i++ )
-	{
+	for (i = 0; i < processors; i++) {
 		// Loop through the utilization counters.
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		{
+		for (stat = 0; stat < CPU_RESULTS; stat++) {
 			// Storing returned CPU utilization statistics.
 			results[which_perf].individual_CPU_utilization[i][stat] = cpu_results->CPU_utilization[i][stat];
-			results[which_perf].CPU_utilization[stat] += cpu_results->CPU_utilization[i][stat]; // calc. ave. below
+			results[which_perf].CPU_utilization[stat] += cpu_results->CPU_utilization[i][stat];	// calc. ave. below
 		}
 	}
 	// Determine average aggregate CPU related utilizations.
 	// Interrupts per second is a total, so is not averaged across CPUs.
-	if ( processors )
-	{
-		for ( stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++ )
+	if (processors) {
+		for (stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++)
 			results[which_perf].CPU_utilization[stat] /= processors;
 	}
-
 	// Record all network related statistics.
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
+	for (stat = 0; stat < TCP_RESULTS; stat++)
 		results[which_perf].tcp_statistics[stat] = net_results->tcp_stats[stat];
-	for ( i = 0; i < net_results->ni_count; i++ )
-	{
+	for (i = 0; i < net_results->ni_count; i++) {
 		results[which_perf].ni_statistics[NI_PACKETS] += net_results->ni_stats[i][NI_PACKETS];
 		results[which_perf].ni_statistics[NI_ERRORS] += net_results->ni_stats[i][NI_OUT_ERRORS];
 		results[which_perf].ni_statistics[NI_ERRORS] += net_results->ni_stats[i][NI_IN_ERRORS];
@@ -847,23 +757,21 @@
 	//
 	// Update Worker Results
 	//
-	for ( i = 0; i < WorkerCount(); i++ )
-	{
-		worker = GetWorker( i );
+	for (i = 0; i < WorkerCount(); i++) {
+		worker = GetWorker(i);
 
 		// Only update the results of workers active in the current test.
-		if ( !worker->ActiveInCurrentTest() )
-		{
+		if (!worker->ActiveInCurrentTest()) {
 			// Reset the results of idle workers to prevent any older results
 			// from being visible.
 			worker->ResetAllResults();
 			continue;
 		}
 		// Receive an update from a worker and process the results.
-		worker->UpdateResults( which_perf );
+		worker->UpdateResults(which_perf);
 
 		// Recording maximum time any of the workers ran.
-		if ( worker->results[which_perf].raw.counter_time > results[which_perf].raw.counter_time )
+		if (worker->results[which_perf].raw.counter_time > results[which_perf].raw.counter_time)
 			results[which_perf].raw.counter_time = worker->results[which_perf].raw.counter_time;
 
 		// Recording error results.
@@ -892,101 +800,101 @@
 		// Recording results related to the number of connections completed.
 		results[which_perf].connections_per_second += worker->results[which_perf].connections_per_second;
 		results[which_perf].raw.connection_count += worker->results[which_perf].raw.connection_count;
-		
+
 		// Recording maximum latency results.
-		if ( results[which_perf].max_latency < worker->results[which_perf].max_latency )
+		if (results[which_perf].max_latency < worker->results[which_perf].max_latency)
 			results[which_perf].max_latency = worker->results[which_perf].max_latency;
-		if ( results[which_perf].max_read_latency < worker->results[which_perf].max_read_latency )
-		{
+		if (results[which_perf].max_read_latency < worker->results[which_perf].max_read_latency) {
 			results[which_perf].max_read_latency = worker->results[which_perf].max_read_latency;
-			results[which_perf].raw.max_raw_read_latency = worker->results[which_perf].raw.max_raw_read_latency;
+			results[which_perf].raw.max_raw_read_latency =
+			    worker->results[which_perf].raw.max_raw_read_latency;
 		}
-		if ( results[which_perf].max_write_latency < worker->results[which_perf].max_write_latency )
-		{
+		if (results[which_perf].max_write_latency < worker->results[which_perf].max_write_latency) {
 			results[which_perf].max_write_latency = worker->results[which_perf].max_write_latency;
-			results[which_perf].raw.max_raw_write_latency = worker->results[which_perf].raw.max_raw_write_latency;
+			results[which_perf].raw.max_raw_write_latency =
+			    worker->results[which_perf].raw.max_raw_write_latency;
 		}
-		if ( results[which_perf].max_transaction_latency < worker->results[which_perf].max_transaction_latency )
-		{
-			results[which_perf].max_transaction_latency = worker->results[which_perf].max_transaction_latency;
-			results[which_perf].raw.max_raw_transaction_latency = worker->results[which_perf].raw.max_raw_transaction_latency;
+		if (results[which_perf].max_transaction_latency < worker->results[which_perf].max_transaction_latency) {
+			results[which_perf].max_transaction_latency =
+			    worker->results[which_perf].max_transaction_latency;
+			results[which_perf].raw.max_raw_transaction_latency =
+			    worker->results[which_perf].raw.max_raw_transaction_latency;
 		}
-		if ( results[which_perf].max_connection_latency < worker->results[which_perf].max_connection_latency )
-		{
+		if (results[which_perf].max_connection_latency < worker->results[which_perf].max_connection_latency) {
 			results[which_perf].max_connection_latency = worker->results[which_perf].max_connection_latency;
-			results[which_perf].raw.max_raw_connection_latency = worker->results[which_perf].raw.max_raw_connection_latency;
+			results[which_perf].raw.max_raw_connection_latency =
+			    worker->results[which_perf].raw.max_raw_connection_latency;
 		}
-		results[which_perf].raw.read_latency_sum		+= worker->results[which_perf].raw.read_latency_sum;
-		results[which_perf].raw.write_latency_sum		+= worker->results[which_perf].raw.write_latency_sum;
-		results[which_perf].raw.transaction_latency_sum	+= worker->results[which_perf].raw.transaction_latency_sum;
-		results[which_perf].raw.connection_latency_sum		+= worker->results[which_perf].raw.connection_latency_sum;
+		results[which_perf].raw.read_latency_sum += worker->results[which_perf].raw.read_latency_sum;
+		results[which_perf].raw.write_latency_sum += worker->results[which_perf].raw.write_latency_sum;
+		results[which_perf].raw.transaction_latency_sum +=
+		    worker->results[which_perf].raw.transaction_latency_sum;
+		results[which_perf].raw.connection_latency_sum +=
+		    worker->results[which_perf].raw.connection_latency_sum;
 
 		// Copying results only reported for the manager to the workers.
 		// This allows the results to be displayed in the results page in the GUI.
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
+		for (stat = 0; stat < CPU_RESULTS; stat++)
 			worker->results[which_perf].CPU_utilization[stat] = results[which_perf].CPU_utilization[stat];
-		for ( stat = 0; stat < TCP_RESULTS; stat++ )
+		for (stat = 0; stat < TCP_RESULTS; stat++)
 			worker->results[which_perf].tcp_statistics[stat] = results[which_perf].tcp_statistics[stat];
-		for ( stat = 0; stat < NI_COMBINE_RESULTS; stat++ )
+		for (stat = 0; stat < NI_COMBINE_RESULTS; stat++)
 			worker->results[which_perf].ni_statistics[stat] = results[which_perf].ni_statistics[stat];
 	}
 
 	// Calculate CPU_effectiveness (number of IOs per second divided by CPU efficiency)
-	if (results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION] != (double) 0)	// avoid a divide by zero
-		results[which_perf].CPU_effectiveness = results[which_perf].IOps / results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION];
+	if (results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION] != (double)0)	// avoid a divide by zero
+		results[which_perf].CPU_effectiveness =
+		    results[which_perf].IOps / results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION];
 	else
-		results[which_perf].CPU_effectiveness = (double) 0;
+		results[which_perf].CPU_effectiveness = (double)0;
 
 	// Calculating average latencies.
-	if ( results[which_perf].raw.read_count || results[which_perf].raw.write_count )
-	{
-		results[which_perf].ave_latency = (double) (_int64) (results[which_perf].raw.read_latency_sum + results[which_perf].raw.write_latency_sum) 
-				* (double) 1000 / processor_speed / (double) (_int64) (results[which_perf].raw.read_count + results[which_perf].raw.write_count);
+	if (results[which_perf].raw.read_count || results[which_perf].raw.write_count) {
+		results[which_perf].ave_latency =
+		    (double)(_int64) (results[which_perf].raw.read_latency_sum +
+				      results[which_perf].raw.write_latency_sum)
+		    * (double)1000 / processor_speed / (double)(_int64) (results[which_perf].raw.read_count +
+									 results[which_perf].raw.write_count);
 
-		if ( results[which_perf].raw.read_count )
-			results[which_perf].ave_read_latency = (double) (_int64) results[which_perf].raw.read_latency_sum * (double) 1000 
-				/ processor_speed / (double) (_int64) results[which_perf].raw.read_count;
+		if (results[which_perf].raw.read_count)
+			results[which_perf].ave_read_latency =
+			    (double)(_int64) results[which_perf].raw.read_latency_sum * (double)1000 / processor_speed /
+			    (double)(_int64) results[which_perf].raw.read_count;
 		else
-			results[which_perf].ave_read_latency = (double) 0;
+			results[which_perf].ave_read_latency = (double)0;
 
-		if ( results[which_perf].raw.write_count )
-			results[which_perf].ave_write_latency = (double) (_int64) results[which_perf].raw.write_latency_sum * (double) 1000 
-				/ processor_speed / (double) (_int64) results[which_perf].raw.write_count;
+		if (results[which_perf].raw.write_count)
+			results[which_perf].ave_write_latency =
+			    (double)(_int64) results[which_perf].raw.write_latency_sum * (double)1000 /
+			    processor_speed / (double)(_int64) results[which_perf].raw.write_count;
 		else
-			results[which_perf].ave_write_latency = (double) 0;
+			results[which_perf].ave_write_latency = (double)0;
 
-		if ( results[which_perf].raw.transaction_count )
-		{
-			results[which_perf].ave_transaction_latency = (double) (_int64) results[which_perf].raw.transaction_latency_sum * (double) 1000 
-				/ processor_speed / (double) (_int64) (results[which_perf].raw.transaction_count);
+		if (results[which_perf].raw.transaction_count) {
+			results[which_perf].ave_transaction_latency =
+			    (double)(_int64) results[which_perf].raw.transaction_latency_sum * (double)1000 /
+			    processor_speed / (double)(_int64) (results[which_perf].raw.transaction_count);
+		} else {
+			results[which_perf].ave_transaction_latency = (double)0;
 		}
-		else
-		{
-			results[which_perf].ave_transaction_latency = (double) 0;
-		}
+	} else {
+		results[which_perf].ave_latency = (double)0;
+		results[which_perf].ave_read_latency = (double)0;
+		results[which_perf].ave_write_latency = (double)0;
+		results[which_perf].ave_transaction_latency = (double)0;
 	}
-	else
-	{
-		results[which_perf].ave_latency = (double) 0;
-		results[which_perf].ave_read_latency = (double) 0;
-		results[which_perf].ave_write_latency = (double) 0;
-		results[which_perf].ave_transaction_latency = (double) 0;
-	}
 
 	// Calculating average connection time.
-	if ( results[which_perf].raw.connection_count )
-	{
-		results[which_perf].ave_connection_latency = (double) (_int64) (results[which_perf].raw.connection_latency_sum) * (double) 1000
-			/ processor_speed / (double) (_int64) results[which_perf].raw.connection_count;
+	if (results[which_perf].raw.connection_count) {
+		results[which_perf].ave_connection_latency =
+		    (double)(_int64) (results[which_perf].raw.connection_latency_sum) * (double)1000 / processor_speed /
+		    (double)(_int64) results[which_perf].raw.connection_count;
+	} else {
+		results[which_perf].ave_connection_latency = (double)0;
 	}
-	else
-	{
-		results[which_perf].ave_connection_latency = (double) 0;
-	}
 }
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 //
 // The following functions update the values for the starting sector, the 
@@ -995,84 +903,76 @@
 // calls the workers function.
 //
 ///////////////////////////////////////////////////////////////////////////////
-void Manager::SetDiskSize( int disk_size )
+void Manager::SetDiskSize(int disk_size)
 {
 	int w, wkr_count;
 
 	// Loop through all the workers.
-	wkr_count = WorkerCount( GenericDiskType );
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w, GenericDiskType )->SetDiskSize( disk_size );
+	wkr_count = WorkerCount(GenericDiskType);
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w, GenericDiskType)->SetDiskSize(disk_size);
 }
 
-
-void Manager::SetDiskStart( int disk_start )
+void Manager::SetDiskStart(int disk_start)
 {
 	int w, wkr_count;
 
 	// Loop through all the workers.
-	wkr_count = WorkerCount( GenericDiskType );
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w, GenericDiskType )->SetDiskStart( disk_start );
+	wkr_count = WorkerCount(GenericDiskType);
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w, GenericDiskType)->SetDiskStart(disk_start);
 }
 
-
-void Manager::SetQueueDepth( int queue_depth, TargetType type )
+void Manager::SetQueueDepth(int queue_depth, TargetType type)
 {
 	int w, wkr_count;
 
 	// Loop through all the workers.
-	wkr_count = WorkerCount( type );
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w, GenericDiskType )->SetQueueDepth( queue_depth );
+	wkr_count = WorkerCount(type);
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w, GenericDiskType)->SetQueueDepth(queue_depth);
 }
 
-
-void Manager::SetMaxSends( int max_sends )
+void Manager::SetMaxSends(int max_sends)
 {
 	int w, wkr_count;
 
 	// Loop through all the workers.
-	wkr_count = WorkerCount( VIServerType );
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w, VIServerType )->SetMaxSends( max_sends );
+	wkr_count = WorkerCount(VIServerType);
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w, VIServerType)->SetMaxSends(max_sends);
 }
 
-
-void Manager::SetLocalNetworkInterface( int iface_index )
+void Manager::SetLocalNetworkInterface(int iface_index)
 {
 	int w, wkr_count;
 
 	// Loop through all the workers.
-	wkr_count = WorkerCount( GenericServerType );
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w, GenericServerType )->SetLocalNetworkInterface( iface_index );
+	wkr_count = WorkerCount(GenericServerType);
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w, GenericServerType)->SetLocalNetworkInterface(iface_index);
 }
 
-
-void Manager::SetConnectionRate( BOOL test_connection_rate, TargetType type )
+void Manager::SetConnectionRate(BOOL test_connection_rate, TargetType type)
 {
 	int w, wkr_count;
 
 	// Loop through all the workers.
-	wkr_count = WorkerCount( type );
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w, type )->SetConnectionRate( test_connection_rate );
+	wkr_count = WorkerCount(type);
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w, type)->SetConnectionRate(test_connection_rate);
 }
 
-
-void Manager::SetTransPerConn( int trans_per_conn, TargetType type )
+void Manager::SetTransPerConn(int trans_per_conn, TargetType type)
 {
 	int w, wkr_count;
 
 	// Loop through all the workers.
-	wkr_count = WorkerCount( type );
-	for ( w = 0; w < wkr_count; w++ )
-		GetWorker( w, type )->SetTransPerConn( trans_per_conn );
+	wkr_count = WorkerCount(type);
+	for (w = 0; w < wkr_count; w++)
+		GetWorker(w, type)->SetTransPerConn(trans_per_conn);
 }
 
-
-
 ///////////////////////////////////////////////
 //
 // Functions to retrieve worker information
@@ -1086,23 +986,21 @@
 // Returns a valid connection rate setting if all the manager's workers of the
 // same type have the same value.
 //
-int Manager::GetConnectionRate( TargetType type )
+int Manager::GetConnectionRate(TargetType type)
 {
 	int w, wkr_count, wkr_result;
 
 	// If there are no workers, return immediately.
-	if ( !(wkr_count = WorkerCount( type ) ) )
+	if (!(wkr_count = WorkerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Find the first worker of the specified type's transaction per
 	// connection value.
-	wkr_result = GetWorker( 0, type )->GetConnectionRate( type );
+	wkr_result = GetWorker(0, type)->GetConnectionRate(type);
 
 	// Compare the value with all the other workers of the same type.
-	for ( w = 1; w < wkr_count; w++ )
-	{
-		if ( wkr_result != GetWorker( w, type )->GetConnectionRate( type ) )
-		{
+	for (w = 1; w < wkr_count; w++) {
+		if (wkr_result != GetWorker(w, type)->GetConnectionRate(type)) {
 			// The value isn't the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -1111,29 +1009,25 @@
 	return wkr_result;
 }
 
-
-
 //
 // Returns a valid transaction per connection value if all the manager's
 // workers of the specified type have the same value.
 //
-int Manager::GetTransPerConn( TargetType type )
+int Manager::GetTransPerConn(TargetType type)
 {
 	int w, wkr_count, wkr_result;
 
 	// If there are no workers, return immediately.
-	if ( !(wkr_count = WorkerCount( type ) ) )
+	if (!(wkr_count = WorkerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Find the first worker of the specified type's transaction per
 	// connection value.
-	wkr_result = GetWorker( 0, type )->GetTransPerConn( type );
+	wkr_result = GetWorker(0, type)->GetTransPerConn(type);
 
 	// Compare the value with all the other workers of the same type.
-	for ( w = 1; w < wkr_count; w++ )
-	{
-		if ( wkr_result != GetWorker( w, type )->GetTransPerConn( type ) )
-		{
+	for (w = 1; w < wkr_count; w++) {
+		if (wkr_result != GetWorker(w, type)->GetTransPerConn(type)) {
 			// The value isn't the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -1142,28 +1036,24 @@
 	return wkr_result;
 }
 
-
-
 //
 // Returns a valid disk start value if all the manager's disk workers
 // have the same value.
 //
-int Manager::GetDiskStart( TargetType type )
+int Manager::GetDiskStart(TargetType type)
 {
 	int w, wkr_count, wkr_result;
 
 	// If there are no workers, return immediately.
-	if ( !(wkr_count = WorkerCount( type ) ) )
+	if (!(wkr_count = WorkerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Find the first disk worker.
-	wkr_result = GetWorker( 0, type )->GetDiskStart( type );
+	wkr_result = GetWorker(0, type)->GetDiskStart(type);
 
 	// Compare the value with all the other workers of the same type.
-	for ( w = 1; w < wkr_count; w++ )
-	{
-		if ( wkr_result != GetWorker( w, type )->GetDiskStart( type ) )
-		{
+	for (w = 1; w < wkr_count; w++) {
+		if (wkr_result != GetWorker(w, type)->GetDiskStart(type)) {
 			// The value isn't the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -1172,28 +1062,24 @@
 	return wkr_result;
 }
 
-
-
 //
 // Returns a valid disk start value if all the manager's disk workers
 // have the same value.
 //
-int Manager::GetDiskSize( TargetType type )
+int Manager::GetDiskSize(TargetType type)
 {
 	int w, wkr_count, wkr_result;
 
 	// If there are no workers, return immediately.
-	if ( !(wkr_count = WorkerCount( type ) ) )
+	if (!(wkr_count = WorkerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Find the first disk worker.
-	wkr_result = GetWorker( 0, type )->GetDiskSize( type );
+	wkr_result = GetWorker(0, type)->GetDiskSize(type);
 
 	// Compare the value with all the other workers of the same type.
-	for ( w = 1; w < wkr_count; w++ )
-	{
-		if ( wkr_result != GetWorker( w, type )->GetDiskSize( type ) )
-		{
+	for (w = 1; w < wkr_count; w++) {
+		if (wkr_result != GetWorker(w, type)->GetDiskSize(type)) {
 			// The value isn't the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -1202,28 +1088,24 @@
 	return wkr_result;
 }
 
-
-
 //
 // Returns a valid queue depth value if all the manager's workers
 // have the same value.
 //
-int Manager::GetQueueDepth( TargetType type )
+int Manager::GetQueueDepth(TargetType type)
 {
 	int w, wkr_count, wkr_result;
 
 	// If there are no workers, return immediately.
-	if ( !(wkr_count = WorkerCount( type ) ) )
+	if (!(wkr_count = WorkerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Find the first worker of the specified type's queue depth value.
-	wkr_result = GetWorker( 0, type )->GetQueueDepth( type );
+	wkr_result = GetWorker(0, type)->GetQueueDepth(type);
 
 	// Compare the value with all the other workers of the same type.
-	for ( w = 1; w < wkr_count; w++ )
-	{
-		if ( wkr_result != GetWorker( w, type )->GetQueueDepth( type ) )
-		{
+	for (w = 1; w < wkr_count; w++) {
+		if (wkr_result != GetWorker(w, type)->GetQueueDepth(type)) {
 			// The value isn't the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -1232,32 +1114,25 @@
 	return wkr_result;
 }
 
-
-
-
-
-
 //
 // Returns a valid maximum number of outstanding sends value if all the 
 // manager's disk workers have the same value.
 //
-int Manager::GetMaxSends( TargetType type )
+int Manager::GetMaxSends(TargetType type)
 {
 	int w, wkr_count, wkr_result;
 
 	// If there are no workers, return immediately.
-	if ( !(wkr_count = WorkerCount( type ) ) )
+	if (!(wkr_count = WorkerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Find the first worker of the specified type's transaction per
 	// connection value.
-	wkr_result = GetWorker( 0, type )->GetMaxSends( type );
+	wkr_result = GetWorker(0, type)->GetMaxSends(type);
 
 	// Compare the value with all the other workers of the same type.
-	for ( w = 1; w < wkr_count; w++ )
-	{
-		if ( wkr_result != GetWorker( w, type )->GetMaxSends( type ) )
-		{
+	for (w = 1; w < wkr_count; w++) {
+		if (wkr_result != GetWorker(w, type)->GetMaxSends(type)) {
 			// The value isn't the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -1266,32 +1141,27 @@
 	return wkr_result;
 }
 
-
-
 //
 // Returns a valid pointer to a net address string if all the manager's 
 // workers have the same net address selected, otherwise NULL.
 // 
-char* Manager::GetLocalNetworkInterface()
+char *Manager::GetLocalNetworkInterface()
 {
-	char	*net_address;
-	int		w, wkr_count;
+	char *net_address;
+	int w, wkr_count;
 
 	// If the manager has no GenericServerType workers, there is no valid 
 	// net address.
-	if ( !(wkr_count = WorkerCount( GenericServerType ) ) )
+	if (!(wkr_count = WorkerCount(GenericServerType)))
 		return NULL;
 
 	// Find the first GenericServerType's local address.
-	net_address = GetWorker( 0, GenericServerType )->GetLocalNetworkInterface();
+	net_address = GetWorker(0, GenericServerType)->GetLocalNetworkInterface();
 
 	// Compare the first GenericServerType's net address with all other 
 	// GenericServerType's.
-	for ( w = 1; w < wkr_count; w++ )
-	{
-		if ( strcmp( net_address, GetWorker(w, 
-			GenericServerType)->GetLocalNetworkInterface() ) )
-		{
+	for (w = 1; w < wkr_count; w++) {
+		if (strcmp(net_address, GetWorker(w, GenericServerType)->GetLocalNetworkInterface())) {
 			return NULL;
 		}
 	}
@@ -1300,44 +1170,36 @@
 	return net_address;
 }
 
-
-
 //
 // Return a pointer to the manager's information about a given interface.
 // This applies to Disk targets as well as Network targets.
 //
-Target_Spec* Manager::GetInterface( int index, TargetType type )
+Target_Spec *Manager::GetInterface(int index, TargetType type)
 {
-	if ( IsType( type, GenericDiskType ) )
+	if (IsType(type, GenericDiskType))
 		return disks[index];
-	else if ( IsType( type, GenericTCPType ) )
+	else if (IsType(type, GenericTCPType))
 		return tcps[index];
-	else if ( IsType( type, GenericVIType ) )
+	else if (IsType(type, GenericVIType))
 		return vis[index];
-	else if ( IsType( type, GenericNetType ) )
-	{
+	else if (IsType(type, GenericNetType)) {
 		// Networks are viewed as TCP interfaces then VI interfaces.
-		if ( index < InterfaceCount( GenericTCPType ) )
+		if (index < InterfaceCount(GenericTCPType))
 			return tcps[index];
-		return vis[index - InterfaceCount( GenericTCPType )];
-	}
-	else
-	{
-		ErrorMessage( "Unknown target type in Manager::GetInterface()" );
+		return vis[index - InterfaceCount(GenericTCPType)];
+	} else {
+		ErrorMessage("Unknown target type in Manager::GetInterface()");
 		return NULL;
 	}
 }
 
-
-
 //
 // Returning the number of interfaces accessible by a manager.  If desired,
 // a count of a specific type may be returned.
 //
-int Manager::InterfaceCount( TargetType type )
+int Manager::InterfaceCount(TargetType type)
 {
-	switch ( type )
-	{
+	switch (type) {
 	case GenericType:
 		return disks.GetSize() + tcps.GetSize() + vis.GetSize();
 	case GenericDiskType:
@@ -1355,20 +1217,17 @@
 	case VIClientType:
 		return vis.GetSize();
 	default:
-		ErrorMessage( "Unknown target type in Manager::InterfaceCount()" );
+		ErrorMessage("Unknown target type in Manager::InterfaceCount()");
 		return 0;
 	}
 }
 
-
-
 ///////////////////////////////////////////////
 //
 // Functions that deal with access specs.
 //
 ///////////////////////////////////////////////
 
-
 //
 // Return the maximum number of access specs assigned to a worker.
 //
@@ -1377,222 +1236,193 @@
 	int max_spec_count = 0, wkr_count = WorkerCount();
 	int w, spec_count;
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		if ( ( spec_count = GetWorker( w )->AccessSpecCount() ) > 
-			max_spec_count )
-		{
+	for (w = 0; w < wkr_count; w++) {
+		if ((spec_count = GetWorker(w)->AccessSpecCount()) > max_spec_count) {
 			max_spec_count = spec_count;
 		}
 	}
 	return max_spec_count;
 }
 
-
-
 //
 // Verify that all assigned access specs are valid.
 //
-BOOL Manager::InvalidSetup( BOOL &invalidSpecOK )
+BOOL Manager::InvalidSetup(BOOL & invalidSpecOK)
 {
-	int	i, w, wkr_count, iface_count, conn_count, queue_depth;
-	DWORD	max_size;
-	Worker	*wkr;
-	CString	msg_box;
+	int i, w, wkr_count, iface_count, conn_count, queue_depth;
+	DWORD max_size;
+	Worker *wkr;
+	CString msg_box;
 
 	// Verify that all specs for each worker is valid.
 	wkr_count = WorkerCount();
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		if ( GetWorker( w )->InvalidSetup( invalidSpecOK ) )
+	for (w = 0; w < wkr_count; w++) {
+		if (GetWorker(w)->InvalidSetup(invalidSpecOK))
 			return TRUE;
 	}
 
 	// If there are no targets using VI interfaces, everything is valid.
-	if ( !WorkerCount( GenericVIType ) )
+	if (!WorkerCount(GenericVIType))
 		return FALSE;
 
 	// Verify that the manager's VIA interfaces can handle the assigned
 	// test setup.
-	iface_count = InterfaceCount( VIClientType );
-	wkr_count = WorkerCount( GenericVIType );
-	for ( i = 0; i < iface_count; i++ )
-	{
+	iface_count = InterfaceCount(VIClientType);
+	wkr_count = WorkerCount(GenericVIType);
+	for (i = 0; i < iface_count; i++) {
 		// Update how much of the VI hardware is in use.
 		conn_count = 0;
 		queue_depth = 0;
-		for ( w = 0; w < wkr_count; w++ )
-		{
-			wkr = GetWorker( w, GenericVIType );
+		for (w = 0; w < wkr_count; w++) {
+			wkr = GetWorker(w, GenericVIType);
 
 			// Skip workers without VI targets.
-			if ( !wkr->TargetCount( GenericVIType ) )
+			if (!wkr->TargetCount(GenericVIType))
 				continue;
 
 			// If the worker will use the VI interface, count it.
-			if ( !strcmp( wkr->GetLocalNetworkInterface(), vis[i]->name ) )
-			{
+			if (!strcmp(wkr->GetLocalNetworkInterface(), vis[i]->name)) {
 				conn_count++;
-				queue_depth += wkr->MaxOutstandingIOs( 0 );
+				queue_depth += wkr->MaxOutstandingIOs(0);
 			}
-
 			// Ensure that the worker will not make an I/O request larger
 			// than that supported by the VI NIC.
 			max_size = wkr->MaxTransferSize();
-			if ( max_size > (DWORD) vis[i]->vi_info.max_transfer_size )
-			{
-				msg_box.Format( (CString)"Worker \"" + wkr->name + "\" on " +
-					"manager \"" + name + "\" cannot perform the largest requested " +
-					"transfer size over VI NIC \"" + vis[i]->name + 
-					"\".  VI hardware supports transfers up to " +
-					"%i bytes.  %i bytes were requested.", 
-					vis[i]->vi_info.max_transfer_size, max_size );
-				ErrorMessage( msg_box );
+			if (max_size > (DWORD) vis[i]->vi_info.max_transfer_size) {
+				msg_box.Format((CString) "Worker \"" + wkr->name + "\" on " +
+					       "manager \"" + name + "\" cannot perform the largest requested " +
+					       "transfer size over VI NIC \"" + vis[i]->name +
+					       "\".  VI hardware supports transfers up to " +
+					       "%i bytes.  %i bytes were requested.",
+					       vis[i]->vi_info.max_transfer_size, max_size);
+				ErrorMessage(msg_box);
 				return TRUE;
 			}
 		}
 
 		// See that the VI NIC can handle the requested number of connections.
-		if ( conn_count > vis[i]->vi_info.max_connections )
-		{
-			msg_box.Format( (CString)"Manager \"" + name + "\" cannot support the " +
-				"requested number of VI connections over VI NIC \"" 
-				+ vis[i]->name + "\".  Only %i connections are allowed.  " +
-				"%i were requested.", vis[i]->vi_info.max_connections, conn_count );
-			ErrorMessage( msg_box );
+		if (conn_count > vis[i]->vi_info.max_connections) {
+			msg_box.Format((CString) "Manager \"" + name + "\" cannot support the " +
+				       "requested number of VI connections over VI NIC \""
+				       + vis[i]->name + "\".  Only %i connections are allowed.  " +
+				       "%i were requested.", vis[i]->vi_info.max_connections, conn_count);
+			ErrorMessage(msg_box);
 			return TRUE;
 		}
-
 		// See that the VI NIC can handle the requested number of posted 
 		// descriptors.
-		if ( queue_depth > vis[i]->vi_info.outstanding_ios )
-		{
-			msg_box.Format( (CString)"Manager \"" + name + "\" cannot support the " +
-				"requested number of outstanding I/Os over VI NIC \"" 
-				+ vis[i]->name + "\".  Only %i connections are allowed.  " +
-				"%i were requested.", vis[i]->vi_info.outstanding_ios, queue_depth );
-			ErrorMessage( msg_box );
+		if (queue_depth > vis[i]->vi_info.outstanding_ios) {
+			msg_box.Format((CString) "Manager \"" + name + "\" cannot support the " +
+				       "requested number of outstanding I/Os over VI NIC \""
+				       + vis[i]->name + "\".  Only %i connections are allowed.  " +
+				       "%i were requested.", vis[i]->vi_info.outstanding_ios, queue_depth);
+			ErrorMessage(msg_box);
 			return TRUE;
 		}
 	}
 	return FALSE;
 }
 
-
-
 //
 // Assigns the default access specs to workers based on their type.
 //
 void Manager::AssignDefaultAccessSpecs()
 {
-	int	w, wkr_count = WorkerCount();
+	int w, wkr_count = WorkerCount();
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		GetWorker( w )->AssignDefaultAccessSpecs();
+	for (w = 0; w < wkr_count; w++) {
+		GetWorker(w)->AssignDefaultAccessSpecs();
 	}
 }
 
-
-
 //
 // Remove all instances of an access spec from all the manager's
 // worker's access spec lists.
 //
-void Manager::RemoveAccessSpec( Test_Spec *spec )
+void Manager::RemoveAccessSpec(Test_Spec * spec)
 {
 	int worker_count = WorkerCount();
-	for ( int w = 0; w < worker_count; w++ )
-		GetWorker( w )->RemoveAccessSpec( spec );
+
+	for (int w = 0; w < worker_count; w++)
+		GetWorker(w)->RemoveAccessSpec(spec);
 }
 
-
-
 //
 // Remove a specific instance of an access spec from all the manager's
 // worker's access spec lists (only if they are all the same).
 //
-void Manager::RemoveAccessSpecAt( int index )
+void Manager::RemoveAccessSpecAt(int index)
 {
-	if ( !AreAccessSpecsIdentical() )
+	if (!AreAccessSpecsIdentical())
 		return;
 
 	int worker_count = WorkerCount();
-	for ( int w = 0; w < worker_count; w++ )
-		GetWorker( w )->RemoveAccessSpecAt( index );
+
+	for (int w = 0; w < worker_count; w++)
+		GetWorker(w)->RemoveAccessSpecAt(index);
 }
 
-
 //
 // Removes all entries from all the manager's
 // worker's access spec lists.
 //
 void Manager::RemoveAllAccessSpecs()
 {
-	int		w, wkr_count = WorkerCount();
-	Worker	*wkr;
+	int w, wkr_count = WorkerCount();
+	Worker *wkr;
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		wkr = GetWorker( w );
+	for (w = 0; w < wkr_count; w++) {
+		wkr = GetWorker(w);
 
-		if ( IsType( wkr->Type(), GenericClientType ) )
+		if (IsType(wkr->Type(), GenericClientType))
 			continue;
 
 		wkr->RemoveAllAccessSpecs();
 	}
 }
 
-
-
 //
 // Adds spec[index] from global access spec list
 // to all the manager's workers at position 'before_index'.
 //
-BOOL Manager::InsertAccessSpec( Test_Spec* spec, int before_index )
+BOOL Manager::InsertAccessSpec(Test_Spec * spec, int before_index)
 {
-	int		w, wkr_count = WorkerCount();
-	Worker	*wkr;
+	int w, wkr_count = WorkerCount();
+	Worker *wkr;
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		wkr = GetWorker( w );
+	for (w = 0; w < wkr_count; w++) {
+		wkr = GetWorker(w);
 
 		// Do not add specs to client workers.
-		if ( IsType( wkr->Type(), GenericClientType ) )
+		if (IsType(wkr->Type(), GenericClientType))
 			continue;
 
-		if ( !wkr->InsertAccessSpec( spec, before_index ) )
+		if (!wkr->InsertAccessSpec(spec, before_index))
 			return FALSE;
 	}
 	return TRUE;
 }
 
-
-
 //
 // Moves the entry at position [index] to [before_index] in the 
 // workers' access spec list to all the manager's workers.
 //
-void Manager::MoveAccessSpec( int index, int before_index )
+void Manager::MoveAccessSpec(int index, int before_index)
 {
-	int		w, wkr_count = WorkerCount();
-	Worker	*wkr;
+	int w, wkr_count = WorkerCount();
+	Worker *wkr;
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		wkr = GetWorker( w );
+	for (w = 0; w < wkr_count; w++) {
+		wkr = GetWorker(w);
 
 		// Do not move client worker specs.
-		if ( IsType( wkr->Type(), GenericClientType ) )
+		if (IsType(wkr->Type(), GenericClientType))
 			continue;
 
-		wkr->MoveAccessSpec( index, before_index );
+		wkr->MoveAccessSpec(index, before_index);
 	}
 }
 
-
-
 //
 // Determines if the manager will be active in the current test.  This is
 // TRUE if any of its workers are active or have been explicitly assigned the
@@ -1600,113 +1430,99 @@
 //
 BOOL Manager::ActiveInCurrentTest()
 {
-	int		w, wkr_count = WorkerCount();
-	int		access_index = theApp.pView->GetCurrentAccessIndex();
-	Worker	*wkr;
+	int w, wkr_count = WorkerCount();
+	int access_index = theApp.pView->GetCurrentAccessIndex();
+	Worker *wkr;
 
 	// Loop through all workers and see if they're either active or have been
 	// explicitly assigned the Idle spec.
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		wkr = GetWorker( w );
+	for (w = 0; w < wkr_count; w++) {
+		wkr = GetWorker(w);
 
 		// See if the worker's active or has the Idle spec.
-		if ( wkr->ActiveInCurrentTest() || wkr->HasIdleCurrentSpec() )
+		if (wkr->ActiveInCurrentTest() || wkr->HasIdleCurrentSpec())
 			return TRUE;
 	}
 	return FALSE;
 }
 
-
-
 //
 // Returns TRUE if any worker has an access spec assigned for the current
 // access index and the spec is not the Idle spec.
 //
 BOOL Manager::HasActiveCurrentSpec()
 {
-	int	w, wkr_count = WorkerCount();
+	int w, wkr_count = WorkerCount();
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		if ( GetWorker( w )->HasActiveCurrentSpec() )
+	for (w = 0; w < wkr_count; w++) {
+		if (GetWorker(w)->HasActiveCurrentSpec())
 			return TRUE;
 	}
 	return FALSE;
 }
 
-
-
 //
 // Returns TRUE if any of the manager's workers has an idle spec assigned
 // at the current access spec index.
 //
 BOOL Manager::HasIdleCurrentSpec()
 {
-	int	w, wkr_count = WorkerCount();
+	int w, wkr_count = WorkerCount();
 
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		if ( GetWorker( w )->HasIdleCurrentSpec() )
+	for (w = 0; w < wkr_count; w++) {
+		if (GetWorker(w)->HasIdleCurrentSpec())
 			return TRUE;
 	}
 	return FALSE;
 }
 
-
 //
 // Returns a TRUE if all of this manager's workers have the same access 
 // specification list.
 //
 BOOL Manager::AreAccessSpecsIdentical()
 {
-	int		w, s, wkr_count, spec_count;
-	Worker	*compare_worker, *current_worker;
+	int w, s, wkr_count, spec_count;
+	Worker *compare_worker, *current_worker;
 
 	// Get the first non-client worker
 	wkr_count = WorkerCount();
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		compare_worker = GetWorker( w );
+	for (w = 0; w < wkr_count; w++) {
+		compare_worker = GetWorker(w);
 
-		if ( !IsType( compare_worker->Type(), GenericClientType ) )
-		{
+		if (!IsType(compare_worker->Type(), GenericClientType)) {
 			spec_count = compare_worker->AccessSpecCount();
 			break;
 		}
 	}
 
 	// If there were no non-client workers, return TRUE;
-	if ( w == wkr_count )
+	if (w == wkr_count)
 		return TRUE;
 
 	// Compare the first worker's Test_Spec to each other worker's Test_Spec.
-	for ( ++w; w < wkr_count; w++ )
-	{
-		current_worker = GetWorker( w );
+	for (++w; w < wkr_count; w++) {
+		current_worker = GetWorker(w);
 
 		// Skip network clients.
-		if ( IsType( current_worker->Type(), GenericClientType ) )
+		if (IsType(current_worker->Type(), GenericClientType))
 			continue;
 
 		// If this worker doesn't have the same number of access specs, return FALSE.
-		if ( current_worker->AccessSpecCount() != spec_count )
+		if (current_worker->AccessSpecCount() != spec_count)
 			return FALSE;
 
 		// Check to make sure each returned Test_Spec pointer is identical to 
 		// and in the same order as the pointer in the first_worker.
-		for ( s = 0; s < spec_count; s++ )
-		{
-			if ( current_worker->GetAccessSpec(s) != compare_worker->GetAccessSpec(s) )
+		for (s = 0; s < spec_count; s++) {
+			if (current_worker->GetAccessSpec(s) != compare_worker->GetAccessSpec(s))
 				return FALSE;
 		}
 	}
-	
+
 	return TRUE;
 }
 
-
-
 //
 // Sees whether all workers have the same access spec assigned at index spec_index.
 // Returns a pointer to the name of the spec if all workers have the same one assigned.
@@ -1715,48 +1531,40 @@
 // Calling function supplies pointer to a char[MAX_WORKER_NAME].
 // This same pointer is returned for convenience.
 //
-char* Manager::GetCommonAccessSpec( int spec_index, char * const specname )
+char *Manager::GetCommonAccessSpec(int spec_index, char *const specname)
 {
-	int		w, wkr_count = WorkerCount();
-	Worker	*wkr;
+	int w, wkr_count = WorkerCount();
+	Worker *wkr;
 
 	// Return null string if there are no workers.
-	if ( wkr_count == 0 )
-	{
+	if (wkr_count == 0) {
 		specname[0] = '\0';
 		return specname;
 	}
-
 	// Find the first worker with this spec assigned and get the name of the spec.
-	for ( w = 0; w < wkr_count; w++ )
-	{
-		wkr = GetWorker( w );
-		if ( spec_index < wkr->AccessSpecCount() )
-		{
-			strcpy( specname, wkr->GetAccessSpec( spec_index )->name );
+	for (w = 0; w < wkr_count; w++) {
+		wkr = GetWorker(w);
+		if (spec_index < wkr->AccessSpecCount()) {
+			strcpy(specname, wkr->GetAccessSpec(spec_index)->name);
 			break;
 		}
 	}
 
-	if ( w >= wkr_count )
-	{
-		ASSERT( 0 );	// (THIS SHOULD NOT HAPPEN.)
+	if (w >= wkr_count) {
+		ASSERT(0);	// (THIS SHOULD NOT HAPPEN.)
 
 		// Return an error if no worker has this access spec.
-		return strcpy( specname, "***ERROR***" );
+		return strcpy(specname, "***ERROR***");
 	}
 
 	w++;
 
 	// Compare that spec name to each other worker's spec name.
-	while ( w < wkr_count )
-	{
+	while (w < wkr_count) {
 		// Return null string if this worker's spec is different.
 		// (Ignore this worker if it is not participating in this test.)
-		wkr = GetWorker( w );
-		if ( wkr->ActiveInCurrentTest()	&& 
-			strcmp( wkr->GetAccessSpec( spec_index )->name, specname ) )
-		{
+		wkr = GetWorker(w);
+		if (wkr->ActiveInCurrentTest() && strcmp(wkr->GetAccessSpec(spec_index)->name, specname)) {
 			specname[0] = '\0';
 			return specname;
 		}
@@ -1768,23 +1576,19 @@
 	return specname;
 }
 
-
-
 //
 // Save the manager/worker configuration to the specified stream.
-//		save_aspecs --> should each worker's access spec assignments be saved?
-//		save_targets --> should each worker's target assignments be saved?
+//              save_aspecs --> should each worker's access spec assignments be saved?
+//              save_targets --> should each worker's target assignments be saved?
 //
-BOOL Manager::SaveConfig(ostream& outfile, BOOL save_aspecs, BOOL save_targets)
+BOOL Manager::SaveConfig(ostream & outfile, BOOL save_aspecs, BOOL save_targets)
 {
 	int wkr_count = WorkerCount();
 
-	outfile << "'Manager ID, manager name" << endl
-			<< "\t" << id << "," << name << endl;
-	outfile << "'Manager network address" << endl
-			<< "\t" << network_name << endl;
+	outfile << "'Manager ID, manager name" << endl << "\t" << id << "," << name << endl;
+	outfile << "'Manager network address" << endl << "\t" << network_name << endl;
 
-	for (int counter=0; counter<wkr_count; counter++)
+	for (int counter = 0; counter < wkr_count; counter++)
 		if (!GetWorker(counter)->SaveConfig(outfile, save_aspecs, save_targets))
 			return FALSE;	// error saving data - propagate back
 
@@ -1792,17 +1596,15 @@
 	return TRUE;
 }
 
-
-
 //
 // Restore the manager/worker configuration from the specified stream.
-//		load_aspecs --> should each worker's access spec assignments be loaded?
-//		load_targets --> should each worker's target assignments be loaded?
+//              load_aspecs --> should each worker's access spec assignments be loaded?
+//              load_targets --> should each worker's target assignments be loaded?
 //
 // Returns TRUE on success, FALSE if any of the requested information
 // couldn't be found in the file.
 //
-BOOL Manager::LoadConfig(ICF_ifstream& infile, BOOL load_aspecs, BOOL load_targets)
+BOOL Manager::LoadConfig(ICF_ifstream & infile, BOOL load_aspecs, BOOL load_targets)
 {
 	CString key, value;
 	int counter;
@@ -1810,10 +1612,10 @@
 	TargetType wkr_type_hex;
 	Worker *wkr;
 	int wkr_count, wkr_svr_count;
-	
+
 	// Using a dynamic because size isn't known at compile time.
-	CArray<BOOL, int> wkr_svr_loaded;	// identifies workers that have been loaded
-	CArray<Worker*, int> wkr_svr_list;	// Pointers to each of the workers (they may move)
+	CArray < BOOL, int >wkr_svr_loaded;	// identifies workers that have been loaded
+	CArray < Worker *, int >wkr_svr_list;	// Pointers to each of the workers (they may move)
 
 	wkr_count = WorkerCount();
 
@@ -1826,87 +1628,63 @@
 	// Identify all workers that are not clients.
 	// (We don't want to deal with the clients here - that's the job of target selection.)
 	wkr_svr_count = 0;
-	for (counter=0; counter<wkr_count; counter++)
-	{
+	for (counter = 0; counter < wkr_count; counter++) {
 		wkr = GetWorker(counter);
-		if ( !IsType( wkr->Type(), GenericClientType ) )
-		{
+		if (!IsType(wkr->Type(), GenericClientType)) {
 			wkr_svr_list[wkr_svr_count] = wkr;
 			wkr_svr_loaded[wkr_svr_count] = FALSE;
 			wkr_svr_count++;
 		}
 	}
 
-	while (1)
-	{
-		if ( !infile.GetPair(key, value) )
-		{
-			ErrorMessage("File is improperly formatted.  Expected a "
-				"worker or \"End manager\".");
+	while (1) {
+		if (!infile.GetPair(key, value)) {
+			ErrorMessage("File is improperly formatted.  Expected a " "worker or \"End manager\".");
 			return FALSE;
 		}
 
-		if ( key.CompareNoCase("'End manager") == 0 )
-		{
+		if (key.CompareNoCase("'End manager") == 0) {
 			break;
-		}
-		else if ( key.CompareNoCase("'Worker") == 0 )
-		{
+		} else if (key.CompareNoCase("'Worker") == 0) {
 			wkr_name = value;
 
-			if ( !infile.GetPair(key, value) )
-			{
-				ErrorMessage("File is improperly formatted.  Expected "
-					"\"Worker type\".");
+			if (!infile.GetPair(key, value)) {
+				ErrorMessage("File is improperly formatted.  Expected " "\"Worker type\".");
 				return FALSE;
 			}
 
-			if ( key.CompareNoCase("'Worker type") != 0 )
-			{
+			if (key.CompareNoCase("'Worker type") != 0) {
 				ErrorMessage("File is improperly formatted.  Worker name "
-					"should be followed by \"Worker type\" comment.");
+					     "should be followed by \"Worker type\" comment.");
 				return FALSE;
 			}
 
-			token = ICF_ifstream::ExtractFirstToken( value );
-			if ( token.CompareNoCase("DISK") == 0 )
-			{
+			token = ICF_ifstream::ExtractFirstToken(value);
+			if (token.CompareNoCase("DISK") == 0) {
 				wkr_type_hex = GenericDiskType;
-			}
-			else if ( token.CompareNoCase("NETWORK") == 0 )
-			{
-				token = ICF_ifstream::ExtractFirstToken( value );
-				if ( token.CompareNoCase("TCP") == 0 )
-				{
+			} else if (token.CompareNoCase("NETWORK") == 0) {
+				token = ICF_ifstream::ExtractFirstToken(value);
+				if (token.CompareNoCase("TCP") == 0) {
 					wkr_type_hex = TCPServerType;
-				}
-				else if ( token.CompareNoCase("VI") == 0 )
-				{
+				} else if (token.CompareNoCase("VI") == 0) {
 					wkr_type_hex = VIServerType;
-				}
-				else
-				{
+				} else {
 					ErrorMessage("Unknown network worker subtype encountered "
-						"for worker \"" + wkr_name + "\": \"" + token
-						+ "\".  Should be either TCP or VI.");
+						     "for worker \"" + wkr_name + "\": \"" + token
+						     + "\".  Should be either TCP or VI.");
 				}
-			}
-			else
-			{
+			} else {
 				ErrorMessage("Unknown worker type encountered for worker \""
-					+ wkr_name + "\": \"" + token
-					+ "\".  Should be either DISK or NETWORK.");
+					     + wkr_name + "\": \"" + token + "\".  Should be either DISK or NETWORK.");
 				return FALSE;
 			}
 
 			// See if this worker already exists on this manager.
-			for (counter=0; counter<wkr_svr_count; counter++)
-			{
-				if ( wkr_name.CompareNoCase( wkr_svr_list[counter]->name ) == 0
-					 && IsType( wkr_svr_list[counter]->Type(),
-						(TargetType)(wkr_type_hex & WORKER_COMPATIBILITY_MASK) )
-					 && !wkr_svr_loaded[counter] )
-				{
+			for (counter = 0; counter < wkr_svr_count; counter++) {
+				if (wkr_name.CompareNoCase(wkr_svr_list[counter]->name) == 0
+				    && IsType(wkr_svr_list[counter]->Type(),
+					      (TargetType) (wkr_type_hex & WORKER_COMPATIBILITY_MASK))
+				    && !wkr_svr_loaded[counter]) {
 					wkr_svr_loaded[counter] = TRUE;
 					wkr = wkr_svr_list[counter];
 
@@ -1915,8 +1693,7 @@
 			}
 
 			// See if we weren't able to find a match.
-			if (counter >= wkr_svr_count)
-			{
+			if (counter >= wkr_svr_count) {
 				// This worker doesn't already exist, or two workers of the
 				// same name have been defined for a single manager, and only
 				// one worker by that name exists in the running copy of
@@ -1928,25 +1705,21 @@
 				// addition of this new worker.  It is only used above, to
 				// search for previously existing workers.
 
-				wkr = theApp.pView->AddWorker( wkr_type_hex, this, wkr_name );
+				wkr = theApp.pView->AddWorker(wkr_type_hex, this, wkr_name);
 
-				if (load_aspecs)
-				{
+				if (load_aspecs) {
 					// If the user has specified that he wishes to restore
 					// access spec assignments, no default assignments should
 					// take place.
 					wkr->RemoveAllAccessSpecs();
 				}
 			}
-
 			// Load the worker.
-			if ( !wkr->LoadConfig(infile, load_aspecs, load_targets) )
+			if (!wkr->LoadConfig(infile, load_aspecs, load_targets))
 				return FALSE;
-		}
-		else
-		{
+		} else {
 			ErrorMessage("File is improperly formatted.  MANAGER section "
-				"contained an unrecognized \"" + key + "\" comment.");
+				     "contained an unrecognized \"" + key + "\" comment.");
 			return FALSE;
 		}
 	}
@@ -1954,7 +1727,6 @@
 	return TRUE;
 }
 
-
 //
 // Disambiguate same-named managers.  This allows managers
 // to be uniquely identified in saved files and other places.
@@ -1966,18 +1738,15 @@
 	int count_up, count_down;
 	const int wkr_count = WorkerCount();
 
-	for (count_up=0; count_up<wkr_count; count_up++)
-	{
+	for (count_up = 0; count_up < wkr_count; count_up++) {
 		wkr = GetWorker(count_up);
 
 		wkr->id = 1;	// Assume this is unique, unless proven otherwise.
 
-		for (count_down=count_up-1; count_down>=0; count_down--)
-		{
+		for (count_down = count_up - 1; count_down >= 0; count_down--) {
 			otherwkr = GetWorker(count_down);
 
-			if ( CString(wkr->name).CompareNoCase(otherwkr->name) == 0 )
-			{
+			if (CString(wkr->name).CompareNoCase(otherwkr->name) == 0) {
 				// If the workers' names are identical, assign
 				// this worker an ID value one greater.
 				wkr->id = otherwkr->id + 1;

Modified: branches/IOMETER-restruct/iometer/src/Manager.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/Manager.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/Manager.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -65,27 +65,23 @@
 #ifndef MANAGER_DEFINED
 #define MANAGER_DEFINED
 
-
 #include "IOCommon.h"
 #include "Worker.h"
 #include "IOPort.h"
 #include <afxtempl.h>
 
-
 // Class information for a single Manager
-class Manager
-{
-public:
+class Manager {
+      public:
 	Manager();
 	~Manager();
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Information about an instance of a manager.
 	//
-	char		name[MAX_WORKER_NAME];			// Displayable name of Manager.
-	char		computer_name[MAX_NETWORK_NAME];// Computer this manager is running on.
-	char		network_name[MAX_NETWORK_NAME];	// Network address of the computer.
+	char name[MAX_WORKER_NAME];	// Displayable name of Manager.
+	char computer_name[MAX_NETWORK_NAME];	// Computer this manager is running on.
+	char network_name[MAX_NETWORK_NAME];	// Network address of the computer.
 	//
 	// Note that network_name is derived from the address Dynamo is connecting from,
 	// but it should NOT be used to refer to the Dynamo link.
@@ -94,174 +90,162 @@
 	// To fill in this value, call ManagerList::IndexManagers().
 	// If any managers are renamed, added, or removed, call
 	// ManagerList::IndexManagers().
-	int			id;
+	int id;
 	//
 	// Return a manager's index into the manager list.
-	int			GetIndex();
-	TargetType	Type();
+	int GetIndex();
+	TargetType Type();
 	//
-	double		processor_speed;	// Speed of manager's system processors in Hz.
-	int			processors;			// Number of processors in manager's system.
+	double processor_speed;	// Speed of manager's system processors in Hz.
+	int processors;		// Number of processors in manager's system.
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Interfaces available to the manager.  A worker is assigned a target
 	// that is accessed through one of these interfaces.
 	//
-	Target_Spec* GetInterface( int index, TargetType type );
-	int			InterfaceCount( TargetType type );
+	Target_Spec *GetInterface(int index, TargetType type);
+	int InterfaceCount(TargetType type);
 	//
 	// Removes cached interface information and all associated worker targets.
-	void		RemoveDiskInfo();
-	void		RemoveNetInfo();
+	void RemoveDiskInfo();
+	void RemoveNetInfo();
 	//
-protected:
-	CTypedPtrArray<CPtrArray, Target_Spec*>	disks;
-	CTypedPtrArray<CPtrArray, Target_Spec*>	tcps;
-	CTypedPtrArray<CPtrArray, Target_Spec*>	vis;
+      protected:
+	 CTypedPtrArray < CPtrArray, Target_Spec * >disks;
+	 CTypedPtrArray < CPtrArray, Target_Spec * >tcps;
+	 CTypedPtrArray < CPtrArray, Target_Spec * >vis;
 	//
-	void		InitTargetList( CTypedPtrArray<CPtrArray, Target_Spec*> *targets );
+	void InitTargetList(CTypedPtrArray < CPtrArray, Target_Spec * >*targets);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-	
-public:
+      public:
 	///////////////////////////////////////////////////////////////////////////
 	// Retrieving/setting information about a worker's targets.
 	//
-	int			GetConnectionRate( TargetType type );
-	int			GetDiskStart( TargetType type );
-	int			GetDiskSize( TargetType type );
-	char*		GetLocalNetworkInterface();
-	int			GetQueueDepth( TargetType type );
-	int			GetMaxSends( TargetType type );
-	int			GetTransPerConn( TargetType type );
+	int GetConnectionRate(TargetType type);
+	int GetDiskStart(TargetType type);
+	int GetDiskSize(TargetType type);
+	char *GetLocalNetworkInterface();
+	int GetQueueDepth(TargetType type);
+	int GetMaxSends(TargetType type);
+	int GetTransPerConn(TargetType type);
 	//
-	void		SetConnectionRate( BOOL test_connection_rate, TargetType type );
-	void		SetDiskSize( int disk_size );
-	void		SetDiskStart( int disk_start );
-	void		SetLocalNetworkInterface( int iface_index );
-	void		SetQueueDepth( int queue_depth, TargetType type );
-	void		SetMaxSends( int max_sends );
-	void		SetTransPerConn( int trans_per_conn, TargetType type );
+	void SetConnectionRate(BOOL test_connection_rate, TargetType type);
+	void SetDiskSize(int disk_size);
+	void SetDiskStart(int disk_start);
+	void SetLocalNetworkInterface(int iface_index);
+	void SetQueueDepth(int queue_depth, TargetType type);
+	void SetMaxSends(int max_sends);
+	void SetTransPerConn(int trans_per_conn, TargetType type);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Manages a manager's workers.
 	//
-	Worker*		GetWorker( int index, TargetType type = GenericType );
-	Worker*		GetWorkerByName( const char *wkr_name, const int wkr_id );
-	int			WorkerCount( TargetType type = GenericType );
+	Worker *GetWorker(int index, TargetType type = GenericType);
+	Worker *GetWorkerByName(const char *wkr_name, const int wkr_id);
+	int WorkerCount(TargetType type = GenericType);
 	//
-	Worker*		AddWorker( TargetType type, Worker *src_worker = NULL,
-					const CString& in_name = "" );
+	Worker *AddWorker(TargetType type, Worker * src_worker = NULL, const CString & in_name = "");
 	//
-	BOOL		RemoveWorker( int index, TargetType type = GenericType );
+	BOOL RemoveWorker(int index, TargetType type = GenericType);
 	//
 	// Disambiguate same-named managers.  This allows managers
 	// to be uniquely identified in saved files and other places.
 	// This should be called any time managers are added, removed, or renamed.
-	void		IndexWorkers();
+	void IndexWorkers();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Manages a manager's workers' targets.
 	//
-	void		UpdateTargetLists();
+	void UpdateTargetLists();
 	//
-	int			TargetCount( TargetType type = GenericType );
+	int TargetCount(TargetType type = GenericType);
 	//
-	int			SetActiveTargets( int worker_index, int active_target_count );
-	void		ClearActiveTargets();
-	void		RemoveTargets( TargetType type = GenericType );
+	int SetActiveTargets(int worker_index, int active_target_count);
+	void ClearActiveTargets();
+	void RemoveTargets(TargetType type = GenericType);
 	//
-	BOOL		ActiveInCurrentTest();
-	BOOL		HasActiveCurrentSpec();
-	BOOL		HasIdleCurrentSpec();
+	BOOL ActiveInCurrentTest();
+	BOOL HasActiveCurrentSpec();
+	BOOL HasIdleCurrentSpec();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Manage communications with corresponding Dynamo.
 	//
-	DWORD		Peek( int worker_index );
-	DWORDLONG	Send( int data, int purpose );
-	DWORDLONG	Send( Message* msg );
-	DWORDLONG	SendData( Data_Message* msg );
-	DWORDLONG	Receive( Message* msg );
-	DWORDLONG	ReceiveData( Data_Message* msg );
-	DWORDLONG	Receive();
+	DWORD Peek(int worker_index);
+	DWORDLONG Send(int data, int purpose);
+	DWORDLONG Send(Message * msg);
+	DWORDLONG SendData(Data_Message * msg);
+	DWORDLONG Receive(Message * msg);
+	DWORDLONG ReceiveData(Data_Message * msg);
+	DWORDLONG Receive();
 	//
-	Port		*port;
+	Port *port;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to deal with specific messages to Dynamo
 	//
-	BOOL		SetAccess( int access_index );
-	BOOL		SetTargets();
-	void		SetTargetsToPrepare( int worker_index );
-	BOOL		PreparedAnswer( int worker_index );
+	BOOL SetAccess(int access_index);
+	BOOL SetTargets();
+	void SetTargetsToPrepare(int worker_index);
+	BOOL PreparedAnswer(int worker_index);
 	//
 	// Functions to deal with results.
-	void		ResetResults( int which_perf );
-	void		ResetAllResults();
-	void		SaveResults( ostream* file, int access_index, int result_type );
-	void		UpdateResults( int which_perf );
+	void ResetResults(int which_perf);
+	void ResetAllResults();
+	void SaveResults(ostream * file, int access_index, int result_type);
+	void UpdateResults(int which_perf);
 	//
 	// Results for the last run test
-	Results		results[MAX_PERF];
+	Results results[MAX_PERF];
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to deal with access specs.
 	//
-	void		AssignDefaultAccessSpecs();
-	void		RemoveAccessSpec( Test_Spec *spec );
-	void		RemoveAccessSpecAt( int index );
-	void		RemoveAllAccessSpecs();
-	int			GetMaxAccessSpecCount();
+	void AssignDefaultAccessSpecs();
+	void RemoveAccessSpec(Test_Spec * spec);
+	void RemoveAccessSpecAt(int index);
+	void RemoveAllAccessSpecs();
+	int GetMaxAccessSpecCount();
 	//
-	void		MoveAccessSpec( int index, int before_index );
-	void		UpAccessSpec( int index );
-	void		DownAccessSpec( int index );
-	BOOL		InsertAccessSpec( Test_Spec* spec, int before_index );
+	void MoveAccessSpec(int index, int before_index);
+	void UpAccessSpec(int index);
+	void DownAccessSpec(int index);
+	BOOL InsertAccessSpec(Test_Spec * spec, int before_index);
 	//
 	// Returns a TRUE if all of this manager's workers
 	// have the same access specification list.
-	BOOL		AreAccessSpecsIdentical();
+	BOOL AreAccessSpecsIdentical();
 	// Gets the name of the current access spec for all managers.
-	char*		GetCommonAccessSpec( int spec_index, char * const specname );
+	char *GetCommonAccessSpec(int spec_index, char *const specname);
 	//
-	BOOL		InvalidSetup( BOOL &invalidSpecOK );
+	BOOL InvalidSetup(BOOL & invalidSpecOK);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to deal with the saving and loading of config files.
 	//
-	BOOL		SaveConfig( ostream& outfile,
-							BOOL save_aspecs,
-							BOOL save_targets );
-	BOOL		LoadConfig( ICF_ifstream& infile,
-							BOOL load_aspecs,
-							BOOL load_targets );
+	BOOL SaveConfig(ostream & outfile, BOOL save_aspecs, BOOL save_targets);
+	BOOL LoadConfig(ICF_ifstream & infile, BOOL load_aspecs, BOOL load_targets);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-protected:
-	CTypedPtrArray<CPtrArray, Worker*>		workers;
+      protected:
+	 CTypedPtrArray < CPtrArray, Worker * >workers;
 };
 
 #endif

Modified: branches/IOMETER-restruct/iometer/src/ManagerList.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/ManagerList.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ManagerList.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -72,13 +72,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "ManagerList.h"
 #include "GalileoView.h"
 #include "IOPortTCP.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -89,75 +87,63 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 ManagerList::ManagerList()
 {
-	ResetResults( WHOLE_TEST_PERF );
-	ResetResults( LAST_UPDATE_PERF );
-	strcpy( name, "All Managers" );
+	ResetResults(WHOLE_TEST_PERF);
+	ResetResults(LAST_UPDATE_PERF);
+	strcpy(name, "All Managers");
 }
 
-
-
 ManagerList::~ManagerList()
 {
 	RemoveAllManagers();
 }
 
-
-
 //
 // Get the nth manager matching the specified type.
 //
-Manager* ManagerList::GetManager( int index, TargetType type )
+Manager *ManagerList::GetManager(int index, TargetType type)
 {
-	int	i, manager_count;
+	int i, manager_count;
 
 	// Make sure that the manager exists.
-	if ( index < 0 || index >= ManagerCount( type ) )
+	if (index < 0 || index >= ManagerCount(type))
 		return NULL;
 
 	manager_count = ManagerCount();
-	for ( i = 0; i < manager_count; i++ )
-	{
-		if ( IsType( managers[i]->Type(), type ) )
-		{
-			if ( !index-- )
+	for (i = 0; i < manager_count; i++) {
+		if (IsType(managers[i]->Type(), type)) {
+			if (!index--)
 				return managers[i];
 		}
 	}
 
-	ASSERT( 0 );	// requested manager not found - should not happen
+	ASSERT(0);		// requested manager not found - should not happen
 	return NULL;
 }
 
-
-
 //
 // Get the first manager having the specified name and ID, if any.
 //
-Manager* ManagerList::GetManagerByName( const char *mgr_name, const int mgr_id )
+Manager *ManagerList::GetManagerByName(const char *mgr_name, const int mgr_id)
 {
-	int	i, manager_count;
+	int i, manager_count;
 
-	if ( !mgr_name )
-	{
-		ErrorMessage("Invalid string in ManagerList::GetManagerByName()" );
+	if (!mgr_name) {
+		ErrorMessage("Invalid string in ManagerList::GetManagerByName()");
 		return NULL;
 	}
 
 	manager_count = ManagerCount();
-	for ( i = 0; i < manager_count; i++ )
-	{
-		if ( strcmp( managers[i]->name, mgr_name ) == 0 && mgr_id == managers[i]->id )
-		{
+	for (i = 0; i < manager_count; i++) {
+		if (strcmp(managers[i]->name, mgr_name) == 0 && mgr_id == managers[i]->id) {
 			return managers[i];
 		}
 	}
@@ -166,18 +152,17 @@
 	return NULL;
 }
 
-
-
 //
 // Adding a new manager to the manager list.  The new manager is always added 
 // to the end of the list.  A connection to the manager is also made
 //
-Manager* ManagerList::AddManager( Manager_Info *manager_info )
+Manager *ManagerList::AddManager(Manager_Info * manager_info)
 {
 	unsigned short network_port = manager_info->port_number;
-	
+
 	// Creating space for a new manager.
-	Manager* manager;
+	Manager *manager;
+
 	manager = new Manager;
 
 	strcpy(manager->computer_name, manager_info->names[0]);
@@ -187,29 +172,25 @@
 	manager->processor_speed = (double)manager_info->processor_speed;
 
 	// Connect to the new manager using TCP/IP as appropriate
-	if ( theApp.login_port->type == PORT_TYPE_TCP )
-	{
+	if (theApp.login_port->type == PORT_TYPE_TCP) {
 		strcpy(manager->network_name, manager_info->names[1]);
 
 		manager->port = new PortTCP;
 
 		// Do not connect to "network_name".  See Manager.h for detailed comments.
-		if ( !manager->port->Connect( manager_info->names[1], network_port ) )
-		{
-			ErrorMessage( "Could not connect to new manager using "
-				"TCP/IP port in ManagerList::AddManager" );
+		if (!manager->port->Connect(manager_info->names[1], network_port)) {
+			ErrorMessage("Could not connect to new manager using "
+				     "TCP/IP port in ManagerList::AddManager");
 			return NULL;
 		}
-	}
-	else
-	{
-		ErrorMessage( "Invalid login port in ManagerList::AddManager" );
+	} else {
+		ErrorMessage("Invalid login port in ManagerList::AddManager");
 		return NULL;
 	}
 
 	// Adding manager to end of the manager list and updating the last manager accessed
 	// to be the new manager.
-	managers.Add( manager );
+	managers.Add(manager);
 
 	// Assign disambiguating integer identifiers to same-named managers.
 	theApp.manager_list.IndexManagers();
@@ -218,185 +199,163 @@
 	// This notification is only necessary if a configuration file restore
 	// is taking place and some of the managers required to restore the
 	// manager/worker configuration are not yet connected to Iometer.
-	if ( loadmap.IsWaitingList() )
-		(void) loadmap.ManagerLoggedIn( manager->name, manager->network_name, manager );
+	if (loadmap.IsWaitingList())
+		(void)loadmap.ManagerLoggedIn(manager->name, manager->network_name, manager);
 
 	// Return a pointer to the new manager.
 	return manager;
 }
 
-
-
 //
 // Comparing the network names of two machines.
 //
-BOOL ManagerList::CompareNames( char* net_name1, char* net_name2 )
+BOOL ManagerList::CompareNames(char *net_name1, char *net_name2)
 {
 	CString name1, name2;
+
 	name1 = net_name1;
 	name2 = net_name2;
-	name1 = name1.Mid( 2 ); // remove the leading '\\'
-	name2 = name2.Mid( 2 ); // remove the leading '\\'
-	name1 = name1.Mid( 0, name1.Find( '\\' ) );
-	name2 = name2.Mid( 0, name2.Find( '\\' ) );
-	return( name1 == name2 );
+	name1 = name1.Mid(2);	// remove the leading '\\'
+	name2 = name2.Mid(2);	// remove the leading '\\'
+	name1 = name1.Mid(0, name1.Find('\\'));
+	name2 = name2.Mid(0, name2.Find('\\'));
+	return (name1 == name2);
 }
 
-
-
 //
 // Removing a manager from the list.
 //
-BOOL ManagerList::RemoveManager( int index, int purpose )
+BOOL ManagerList::RemoveManager(int index, int purpose)
 {
-	if ( index < 0 || index >= ManagerCount() )
-	{
-		ErrorMessage( "Invalid index in ManagerList::RemoveManager()." );
+	if (index < 0 || index >= ManagerCount()) {
+		ErrorMessage("Invalid index in ManagerList::RemoveManager().");
 		return FALSE;
 	}
-
 	// Informing manager to end execution or reset depending on the purpose.
-	Send( index, purpose );
+	Send(index, purpose);
 
 	// Remove both the manager and it's reference in the list.
-	delete GetManager( index );
-	managers.RemoveAt( index );
+	delete GetManager(index);
 
+	managers.RemoveAt(index);
+
 	// Assign disambiguating integer identifiers to same-named managers.
 	theApp.manager_list.IndexManagers();
 
 	// Perform a full reset if all managers have
 	// been removed to reset the display properly.
-	if ( !ManagerCount() )
+	if (!ManagerCount())
 		theApp.pView->Reset();
 
-	return( ManagerCount() );
+	return (ManagerCount());
 }
 
-
-
 //
 // Clearing the list of all managers.
 //
-void ManagerList::RemoveAllManagers( int purpose )
+void ManagerList::RemoveAllManagers(int purpose)
 {
-	while ( ManagerCount() )
-		RemoveManager( 0, purpose );
+	while (ManagerCount())
+		RemoveManager(0, purpose);
 }
 
-
-
 //
 // Initializing results for all systems and their workers.
 //
-void ManagerList::ResetResults( int which_perf )
+void ManagerList::ResetResults(int which_perf)
 {
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF))
 		return;
 
-	memset( &(results[which_perf]), 0, sizeof( Results ) );
+	memset(&(results[which_perf]), 0, sizeof(Results));
 }
 
-
-
 //
 // Reset all results for all managers.  This includes resetting the results for all
 // managers and any results stored for them.
 //
 void ManagerList::ResetAllResults()
 {
-	ResetResults( WHOLE_TEST_PERF );
-	ResetResults( LAST_UPDATE_PERF );
+	ResetResults(WHOLE_TEST_PERF);
+	ResetResults(LAST_UPDATE_PERF);
 
 	// Have all managers reset their results too.
-	for ( int i = 0; i < ManagerCount(); i++ )
-		GetManager( i )->ResetAllResults();
+	for (int i = 0; i < ManagerCount(); i++)
+		GetManager(i)->ResetAllResults();
 }
 
-
-
 //
 // Sending a message to a manager.
 //
-DWORDLONG ManagerList::Send( int manager_index, Message* msg, int recipient )
+DWORDLONG ManagerList::Send(int manager_index, Message * msg, int recipient)
 {
 	msg->data = recipient;
-	return GetManager( manager_index )->Send( msg );
+	return GetManager(manager_index)->Send(msg);
 }
 
-
-DWORDLONG ManagerList::Send( int manager_index, int purpose, int recipient )
+DWORDLONG ManagerList::Send(int manager_index, int purpose, int recipient)
 {
 	Message msg;
+
 	msg.purpose = purpose;
 	msg.data = recipient;
-	return GetManager( manager_index )->Send( &msg );
+	return GetManager(manager_index)->Send(&msg);
 }
 
-
-
 //
 // Sending a message to all managers.
 //
-void ManagerList::SendManagers( Message* msg, int recipient )
+void ManagerList::SendManagers(Message * msg, int recipient)
 {
 	msg->data = recipient;
-	for ( int i = 0; i < ManagerCount(); i++ )
-		GetManager( i )->Send( msg );
+	for (int i = 0; i < ManagerCount(); i++)
+		GetManager(i)->Send(msg);
 }
 
-
-void ManagerList::SendManagers( int purpose, int recipient )
+void ManagerList::SendManagers(int purpose, int recipient)
 {
 	Message msg;
+
 	msg.purpose = purpose;
-	SendManagers( &msg, recipient );
+	SendManagers(&msg, recipient);
 }
 
-
-
 //
 // Sending a message to all managers which are active in the current test.
 //
-BOOL ManagerList::SendActiveManagers( int purpose )
+BOOL ManagerList::SendActiveManagers(int purpose)
 {
-	Manager	*manager;
-	Message	reply_msg;
+	Manager *manager;
+	Message reply_msg;
 
-	for ( int i = 0; i < ManagerCount(); i++ )
-	{
-		manager = GetManager( i );
+	for (int i = 0; i < ManagerCount(); i++) {
+		manager = GetManager(i);
 
 		// Skip managers not active in the current test.
-		if ( !manager->ActiveInCurrentTest() )
+		if (!manager->ActiveInCurrentTest())
 			continue;
 
-		manager->Send( ALL_WORKERS, purpose );
+		manager->Send(ALL_WORKERS, purpose);
 
 		// Check to see if a reply is necessary.
-		if ( purpose & REPLY_FILTER )
-		{
+		if (purpose & REPLY_FILTER) {
 			// Reply expected.  Check for success.
-			manager->Receive( &reply_msg );
-			if ( !reply_msg.data )
+			manager->Receive(&reply_msg);
+			if (!reply_msg.data)
 				return FALSE;
 		}
 	}
 	return TRUE;
 }
 
-
-
 //
 // Getting a message from a specified manager.
 //
-DWORDLONG ManagerList::ReceiveManager( int index, Message* msg  )
+DWORDLONG ManagerList::ReceiveManager(int index, Message * msg)
 {
-	return GetManager( index )->Receive( msg );
+	return GetManager(index)->Receive(msg);
 }
 
-
-
 //
 // Receiving a message from all managers.  The contents of the message are 
 // discarded. This is usually used to indicate reply messages from the 
@@ -406,201 +365,175 @@
 {
 	Message msg;
 
-	for ( int m = 0; m < ManagerCount(); m++ )
-		ReceiveManager( m, &msg );
+	for (int m = 0; m < ManagerCount(); m++)
+		ReceiveManager(m, &msg);
 }
 
-
-
-BOOL ManagerList::SetAccess( int spec_index )
+BOOL ManagerList::SetAccess(int spec_index)
 {
-	for ( int m = 0; m < ManagerCount(); m++ )
-	{
-		if ( !GetManager( m )->SetAccess( spec_index ) )
+	for (int m = 0; m < ManagerCount(); m++) {
+		if (!GetManager(m)->SetAccess(spec_index))
 			return FALSE;
 	}
 	return TRUE;
 }
 
-
-
 //
 // Setting active targets of all workers.
 //
 BOOL ManagerList::SetTargets()
 {
-	for ( int m = 0; m < ManagerCount(); m++ )
-	{
-		if ( !GetManager( m )->SetTargets() )
+	for (int m = 0; m < ManagerCount(); m++) {
+		if (!GetManager(m)->SetTargets())
 			return FALSE;
 	}
 	return TRUE;
 }
 
-
-
 void ManagerList::Reset()
 {
-	RemoveAllManagers( RESET );
+	RemoveAllManagers(RESET);
 	// Clear the manager list's results.
-	ResetResults( WHOLE_TEST_PERF );
-	ResetResults( LAST_UPDATE_PERF );
+	ResetResults(WHOLE_TEST_PERF);
+	ResetResults(LAST_UPDATE_PERF);
 }
 
-
-
-void ManagerList::SaveResults( ostream* file, int access_index, int result_type )
+void ManagerList::SaveResults(ostream * file, int access_index, int result_type)
 {
 	char specname[MAX_WORKER_NAME];
 	int stat = 0;
-	struct _timeb  tb;
-	struct tm     *ptm;
+	struct _timeb tb;
+	struct tm *ptm;
 	char acDummy[64];
 
 	// Writing result header information.
 	(*file) << "'Results" << endl
-		<< "'Target Type,Target Name,Access Specification Name,# Managers,"
-		<< "# Workers,# Disks,IOps,Read IOps,Write IOps,MBps,Read MBps,"
-		<< "Write MBps,Transactions per Second,Connections per Second,"
-		<< "Average Response Time,Average Read Response Time,"
-		<< "Average Write Response Time,Average Transaction Time,"
-		<< "Average Connection Time,Maximum Response Time,"
-		<< "Maximum Read Response Time,Maximum Write Response Time,"
-		<< "Maximum Transaction Time,Maximum Connection Time,"
-		<< "Errors,Read Errors,Write Errors,Bytes Read,Bytes Written,Read I/Os,"
-		<< "Write I/Os,Connections,Transactions per Connection,"
-		<< "Total Raw Read Response Time,Total Raw Write Response Time,"
-		<< "Total Raw Transaction Time,Total Raw Connection Time,"
-		<< "Maximum Raw Read Response Time,Maximum Raw Write Response Time,"
-		<< "Maximum Raw Transaction Time,Maximum Raw Connection Time,"
-		<< "Total Raw Run Time,Starting Sector,Maximum Size,Queue Depth,"
-		<< "% CPU Utilization,% User Time,% Privileged Time,% DPC Time,"
-		<< "% Interrupt Time,Processor Speed,Interrupts per Second,"
-		<< "CPU Effectiveness,Packets/Second,Packet Errors,"
-		<< "Segments Retransmitted/Second" << endl;
+	    << "'Target Type,Target Name,Access Specification Name,# Managers,"
+	    << "# Workers,# Disks,IOps,Read IOps,Write IOps,MBps,Read MBps,"
+	    << "Write MBps,Transactions per Second,Connections per Second,"
+	    << "Average Response Time,Average Read Response Time,"
+	    << "Average Write Response Time,Average Transaction Time,"
+	    << "Average Connection Time,Maximum Response Time,"
+	    << "Maximum Read Response Time,Maximum Write Response Time,"
+	    << "Maximum Transaction Time,Maximum Connection Time,"
+	    << "Errors,Read Errors,Write Errors,Bytes Read,Bytes Written,Read I/Os,"
+	    << "Write I/Os,Connections,Transactions per Connection,"
+	    << "Total Raw Read Response Time,Total Raw Write Response Time,"
+	    << "Total Raw Transaction Time,Total Raw Connection Time,"
+	    << "Maximum Raw Read Response Time,Maximum Raw Write Response Time,"
+	    << "Maximum Raw Transaction Time,Maximum Raw Connection Time,"
+	    << "Total Raw Run Time,Starting Sector,Maximum Size,Queue Depth,"
+	    << "% CPU Utilization,% User Time,% Privileged Time,% DPC Time,"
+	    << "% Interrupt Time,Processor Speed,Interrupts per Second,"
+	    << "CPU Effectiveness,Packets/Second,Packet Errors," << "Segments Retransmitted/Second" << endl;
 
 	// Writing manager list results
 
-	(*file)	<< "ALL" 
-			<< "," << "All" 
-			<< "," << GetCommonAccessSpec( access_index, specname ) 
-			<< "," << ManagerCount( ActiveType )
-			<< "," << WorkerCount( ActiveType )
-			<< "," << TargetCount( ActiveType )	+ WorkerCount( 
-						(TargetType)(GenericClientType | ActiveType) )
-			<< "," << results[WHOLE_TEST_PERF].IOps 
-			<< "," << results[WHOLE_TEST_PERF].read_IOps 
-			<< "," << results[WHOLE_TEST_PERF].write_IOps 
-			<< "," << results[WHOLE_TEST_PERF].MBps 
-			<< "," << results[WHOLE_TEST_PERF].read_MBps 
-			<< "," << results[WHOLE_TEST_PERF].write_MBps 
-			<< "," << results[WHOLE_TEST_PERF].transactions_per_second 
-			<< "," << results[WHOLE_TEST_PERF].connections_per_second 
-			<< "," << results[WHOLE_TEST_PERF].ave_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_write_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_write_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].total_errors 
-			<< "," << results[WHOLE_TEST_PERF].raw.read_errors 
-			<< "," << results[WHOLE_TEST_PERF].raw.write_errors 
-			<< "," << results[WHOLE_TEST_PERF].raw.bytes_read 
-			<< "," << results[WHOLE_TEST_PERF].raw.bytes_written 
-			<< "," << results[WHOLE_TEST_PERF].raw.read_count 
-			<< "," << results[WHOLE_TEST_PERF].raw.write_count 
-			<< "," << results[WHOLE_TEST_PERF].raw.connection_count << ",";
+	(*file) << "ALL" << "," << "All" << "," << GetCommonAccessSpec(access_index, specname)
+	    << "," << ManagerCount(ActiveType)
+	    << "," << WorkerCount(ActiveType)
+	    << "," << TargetCount(ActiveType) + WorkerCount((TargetType) (GenericClientType | ActiveType))
+	    << "," << results[WHOLE_TEST_PERF].IOps
+	    << "," << results[WHOLE_TEST_PERF].read_IOps
+	    << "," << results[WHOLE_TEST_PERF].write_IOps
+	    << "," << results[WHOLE_TEST_PERF].MBps
+	    << "," << results[WHOLE_TEST_PERF].read_MBps
+	    << "," << results[WHOLE_TEST_PERF].write_MBps
+	    << "," << results[WHOLE_TEST_PERF].transactions_per_second
+	    << "," << results[WHOLE_TEST_PERF].connections_per_second
+	    << "," << results[WHOLE_TEST_PERF].ave_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_read_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_write_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].max_latency
+	    << "," << results[WHOLE_TEST_PERF].max_read_latency
+	    << "," << results[WHOLE_TEST_PERF].max_write_latency
+	    << "," << results[WHOLE_TEST_PERF].max_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].max_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].total_errors
+	    << "," << results[WHOLE_TEST_PERF].raw.read_errors
+	    << "," << results[WHOLE_TEST_PERF].raw.write_errors
+	    << "," << results[WHOLE_TEST_PERF].raw.bytes_read
+	    << "," << results[WHOLE_TEST_PERF].raw.bytes_written
+	    << "," << results[WHOLE_TEST_PERF].raw.read_count
+	    << "," << results[WHOLE_TEST_PERF].raw.write_count
+	    << "," << results[WHOLE_TEST_PERF].raw.connection_count << ",";
 
-	if ( GetConnectionRate( ActiveType ) == ENABLED_VALUE )
-		(*file) << GetTransPerConn( ActiveType );
+	if (GetConnectionRate(ActiveType) == ENABLED_VALUE)
+		(*file) << GetTransPerConn(ActiveType);
 	else
 		(*file) << AMBIGUOUS_VALUE;
 
 	(*file) << ",,,,,,,,,";	// unused raw results for manager list
 
-	(*file) << "," << GetDiskStart( (TargetType)(GenericDiskType | ActiveType) ) 
-			<< "," << GetDiskSize( (TargetType)(GenericDiskType | ActiveType) )
-			<< "," << GetQueueDepth( ActiveType );
+	(*file) << "," << GetDiskStart((TargetType) (GenericDiskType | ActiveType))
+	    << "," << GetDiskSize((TargetType) (GenericDiskType | ActiveType))
+	    << "," << GetQueueDepth(ActiveType);
 
-	for ( stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++ )
-			(*file) << "," << results[WHOLE_TEST_PERF].CPU_utilization[stat];
+	for (stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++)
+		(*file) << "," << results[WHOLE_TEST_PERF].CPU_utilization[stat];
 
-	(*file) << ","	// processor speed
-			<< "," << results[WHOLE_TEST_PERF].CPU_utilization[CPU_IRQ];
+	(*file) << ","		// processor speed
+	    << "," << results[WHOLE_TEST_PERF].CPU_utilization[CPU_IRQ];
 
 	(*file) << "," << results[WHOLE_TEST_PERF].CPU_effectiveness;
 
-	for ( stat = 0; stat < NI_COMBINE_RESULTS; stat++ )
+	for (stat = 0; stat < NI_COMBINE_RESULTS; stat++)
 		(*file) << "," << results[WHOLE_TEST_PERF].ni_statistics[stat];
 
-	for ( stat = 0; stat < TCP_RESULTS; stat++ )
+	for (stat = 0; stat < TCP_RESULTS; stat++)
 		(*file) << "," << results[WHOLE_TEST_PERF].tcp_statistics[stat];
-	
+
 	(*file) << endl;
 
 	// If requested, save manager results.
-	if ( result_type == RecordAll
-			|| result_type == RecordNoTargets
-			|| result_type == RecordNoWorkers )
-	{
-		for ( int i = 0; i < ManagerCount(); i++ )
-			GetManager(i)->SaveResults( file, access_index, result_type );
+	if (result_type == RecordAll || result_type == RecordNoTargets || result_type == RecordNoWorkers) {
+		for (int i = 0; i < ManagerCount(); i++)
+			GetManager(i)->SaveResults(file, access_index, result_type);
 	}
-
 	// Write current timestamp into the result file
 	(*file) << "'Time Stamp" << endl;
-	_ftime( &tb );
-	ptm = localtime( &tb.time );
-	sprintf( acDummy, "%04d-%02d-%02d %02d:%02d:%02d:%003d", ptm->tm_year + 1900,
-	                                                         ptm->tm_mon + 1,
-								 ptm->tm_mday,
-								 ptm->tm_hour,
-								 ptm->tm_min,
-								 ptm->tm_sec,
-								 tb.millitm );
+	_ftime(&tb);
+	ptm = localtime(&tb.time);
+	sprintf(acDummy, "%04d-%02d-%02d %02d:%02d:%02d:%003d", ptm->tm_year + 1900,
+		ptm->tm_mon + 1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, tb.millitm);
 	(*file) << acDummy << endl;
 }
 
-
-
 //
 // Calculation intensive code to determine the combined performance for
 // all managers and their workers.  Programmers beware.
 //
-void ManagerList::UpdateResults( int which_perf )
+void ManagerList::UpdateResults(int which_perf)
 {
-	Manager*	manager;
+	Manager *manager;
+
 	// Total time each manager used transferring I/Os in ms.
-	double		read_latency_sum = 0;
-	double		write_latency_sum = 0;
-	double		transaction_latency_sum = 0;
-	double		connection_latency_sum = 0;
-	int			stat;						// loop control
+	double read_latency_sum = 0;
+	double write_latency_sum = 0;
+	double transaction_latency_sum = 0;
+	double connection_latency_sum = 0;
+	int stat;		// loop control
 
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF))
 		return;
 
-	ResetResults( which_perf );
+	ResetResults(which_perf);
 
 	// Loop through all managers to get their results.
-	for ( int i = 0; i < ManagerCount(); i++ )
-	{
-		manager = GetManager( i );
+	for (int i = 0; i < ManagerCount(); i++) {
+		manager = GetManager(i);
 
 		// Skip managers not active in the current test.
-		if ( !manager->ActiveInCurrentTest() )
-		{
+		if (!manager->ActiveInCurrentTest()) {
 			// Clear the results of idle managers to prevent them from being
 			// displayed in the results window.
 			manager->ResetAllResults();
 			continue;
 		}
 		// Request an update from all managers and process the results.
-		manager->UpdateResults( which_perf );
+		manager->UpdateResults(which_perf);
 
 		// Recording error results.
 		results[which_perf].total_errors += manager->results[which_perf].total_errors;
@@ -622,139 +555,105 @@
 		results[which_perf].raw.bytes_written += manager->results[which_perf].raw.bytes_written;
 
 		// Recording results related to the number of transactions completed.
-		results[which_perf].transactions_per_second += 
-			manager->results[which_perf].transactions_per_second;
-		results[which_perf].raw.transaction_count += 
-			manager->results[which_perf].raw.transaction_count;
+		results[which_perf].transactions_per_second += manager->results[which_perf].transactions_per_second;
+		results[which_perf].raw.transaction_count += manager->results[which_perf].raw.transaction_count;
 
 		// Recording results related to the number of connections completed.
-		results[which_perf].connections_per_second += 
-			manager->results[which_perf].connections_per_second;
-		results[which_perf].raw.connection_count += 
-			manager->results[which_perf].raw.connection_count;
+		results[which_perf].connections_per_second += manager->results[which_perf].connections_per_second;
+		results[which_perf].raw.connection_count += manager->results[which_perf].raw.connection_count;
 
 		// Recording maximum latency information.
-		if ( results[which_perf].max_latency < manager->results[which_perf].max_latency )
-		{
+		if (results[which_perf].max_latency < manager->results[which_perf].max_latency) {
 			results[which_perf].max_latency = manager->results[which_perf].max_latency;
 		}
-		if ( results[which_perf].max_read_latency < manager->results[which_perf].max_read_latency )
-		{
+		if (results[which_perf].max_read_latency < manager->results[which_perf].max_read_latency) {
 			results[which_perf].max_read_latency = manager->results[which_perf].max_read_latency;
 		}
-		if ( results[which_perf].max_write_latency < manager->results[which_perf].max_write_latency )
-		{
+		if (results[which_perf].max_write_latency < manager->results[which_perf].max_write_latency) {
 			results[which_perf].max_write_latency = manager->results[which_perf].max_write_latency;
 		}
-		if ( results[which_perf].max_transaction_latency < 
-			manager->results[which_perf].max_transaction_latency )
-		{
-			results[which_perf].max_transaction_latency = 
-			manager->results[which_perf].max_transaction_latency;
+		if (results[which_perf].max_transaction_latency < manager->results[which_perf].max_transaction_latency) {
+			results[which_perf].max_transaction_latency =
+			    manager->results[which_perf].max_transaction_latency;
 		}
-		if ( results[which_perf].max_connection_latency < 
-			manager->results[which_perf].max_connection_latency )
-		{
-			results[which_perf].max_connection_latency = 
-			manager->results[which_perf].max_connection_latency;
+		if (results[which_perf].max_connection_latency < manager->results[which_perf].max_connection_latency) {
+			results[which_perf].max_connection_latency =
+			    manager->results[which_perf].max_connection_latency;
 		}
 
-		read_latency_sum += (double) (_int64) 
-			manager->results[which_perf].raw.read_latency_sum / (double) 
-			manager->processor_speed;
-		write_latency_sum += (double) (_int64) 
-			manager->results[which_perf].raw.write_latency_sum / (double) 
-			manager->processor_speed;
-		transaction_latency_sum	+= (double) (_int64) 
-			manager->results[which_perf].raw.transaction_latency_sum / (double) 
-			manager->processor_speed;
-		connection_latency_sum += (double) (_int64) 
-			manager->results[which_perf].raw.connection_latency_sum / (double) 
-			manager->processor_speed;
+		read_latency_sum += (double)(_int64)
+		    manager->results[which_perf].raw.read_latency_sum / (double)
+		    manager->processor_speed;
+		write_latency_sum += (double)(_int64)
+		    manager->results[which_perf].raw.write_latency_sum / (double)
+		    manager->processor_speed;
+		transaction_latency_sum += (double)(_int64)
+		    manager->results[which_perf].raw.transaction_latency_sum / (double)
+		    manager->processor_speed;
+		connection_latency_sum += (double)(_int64)
+		    manager->results[which_perf].raw.connection_latency_sum / (double)
+		    manager->processor_speed;
 
-		for ( stat = 0; stat < CPU_RESULTS; stat++ )
-		{
-			results[which_perf].CPU_utilization[stat] += 
-				manager->results[which_perf].CPU_utilization[stat];
+		for (stat = 0; stat < CPU_RESULTS; stat++) {
+			results[which_perf].CPU_utilization[stat] += manager->results[which_perf].CPU_utilization[stat];
 		}
 
-		for ( stat = 0; stat < TCP_RESULTS; stat++ )
-		{
-			results[which_perf].tcp_statistics[stat] +=	
-				manager->results[which_perf].tcp_statistics[stat];
+		for (stat = 0; stat < TCP_RESULTS; stat++) {
+			results[which_perf].tcp_statistics[stat] += manager->results[which_perf].tcp_statistics[stat];
 		}
-		for ( stat = 0; stat < NI_COMBINE_RESULTS; stat++ )
-		{
-			results[which_perf].ni_statistics[stat] +=
-				manager->results[which_perf].ni_statistics[stat];
+		for (stat = 0; stat < NI_COMBINE_RESULTS; stat++) {
+			results[which_perf].ni_statistics[stat] += manager->results[which_perf].ni_statistics[stat];
 		}
 	}
-	if ( results[which_perf].raw.read_count || results[which_perf].raw.write_count )
-	{
+	if (results[which_perf].raw.read_count || results[which_perf].raw.write_count) {
 		results[which_perf].ave_latency = (read_latency_sum + write_latency_sum) * (double)
-			1000 / (double) (_int64) (results[which_perf].raw.read_count + 
-			results[which_perf].raw.write_count);
+		    1000 / (double)(_int64) (results[which_perf].raw.read_count + results[which_perf].raw.write_count);
 
-		if ( results[which_perf].raw.read_count )
-			results[which_perf].ave_read_latency = read_latency_sum * (double) 1000 / 
-			(double) (_int64) results[which_perf].raw.read_count;
+		if (results[which_perf].raw.read_count)
+			results[which_perf].ave_read_latency = read_latency_sum * (double)1000 /
+			    (double)(_int64) results[which_perf].raw.read_count;
 		else
-			results[which_perf].ave_read_latency = (double) 0;
+			results[which_perf].ave_read_latency = (double)0;
 
-		if ( results[which_perf].raw.write_count )
-			results[which_perf].ave_write_latency = write_latency_sum * (double) 1000 
-			/ (double) (_int64) results[which_perf].raw.write_count;
+		if (results[which_perf].raw.write_count)
+			results[which_perf].ave_write_latency = write_latency_sum * (double)1000
+			    / (double)(_int64) results[which_perf].raw.write_count;
 		else
-			results[which_perf].ave_write_latency = (double) 0;
+			results[which_perf].ave_write_latency = (double)0;
 
-		if ( results[which_perf].raw.transaction_count )
-		{
-			results[which_perf].ave_transaction_latency = transaction_latency_sum * 
-				(double) 1000 / (double) (_int64) 
-				(results[which_perf].raw.transaction_count);
+		if (results[which_perf].raw.transaction_count) {
+			results[which_perf].ave_transaction_latency = transaction_latency_sum *
+			    (double)1000 / (double)(_int64)
+			    (results[which_perf].raw.transaction_count);
+		} else {
+			results[which_perf].ave_transaction_latency = (double)0;
 		}
-		else
-		{
-			results[which_perf].ave_transaction_latency = (double) 0;
-		}
+	} else {
+		results[which_perf].ave_latency = (double)0;
+		results[which_perf].ave_read_latency = (double)0;
+		results[which_perf].ave_write_latency = (double)0;
+		results[which_perf].ave_transaction_latency = (double)0;
 	}
-	else
-	{
-		results[which_perf].ave_latency = (double) 0;
-		results[which_perf].ave_read_latency = (double) 0;
-		results[which_perf].ave_write_latency = (double) 0;
-		results[which_perf].ave_transaction_latency = (double) 0;
-	}
 
-	if ( results[which_perf].raw.connection_count )
-	{
-		results[which_perf].ave_connection_latency = connection_latency_sum * (double) 1000
-			/ (double) (_int64) (results[which_perf].raw.connection_count);
+	if (results[which_perf].raw.connection_count) {
+		results[which_perf].ave_connection_latency = connection_latency_sum * (double)1000
+		    / (double)(_int64) (results[which_perf].raw.connection_count);
+	} else {
+		results[which_perf].ave_connection_latency = (double)0;
 	}
-	else
-	{
-		results[which_perf].ave_connection_latency = (double) 0;
-	}
 
-	for ( stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++ )
-	{
-		results[which_perf].CPU_utilization[stat] /= ManagerCount( ActiveType );
+	for (stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++) {
+		results[which_perf].CPU_utilization[stat] /= ManagerCount(ActiveType);
 	}
 
-	if (results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION] != (double) 0)
-	{
-		results[which_perf].CPU_effectiveness = results[which_perf].IOps / 
-			results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION];
+	if (results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION] != (double)0) {
+		results[which_perf].CPU_effectiveness = results[which_perf].IOps /
+		    results[which_perf].CPU_utilization[CPU_TOTAL_UTILIZATION];
+	} else {
+		results[which_perf].CPU_effectiveness = (double)0;
 	}
-	else
-	{
-		results[which_perf].CPU_effectiveness = (double) 0;
-	}
 }
 
-
-
-
 ////////////////////////////////////////////////////////////////////////////////////
 //
 // The following functions update the values for the starting sector, the number of
@@ -763,78 +662,66 @@
 // calls the managers function.
 //
 ////////////////////////////////////////////////////////////////////////////////////
-void ManagerList::SetDiskSize( int disk_size )
+void ManagerList::SetDiskSize(int disk_size)
 {
 	int i, mgr_count;
 
 	// Loop through all the managers.
-	mgr_count = ManagerCount( GenericDiskType );
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i, GenericDiskType )->SetDiskSize( disk_size );
+	mgr_count = ManagerCount(GenericDiskType);
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i, GenericDiskType)->SetDiskSize(disk_size);
 }
 
-
-
-void ManagerList::SetDiskStart( int disk_start )
+void ManagerList::SetDiskStart(int disk_start)
 {
 	int i, mgr_count;
 
 	// Loop through all the managers.
-	mgr_count = ManagerCount( GenericDiskType );
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i, GenericDiskType )->SetDiskStart( disk_start );
+	mgr_count = ManagerCount(GenericDiskType);
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i, GenericDiskType)->SetDiskStart(disk_start);
 }
 
-
-
-void ManagerList::SetQueueDepth( int queue_size, TargetType type )
+void ManagerList::SetQueueDepth(int queue_size, TargetType type)
 {
 	int i, mgr_count;
 
 	// Loop through all the managers.
-	mgr_count = ManagerCount( type );
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i, type )->SetQueueDepth( queue_size, type );
+	mgr_count = ManagerCount(type);
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i, type)->SetQueueDepth(queue_size, type);
 }
 
-
-
-void ManagerList::SetMaxSends( int max_sends )
+void ManagerList::SetMaxSends(int max_sends)
 {
 	int i, mgr_count;
 
 	// Loop through all the managers.
-	mgr_count = ManagerCount( VIServerType );
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i, VIServerType )->SetMaxSends( max_sends );
+	mgr_count = ManagerCount(VIServerType);
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i, VIServerType)->SetMaxSends(max_sends);
 }
 
-
-
-void ManagerList::SetConnectionRate( BOOL connection_rate, TargetType type )
+void ManagerList::SetConnectionRate(BOOL connection_rate, TargetType type)
 {
 	int i, mgr_count;
 
 	// Loop through all the managers.
-	mgr_count = ManagerCount( type );
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i, type )->SetConnectionRate( connection_rate, type );
+	mgr_count = ManagerCount(type);
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i, type)->SetConnectionRate(connection_rate, type);
 }
 
-
-
-void ManagerList::SetTransPerConn( int trans_per_conn, TargetType type )
+void ManagerList::SetTransPerConn(int trans_per_conn, TargetType type)
 {
 	int i, mgr_count;
 
 	// Loop through all the managers.
-	mgr_count = ManagerCount( type );
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i, type )->SetTransPerConn( trans_per_conn, type );
+	mgr_count = ManagerCount(type);
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i, type)->SetTransPerConn(trans_per_conn, type);
 }
 
-
-
 ///////////////////////////////////////////////
 //
 // Functions to retrieve worker information
@@ -844,23 +731,20 @@
 //
 ///////////////////////////////////////////////
 
-
-int ManagerList::GetConnectionRate( TargetType type )
+int ManagerList::GetConnectionRate(TargetType type)
 {
 	int m, mgr_count, mgr_result;
-	
-	if ( !( mgr_count = ManagerCount( type ) ) )
+
+	if (!(mgr_count = ManagerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Get the value of the first manager.
-	mgr_result = GetManager( 0, type )->GetConnectionRate( type );
+	mgr_result = GetManager(0, type)->GetConnectionRate(type);
 
 	// Compare each manager's value with the first manager.
-	for ( m = 1; m < mgr_count; m++ )
-	{
-		if ( GetManager( m, type )->WorkerCount( type ) && 
-			mgr_result != GetManager( m, type )->GetConnectionRate( type ) )
-		{
+	for (m = 1; m < mgr_count; m++) {
+		if (GetManager(m, type)->WorkerCount(type) &&
+		    mgr_result != GetManager(m, type)->GetConnectionRate(type)) {
 			// The values are not the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -869,25 +753,20 @@
 	return mgr_result;
 }
 
-
-
-int ManagerList::GetTransPerConn( TargetType type )
+int ManagerList::GetTransPerConn(TargetType type)
 {
 	int m, mgr_count, mgr_result;
 
-	if ( !( mgr_count = ManagerCount( type ) ) )
+	if (!(mgr_count = ManagerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Get the value of the first manager.
-	mgr_result = GetManager( 0, type )->GetTransPerConn( type );
+	mgr_result = GetManager(0, type)->GetTransPerConn(type);
 
 	// Compare each manager's value with the first manager, if it has any
 	// workers of the specified type.
-	for ( m = 1; m < mgr_count; m++ )
-	{
-		if ( GetManager( m, type )->WorkerCount( type ) &&
-			mgr_result != GetManager( m, type )->GetTransPerConn( type ) )
-		{
+	for (m = 1; m < mgr_count; m++) {
+		if (GetManager(m, type)->WorkerCount(type) && mgr_result != GetManager(m, type)->GetTransPerConn(type)) {
 			// The values are not the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -895,24 +774,19 @@
 	return mgr_result;
 }
 
-
-
-int ManagerList::GetDiskStart( TargetType type )
+int ManagerList::GetDiskStart(TargetType type)
 {
 	int m, mgr_count, mgr_result;
 
-	if ( !( mgr_count = ManagerCount( type ) ) )
+	if (!(mgr_count = ManagerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Get the value of the first manager.
-	mgr_result = GetManager( 0, type )->GetDiskStart( type );
+	mgr_result = GetManager(0, type)->GetDiskStart(type);
 
 	// Compare each manager's value with the first manager.
-	for ( m = 1; m < mgr_count; m++ )
-	{
-		if ( GetManager( m, type )->WorkerCount( type ) &&
-			mgr_result != GetManager( m, type )->GetDiskStart( type ) )
-		{
+	for (m = 1; m < mgr_count; m++) {
+		if (GetManager(m, type)->WorkerCount(type) && mgr_result != GetManager(m, type)->GetDiskStart(type)) {
 			// The values are not the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -920,24 +794,19 @@
 	return mgr_result;
 }
 
-
-
-int ManagerList::GetDiskSize( TargetType type )
+int ManagerList::GetDiskSize(TargetType type)
 {
 	int m, mgr_count, mgr_result;
 
-	if ( !( mgr_count = ManagerCount( type ) ) )
+	if (!(mgr_count = ManagerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Get the value of the first manager.
-	mgr_result = GetManager( 0, type )->GetDiskSize( type );
+	mgr_result = GetManager(0, type)->GetDiskSize(type);
 
 	// Compare each manager's value with the first manager.
-	for ( m = 1; m < mgr_count; m++ )
-	{
-		if ( GetManager( m, type )->WorkerCount( type ) &&
-			mgr_result != GetManager( m, type )->GetDiskSize( type ) )
-		{
+	for (m = 1; m < mgr_count; m++) {
+		if (GetManager(m, type)->WorkerCount(type) && mgr_result != GetManager(m, type)->GetDiskSize(type)) {
 			// The values are not the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -945,24 +814,19 @@
 	return mgr_result;
 }
 
-
-
-int ManagerList::GetQueueDepth( TargetType type )
+int ManagerList::GetQueueDepth(TargetType type)
 {
 	int m, mgr_count, mgr_result;
 
-	if ( !( mgr_count = ManagerCount( type ) ) )
+	if (!(mgr_count = ManagerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Get the value of the first manager.
-	mgr_result = GetManager( 0, type )->GetQueueDepth( type );
+	mgr_result = GetManager(0, type)->GetQueueDepth(type);
 
 	// Compare each manager's value with the first manager.
-	for ( m = 1; m < mgr_count; m++ )
-	{
-		if ( GetManager( m, type  )->WorkerCount( type ) &&
-			mgr_result != GetManager( m, type )->GetQueueDepth( type ) )
-		{
+	for (m = 1; m < mgr_count; m++) {
+		if (GetManager(m, type)->WorkerCount(type) && mgr_result != GetManager(m, type)->GetQueueDepth(type)) {
 			// The values are not the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -970,24 +834,19 @@
 	return mgr_result;
 }
 
-
-
-int ManagerList::GetMaxSends( TargetType type )
+int ManagerList::GetMaxSends(TargetType type)
 {
 	int m, mgr_count, mgr_result;
 
-	if ( !( mgr_count = ManagerCount( type ) ) )
+	if (!(mgr_count = ManagerCount(type)))
 		return AMBIGUOUS_VALUE;
 
 	// Get the value of the first manager.
-	mgr_result = GetManager( 0, type )->GetMaxSends( type );
+	mgr_result = GetManager(0, type)->GetMaxSends(type);
 
 	// Compare each manager's value with the first manager.
-	for ( m = 1; m < mgr_count; m++ )
-	{
-		if ( GetManager( m, type )->WorkerCount( type ) &&
-			mgr_result != GetManager( m, type )->GetMaxSends( type ) )
-		{
+	for (m = 1; m < mgr_count; m++) {
+		if (GetManager(m, type)->WorkerCount(type) && mgr_result != GetManager(m, type)->GetMaxSends(type)) {
 			// The values are not the same.
 			return AMBIGUOUS_VALUE;
 		}
@@ -995,57 +854,48 @@
 	return mgr_result;
 }
 
-
-
 //
 // Return the number of managers that have workers with targets of the
 // specified type
 //
-int ManagerList::ManagerCount( TargetType type )
+int ManagerList::ManagerCount(TargetType type)
 {
 	int i, mgr_count, count = 0;
 
 	mgr_count = managers.GetSize();
-	for ( i = 0; i < mgr_count; i++ )
-	{
-		if ( IsType( managers[i]->Type(), type ) )
+	for (i = 0; i < mgr_count; i++) {
+		if (IsType(managers[i]->Type(), type))
 			count++;
 	}
 	return count;
 }
 
-
-
 //
 // Return the total number of workers summed for all managers.
 //
-int ManagerList::WorkerCount( TargetType type )
+int ManagerList::WorkerCount(TargetType type)
 {
-	int i, count = 0, mgr_count = ManagerCount( type );
+	int i, count = 0, mgr_count = ManagerCount(type);
 
-	for ( i = 0; i < mgr_count; i++ )
-		count += GetManager( i, type )->WorkerCount( type );
+	for (i = 0; i < mgr_count; i++)
+		count += GetManager(i, type)->WorkerCount(type);
 
 	return count;
 }
 
-
-
 //
 // Return the total number of targets for all workers of all managers.
 //
-int ManagerList::TargetCount( TargetType type )
+int ManagerList::TargetCount(TargetType type)
 {
-	int i, count = 0, mgr_count = ManagerCount( type );
+	int i, count = 0, mgr_count = ManagerCount(type);
 
-	for ( i = 0; i < mgr_count; i++ )
-		count += GetManager( i, type )->TargetCount( type );
+	for (i = 0; i < mgr_count; i++)
+		count += GetManager(i, type)->TargetCount(type);
 
 	return count;
 }
 
-
-
 //
 // Marking all assigned targets as inactive.
 //
@@ -1053,19 +903,16 @@
 {
 	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i )->ClearActiveTargets();
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i)->ClearActiveTargets();
 }
 
-
-
 ///////////////////////////////////////////////
 //
 // Functions that deal with access specs.
 //
 ///////////////////////////////////////////////
 
-
 //
 // Find the maximum number of access specs assigned to any worker.
 //
@@ -1073,57 +920,47 @@
 {
 	int i, max = 0, mgr_max, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-	{
-		if ( ( mgr_max = GetManager( i )->GetMaxAccessSpecCount() ) > max )
+	for (i = 0; i < mgr_count; i++) {
+		if ((mgr_max = GetManager(i)->GetMaxAccessSpecCount()) > max)
 			max = mgr_max;
 	}
 	return max;
 }
 
-
-
 //
 // Verify that all assigned configuration parameters are valid.
 //
-BOOL ManagerList::InvalidSetup( BOOL &invalidSpecOK )
+BOOL ManagerList::InvalidSetup(BOOL & invalidSpecOK)
 {
-	int		m, w;
-	Manager	*mgr;
-	Worker	*wkr;
-	BOOL	nonidle_worker_with_targets = FALSE;
-	BOOL	all_workers_idle = TRUE;
+	int m, w;
+	Manager *mgr;
+	Worker *wkr;
+	BOOL nonidle_worker_with_targets = FALSE;
+	BOOL all_workers_idle = TRUE;
 
 	// Verify that at least one spec was assigned, even if Idle.
-	if ( !GetMaxAccessSpecCount() )
-	{
-		ErrorMessage( "You must assign at least one access specification "
-			"to a worker." );
+	if (!GetMaxAccessSpecCount()) {
+		ErrorMessage("You must assign at least one access specification " "to a worker.");
 		return TRUE;
 	}
-
 	// We need to loop through all workers of all managers to verify
 	// their assigned specs are valid.
-	for ( m = 0; m < ManagerCount(); m++ )
-	{
-		mgr = GetManager( m );
-		if ( mgr->InvalidSetup( invalidSpecOK ) ) {
+	for (m = 0; m < ManagerCount(); m++) {
+		mgr = GetManager(m);
+		if (mgr->InvalidSetup(invalidSpecOK)) {
 			return TRUE;
 		}
-
 		// Verify that at least one worker has targets assigned with a
 		// non-idle spec or all specs are idle.
-		for ( w = 0; w < mgr->WorkerCount(); w++ )
-		{
-			wkr = mgr->GetWorker( w );
+		for (w = 0; w < mgr->WorkerCount(); w++) {
+			wkr = mgr->GetWorker(w);
 
 			// Keep track if all workers have only the idle spec.
-			if ( wkr->AccessSpecCount() != wkr->IdleAccessSpecCount() )
-			{
+			if (wkr->AccessSpecCount() != wkr->IdleAccessSpecCount()) {
 				all_workers_idle = FALSE;
 
 				// Keep track if any non-idle worker has targets.
-				if ( wkr->TargetCount() )
+				if (wkr->TargetCount())
 					nonidle_worker_with_targets = TRUE;
 			}
 		}
@@ -1131,18 +968,15 @@
 
 	// Verify that at least one worker has targets assigned with a
 	// non-idle spec or all specs are idle.
-	if ( !all_workers_idle && !nonidle_worker_with_targets )
-	{
-		ErrorMessage( "If no worker has targets selected, then all workers "
-			"must have the idle spec assigned." );
+	if (!all_workers_idle && !nonidle_worker_with_targets) {
+		ErrorMessage("If no worker has targets selected, then all workers "
+			     "must have the idle spec assigned.");
 		return TRUE;
 	}
 
 	return FALSE;
 }
 
-
-
 //
 // Assigns the default access specs to the workers based on their type.
 //
@@ -1150,42 +984,38 @@
 {
 	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-	{
-		GetManager( i )->AssignDefaultAccessSpecs();
+	for (i = 0; i < mgr_count; i++) {
+		GetManager(i)->AssignDefaultAccessSpecs();
 	}
 }
 
-
-
 //
 // Remove all instances of an access spec from all the managers'
 // workers' access spec lists.
 //
-void ManagerList::RemoveAccessSpec( Test_Spec *spec )
+void ManagerList::RemoveAccessSpec(Test_Spec * spec)
 {
 	int manager_count = ManagerCount();
-	for ( int i = 0; i < manager_count; i++ )
-		GetManager( i )->RemoveAccessSpec( spec );
+
+	for (int i = 0; i < manager_count; i++)
+		GetManager(i)->RemoveAccessSpec(spec);
 }
 
-
-
 //
 // Remove a specific instance of an access spec from all the managers'
 // workers' access spec lists (only if they are all the same).
 //
-void ManagerList::RemoveAccessSpecAt( int index )
+void ManagerList::RemoveAccessSpecAt(int index)
 {
-	if ( !AreAccessSpecsIdentical() )
+	if (!AreAccessSpecsIdentical())
 		return;
 
 	int manager_count = ManagerCount();
-	for ( int i = 0; i < manager_count; i++ )
-		GetManager( i )->RemoveAccessSpecAt( index );
+
+	for (int i = 0; i < manager_count; i++)
+		GetManager(i)->RemoveAccessSpecAt(index);
 }
 
-
 //
 // Remove all entries from all the managers'
 // workers' access spec lists.
@@ -1194,44 +1024,37 @@
 {
 	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i )->RemoveAllAccessSpecs();
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i)->RemoveAllAccessSpecs();
 }
 
-
-
 //
 // Adds spec[index] from global access spec list
 // to all the manager's workers at position 'before_index'.
 //
-BOOL ManagerList::InsertAccessSpec( Test_Spec* spec, int before_index )
+BOOL ManagerList::InsertAccessSpec(Test_Spec * spec, int before_index)
 {
 	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-	{
-		if ( !GetManager( i )->InsertAccessSpec( spec, before_index ) )
+	for (i = 0; i < mgr_count; i++) {
+		if (!GetManager(i)->InsertAccessSpec(spec, before_index))
 			return FALSE;
 	}
 	return TRUE;
 }
 
-
-
 //
 // Moves the entry at position [index] to [before_index] in the 
 // workers' access spec list to all the manager's workers.
 //
-void ManagerList::MoveAccessSpec( int index, int before_index )
+void ManagerList::MoveAccessSpec(int index, int before_index)
 {
 	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-		GetManager( i )->MoveAccessSpec( index, before_index );
+	for (i = 0; i < mgr_count; i++)
+		GetManager(i)->MoveAccessSpec(index, before_index);
 }
 
-
-
 //
 // Returns TRUE if any manager will be active for the current test.
 //
@@ -1239,125 +1062,108 @@
 {
 	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-	{
-		if ( GetManager( i )->ActiveInCurrentTest() )
+	for (i = 0; i < mgr_count; i++) {
+		if (GetManager(i)->ActiveInCurrentTest())
 			return TRUE;
 	}
 	return FALSE;
 }
 
-
-
 //
 // Returns TRUE if any worker has an access spec assigned for the current
 // access index and the spec is not the Idle spec.
 //
 BOOL ManagerList::HasActiveCurrentSpec()
 {
-	int	i, mgr_count = ManagerCount();
+	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-	{
-		if ( GetManager( i )->HasActiveCurrentSpec() )
+	for (i = 0; i < mgr_count; i++) {
+		if (GetManager(i)->HasActiveCurrentSpec())
 			return TRUE;
 	}
 	return FALSE;
 }
 
-
-
 //
 // Returns TRUE if any of the manager's workers has an idle spec assigned
 // at the current access spec index.
 //
 BOOL ManagerList::HasIdleCurrentSpec()
 {
-	int	i, mgr_count = ManagerCount();
+	int i, mgr_count = ManagerCount();
 
-	for ( i = 0; i < mgr_count; i++ )
-	{
-		if ( GetManager( i )->HasIdleCurrentSpec() )
+	for (i = 0; i < mgr_count; i++) {
+		if (GetManager(i)->HasIdleCurrentSpec())
 			return TRUE;
 	}
 	return FALSE;
 }
 
-
-
 //
 // Returns TRUE if all of the workers (on all managers) have
 // the same access specification list.
 //
 BOOL ManagerList::AreAccessSpecsIdentical()
 {
-	int		m, w, s, wkr_count, mgr_count, spec_count;
-	Worker	*compare_worker, *current_worker;
-	Manager	*mgr;
+	int m, w, s, wkr_count, mgr_count, spec_count;
+	Worker *compare_worker, *current_worker;
+	Manager *mgr;
 
 	// Get the first non-client worker for any manager.
 	mgr_count = ManagerCount();
-	for ( m = 0; m < mgr_count; m++ )
-	{
-		mgr = GetManager( m );
+	for (m = 0; m < mgr_count; m++) {
+		mgr = GetManager(m);
 		wkr_count = mgr->WorkerCount();
 
 		// Find the first non-client worker for this manager.
-		for ( w = 0; w < wkr_count; w++ )
-		{
-			compare_worker = mgr->GetWorker( w );
+		for (w = 0; w < wkr_count; w++) {
+			compare_worker = mgr->GetWorker(w);
 
-			if ( !IsType( compare_worker->Type(), GenericClientType ) )
-			{
+			if (!IsType(compare_worker->Type(), GenericClientType)) {
 				spec_count = compare_worker->AccessSpecCount();
 				break;
 			}
 		}
 
 		// See if we found a valid worker for this manager
-		if ( w < wkr_count )
+		if (w < wkr_count)
 			break;
 	}
 
 	// Did we find a worker to compare against?
-	if ( m == mgr_count )
+	if (m == mgr_count)
 		return TRUE;
 
 	// Compare the first worker's Test_Spec to each other worker's Test_Spec.
 	// Include the manager with the worker being compared with in our testing.
-	for ( m; m < mgr_count; m++ )
-	{
-		mgr = GetManager( m );
+	for (m; m < mgr_count; m++) {
+		mgr = GetManager(m);
 		wkr_count = mgr->WorkerCount();
 
 		// Only compare against non-client workers.
-		for ( w = 0; w < wkr_count; w++ )
-		{
-			current_worker = mgr->GetWorker( w );
+		for (w = 0; w < wkr_count; w++) {
+			current_worker = mgr->GetWorker(w);
 
 			// Skip network clients.
-			if ( IsType( current_worker->Type(), GenericClientType ) )
+			if (IsType(current_worker->Type(), GenericClientType))
 				continue;
 
 			// If this worker doesn't have the same number of access specs, return FALSE.
-			if ( current_worker->AccessSpecCount() != spec_count )
+			if (current_worker->AccessSpecCount() != spec_count)
 				return FALSE;
 
 			// Check to make sure each returned Test_Spec pointer is identical to (and in the
 			// same order as) the pointer in the first_worker.
-			for ( s = 0; s < spec_count; s++ )
-			{
-				if ( current_worker->GetAccessSpec(s) != compare_worker->GetAccessSpec(s) )
+			for (s = 0; s < spec_count; s++) {
+				if (current_worker->GetAccessSpec(s) != compare_worker->GetAccessSpec(s))
 					return FALSE;
 			}
 		}
 	}
-	
+
 	return TRUE;
 }
 
-
-
 //
 // Sees whether all managers have the same access spec assigned at index spec_index.
 // Returns a pointer to the name of the spec if all managers have the same one assigned.
@@ -1366,30 +1172,25 @@
 // Calling function supplies pointer to a char[MAX_WORKER_NAME].
 // This same pointer is returned for convenience.
 //
-char* ManagerList::GetCommonAccessSpec( int spec_index, char * const specname )
+char *ManagerList::GetCommonAccessSpec(int spec_index, char *const specname)
 {
 	char compare_string[MAX_WORKER_NAME];
 
 	// Return null string if there are no managers.
-	if ( ManagerCount() == 0 )
-	{
+	if (ManagerCount() == 0) {
 		specname[0] = '\0';
 		return specname;
 	}
-
 	// Find the first manager with workers.
-	for ( int manager_index = 0; manager_index < ManagerCount(); manager_index++ )
-	{
-		if ( GetManager( manager_index )->WorkerCount() )
-		{
+	for (int manager_index = 0; manager_index < ManagerCount(); manager_index++) {
+		if (GetManager(manager_index)->WorkerCount()) {
 			// Store that manager's access spec name.
-			GetManager( manager_index )->GetCommonAccessSpec( spec_index, specname );
+			GetManager(manager_index)->GetCommonAccessSpec(spec_index, specname);
 			break;
 		}
 	}
 
-	if ( manager_index >= ManagerCount() )
-	{
+	if (manager_index >= ManagerCount()) {
 		// Return a null string if no managers have workers.
 		specname[0] = '\0';
 		return specname;
@@ -1398,14 +1199,11 @@
 	manager_index++;
 
 	// Compare the first manager's spec name to each other manager's spec name.
-	while ( manager_index < ManagerCount() )
-	{
+	while (manager_index < ManagerCount()) {
 		// Return a null string if this manager's spec is different from the first manager's.
 		// (Ignore this manager if it doesn't have any workers.)
-		if ( GetManager( manager_index )->WorkerCount()
-				&& strcmp( GetManager( manager_index )->GetCommonAccessSpec( spec_index, compare_string ),
-						specname ) )
-		{
+		if (GetManager(manager_index)->WorkerCount()
+		    && strcmp(GetManager(manager_index)->GetCommonAccessSpec(spec_index, compare_string), specname)) {
 			specname[0] = '\0';
 			return specname;
 		}
@@ -1416,21 +1214,18 @@
 	return specname;
 }
 
-
-
 //
 // Save the manager/worker configuration to the specified stream.
-//		save_aspecs --> should each worker's access spec assignments be saved?
-//		save_targets --> should each worker's target assignments be saved?
+//              save_aspecs --> should each worker's access spec assignments be saved?
+//              save_targets --> should each worker's target assignments be saved?
 //
-BOOL ManagerList::SaveConfig(ostream& outfile, BOOL save_aspecs, BOOL save_targets)
+BOOL ManagerList::SaveConfig(ostream & outfile, BOOL save_aspecs, BOOL save_targets)
 {
 	int mgr_count = ManagerCount();
 
-	outfile << "'MANAGER LIST =========================="
-			   "========================================" << endl;
+	outfile << "'MANAGER LIST ==========================" "========================================" << endl;
 
-	for (int counter=0; counter<mgr_count; counter++)
+	for (int counter = 0; counter < mgr_count; counter++)
 		if (!GetManager(counter)->SaveConfig(outfile, save_aspecs, save_targets))
 			return FALSE;	// error saving data - propagate back
 
@@ -1439,57 +1234,52 @@
 	return TRUE;
 }
 
-
-
 //
 // This first pass through the load file maps saved managers to the managers
 // currently running in Iometer.  Any managers that aren't found in Iometer
 // are added to the "waiting list".
 //
-BOOL ManagerList::LoadConfigPreprocess(	const CString& infilename,
-										BOOL* flags,
-										BOOL replace )
+BOOL ManagerList::LoadConfigPreprocess(const CString & infilename, BOOL * flags, BOOL replace)
 {
 	ICF_ifstream infileForCount(infilename);
 	CString key, value;
 	CString mgr_name, mgr_network;
 	int mgr_id, counter;
 	Manager *mgr;
-	CArray<BOOL, int> mgr_flag;
+	CArray < BOOL, int >mgr_flag;
 	int mgr_count = ManagerCount();
 
 	// Set the array size, initialize to FALSE.
-	for (counter=0; counter<mgr_count; counter++)
+	for (counter = 0; counter < mgr_count; counter++)
 		mgr_flag.Add(FALSE);
 
 	// Skip into the MANAGER LIST section.
 	// If it can't find it, return TRUE.  (This is okay.)
-	if ( !infileForCount.SkipTo("'MANAGER LIST") )
+	if (!infileForCount.SkipTo("'MANAGER LIST"))
 		return TRUE;
 
 	//Count the # of managers in the .icf file being processed.
-	int	icfManagerCount = 0;
-	while ( infileForCount.SkipTo("'Manager ID, manager name") )
-	{
+	int icfManagerCount = 0;
+
+	while (infileForCount.SkipTo("'Manager ID, manager name")) {
 		// Read the manager info from the config file.
-		if ( !GetManagerInfo( infileForCount, mgr_name, mgr_id, mgr_network ) )
+		if (!GetManagerInfo(infileForCount, mgr_name, mgr_id, mgr_network))
 			return FALSE;
 		icfManagerCount++;
 	}
 
 	// "Rewind" the .icf file and re-position to start of "MANAGER LIST" section.
 	ICF_ifstream infile(infilename);
+
 	infile.SkipTo("'MANAGER LIST");
-	
-	while ( infile.SkipTo("'Manager ID, manager name") )
-	{
+
+	while (infile.SkipTo("'Manager ID, manager name")) {
 		// Read the manager info from the config file.
-		if ( !GetManagerInfo( infile, mgr_name, mgr_id, mgr_network ) )
+		if (!GetManagerInfo(infile, mgr_name, mgr_id, mgr_network))
 			return FALSE;
 
 		// Identify the first unused manager matching these specs
-		for (counter=0; counter<mgr_count; counter++)
-		{
+		for (counter = 0; counter < mgr_count; counter++) {
 			// For a saved manager's settings to be restored, a manager by the
 			// same name, connecting to Iometer via the same network address,
 			// must be currently available in Iometer.
@@ -1498,10 +1288,8 @@
 			// same names.
 
 			mgr = GetManager(counter);
-			if ( mgr_name.CompareNoCase(mgr->name) == 0
-				&& mgr_network.CompareNoCase(mgr->network_name) == 0
-				&& !mgr_flag[counter] )
-			{
+			if (mgr_name.CompareNoCase(mgr->name) == 0
+			    && mgr_network.CompareNoCase(mgr->network_name) == 0 && !mgr_flag[counter]) {
 				mgr_flag[counter] = TRUE;	// mark this off
 				loadmap.Store(mgr_name, mgr_id, mgr_network, mgr);
 				break;
@@ -1509,10 +1297,8 @@
 		}
 
 		// Did we go past the end without a match?
-		if (counter >= mgr_count)
-		{
-			if ( mgr_count == 0 && icfManagerCount == 1 )
-			{
+		if (counter >= mgr_count) {
+			if (mgr_count == 0 && icfManagerCount == 1) {
 				// Special case:  No managers logged in, and exactly one in the file.
 				// Create a special entry with a null address and a special local
 				// manager name.  This special entry is used to identify the need to
@@ -1520,9 +1306,7 @@
 				// match against a local manager in ManagerMap::ManagerLoggedIn() and
 				// ManagerMap::ManagerRetrieve().
 				loadmap.Store(HOSTNAME_LOCAL, 1, "", NULL);
-			}
-			else
-			{
+			} else {
 				// Store an incomplete entry (NULL mgr ptr) in the manager map.
 				// This will put the load operation in a waiting state.
 				loadmap.Store(mgr_name, mgr_id, mgr_network, NULL);
@@ -1534,29 +1318,26 @@
 
 	// If there is exactly one manager in Iometer and one manager
 	// in the ManagerMap, they should be mapped together.
-	if ( mgr_count == 1 && mgr_flag[0] == FALSE )
-	{
+	if (mgr_count == 1 && mgr_flag[0] == FALSE) {
 		mgr = GetManager(0);
 
 		// "SetIfOneManager" means "if there is one manager in the
 		//   load map and it is unassigned, assign it this pointer"
 		loadmap.SetIfOneManager(mgr);
 	}
-
 	// Spawn any local managers that are missing.
 	loadmap.SpawnLocalManagers();
 
 	return TRUE;
 }
 
-
 //
 // Restore the manager/worker configuration from the specified filename.
-//		load_aspecs --> should each worker's access spec assignments be loaded?
-//		load_targets --> should each worker's target assignments be loaded?
-//		replace --> should these settings...
-//						...overwrite the current worker settings (TRUE)
-//						...or be merged with current worker settings (FALSE)
+//              load_aspecs --> should each worker's access spec assignments be loaded?
+//              load_targets --> should each worker's target assignments be loaded?
+//              replace --> should these settings...
+//                                              ...overwrite the current worker settings (TRUE)
+//                                              ...or be merged with current worker settings (FALSE)
 //
 // Returns TRUE on success, FALSE if any of the requested information
 // couldn't be found in the file.
@@ -1564,7 +1345,7 @@
 // If replace is TRUE, it also removes managers that weren't affected by the
 // file restore (those that weren't specified in the config file).
 //
-BOOL ManagerList::LoadConfig(const CString& infilename, BOOL load_aspecs, BOOL load_targets, BOOL replace)
+BOOL ManagerList::LoadConfig(const CString & infilename, BOOL load_aspecs, BOOL load_targets, BOOL replace)
 {
 	ICF_ifstream infile;
 	long version;
@@ -1580,59 +1361,49 @@
 
 	// Skip into the MANAGER LIST section.
 	// If it can't find it, return TRUE.  (This is okay.)
-	if ( !infile.SkipTo("'MANAGER LIST") )
+	if (!infile.SkipTo("'MANAGER LIST"))
 		return TRUE;
 
 	mgr_count = ManagerCount();
 
 	// If we're replacing everything, go through each
 	// of the managers and remove all of its workers.
-	if ( replace )
-	{
-		for (counter=0; counter<mgr_count; counter++)
-		{
-			mgr = GetManager( counter );
+	if (replace) {
+		for (counter = 0; counter < mgr_count; counter++) {
+			mgr = GetManager(counter);
 
-			while ( mgr->WorkerCount() )
-				theApp.pView->m_pWorkerView->RemoveWorker( mgr->GetWorker(0) );
+			while (mgr->WorkerCount())
+				theApp.pView->m_pWorkerView->RemoveWorker(mgr->GetWorker(0));
 		}
 	}
 
-	while (1)
-	{
+	while (1) {
 		key = infile.GetNextLine();
 
-		if ( key.CompareNoCase("'END manager list") == 0 )
-		{
+		if (key.CompareNoCase("'END manager list") == 0) {
 			break;
-		}
-		else if ( key.CompareNoCase("'Manager ID, manager name") == 0 )
-		{
+		} else if (key.CompareNoCase("'Manager ID, manager name") == 0) {
 			CString mgr_name, mgr_netaddr;
 			int mgr_id;
 
 			// Read the manager info from the config file.
-			if ( !GetManagerInfo( infile, mgr_name, mgr_id, mgr_netaddr ) )
+			if (!GetManagerInfo(infile, mgr_name, mgr_id, mgr_netaddr))
 				return FALSE;
 
 			// Gets the pointer to the specified manager from the ManagerMap.
 			mgr = loadmap.Retrieve(mgr_name, mgr_id);
 
-			if (mgr == NULL)
-			{
+			if (mgr == NULL) {
 				ErrorMessage("Manager could not be found in the ManagerMap.  "
-					"Please report this as an Iometer bug.");
+					     "Please report this as an Iometer bug.");
 				return FALSE;
 			}
-
 			// Load the manager.
-			if ( !mgr->LoadConfig(infile, load_aspecs, load_targets) )
+			if (!mgr->LoadConfig(infile, load_aspecs, load_targets))
 				return FALSE;
-		}
-		else
-		{
+		} else {
 			ErrorMessage("File is improperly formatted.  Expected another "
-				"manager or \"End manager list\" comment.");
+				     "manager or \"End manager list\" comment.");
 			return FALSE;
 		}
 	}
@@ -1640,19 +1411,16 @@
 	infile.close();
 
 	// If a manager connected to Iometer wasn't mentioned in the config file, remove it.
-	if ( replace )
-	{
-		for (counter=mgr_count-1; counter>=0; counter--)
-		{
-			if ( !theApp.manager_list.loadmap.IsThisManagerNeeded( GetManager(counter) ) )
-				theApp.pView->m_pWorkerView->RemoveManager( GetManager(counter) );
+	if (replace) {
+		for (counter = mgr_count - 1; counter >= 0; counter--) {
+			if (!theApp.manager_list.loadmap.IsThisManagerNeeded(GetManager(counter)))
+				theApp.pView->m_pWorkerView->RemoveManager(GetManager(counter));
 		}
 	}
 
 	return TRUE;
 }
 
-
 //
 // Disambiguate same-named managers.  This allows managers
 // to be uniquely identified in saved files and other places.
@@ -1664,17 +1432,14 @@
 	int count_up, count_down;
 	const int mgr_count = ManagerCount();
 
-	for (count_up=0; count_up<mgr_count; count_up++)
-	{
+	for (count_up = 0; count_up < mgr_count; count_up++) {
 		mgr = GetManager(count_up);
 		mgr->id = 1;	// Assume this is unique, unless proven otherwise.
 
-		for (count_down=count_up-1; count_down>=0; count_down--)
-		{
+		for (count_down = count_up - 1; count_down >= 0; count_down--) {
 			othermgr = GetManager(count_down);
 
-			if ( CString(mgr->name).CompareNoCase(othermgr->name) == 0 )
-			{
+			if (CString(mgr->name).CompareNoCase(othermgr->name) == 0) {
 				// If the managers' names are identical, assign
 				// this manager an ID value one greater.
 				mgr->id = othermgr->id + 1;
@@ -1684,7 +1449,6 @@
 	}
 }
 
-
 //
 // Retrieves the manager name, network address, and discriminator value from an
 // the infile.  Expects the file pointer to be immediately after the newline
@@ -1693,41 +1457,34 @@
 // Return value of FALSE indicates an error.  The calling function
 // should NOT report an error.  Error reporting is handled here.
 //
-BOOL ManagerList::GetManagerInfo(	ICF_ifstream& infile, CString& manager_name,
-									int& id, CString& network_name )
+BOOL ManagerList::GetManagerInfo(ICF_ifstream & infile, CString & manager_name, int &id, CString & network_name)
 {
 	CString key = "";
 	CString value = "";
 
 	value = infile.GetNextLine();
 
-	if ( value.IsEmpty() )
-	{
-		ErrorMessage("File is improperly formatted.  "
-			"Error retrieving manager name or empty manager name.");
+	if (value.IsEmpty()) {
+		ErrorMessage("File is improperly formatted.  " "Error retrieving manager name or empty manager name.");
 		return FALSE;
 	}
 
-	if ( !ICF_ifstream::ExtractFirstInt(value, id) )
-	{
+	if (!ICF_ifstream::ExtractFirstInt(value, id)) {
 		ErrorMessage("File is improperly formatted.  "
-			"Error retrieving manager ID.  This value must be an integer.");
+			     "Error retrieving manager ID.  This value must be an integer.");
 		return FALSE;
 	}
 
 	manager_name = value;
 
-	if ( !infile.GetPair(key, value) )
-	{
-		ErrorMessage("File is improperly formatted.  "
-			"Error retrieving manager network address.");
+	if (!infile.GetPair(key, value)) {
+		ErrorMessage("File is improperly formatted.  " "Error retrieving manager network address.");
 		return FALSE;
 	}
 
-	if ( key.CompareNoCase("'Manager network address") != 0 )
-	{
+	if (key.CompareNoCase("'Manager network address") != 0) {
 		ErrorMessage("File is improperly formatted.  Expected a \"Manager network "
-			"address\" comment after manager ID.");
+			     "address\" comment after manager ID.");
 		return FALSE;
 	}
 

Modified: branches/IOMETER-restruct/iometer/src/ManagerList.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/ManagerList.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ManagerList.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -75,160 +75,144 @@
 #ifndef MANAGER_LIST_DEFINED
 #define MANAGER_LIST_DEFINED
 
-
 #include "IOCommon.h"
 #include "Manager.h"
 #include "ManagerMap.h"
 #include "WaitingForManagers.h"
 
-
 // Class information for a list of managers.
-class	ManagerList
-{
-public:
+class ManagerList {
+      public:
 	ManagerList();
 	~ManagerList();
-	void		Reset();
+	void Reset();
 
 	///////////////////////////////////////////////////////////////////////////
 	// Information about the manager list instance.
 	//
-	char		name[MAX_WORKER_NAME];		// Displayable name of list.
+	char name[MAX_WORKER_NAME];	// Displayable name of list.
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Managing list of managers.
 	//
-	Manager*	GetManager( int index, TargetType type = GenericType );
-	Manager*	GetManagerByName( const char *mgr_name, const int mgr_id );
+	Manager *GetManager(int index, TargetType type = GenericType);
+	Manager *GetManagerByName(const char *mgr_name, const int mgr_id);
 	//
 	// Updating worker information.
-	Manager*	AddManager( Manager_Info *manager_info );
-	BOOL		RemoveManager( int index, int purpose = EXIT );
-	void		RemoveAllManagers( int purpose = EXIT );
+	Manager *AddManager(Manager_Info * manager_info);
+	BOOL RemoveManager(int index, int purpose = EXIT);
+	void RemoveAllManagers(int purpose = EXIT);
 	//
-	int			TargetCount( TargetType type = GenericType );
-	int			WorkerCount( TargetType type = GenericType );
-	int			ManagerCount( TargetType type = GenericType );
+	int TargetCount(TargetType type = GenericType);
+	int WorkerCount(TargetType type = GenericType);
+	int ManagerCount(TargetType type = GenericType);
 	//
 	// Disambiguate same-named managers.  This allows managers
 	// to be uniquely identified in saved files and other places.
 	// This should be called any time managers are added, removed, or renamed.
-	void		IndexManagers();
+	void IndexManagers();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Managing targets of manager's workers.
-	void		ClearActiveTargets();
-	BOOL		SetTargets();
+	void ClearActiveTargets();
+	BOOL SetTargets();
 	//
-	BOOL		ActiveInCurrentTest();
-	BOOL		HasActiveCurrentSpec();
-	BOOL		HasIdleCurrentSpec();
+	BOOL ActiveInCurrentTest();
+	BOOL HasActiveCurrentSpec();
+	BOOL HasIdleCurrentSpec();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Managing communication with corresponding Dynamos.
-	void		SendManagers( Message* msg, int recipient = MANAGER );
-	void		SendManagers( int purpose, int recipient = MANAGER );
-	DWORDLONG	Send( int manager_index, int purpose, int recipient = MANAGER );
-	DWORDLONG	Send( int manager_index, Message* msg, int recipient = MANAGER );
-	BOOL		SendActiveManagers( int purpose );
-	DWORDLONG	ReceiveManager( int index, Message* msg );
-	void		ReceiveManagers();
+	void SendManagers(Message * msg, int recipient = MANAGER);
+	void SendManagers(int purpose, int recipient = MANAGER);
+	DWORDLONG Send(int manager_index, int purpose, int recipient = MANAGER);
+	DWORDLONG Send(int manager_index, Message * msg, int recipient = MANAGER);
+	BOOL SendActiveManagers(int purpose);
+	DWORDLONG ReceiveManager(int index, Message * msg);
+	void ReceiveManagers();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to set/retrieve worker target information
-	int			GetConnectionRate( TargetType type );
-	int			GetDiskStart( TargetType type );
-	int			GetDiskSize( TargetType type );
-	int			GetQueueDepth( TargetType type );
-	int			GetMaxSends( TargetType type );
-	int			GetTransPerConn( TargetType type );
+	int GetConnectionRate(TargetType type);
+	int GetDiskStart(TargetType type);
+	int GetDiskSize(TargetType type);
+	int GetQueueDepth(TargetType type);
+	int GetMaxSends(TargetType type);
+	int GetTransPerConn(TargetType type);
 	//
-	void		SetConnectionRate( BOOL connection_rate, TargetType type );
-	void		SetDiskSize( int disk_size );
-	void		SetDiskStart( int disk_start );
-	void		SetQueueDepth( int queue_size, TargetType type );
-	void		SetMaxSends( int max_sends );
-	void		SetTransPerConn( int trans_per_conn, TargetType type );
+	void SetConnectionRate(BOOL connection_rate, TargetType type);
+	void SetDiskSize(int disk_size);
+	void SetDiskStart(int disk_start);
+	void SetQueueDepth(int queue_size, TargetType type);
+	void SetMaxSends(int max_sends);
+	void SetTransPerConn(int trans_per_conn, TargetType type);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to deal with access specs.
 	//
-	BOOL		InsertAccessSpec( Test_Spec* spec, int before_index );
-	void		RemoveAccessSpec( Test_Spec* spec );
-	void		RemoveAccessSpecAt( int index );
-	void		RemoveAllAccessSpecs();
+	BOOL InsertAccessSpec(Test_Spec * spec, int before_index);
+	void RemoveAccessSpec(Test_Spec * spec);
+	void RemoveAccessSpecAt(int index);
+	void RemoveAllAccessSpecs();
 	//
-	void		MoveAccessSpec( int index, int before_index );
-	void		DownAccessSpec( int index );
-	void		UpAccessSpec( int index );
+	void MoveAccessSpec(int index, int before_index);
+	void DownAccessSpec(int index);
+	void UpAccessSpec(int index);
 	//
-	BOOL		SetAccess( int spec_index );
-	BOOL		InvalidSetup( BOOL &invalidSpecOK );
-	int		GetMaxAccessSpecCount();
-	void		AssignDefaultAccessSpecs();
+	BOOL SetAccess(int spec_index);
+	BOOL InvalidSetup(BOOL & invalidSpecOK);
+	int GetMaxAccessSpecCount();
+	void AssignDefaultAccessSpecs();
 	//
 	// Returns TRUE if all of the workers (on all managers) have
 	// the same access specification list.
-	BOOL		AreAccessSpecsIdentical();
+	BOOL AreAccessSpecsIdentical();
 	//
 	// Gets the name of the current access spec for all workers.
-	char*		GetCommonAccessSpec( int spec_index, char * const specname );
+	char *GetCommonAccessSpec(int spec_index, char *const specname);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Results from a test.
 	//
 	// Functions to deal with results.
- 	void		ResetResults( int which_perf );
- 	void		ResetAllResults();
-	void		SaveResults( ostream* file, int access_index, int result_type );
-	void		UpdateResults( int which_perf );
+	void ResetResults(int which_perf);
+	void ResetAllResults();
+	void SaveResults(ostream * file, int access_index, int result_type);
+	void UpdateResults(int which_perf);
 	//
 	// Results for the last run test.
-	Results		results[MAX_PERF];
+	Results results[MAX_PERF];
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-	
 	///////////////////////////////////////////////////////////////////////////
 	// Saving and loading of Iometer Configuration Files (ICF's)
 	//
-	ManagerMap	loadmap;
-	BOOL		SaveConfig( ostream& outfile, BOOL save_aspecs, BOOL save_targets );
-	BOOL		LoadConfigPreprocess(	const CString& infilename,
-										BOOL* flags,
-										BOOL replace );
-	BOOL		LoadConfig(				const CString &infilename,
-										BOOL save_aspecs, BOOL save_targets,
-										BOOL replace );
-private:
-	BOOL		GetManagerInfo(	ICF_ifstream& infile, CString& manager_name,
-								int& id, CString& network_name );
+	ManagerMap loadmap;
+	BOOL SaveConfig(ostream & outfile, BOOL save_aspecs, BOOL save_targets);
+	BOOL LoadConfigPreprocess(const CString & infilename, BOOL * flags, BOOL replace);
+	BOOL LoadConfig(const CString & infilename, BOOL save_aspecs, BOOL save_targets, BOOL replace);
+      private:
+	 BOOL GetManagerInfo(ICF_ifstream & infile, CString & manager_name, int &id, CString & network_name);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
+      protected:
+	 BOOL CompareNames(char *net_name1, char *net_name2);
 
-protected:
-	BOOL		CompareNames( char* net_name1, char* net_name2 );
-
-	CTypedPtrArray<CPtrArray, Manager*>		managers;
+	 CTypedPtrArray < CPtrArray, Manager * >managers;
 };
 
 #endif

Modified: branches/IOMETER-restruct/iometer/src/ManagerMap.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/ManagerMap.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ManagerMap.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,12 +61,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "ManagerMap.h"
 #include "GalileoApp.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -77,20 +75,18 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 ManagerMap::ManagerMap()
 {
 	Reset();
 }
 
-
 //
 // Prepare the ManagerMap for reuse.
 //
@@ -100,7 +96,6 @@
 	waiting_dialog.Reset();
 }
 
-
 //
 // Add a manager to the list
 //
@@ -109,14 +104,11 @@
 // until ManagerLoggedIn is called with a valid pointer for that manager.
 // The manager will also be added to the waiting list if necessary.
 //
-void ManagerMap::Store(	const CString& name,
-						const int id,
-						const CString& address,
-						Manager *mgr	)
+void ManagerMap::Store(const CString & name, const int id, const CString & address, Manager * mgr)
 {
 	int new_index = map.GetSize();
 
-	map.SetSize( new_index + 1 );	// grow the array by one
+	map.SetSize(new_index + 1);	// grow the array by one
 
 	map[new_index].name = name;
 	map[new_index].id = id;
@@ -124,29 +116,25 @@
 	map[new_index].mgr = mgr;
 
 	// Add this manager to the waiting list if necessary.
-	if ( mgr == NULL )
-		waiting_dialog.AddWaitingManager( name, address );
+	if (mgr == NULL)
+		waiting_dialog.AddWaitingManager(name, address);
 }
 
-
 //
 // Retrieve a manager pointer matching the specified criteria
 //
 // NULL if no matching manager was found.
 //
-Manager* ManagerMap::Retrieve(	const CString& name,
-								const int id	)
+Manager *ManagerMap::Retrieve(const CString & name, const int id)
 {
 	int mapsize = map.GetSize();
 
 	// Make sure the ManagerMap isn't in a waiting list state (DEBUG only)
-	ASSERT( !IsWaitingList() );
+	ASSERT(!IsWaitingList());
 
-	for (int counter=0; counter<mapsize; counter++)
-	{
-		if ( (name.CompareNoCase(map[counter].name) == 0
-			 && id == map[counter].id )
-			|| ( map[counter].name == HOSTNAME_LOCAL ) ) // "special local host" case
+	for (int counter = 0; counter < mapsize; counter++) {
+		if ((name.CompareNoCase(map[counter].name) == 0 && id == map[counter].id)
+		    || (map[counter].name == HOSTNAME_LOCAL))	// "special local host" case
 		{
 			return map[counter].mgr;
 		}
@@ -155,7 +143,6 @@
 	return NULL;
 }
 
-
 //
 // When a manager logs in, call this function to find the first matching
 // entry in the map and store the new manager's pointer there.
@@ -163,28 +150,22 @@
 //
 // Returns FALSE if no matching manager could be found.
 //
-BOOL ManagerMap::ManagerLoggedIn(	const CString& name,
-									const CString& address,
-									Manager *mgr	)
+BOOL ManagerMap::ManagerLoggedIn(const CString & name, const CString & address, Manager * mgr)
 {
 	int mapsize = map.GetSize();
 
-	for (int counter=0; counter<mapsize; counter++)
-	{
+	for (int counter = 0; counter < mapsize; counter++) {
 		// If manager is unassigned (waiting) and all other criteria
 		// match, assign it the passed-in pointer.
-		if ( map[counter].mgr == NULL
-			&& 
-			( (name.CompareNoCase(map[counter].name) == 0
-			  && address.CompareNoCase(map[counter].address) == 0) )
-			||
-			( (map[counter].address == "") // "special local host" case
-			  && (map[counter].name.Compare(HOSTNAME_LOCAL) == 0 ) ) )
-		{
+		if (map[counter].mgr == NULL
+		    &&
+		    ((name.CompareNoCase(map[counter].name) == 0 && address.CompareNoCase(map[counter].address) == 0))
+		    || ((map[counter].address == "")	// "special local host" case
+			&& (map[counter].name.Compare(HOSTNAME_LOCAL) == 0))) {
 			map[counter].mgr = mgr;
 
 			// Remove this manager from the waiting list.
-			(void) waiting_dialog.RemoveWaitingManager( name, address );
+			(void)waiting_dialog.RemoveWaitingManager(name, address);
 
 			return TRUE;
 		}
@@ -193,13 +174,12 @@
 	return FALSE;
 }
 
-
 //
 // If there is only one manager in the ManagerMap and it is unassigned
 // (mgr pointer is NULL), assign it the given manager pointer, return TRUE.
 // Otherwise, return FALSE.
 //
-BOOL ManagerMap::SetIfOneManager( Manager *mgr )
+BOOL ManagerMap::SetIfOneManager(Manager * mgr)
 {
 	// Make sure there's exactly one manager in the map...
 	if (map.GetSize() != 1)
@@ -214,7 +194,6 @@
 	return TRUE;
 }
 
-
 //
 // Are we waiting for any managers to log in before restoring
 // the manager configuration from a saved file?
@@ -223,16 +202,14 @@
 {
 	int mapsize = map.GetSize();
 
-	for (int counter=0; counter<mapsize; counter++)
-	{
-		if ( map[counter].mgr == NULL )
+	for (int counter = 0; counter < mapsize; counter++) {
+		if (map[counter].mgr == NULL)
 			return TRUE;
 	}
 
 	return FALSE;
 }
 
-
 //
 // Use this function to determine whether to keep or remove a
 // manager when restoring manager settings from a config file.
@@ -240,20 +217,18 @@
 // ManagerMap, the manager is needed for restoring the config
 // file.  Otherwise, it should be removed.
 //
-BOOL ManagerMap::IsThisManagerNeeded( const Manager * const mgr )
+BOOL ManagerMap::IsThisManagerNeeded(const Manager * const mgr)
 {
 	int mapsize = map.GetSize();
 
-	for (int counter=0; counter<mapsize; counter++)
-	{
-		if ( map[counter].mgr == mgr )
+	for (int counter = 0; counter < mapsize; counter++) {
+		if (map[counter].mgr == mgr)
 			return TRUE;
 	}
 
 	return FALSE;
 }
 
-
 //
 // Find all unassigned managers (mgr ptrs are NULL) with the local
 // network address and spawn Dynamos with the appropriate names.
@@ -263,24 +238,19 @@
 	int mapsize = map.GetSize();
 
 	// Go through each manager entry in the map.
-	for (int counter=0; counter<mapsize; counter++)
-	{
+	for (int counter = 0; counter < mapsize; counter++) {
 		// If this manager's address is local and the manager is unassigned...
 
-		if ( map[counter].mgr == NULL
-			&& 
-			  (theApp.IsAddressLocal( map[counter].address )
-			||
-			( (map[counter].address == "") // "special local host" case
-			  && (map[counter].name.Compare(HOSTNAME_LOCAL) == 0 ) ) ) )
-		{
+		if (map[counter].mgr == NULL && (theApp.IsAddressLocal(map[counter].address)
+						 || ((map[counter].address == "")	// "special local host" case
+						     && (map[counter].name.Compare(HOSTNAME_LOCAL) == 0)))) {
 			// Get the local machine's NetBIOS/NT name.
 			// This can be done using CGalileoApp::IsAddressLocal, but that
 			// would match IP addresses as well, which is undesirable.
 			CString nt_name;
 			DWORD namelength = MAX_NETWORK_NAME;
 
-			::GetComputerName( nt_name.GetBuffer(MAX_NETWORK_NAME), &namelength );
+			::GetComputerName(nt_name.GetBuffer(MAX_NETWORK_NAME), &namelength);
 			nt_name.ReleaseBuffer();
 
 			// See if it is necessary to specify a name parameter for this manager.
@@ -292,27 +262,23 @@
 			// attempting a connection to Iometer if a name parameter is specified.
 			// The user will not see any incompatible version notice in this case.
 			// When possible, using the name parameter should be avoided for this reason.
-			if ( ( nt_name.CompareNoCase(map[counter].name) == 0 )
-				|| ( (map[counter].address == "") // "special local host" case
-					&& (map[counter].name.Compare(HOSTNAME_LOCAL) == 0 ) ) )
-			{
+			if ((nt_name.CompareNoCase(map[counter].name) == 0)
+			    || ((map[counter].address == "")	// "special local host" case
+				&& (map[counter].name.Compare(HOSTNAME_LOCAL) == 0))) {
 				// Spawn a Dynamo with the default name (the machine's name).
 				theApp.LaunchDynamo();
-			}
-			else
-			{
+			} else {
 				// Spawn a Dynamo with the appropriate name parameter.
-				theApp.LaunchDynamo( " /n " + map[counter].name );
+				theApp.LaunchDynamo(" /n " + map[counter].name);
 			}
 		}
 	}
 }
 
-
 //
 // Show the waiting list dialog box, return immediately.
 //
-void ManagerMap::ShowWaitingList( const CString& infilename, BOOL* flags, BOOL replace )
+void ManagerMap::ShowWaitingList(const CString & infilename, BOOL * flags, BOOL replace)
 {
-	waiting_dialog.Create( infilename, flags, replace );	
+	waiting_dialog.Create(infilename, flags, replace);
 }

Modified: branches/IOMETER-restruct/iometer/src/ManagerMap.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/ManagerMap.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ManagerMap.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -67,68 +67,57 @@
 #ifndef MANAGERMAP_DEFINED
 #define MANAGERMAP_DEFINED
 
-
 #include "Manager.h"
 #include "WaitingForManagers.h"
 
-
-struct ManagerMapEntry
-{
+struct ManagerMapEntry {
 	CString name;
 	int id;
 	CString address;
 	Manager *mgr;
 };
 
+class ManagerMap {
+      private:
+	CArray < ManagerMapEntry, int >map;
+	CWaitingForManagers waiting_dialog;
 
-class ManagerMap
-{
-private:
-	CArray<ManagerMapEntry, int>	map;
-	CWaitingForManagers				waiting_dialog;
+      public:
+	 ManagerMap();
 
-public:
-	ManagerMap();
-
 	// Prepares the ManagerMap for reuse.
-	void		Reset();
+	void Reset();
 
 	// Add a manager to the list.  (mgr pointer, if unknown, can be NULL)
-	void		Store(				const CString& name,
-									const int id,
-									const CString& address,
-									Manager *mgr	);
+	void Store(const CString & name, const int id, const CString & address, Manager * mgr);
 
 	// Retrieve a manager pointer matching the specified criteria
-	Manager*	Retrieve(			const CString& name,
-									const int id	);
+	Manager *Retrieve(const CString & name, const int id);
 
 	// When a manager logs in, call this function to find the first matching
 	// entry in the map and store the new manager's pointer there.
-	BOOL		ManagerLoggedIn(	const CString& name,
-									const CString& address,
-									Manager *mgr	);
+	BOOL ManagerLoggedIn(const CString & name, const CString & address, Manager * mgr);
 
 	// If there is only one manager in the ManagerMap and it is unassigned
 	// (mgr pointer is NULL), assign it the given manager pointer, return TRUE.
 	// Otherwise, return FALSE.  (Yes, awkward name...)
-	BOOL		SetIfOneManager( Manager *mgr );
+	BOOL SetIfOneManager(Manager * mgr);
 
 	// Find all unassigned managers (mgr ptrs are NULL) with the local
 	// network address and spawn Dynamos with the appropriate names.
-	void		SpawnLocalManagers();
+	void SpawnLocalManagers();
 
 	// Are we waiting for any managers to log in before restoring
 	// the manager configuration from a saved file?
-	BOOL		IsWaitingList();
+	BOOL IsWaitingList();
 
 	// Show the waiting list dialog box, return immediately.
-	void		ShowWaitingList( const CString& infilename, BOOL* flags, BOOL replace );
+	void ShowWaitingList(const CString & infilename, BOOL * flags, BOOL replace);
 
 	// See the manager at this address is found in the manager map.  Used to
 	// determine whether this manager should be kept (TRUE) or disconnected
 	// (FALSE) after the config file manager settings are restored.
-	BOOL		IsThisManagerNeeded( const Manager * const mgr );
+	BOOL IsThisManagerNeeded(const Manager * const mgr);
 };
 
 #endif

Modified: branches/IOMETER-restruct/iometer/src/MeterCtrl.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/MeterCtrl.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/MeterCtrl.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -65,13 +65,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include <math.h>
 #include "stdafx.h"
 #include "MeterCtrl.h"
 #include "TextDisplay.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -82,29 +80,24 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 #define	PI				3.14159265
 
-
-IMPLEMENT_DYNAMIC( CMeterCtrl, CWnd )
-
+IMPLEMENT_DYNAMIC(CMeterCtrl, CWnd)
 // Message mapping
-BEGIN_MESSAGE_MAP( CMeterCtrl, CWnd )
-	//{{AFX_MSG_MAP(CMeterCtrl)
-	ON_WM_PAINT()
-	ON_WM_CREATE()
-	//}}AFX_MSG_MAP
-END_MESSAGE_MAP()
+    BEGIN_MESSAGE_MAP(CMeterCtrl, CWnd)
+    //{{AFX_MSG_MAP(CMeterCtrl)
+    ON_WM_PAINT()
+    ON_WM_CREATE()
+    //}}AFX_MSG_MAP
+    END_MESSAGE_MAP()
 
-
-
 // Static member initialization
 // (This verifies that the "meter" window class is registered before CMeterCtrl is used.)
 BOOL CMeterCtrl::is_registered = Register();
@@ -113,7 +106,6 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-
 CMeterCtrl::CMeterCtrl()
 {
 	// Initialize the meter.
@@ -128,26 +120,24 @@
 	show_watermark = FALSE;
 }
 
-
-
 //
 // Handles WM_CREATE message (Window is being created)
 //
-int CMeterCtrl::OnCreate( LPCREATESTRUCT lpCreateStruct )
+int CMeterCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
 {
-	CRect	control_box;
-	POINT	temp_point;
+	CRect control_box;
+	POINT temp_point;
 
 	// Allow the framework to create the window
-	VERIFY( CWnd::OnCreate( lpCreateStruct ) == 0 );
+	VERIFY(CWnd::OnCreate(lpCreateStruct) == 0);
 
 	// Store the control's client area rectangle
-	GetClientRect( &control_box );
+	GetClientRect(&control_box);
 
 	// Determine where the pivot point should be located.
 	// Get the length of the longest radius that will fit inside the box.
-	outer_radius = (int)min( control_box.Width() / 2, control_box.Height() 
-		/ ( 1 + cos( PIVOT_ARC_ANGLE * PI / 180 ) ));
+	outer_radius = (int)min(control_box.Width() / 2, control_box.Height()
+				/ (1 + cos(PIVOT_ARC_ANGLE * PI / 180)));
 	inner_radius = (int)(outer_radius * .70);
 	pivot_point.x = (int)(control_box.Width() / 2);
 	pivot_point.y = outer_radius;
@@ -160,13 +150,12 @@
 
 	// Initialize the needle's center pivot circle.
 	pivot_radius = inner_radius / 12;
-	needle_pivot.SetRect( pivot_point.x - pivot_radius,
-		pivot_point.y - pivot_radius, pivot_point.x + pivot_radius,
-		pivot_point.y + pivot_radius );
+	needle_pivot.SetRect(pivot_point.x - pivot_radius,
+			     pivot_point.y - pivot_radius, pivot_point.x + pivot_radius, pivot_point.y + pivot_radius);
 
 	// Set the points for the bounding pie wedge.
-	CalculatePoint( 0, inner_radius, &(min_point.x), &(min_point.y) );
-	max_point.x = pivot_point.x + ( pivot_point.x - min_point.x );
+	CalculatePoint(0, inner_radius, &(min_point.x), &(min_point.y));
+	max_point.x = pivot_point.x + (pivot_point.x - min_point.x);
 	max_point.y = min_point.y;
 
 	// Now set the needle to the resting position.
@@ -175,19 +164,18 @@
 	SetNeedlePoints();
 
 	// Create the text box for the scale display.
-	CalculatePoint( 0, inner_radius, &scale_box.right, &temp_point.y );
-	CalculatePoint( 0, outer_radius, &temp_point.x, &scale_box.bottom );
-	CalculatePoint( NEEDLE_SWEEP, inner_radius, &scale_box.left,
-		&scale_box.top );
-	
+	CalculatePoint(0, inner_radius, &scale_box.right, &temp_point.y);
+	CalculatePoint(0, outer_radius, &temp_point.x, &scale_box.bottom);
+	CalculatePoint(NEEDLE_SWEEP, inner_radius, &scale_box.left, &scale_box.top);
+
 	// Initialize information needed to display the scale and labels.
-	scale_font.CreateFont( (int)(outer_radius * .2), 0, 0, 0, FW_NORMAL, FALSE,
-		FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, 
-		DEFAULT_QUALITY, DEFAULT_PITCH, "Arial" );
-	label_font.CreateFont( (int)(outer_radius * .18), 0, 0, 0, FW_NORMAL, FALSE,
-		FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, 
-		DEFAULT_QUALITY, DEFAULT_PITCH, "Arial" );
-	marker_pen.CreatePen( PS_SOLID, 2, 0x00FFFFFF );
+	scale_font.CreateFont((int)(outer_radius * .2), 0, 0, 0, FW_NORMAL, FALSE,
+			      FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS,
+			      DEFAULT_QUALITY, DEFAULT_PITCH, "Arial");
+	label_font.CreateFont((int)(outer_radius * .18), 0, 0, 0, FW_NORMAL, FALSE,
+			      FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS,
+			      DEFAULT_QUALITY, DEFAULT_PITCH, "Arial");
+	marker_pen.CreatePen(PS_SOLID, 2, 0x00FFFFFF);
 	label_box_size = (int)(outer_radius * .1);
 	label_radius = (int)(outer_radius * .8275);
 	tick_mark_radius = (int)(outer_radius * .96);
@@ -203,28 +191,26 @@
 	return 0;
 }
 
-
-
 //
 // Set the range of the meter and updates the display.
 //
-void CMeterCtrl::SetRange( int range1, int range2 )
+void CMeterCtrl::SetRange(int range1, int range2)
 {
 	// Disallow setting the ranges to the same value.
-	if ( range1 == range2 )
+	if (range1 == range2)
 		return;
 
-	min_range = (( range1 < range2 ) ? range1 : range2 );
-	max_range = (( range1 > range2 ) ? range1 : range2 );
+	min_range = ((range1 < range2) ? range1 : range2);
+	max_range = ((range1 > range2) ? range1 : range2);
 
 	// Make sure that the needle value is within the new range and update
 	// the actual angle that the needle should be.
-	if ( value < min_range )
+	if (value < min_range)
 		actual_angle = 0;
-	else if ( value > max_range )
+	else if (value > max_range)
 		actual_angle = NEEDLE_SWEEP;
 	else
-		actual_angle  = (int)(value / (max_range - min_range) * NEEDLE_SWEEP);
+		actual_angle = (int)(value / (max_range - min_range) * NEEDLE_SWEEP);
 
 	// Update the displayed scale and marker labels.
 	UpdateScaleInfo();
@@ -233,8 +219,6 @@
 	RedrawWindow();
 }
 
-
-
 //
 // Resetting information used to maintain watermark range.
 //
@@ -248,45 +232,36 @@
 	RedrawWindow();
 }
 
-
-
 //
 // Updating the information used to display the scale at the bottom of the 
 // meter.
 //
 void CMeterCtrl::UpdateScaleInfo()
 {
-	int		p, scale;
+	int p, scale;
 
 	// Only show text if entire scale cannot be shown by the label markers.
-	if ( max_range <= 10 )
-	{
+	if (max_range <= 10) {
 		scale_text = "";
 		return;
 	}
-
 	// Calculate the new scale.
-	scale = (int)pow( 10, (int)floor( log10( (double)max_range ) ) );
+	scale = (int)pow(10, (int)floor(log10((double)max_range)));
 
-	if ( ( max_range == pow( 10, (int)floor( log10( (double)max_range ) ) ) )  )
-	{
+	if ((max_range == pow(10, (int)floor(log10((double)max_range))))) {
 		// max_range is a power of 10
 		scale /= 10;
 	}
-
 	// Format the displayed scale text.
-	scale_text.Format( "x%d", scale );
+	scale_text.Format("x%d", scale);
 
 	// Add commas into the number for easier reading.
-	for ( p = 3; p < scale_text.GetLength() - 1; p += 4 )
-	{
-		scale_text = scale_text.Left( scale_text.GetLength() - p ) 
-			+ "," + scale_text.Right( p );
+	for (p = 3; p < scale_text.GetLength() - 1; p += 4) {
+		scale_text = scale_text.Left(scale_text.GetLength() - p)
+		    + "," + scale_text.Right(p);
 	}
 }
 
-
-
 //
 // Updating the information used to display the marker labels along the 
 // outer edge of the meter.  Because a scale is used, we are ensured that
@@ -294,87 +269,78 @@
 //
 void CMeterCtrl::UpdateLabelInfo()
 {
-	double	range_diff;
-	double	display_range;	// range normalized to ##.##### for ranges > 10
-	double	label_increment;
-	double	display_value;
-	int		label_angle;
-	LONG	x, y;			// temporary point coordinates
+	double range_diff;
+	double display_range;	// range normalized to ##.##### for ranges > 10
+	double label_increment;
+	double display_value;
+	int label_angle;
+	LONG x, y;		// temporary point coordinates
 
 	// Sets the range that the marker labels will span.
 	range_diff = max_range - min_range;
-	if ( ( range_diff == pow( 10, (int)floor( log10( range_diff ) ) ) ) && ( range_diff != 1 ) )
-	{
+	if ((range_diff == pow(10, (int)floor(log10(range_diff)))) && (range_diff != 1)) {
 		// range_diff is a power of 10, but is not exactly 1
 		display_range = 10;
+	} else {
+		display_range = range_diff / pow(10, (int)floor(log10(range_diff)));
 	}
-	else
-	{
-		display_range = range_diff / pow( 10, (int)floor( log10( range_diff ) ) );
-	}
 
 	// Set the increment from one label to the next.
-	if ( display_range <= 1 )
+	if (display_range <= 1)
 		label_increment = .1;
-	else if ( display_range <= 2 )
+	else if (display_range <= 2)
 		label_increment = .2;
-	else if ( display_range <= 5 )
+	else if (display_range <= 5)
 		label_increment = .5;
-	else if ( display_range <= 10 )
+	else if (display_range <= 10)
 		label_increment = 1;
 
 	// Update the marker label text boxes.
 	label_count = 0;
 	display_value = min_range;
-	while ( display_value <= display_range )
-	{
+	while (display_value <= display_range) {
 		// Set the position of the text boxes.
 		label_angle = (int)(display_value / display_range * NEEDLE_SWEEP);
-		CalculatePoint( label_angle, label_radius, &x, &y );
+		CalculatePoint(label_angle, label_radius, &x, &y);
 		label_box[label_count].left = x - label_box_size;
 		label_box[label_count].top = y - label_box_size;
 		label_box[label_count].right = x + label_box_size;
 		label_box[label_count].bottom = y + label_box_size;
 
 		// Format the label's text.  
-		if ( display_value > 0.0 && display_value <= 0.9 )
-			label[label_count].Format( ".%.1g\n", display_value * 10.0 );
+		if (display_value > 0.0 && display_value <= 0.9)
+			label[label_count].Format(".%.1g\n", display_value * 10.0);
 		else
-			label[label_count].Format( "%.2g\n", display_value );
+			label[label_count].Format("%.2g\n", display_value);
 
 		// Set the location for the tick marks.
-		CalculatePoint( label_angle, tick_mark_radius, 
-			&tick_mark[label_count][0].x, &tick_mark[label_count][0].y );
-		CalculatePoint( label_angle, outer_radius, 
-			&tick_mark[label_count][1].x, &tick_mark[label_count][1].y );
+		CalculatePoint(label_angle, tick_mark_radius,
+			       &tick_mark[label_count][0].x, &tick_mark[label_count][0].y);
+		CalculatePoint(label_angle, outer_radius, &tick_mark[label_count][1].x, &tick_mark[label_count][1].y);
 
 		label_count++;
 		display_value += label_increment;
 	}
 }
 
-
-
 //
 // Set the value being displayed by the meter.  It also checks to see if the
 // display needs to be updated and does so.
 //
-void CMeterCtrl::SetValue( double new_value )
+void CMeterCtrl::SetValue(double new_value)
 {
-	BOOL	update_watermark = FALSE;
+	BOOL update_watermark = FALSE;
 
 	// If the value is the same as what we had, we don't need to do anything.
-	if ( new_value == value )
+	if (new_value == value)
 		return;
 
 	// See if the new value falls outside the current watermark ranges.
-	if ( new_value < low_value || low_value == -1 )
-	{
+	if (new_value < low_value || low_value == -1) {
 		low_value = new_value;
 		update_watermark = TRUE;
 	}
-	if ( new_value > high_value )
-	{
+	if (new_value > high_value) {
 		high_value = new_value;
 		update_watermark = TRUE;
 	}
@@ -383,167 +349,151 @@
 
 	// Make sure that the new value is within the current range and update
 	// the actual angle that the needle should be.
-	if ( new_value < min_range )
+	if (new_value < min_range)
 		actual_angle = 0;
-	else if ( new_value > max_range )
+	else if (new_value > max_range)
 		actual_angle = NEEDLE_SWEEP;
 	else
-		actual_angle  = (int)(value / (max_range - min_range) * NEEDLE_SWEEP);
+		actual_angle = (int)(value / (max_range - min_range) * NEEDLE_SWEEP);
 
 	// See if the needle would move significantly.  If not, we're done.
-	if ( fabs((double)actual_angle  - shown_angle) < NEEDLE_SENSITIVITY )
+	if (fabs((double)actual_angle - shown_angle) < NEEDLE_SENSITIVITY)
 		return;
 
 	// Update the location and angle of the needle's point.
 	DrawNeedle();
-	if ( show_watermark && update_watermark )
+	if (show_watermark && update_watermark)
 		DrawWatermark();
 }
 
-
-
 //
 // Calculate a point on the display given an angle (in degrees) and the 
 // length of the radius.  The point is offset based on the pivot point.
 //
-void CMeterCtrl::CalculatePoint( int angle, int radius, LONG *x, LONG *y )
+void CMeterCtrl::CalculatePoint(int angle, int radius, LONG * x, LONG * y)
 {
 	// The given angle is from the minimum value and does not include the
 	// rotation in the display.
 	angle += 90 + PIVOT_ARC_ANGLE;
-	*x = pivot_point.x + (int)(cos( angle * PI / 180 ) * radius);
-	*y = pivot_point.y + (int)(sin( angle * PI / 180 ) * radius);
+	*x = pivot_point.x + (int)(cos(angle * PI / 180) * radius);
+	*y = pivot_point.y + (int)(sin(angle * PI / 180) * radius);
 }
 
-
-
 //
 // Sets the three points needed to draw the needle.
 //
 void CMeterCtrl::SetNeedlePoints()
 {
-	CalculatePoint( actual_angle, inner_radius, 
-		&(needle[0].x), &(needle[0].y) );
-	CalculatePoint( 180 + actual_angle - 20, pivot_radius + 5,
-		&(needle[1].x), &(needle[1].y) );
-	CalculatePoint( 180 + actual_angle + 20, pivot_radius + 5,
-		&(needle[2].x), &(needle[2].y) );
+	CalculatePoint(actual_angle, inner_radius, &(needle[0].x), &(needle[0].y));
+	CalculatePoint(180 + actual_angle - 20, pivot_radius + 5, &(needle[1].x), &(needle[1].y));
+	CalculatePoint(180 + actual_angle + 20, pivot_radius + 5, &(needle[2].x), &(needle[2].y));
 
 	// Update the angle that the needle now shows.
 	shown_angle = actual_angle;
 }
 
-
-
 //
 // Updating the display of the needle image.
 //
 void CMeterCtrl::DrawNeedle()
 {
-	CClientDC	dc(this);
-	CPen		black_pen( PS_SOLID, 1, (COLORREF) 0x00000000 );
-	CBrush		black_brush( (COLORREF) 0x00000000 );
-	CPen		needle_pen( PS_SOLID, 1, (COLORREF) 0x0000000FF );
-	CBrush		needle_brush( (COLORREF) 0x0000000FF );
-	CBrush		pivot_brush( PALETTERGB( 170, 170, 170 ) );
+	CClientDC dc(this);
+	CPen black_pen(PS_SOLID, 1, (COLORREF) 0x00000000);
+	CBrush black_brush((COLORREF) 0x00000000);
+	CPen needle_pen(PS_SOLID, 1, (COLORREF) 0x0000000FF);
+	CBrush needle_brush((COLORREF) 0x0000000FF);
+	CBrush pivot_brush(PALETTERGB(170, 170, 170));
 
 	// Clear the current needle by painting it black.
-	dc.SelectObject( black_pen );
-	dc.SelectObject( black_brush );
-	dc.Polygon( needle, 3 );
+	dc.SelectObject(black_pen);
+	dc.SelectObject(black_brush);
+	dc.Polygon(needle, 3);
 
 	// Draw the pivot circle.
-	dc.SelectObject( black_pen );
-	dc.SelectObject( pivot_brush );
-	dc.Ellipse( &needle_pivot );
+	dc.SelectObject(black_pen);
+	dc.SelectObject(pivot_brush);
+	dc.Ellipse(&needle_pivot);
 
 	// Draw the new needle.
 	SetNeedlePoints();
-	dc.SelectObject( needle_pen );
-	dc.SelectObject( needle_brush );
-	dc.Polygon( needle, 3 );
+	dc.SelectObject(needle_pen);
+	dc.SelectObject(needle_brush);
+	dc.Polygon(needle, 3);
 }
 
-
-
 //
 // Update the display of the watermark ranges.
 //
 void CMeterCtrl::DrawWatermark()
 {
-	CClientDC	dc(this);
-	CPen		watermark_pen( PS_SOLID, 2, 0x00FF0000 );
-	int			low_angle, high_angle;
-	POINT		start, end;
+	CClientDC dc(this);
+	CPen watermark_pen(PS_SOLID, 2, 0x00FF0000);
+	int low_angle, high_angle;
+	POINT start, end;
 
 	// Calculate the angle that the low watermark makes.
-	if ( low_value < min_range )
+	if (low_value < min_range)
 		low_angle = 0;
-	else if ( low_value > max_range )
+	else if (low_value > max_range)
 		low_angle = NEEDLE_SWEEP;
 	else
-		low_angle  = (int)(low_value / (max_range - min_range) * NEEDLE_SWEEP);
+		low_angle = (int)(low_value / (max_range - min_range) * NEEDLE_SWEEP);
 
 	// Calculate the angle that the high watermark makes.
-	if ( high_value < min_range )
+	if (high_value < min_range)
 		high_angle = 0;
-	else if ( high_value > max_range )
+	else if (high_value > max_range)
 		high_angle = NEEDLE_SWEEP;
 	else
-		high_angle  = (int)(high_value / (max_range - min_range) * NEEDLE_SWEEP);
+		high_angle = (int)(high_value / (max_range - min_range) * NEEDLE_SWEEP);
 
 	// If the two angles are the same, don't display the watermark.
-	if ( low_angle == high_angle )
+	if (low_angle == high_angle)
 		return;
 
 	// Get the endpoints of the watermark arc.  The arc is drawn counter-
 	// clockwise.
-	CalculatePoint( high_angle, inner_radius + 2, &start.x, &start.y );
-	CalculatePoint( low_angle, inner_radius + 2, &end.x, &end.y );
+	CalculatePoint(high_angle, inner_radius + 2, &start.x, &start.y);
+	CalculatePoint(low_angle, inner_radius + 2, &end.x, &end.y);
 
 	// Draw the watermark range of the currently displayed value.
-	dc.SelectObject( watermark_pen );
-	dc.Arc( &watermark_box, start, end );
+	dc.SelectObject(watermark_pen);
+	dc.Arc(&watermark_box, start, end);
 }
 
-
-
 //
 // Redraws the display from a WM_PAINT message.
 //
 void CMeterCtrl::OnPaint()
 {
-	CPaintDC	dc(this);
-	int			i;
+	CPaintDC dc(this);
+	int i;
 
 	// Draw the dial.
-	dc.SelectStockObject( BLACK_PEN );
-	dc.SelectStockObject( BLACK_BRUSH );
-	dc.Ellipse( &meter_box );
+	dc.SelectStockObject(BLACK_PEN);
+	dc.SelectStockObject(BLACK_BRUSH);
+	dc.Ellipse(&meter_box);
 
 	// Indicate the scale.
-	dc.SelectObject( &scale_font );
-	dc.SetBkColor( 0x00000000 );
-	dc.SetTextColor( 0x00FFFFFF );
-	dc.DrawText( scale_text, -1, &scale_box, DT_CENTER );
+	dc.SelectObject(&scale_font);
+	dc.SetBkColor(0x00000000);
+	dc.SetTextColor(0x00FFFFFF);
+	dc.DrawText(scale_text, -1, &scale_box, DT_CENTER);
 
 	// Add the labels and tick marks.
-	dc.SelectObject( &label_font );
-	dc.SelectObject( &marker_pen );
-	for ( i = 0; i < label_count; i++ )
-	{
-		dc.DrawText( label[i], -1, &label_box[i], DT_CENTER | DT_NOCLIP );
-		dc.MoveTo( tick_mark[i][0] );
-		dc.LineTo( tick_mark[i][1] );
+	dc.SelectObject(&label_font);
+	dc.SelectObject(&marker_pen);
+	for (i = 0; i < label_count; i++) {
+		dc.DrawText(label[i], -1, &label_box[i], DT_CENTER | DT_NOCLIP);
+		dc.MoveTo(tick_mark[i][0]);
+		dc.LineTo(tick_mark[i][1]);
 	}
 
 	DrawNeedle();
-	if ( show_watermark )
+	if (show_watermark)
 		DrawWatermark();
 }
 
-
-
 //
 // Removes used memory.  Called after response to WM_NCDESTROY
 //
@@ -552,8 +502,6 @@
 	delete this;
 }
 
-
-
 //
 // Registers the "meter" window class
 //
@@ -562,21 +510,18 @@
 	WNDCLASS wc;
 
 	// See if the class has already been registered.
-	if ( GetClassInfo( NULL, "CMeterCtrl", &wc ) )
-	{
+	if (GetClassInfo(NULL, "CMeterCtrl", &wc)) {
 		// Name already registered - ok if it was us
-		return ( wc.lpfnWndProc == (WNDPROC)CMeterCtrl::MeterCtrlWndProc );
+		return (wc.lpfnWndProc == (WNDPROC) CMeterCtrl::MeterCtrlWndProc);
 	}
-
 	// Register the window class of the control.
-	wc.style = CS_GLOBALCLASS | CS_OWNDC | CS_BYTEALIGNCLIENT |
-		CS_BYTEALIGNWINDOW;
+	wc.style = CS_GLOBALCLASS | CS_OWNDC | CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW;
 	wc.lpfnWndProc = CMeterCtrl::MeterCtrlWndProc;
 	wc.cbClsExtra = 0;
 	wc.cbWndExtra = 0;
 	wc.hInstance = NULL;
 	wc.hIcon = NULL;
-	wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
+	wc.hCursor =::LoadCursor(NULL, IDC_ARROW);
 	wc.hbrBackground = (HBRUSH) COLOR_WINDOW;
 	wc.lpszMenuName = NULL;
 	wc.lpszClassName = "CMeterCtrl";
@@ -584,26 +529,23 @@
 	return RegisterClass(&wc);
 }
 
-
 //
 // Window procedure for the "meter" window class.  This global function handles the
 // creation of new CMeterCtrl objects and subclasses the objects so the MFC framework
 // passes messages along to the CMeterCtrl member functions.
 //
-LRESULT CALLBACK EXPORT CMeterCtrl::MeterCtrlWndProc( HWND hWnd, UINT message, 
-	WPARAM wParam, LPARAM lParam)
+LRESULT CALLBACK EXPORT CMeterCtrl::MeterCtrlWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
 {
-	AFX_MANAGE_STATE( AfxGetStaticModuleState() );
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 
-	CWnd	*pWnd;
+	CWnd *pWnd;
 
 	// See if we're creating the window.
-	if ( !(pWnd = CWnd::FromHandlePermanent( hWnd )) && message == WM_NCCREATE )
-	{
+	if (!(pWnd = CWnd::FromHandlePermanent(hWnd)) && message == WM_NCCREATE) {
 		// Yes, create the object.
 		pWnd = new CMeterCtrl();
-		pWnd->Attach( hWnd );
+		pWnd->Attach(hWnd);
 	}
 
-	return AfxCallWndProc( pWnd, hWnd, message, wParam, lParam );
+	return AfxCallWndProc(pWnd, hWnd, message, wParam, lParam);
 }

Modified: branches/IOMETER-restruct/iometer/src/MeterCtrl.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/MeterCtrl.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/MeterCtrl.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,11 +60,8 @@
 #ifndef METERCTRL_DEFINED
 #define METERCTRL_DEFINED
 
-
 #include "TextDisplay.h"
 
-
-
 // Angle of half pie slice not used by display, in degrees.
 #define NEEDLE_SWEEP		270
 #define PIVOT_ARC_ANGLE		(360 - NEEDLE_SWEEP) / 2
@@ -72,132 +69,121 @@
 // Degree of change needed in result before needed is moved.
 #define NEEDLE_SENSITIVITY	3	// degrees
 
+class CMeterCtrl:public CWnd {
+	DECLARE_DYNAMIC(CMeterCtrl)
 
-class CMeterCtrl : public CWnd
-{
-	DECLARE_DYNAMIC( CMeterCtrl )
-
-public:
+      public:
 	CMeterCtrl();
 
 	// Members which handle window class registration.
-	static BOOL	Register();
-	static BOOL	is_registered;
+	static BOOL Register();
+	static BOOL is_registered;
 
-protected:
+      protected:
 
 	///////////////////////////////////////////////////////////////////////////
 	// Meter setup information.
-public:
-	void	SetRange( int range1, int range2 );
-	void	SetValue( double new_value );
+      public:
+	void SetRange(int range1, int range2);
+	void SetValue(double new_value);
 	//
-protected:
-	int		min_range;
-	int		max_range;
-	double	value;
+      protected:
+	int min_range;
+	int max_range;
+	double value;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Information about low to high performance marks.
-public:
-	void	ResetWatermark();
-	BOOL	show_watermark;
+      public:
+	void ResetWatermark();
+	BOOL show_watermark;
 	//
-protected:
-	double	low_value;
-	double	high_value;
+      protected:
+	double low_value;
+	double high_value;
 	//
-	RECT	watermark_box;
-	void	DrawWatermark();
+	RECT watermark_box;
+	void DrawWatermark();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Information about the position and size of the bounding control box.
 	//
-	POINT	pivot_point;
+	POINT pivot_point;
 	//
 	// The display is bounded by two circles.  The outer circle defines the
 	// limit of the display, and the text is located between the outer and 
 	// inner circles.  The inner circle defines the limit of how far the 
 	// needed reaches.  Two circles are needed to prevent the needle from
 	// sweeping over the text markers.
-	int		outer_radius;
-	int		inner_radius;
-	int		label_radius;
-	int		tick_mark_radius;
-	int		pivot_radius;
+	int outer_radius;
+	int inner_radius;
+	int label_radius;
+	int tick_mark_radius;
+	int pivot_radius;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Managing the updates to the needle display.
 	//
-	void	DrawNeedle();
-	void	CalculatePoint( int angle, int radius, LONG *x, LONG *y );
-	void	SetNeedlePoints();
+	void DrawNeedle();
+	void CalculatePoint(int angle, int radius, LONG * x, LONG * y);
+	void SetNeedlePoints();
 	//
-	int		actual_angle;
-	int		shown_angle;
+	int actual_angle;
+	int shown_angle;
 	//
 	// The needle is drawn as a triangle, given three points.
-	POINT	needle[3];
-	CRect	needle_pivot;	// inner circle needle pivots around
+	POINT needle[3];
+	CRect needle_pivot;	// inner circle needle pivots around
 	//
-	POINT	min_point, max_point;
+	POINT min_point, max_point;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Managing the updates to the display.
 	//
-	RECT	meter_box;
-	CFont	scale_font;
-	CFont	label_font;
+	RECT meter_box;
+	CFont scale_font;
+	CFont label_font;
 	//
-	void	UpdateScaleInfo();
-	CString	scale_text;
-	RECT	scale_box;
+	void UpdateScaleInfo();
+	CString scale_text;
+	RECT scale_box;
 	//
-	void	UpdateLabelInfo();
-	int		label_box_size;		// used to adjust size of the labels
-	RECT	label_box[11];		
-	CString	label[11];
-	int		label_count;
+	void UpdateLabelInfo();
+	int label_box_size;	// used to adjust size of the labels
+	RECT label_box[11];
+	CString label[11];
+	int label_count;
 	//
-	CPen	marker_pen;
-	POINT	tick_mark[11][2];	// endpoints of tick marks
+	CPen marker_pen;
+	POINT tick_mark[11][2];	// endpoints of tick marks
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	// Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CMeterCtrl)
-	virtual void	PostNcDestroy();
+	virtual void PostNcDestroy();
 	//}}AFX_VIRTUAL
 
-	
 	// Generated message map functions
 	//{{AFX_MSG(CMeterCtrl)
-	afx_msg int		OnCreate( LPCREATESTRUCT lpCreateStruct );
-	afx_msg void	OnPaint();
+	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
+	afx_msg void OnPaint();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 
-	static LRESULT CALLBACK EXPORT 
-	MeterCtrlWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
+	static LRESULT CALLBACK EXPORT MeterCtrlWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
 };
 
-
 //{{AFX_INSERT_LOCATION}}
 // Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 
-
-#endif // !METERCTRL_DEFINED
+#endif				// !METERCTRL_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/NetTCP.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/NetTCP.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/NetTCP.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -75,98 +75,89 @@
 #ifndef NET_ASYNC_TCP_DEFINED
 #define NET_ASYNC_TCP_DEFINED
 
-
 #include "Network.h"
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include "winsock2.h"
+#include "winsock2.h"
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
- #include <sys/time.h>
- #include <unistd.h>
- #include <sys/socket.h>
- #include <netinet/in.h>
- #include <netdb.h>
- #include <arpa/inet.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <arpa/inet.h>
 
- #define SOCKADDR_IN sockaddr_in
+#define SOCKADDR_IN sockaddr_in
 
- typedef struct linger LINGER;
+typedef struct linger LINGER;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done! 
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
  // nop
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #define socklen_t int  
+#define socklen_t int
 #elif defined(IOMTR_OS_NETWARE)
- #define socklen_t unsigned int
- #define TCP_NODELAY	1
+#define socklen_t unsigned int
+#define TCP_NODELAY	1
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
-class NetAsyncTCP : public Network
-{
-public:
+class NetAsyncTCP:public Network {
+      public:
 	// Member Functions.
 	NetAsyncTCP();
 	~NetAsyncTCP();
-	virtual ReturnVal	Create( BOOL create_server );
-	virtual ReturnVal	Connect( const char *ip_address, 
-							unsigned short port_number );
-	ReturnVal		ConnectSocket( SOCKADDR_IN *address );
-	virtual ReturnVal	Accept();
-	virtual ReturnVal	Destroy();
-	virtual ReturnVal	Receive( LPVOID buffer, DWORD bytes, LPDWORD return_value,
-							LPOVERLAPPED asynchronous_io, DWORD flags = 0 );
-	virtual ReturnVal	Send( LPVOID buffer, DWORD bytes, LPDWORD return_value,
-							LPOVERLAPPED asynchronous_io, DWORD flags = 0 );
-	virtual DWORD		Peek();
-	virtual ReturnVal	Close( BOOL close_server );
-	ReturnVal		WaitForDisconnect();
-	void			SetTimeout( int sec, int usec );
-	void			SetAddress( BOOL set_server, 
-							const char *ip_address = NULL,
-							unsigned short port_num = 0 );
+	virtual ReturnVal Create(BOOL create_server);
+	virtual ReturnVal Connect(const char *ip_address, unsigned short port_number);
+	ReturnVal ConnectSocket(SOCKADDR_IN * address);
+	virtual ReturnVal Accept();
+	virtual ReturnVal Destroy();
+	virtual ReturnVal Receive(LPVOID buffer, DWORD bytes, LPDWORD return_value,
+				  LPOVERLAPPED asynchronous_io, DWORD flags = 0);
+	virtual ReturnVal Send(LPVOID buffer, DWORD bytes, LPDWORD return_value,
+			       LPOVERLAPPED asynchronous_io, DWORD flags = 0);
+	virtual DWORD Peek();
+	virtual ReturnVal Close(BOOL close_server);
+	ReturnVal WaitForDisconnect();
+	void SetTimeout(int sec, int usec);
+	void SetAddress(BOOL set_server, const char *ip_address = NULL, unsigned short port_num = 0);
 
 	// Member Variables
-	SOCKADDR_IN		server_address;		// IP address, port.
-	SOCKADDR_IN		client_address;		// IP address, port.
+	SOCKADDR_IN server_address;	// IP address, port.
+	SOCKADDR_IN client_address;	// IP address, port.
 
-	CONNECTION              server_socket;		// Socket where server listens for 
-							// connections.  Not used by client.
-	CONNECTION              client_socket;		// Socket used for client/server data 
-							// transmission.
+	CONNECTION server_socket;	// Socket where server listens for 
+	// connections.  Not used by client.
+	CONNECTION client_socket;	// Socket used for client/server data 
+	// transmission.
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	struct File		server_fp;			// The actual structures that will hold
-	struct File		client_fp;			// the client and server sockets on UNIX.
-	int			maxfd;				// The max nos of fds' for select() call.
-	
+	struct File server_fp;	// The actual structures that will hold
+	struct File client_fp;	// the client and server sockets on UNIX.
+	int maxfd;		// The max nos of fds' for select() call.
+
 #ifdef WORKAROUND_LISTEN_BUG
-	BOOL 			listening;			// flag to indicate if a socket is listening or not.
-#endif // WORKAROUND_LISTEN_BUG
+	BOOL listening;		// flag to indicate if a socket is listening or not.
+#endif				// WORKAROUND_LISTEN_BUG
 
-#endif // IOMTR_OSFAMILY_UNIX
+#endif				// IOMTR_OSFAMILY_UNIX
 
-protected:
+      protected:
 	// Member Functions.
-	ReturnVal			CreateSocket( CONNECTION *s );
-	ReturnVal			BindSocket( CONNECTION *s, SOCKADDR_IN *address );
-	ReturnVal			CloseSocket( CONNECTION *s );
-	void				SetOptions( CONNECTION *s );
-	char *				Error( int error_num );
+	 ReturnVal CreateSocket(CONNECTION * s);
+	ReturnVal BindSocket(CONNECTION * s, SOCKADDR_IN * address);
+	ReturnVal CloseSocket(CONNECTION * s);
+	void SetOptions(CONNECTION * s);
+	char *Error(int error_num);
 
 	// Member Variables.
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	WSABUF			wsa_buf;
+	WSABUF wsa_buf;
 #endif
-	timeval			timeout;
-	static LONG		sockets_in_use;		// Used to control WinSock 
-							// initialization/cleanup.
+	timeval timeout;
+	static LONG sockets_in_use;	// Used to control WinSock 
+	// initialization/cleanup.
 };
 
-
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/NetVI.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/NetVI.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/NetVI.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -57,25 +57,19 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
+#define VI_DETAILS 0		// Set to 1 to enable additional debug messages.
 
-
-#define VI_DETAILS 0 // Set to 1 to enable additional debug messages.
-
-
-
 #include "NetVI.h"
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <iostream>
- using namespace std;
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS) 
- #include <iostream.h>
+#include <iostream>
+using namespace std;
+#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+#include <iostream.h>
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
 //
 // Initialization.
 //
@@ -84,50 +78,44 @@
 	vi = NULL;
 }
 
-
-
 //
 // Creating a new virtual interface on the specified VI NIC.
 //
-ReturnVal NetVI::Create( VINic *nic, TargetVI *vi_target )
+ReturnVal NetVI::Create(VINic * nic, TargetVI * vi_target)
 {
-	VIP_VI_STATE		vi_state;
-	VIP_BOOLEAN			send_queue_empty, receive_queue_empty;
-	VIP_VI_ATTRIBUTES	vi_attributes;
-	VIP_RETURN			result;
+	VIP_VI_STATE vi_state;
+	VIP_BOOLEAN send_queue_empty, receive_queue_empty;
+	VIP_VI_ATTRIBUTES vi_attributes;
+	VIP_RETURN result;
 
-	#if VI_DETAILS
-		cout << "Creating VI on nic " << nic->nic_attributes.Name << endl;
-	#endif
+#if VI_DETAILS
+	cout << "Creating VI on nic " << nic->nic_attributes.Name << endl;
+#endif
 
 	// Create the VI completion queue for the specified VI NIC.
-	if ( !vi_cq.Create( nic, vi_target ) )
+	if (!vi_cq.Create(nic, vi_target))
 		return ReturnError;
 
 	// Set the VI attributes to match the NIC it's created on.
 	vi_attributes.ReliabilityLevel = VIP_SERVICE_RELIABLE_DELIVERY;
 	vi_attributes.MaxTransferSize = nic->nic_attributes.MaxTransferSize;
-	vi_attributes.QoS = 0; // not defined by spec as of 7/24/98
+	vi_attributes.QoS = 0;	// not defined by spec as of 7/24/98
 	vi_attributes.Ptag = nic->nic_mem_attributes.Ptag;
 	vi_attributes.EnableRdmaWrite = nic->nic_mem_attributes.EnableRdmaWrite;
 	vi_attributes.EnableRdmaRead = nic->nic_mem_attributes.EnableRdmaRead;
 
 	// Create the virtual interface.
-	result = vipl.VipCreateVi( nic->nic, &vi_attributes, 
-		vi_cq.completion_queue, vi_cq.completion_queue, &vi );
-	if ( result != VIP_SUCCESS )
-	{
-		cout << "*** Unable to create VI: " << vipl.Error( result ) << endl;
+	result = vipl.VipCreateVi(nic->nic, &vi_attributes, vi_cq.completion_queue, vi_cq.completion_queue, &vi);
+	if (result != VIP_SUCCESS) {
+		cout << "*** Unable to create VI: " << vipl.Error(result) << endl;
 		vi_cq.Destroy();
 		return ReturnError;
 	}
-
 	// Get the VI attributes that were actually assigned.
-	if ( (result = vipl.VipQueryVi( vi, &vi_state, &vi_attributes, 
-		&send_queue_empty, &receive_queue_empty )) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to retrieve VI attributes: " << vipl.Error( result ) << endl;
-		vipl.VipDestroyVi( &vi );
+	if ((result = vipl.VipQueryVi(vi, &vi_state, &vi_attributes,
+				      &send_queue_empty, &receive_queue_empty)) != VIP_SUCCESS) {
+		cout << "*** Unable to retrieve VI attributes: " << vipl.Error(result) << endl;
+		vipl.VipDestroyVi(&vi);
 		vi_cq.Destroy();
 		return ReturnError;
 	}
@@ -136,53 +124,44 @@
 	return ReturnSuccess;
 }
 
-
-
 //
 // Closing the VI connection.
 //
 ReturnVal NetVI::Close()
 {
-	VIP_DESCRIPTOR	*descriptor;
-	VIP_RETURN		result;
+	VIP_DESCRIPTOR *descriptor;
+	VIP_RETURN result;
 
-	#if VI_DETAILS
-		cout << "Closing VI on " << vi_nic->nic_attributes.Name << endl;
-	#endif
+#if VI_DETAILS
+	cout << "Closing VI on " << vi_nic->nic_attributes.Name << endl;
+#endif
 
 	// See if the VI exists.  If it doesn't, we're done.
-	if ( !vi )
+	if (!vi)
 		return ReturnSuccess;
 
 	// Disconnect the VI.  This will mark all outstanding requests as complete.
-	if ( ( result = vipl.VipDisconnect( vi ) ) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to disconnect VI while closing: " << vipl.Error( result ) << endl;
+	if ((result = vipl.VipDisconnect(vi)) != VIP_SUCCESS) {
+		cout << "*** Unable to disconnect VI while closing: " << vipl.Error(result) << endl;
 		return ReturnError;
 	}
-
 	// Remove outstanding requests from the completion queue.
 	do {
-		result = vipl.VipRecvDone( vi, &descriptor );
+		result = vipl.VipRecvDone(vi, &descriptor);
 	}
-	while ( result == VIP_SUCCESS || result == VIP_DESCRIPTOR_ERROR && 
-		descriptor );
+	while (result == VIP_SUCCESS || result == VIP_DESCRIPTOR_ERROR && descriptor);
 	do {
-		result = vipl.VipSendDone( vi, &descriptor );
+		result = vipl.VipSendDone(vi, &descriptor);
 	}
-	while ( result == VIP_SUCCESS || result == VIP_DESCRIPTOR_ERROR && 
-		descriptor );
+	while (result == VIP_SUCCESS || result == VIP_DESCRIPTOR_ERROR && descriptor);
 
 	// Destroy the VI.
-	if ( ( result = vipl.VipDestroyVi( vi ) ) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to destroy VI while closing: " << vipl.Error( result ) << endl;
+	if ((result = vipl.VipDestroyVi(vi)) != VIP_SUCCESS) {
+		cout << "*** Unable to destroy VI while closing: " << vipl.Error(result) << endl;
 		return ReturnError;
 	}
-
 	// Destroy the associated completion queue.
-	if ( !vi_cq.Destroy() )
-	{
+	if (!vi_cq.Destroy()) {
 		cout << "*** Unable to destroy VI completion queue." << endl;
 		return ReturnError;
 	}
@@ -191,180 +170,155 @@
 	return ReturnSuccess;
 }
 
-
-
 //
 // Waiting for the remote side to disconnect from the VI connection.
 //
 ReturnVal NetVI::CheckForDisconnect()
 {
-	VIP_VI_STATE		vi_state;
-	VIP_VI_ATTRIBUTES	vi_attributes;
-	VIP_BOOLEAN			no_sends;
-	VIP_BOOLEAN			no_receives;
+	VIP_VI_STATE vi_state;
+	VIP_VI_ATTRIBUTES vi_attributes;
+	VIP_BOOLEAN no_sends;
+	VIP_BOOLEAN no_receives;
 
 	// See if the VI exists, if not, we're done.
-	if ( !vi )
+	if (!vi)
 		return ReturnSuccess;
 
 	// Get the current state of the VI connection.
-	if ( vipl.VipQueryVi( vi, &vi_state, &vi_attributes, &no_sends, 
-		&no_receives ) != VIP_SUCCESS )
-	{
+	if (vipl.VipQueryVi(vi, &vi_state, &vi_attributes, &no_sends, &no_receives) != VIP_SUCCESS) {
 		return ReturnError;
 	}
-
 	// See if it's still connected.
-	if ( vi_state == VIP_STATE_CONNECTED )
+	if (vi_state == VIP_STATE_CONNECTED)
 		return ReturnRetry;
 
 	return ReturnSuccess;
 }
 
-
-
 //
 // Using the VI "client/server" connection model to wait and accept a VI 
 // connection.
 // This is called by the worker designated as the server.
 //
-ReturnVal NetVI::Accept( VIP_NET_ADDRESS *local_nic_address )
+ReturnVal NetVI::Accept(VIP_NET_ADDRESS * local_nic_address)
 {
-	VIP_RETURN			result;
-	VIP_NET_ADDRESS		remote_nic_address;
-	VIP_VI_ATTRIBUTES	remote_vi_attributes;
-	VIP_CONN_HANDLE		connection;
+	VIP_RETURN result;
+	VIP_NET_ADDRESS remote_nic_address;
+	VIP_VI_ATTRIBUTES remote_vi_attributes;
+	VIP_CONN_HANDLE connection;
 
-	#if VI_DETAILS
-		cout << "Waiting to accept VI connection on " 
-			<< vi_nic->nic_attributes.Name << endl;
-	#endif
+#if VI_DETAILS
+	cout << "Waiting to accept VI connection on " << vi_nic->nic_attributes.Name << endl;
+#endif
 
 	// Waiting until the client can connect.
-	switch ( result = vipl.VipConnectWait( vi_nic->nic, local_nic_address,
-		RETRY_DELAY, &remote_nic_address, &remote_vi_attributes, &connection ) )
-	{
-	// Client ready to connect, accept the connection.
+	switch (result = vipl.VipConnectWait(vi_nic->nic, local_nic_address,
+					     RETRY_DELAY, &remote_nic_address, &remote_vi_attributes, &connection)) {
+		// Client ready to connect, accept the connection.
 	case VIP_SUCCESS:
-		#if VI_DETAILS
-			cout << "VipConnectWait succeeded!  Accepting connection." << endl;
-		#endif
-		switch ( result = vipl.VipConnectAccept( connection, vi )) 
-		{
+#if VI_DETAILS
+		cout << "VipConnectWait succeeded!  Accepting connection." << endl;
+#endif
+		switch (result = vipl.VipConnectAccept(connection, vi)) {
 		case VIP_SUCCESS:
-			#if VI_DETAILS
-				cout << "VipConnectAccept succeeded!" << endl;
-			#endif
+#if VI_DETAILS
+			cout << "VipConnectAccept succeeded!" << endl;
+#endif
 			return ReturnSuccess;
 		case VIP_TIMEOUT:
 		case VIP_ERROR_RESOURCE:
-			#if VI_DETAILS
-				cout << "VipConnectAccept() failed (trying again): " << vipl.Error( result ) << endl;
-			#endif
+#if VI_DETAILS
+			cout << "VipConnectAccept() failed (trying again): " << vipl.Error(result) << endl;
+#endif
 			return ReturnRetry;
 		default:
-			cout << "*** VipConnectAccept() failed: " << vipl.Error( result ) << endl;
+			cout << "*** VipConnectAccept() failed: " << vipl.Error(result) << endl;
 			return ReturnError;
 		}
 
-	// Client did not connect within the time limit.
+		// Client did not connect within the time limit.
 	case VIP_TIMEOUT:
 	case VIP_ERROR_RESOURCE:
-		#if VI_DETAILS
-			cout << "VipConnectWait() failed (trying again): " << vipl.Error( result ) << endl;
-		#endif
+#if VI_DETAILS
+		cout << "VipConnectWait() failed (trying again): " << vipl.Error(result) << endl;
+#endif
 		return ReturnRetry;
 	default:
-		cout << "*** VipConnectWait() failed: " << vipl.Error( result ) << endl;
+		cout << "*** VipConnectWait() failed: " << vipl.Error(result) << endl;
 		return ReturnError;
 	}
 }
 
-
-
 //
 // Using the VI "client/server" connection model to connect to a waiting VI 
 // connection.
 // This is called by the worker designated as the client.
 //
-ReturnVal NetVI::Connect( VIP_NET_ADDRESS *local_nic_address, VIP_NET_ADDRESS *remote_nic_address )
+ReturnVal NetVI::Connect(VIP_NET_ADDRESS * local_nic_address, VIP_NET_ADDRESS * remote_nic_address)
 {
-	VIP_RETURN			result;
-	VIP_VI_ATTRIBUTES	remote_vi_attributes;
+	VIP_RETURN result;
+	VIP_VI_ATTRIBUTES remote_vi_attributes;
 
-	#if VI_DETAILS
-		cout << "Requesting VI connection from " 
-			<< vi_nic->nic_attributes.Name << endl;
-	#endif
+#if VI_DETAILS
+	cout << "Requesting VI connection from " << vi_nic->nic_attributes.Name << endl;
+#endif
 
 	// Request to connect to a remote VI.
-	switch ( result = vipl.VipConnectRequest( vi, local_nic_address, 
-		remote_nic_address, RETRY_DELAY, &remote_vi_attributes ))
-	{
+	switch (result = vipl.VipConnectRequest(vi, local_nic_address,
+						remote_nic_address, RETRY_DELAY, &remote_vi_attributes)) {
 	case VIP_SUCCESS:
-		#if VI_DETAILS
-			cout << "VipConnectRequest succeeded!" << endl;
-		#endif
+#if VI_DETAILS
+		cout << "VipConnectRequest succeeded!" << endl;
+#endif
 		return ReturnSuccess;
 	case VIP_TIMEOUT:
 	case VIP_NO_MATCH:
 	case VIP_ERROR_RESOURCE:
 	case VIP_REJECT:
-		#if VI_DETAILS
-			cout << "VipConnectRequest() failed (trying again): " << vipl.Error( result ) << endl;
-		#endif
+#if VI_DETAILS
+		cout << "VipConnectRequest() failed (trying again): " << vipl.Error(result) << endl;
+#endif
 		return ReturnRetry;
 	default:
-		cout << "*** VipConnectRequest() failed: " << vipl.Error( result ) << endl;
+		cout << "*** VipConnectRequest() failed: " << vipl.Error(result) << endl;
 		return ReturnError;
 	}
 }
 
-
-
 //
 // Sending data to the remote VI connection.
 //
-ReturnVal NetVI::Send( VIP_DESCRIPTOR *descriptor,
-	VIP_MEM_HANDLE descriptor_handle )
+ReturnVal NetVI::Send(VIP_DESCRIPTOR * descriptor, VIP_MEM_HANDLE descriptor_handle)
 {
 	VIP_RETURN result;
 
-	#if VI_DETAILS
-		cout << "Sending " << descriptor->CS.Length << " bytes over VI NIC "
-			<< vi_nic->nic_attributes.Name << endl;
-	#endif
+#if VI_DETAILS
+	cout << "Sending " << descriptor->CS.Length << " bytes over VI NIC " << vi_nic->nic_attributes.Name << endl;
+#endif
 
 	// Send the I/O request.
-	if ( ( result = vipl.VipPostSend( vi, descriptor, descriptor_handle ) ) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to post VI send: " << vipl.Error( result ) << endl;
+	if ((result = vipl.VipPostSend(vi, descriptor, descriptor_handle)) != VIP_SUCCESS) {
+		cout << "*** Unable to post VI send: " << vipl.Error(result) << endl;
 		return ReturnError;
 	}
 	return ReturnSuccess;
 }
 
-
-
 //
 // Pre-posting a receiving for data from the remote VI connection.
 //
-ReturnVal NetVI::Receive( VIP_DESCRIPTOR *descriptor,
-	VIP_MEM_HANDLE descriptor_handle )
+ReturnVal NetVI::Receive(VIP_DESCRIPTOR * descriptor, VIP_MEM_HANDLE descriptor_handle)
 {
 	VIP_RETURN result;
 
-	#if VI_DETAILS
-		cout << "Receiving " << descriptor->CS.Length << " bytes over VI NIC "
-			<< vi_nic->nic_attributes.Name << endl;
-	#endif
+#if VI_DETAILS
+	cout << "Receiving " << descriptor->CS.Length << " bytes over VI NIC " << vi_nic->nic_attributes.Name << endl;
+#endif
 
 	// Send the I/O request.
-	if ( ( result = vipl.VipPostRecv( vi, descriptor, descriptor_handle ) ) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to post VI receive: " << vipl.Error( result ) << endl;
+	if ((result = vipl.VipPostRecv(vi, descriptor, descriptor_handle)) != VIP_SUCCESS) {
+		cout << "*** Unable to post VI receive: " << vipl.Error(result) << endl;
 		return ReturnError;
 	}
 	return ReturnSuccess;
 }
-

Modified: branches/IOMETER-restruct/iometer/src/NetVI.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/NetVI.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/NetVI.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -58,13 +58,9 @@
 #ifndef	NETVI_DEFINED
 #define	NETVI_DEFINED
 
-
-
 #include "IOCQVI.h"
 #include "Network.h"
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // Abstracts VI message passing calls.
 //
@@ -72,45 +68,38 @@
 // this class.
 //
 ///////////////////////////////////////////////////////////////////////////////
-class NetVI
-{
-public:
+class NetVI {
+      public:
 
 	NetVI();
 
 	///////////////////////////////////////////////////////////////////////////
 	// Public functions used to communicate over a VI connection.
 	//
-	ReturnVal	Create( VINic *nic, TargetVI *vi_target );
-	ReturnVal	Close();
-	ReturnVal	CheckForDisconnect();
+	ReturnVal Create(VINic * nic, TargetVI * vi_target);
+	ReturnVal Close();
+	ReturnVal CheckForDisconnect();
 	//
-	ReturnVal	Connect( VIP_NET_ADDRESS *local_nic_address, VIP_NET_ADDRESS *remote_nic_address );
-	ReturnVal	Accept( VIP_NET_ADDRESS *local_nic_address );
+	ReturnVal Connect(VIP_NET_ADDRESS * local_nic_address, VIP_NET_ADDRESS * remote_nic_address);
+	ReturnVal Accept(VIP_NET_ADDRESS * local_nic_address);
 	//
-	ReturnVal	Send( VIP_DESCRIPTOR *descriptor, 
-					VIP_MEM_HANDLE descriptor_handle );
-	ReturnVal	Receive( VIP_DESCRIPTOR *descriptor, 
-					VIP_MEM_HANDLE descriptor_handle );
+	ReturnVal Send(VIP_DESCRIPTOR * descriptor, VIP_MEM_HANDLE descriptor_handle);
+	ReturnVal Receive(VIP_DESCRIPTOR * descriptor, VIP_MEM_HANDLE descriptor_handle);
 	//
 	///////////////////////////////////////////////////////////////////////////
-	 
 
 	///////////////////////////////////////////////////////////////////////////
 	// Information about the VI connection.
 	//
-	VIP_VI_HANDLE	vi;
-	VINic			*vi_nic;
-	CQVI			vi_cq;
+	VIP_VI_HANDLE vi;
+	VINic *vi_nic;
+	CQVI vi_cq;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
+      private:
 
-private:
-
-	VIPL		vipl;		// Dynamically linked library.
+	 VIPL vipl;		// Dynamically linked library.
 };
 
-
-
-#endif // NETVI_DEFINED
+#endif				// NETVI_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/Network.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/Network.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/Network.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -71,12 +71,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <afx.h>
+#include <afx.h>
 #endif
 
-
 #include "Network.h"
 
 //////////////////////////////////////////////////////////////////////
@@ -93,23 +91,19 @@
 	delete errmsg;
 }
 
-
-
 //
 // Utility function: output the "errmsg" message in an appropriate manner for the
 // current environment (Dynamo or Iometer).
 //
 void Network::OutputErrMsg()
 {
-	if ( !errmsg )
-	{
+	if (!errmsg) {
 		errmsg = new ostringstream;
 		*errmsg << "Port::OutputErrMsg() called with invalid errmsg value!" << ends;
 	}
-
 #if defined(_GALILEO_)
 	// Iometer
-	ErrorMessage( errmsg->str().c_str() );
+	ErrorMessage(errmsg->str().c_str());
 #else
 	// Dynamo
 	cout << errmsg->str() << endl;
@@ -117,11 +111,12 @@
 
 	// str() returns pointer to buffer and freezes it, we must call freeze(FALSE) to 
 	// unfreeze the buffer before we can delete the object
-        // ---
+	// ---
 	// REMARK: freeze() no longer needed because new are now
-	// using ostringstream instead of ostrstream.	
+	// using ostringstream instead of ostrstream.   
 	//
 	// errmsg->rdbuf()->freeze( FALSE );
 	delete errmsg;
+
 	errmsg = new ostringstream;
 }

Modified: branches/IOMETER-restruct/iometer/src/Network.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/Network.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/Network.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -73,56 +73,49 @@
 #define NETWORK_DEFINED
 
 #ifdef IOMTR_OSFAMILY_WINDOWS
-namespace std {}
+namespace std {
+}
 #endif
 using namespace std;
+
 #include <sstream>
 
 #include "IOCommon.h"
 
-
 // Set NETWORK_DETAILS to 1 to enable network related debug messages, 0 to disable them.
 // If _DETAILS  is defined and NETWORK_DETAILS is set to 0, some messages will
 // still appear.
 #define NETWORK_DETAILS	0
 
-
 #define NETWORK_ERROR	0xffffffffffffffff
 #define SERVER	TRUE
 #define CLIENT	FALSE
 
-
-
-enum ReadWriteType
-{
+enum ReadWriteType {
 	READ,
 	WRITE
 };
 
-
-
-class Network
-{
-public:
-	// constructor and destructor	
+class Network {
+      public:
+	// constructor and destructor   
 	Network();
-	virtual	~Network();
+	virtual ~ Network();
 
 	// public functions common to all Networks (pure virtual, not implemented by Network)
-	virtual ReturnVal	Create( BOOL create_server ) = 0;
-	virtual ReturnVal	Connect( const char* ip_address, 
-							unsigned short port_number ) = 0;
-	virtual ReturnVal	Accept() = 0;
-	virtual ReturnVal	Destroy() = 0;
-	virtual ReturnVal	Receive( LPVOID buffer, DWORD bytes, LPDWORD return_value,
-							LPOVERLAPPED asynchronous_io, DWORD flags = 0 ) = 0;
-	virtual ReturnVal	Send( LPVOID buffer, DWORD bytes, LPDWORD return_value,
-							LPOVERLAPPED asynchronous_io, DWORD flags = 0 ) = 0;
-	virtual DWORD		Peek() = 0;
-	virtual ReturnVal	Close( BOOL close_server ) = 0;
+	virtual ReturnVal Create(BOOL create_server) = 0;
+	virtual ReturnVal Connect(const char *ip_address, unsigned short port_number) = 0;
+	virtual ReturnVal Accept() = 0;
+	virtual ReturnVal Destroy() = 0;
+	virtual ReturnVal Receive(LPVOID buffer, DWORD bytes, LPDWORD return_value,
+				  LPOVERLAPPED asynchronous_io, DWORD flags = 0) = 0;
+	virtual ReturnVal Send(LPVOID buffer, DWORD bytes, LPDWORD return_value,
+			       LPOVERLAPPED asynchronous_io, DWORD flags = 0) = 0;
+	virtual DWORD Peek() = 0;
+	virtual ReturnVal Close(BOOL close_server) = 0;
 
-protected:
-	virtual void OutputErrMsg();
+      protected:
+	 virtual void OutputErrMsg();
 
 	ostringstream *errmsg;
 };

Modified: branches/IOMETER-restruct/iometer/src/PageAccess.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageAccess.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageAccess.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -65,13 +65,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "PageAccess.h"
 #include "GalileoView.h"
 #include "AccessDialog.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -82,21 +80,19 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageAccess property page
 
 IMPLEMENT_DYNCREATE(CPageAccess, CPropertyPage)
 
-
-CPageAccess::CPageAccess() : CPropertyPage(CPageAccess::IDD)
+CPageAccess::CPageAccess():CPropertyPage(CPageAccess::IDD)
 {
 	global_dragging = FALSE;
 	assigned_dragging = FALSE;
@@ -104,7 +100,7 @@
 	//}}AFX_DATA_INIT
 }
 
-void CPageAccess::DoDataExchange(CDataExchange* pDX)
+void CPageAccess::DoDataExchange(CDataExchange * pDX)
 {
 	CPropertyPage::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CPageAccess)
@@ -123,178 +119,167 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CPageAccess, CPropertyPage)
-	//{{AFX_MSG_MAP(CPageAccess)
-	ON_BN_CLICKED(BEdit, OnBEdit)
-	ON_BN_CLICKED(BNew, OnBNew)
-	ON_BN_CLICKED(BDelete, OnBDelete)
-	ON_BN_CLICKED(BAdd, OnBAdd)
-	ON_BN_CLICKED(BRemove, OnBRemove)
-	ON_BN_CLICKED(BDown, OnBDown)
-	ON_BN_CLICKED(BUp, OnBUp)
-	ON_NOTIFY(NM_DBLCLK, LGlobalAccess, OnDblclkLGlobalAccess)
-	ON_NOTIFY(LVN_BEGINDRAG, LGlobalAccess, OnBegindragLGlobalAccess)
-	ON_WM_SETCURSOR()
-	ON_NOTIFY(LVN_ITEMCHANGED, LAssignedAccess, OnItemchangedLAssignedAccess)
-	ON_NOTIFY(LVN_BEGINDRAG, LAssignedAccess, OnBegindragLAssignedAccess)
-	ON_NOTIFY(LVN_ITEMCHANGED, LGlobalAccess, OnItemchangedLGlobalAccess)
-	ON_NOTIFY(NM_SETFOCUS, LGlobalAccess, OnSetfocusLGlobalAccess)
-	ON_NOTIFY(NM_SETFOCUS, LAssignedAccess, OnSetfocusLAssignedAccess)
-	ON_BN_CLICKED(BEditCopy, OnBEditCopy)
-	ON_NOTIFY(NM_KILLFOCUS, LGlobalAccess, OnKillfocusLGlobalAccess)
-	ON_NOTIFY(NM_KILLFOCUS, LAssignedAccess, OnKillfocusLAssignedAccess)
-	ON_NOTIFY(NM_CLICK, LGlobalAccess, OnClickLGlobalAccess)
-	ON_NOTIFY(NM_CLICK, LAssignedAccess, OnClickLAssignedAccess)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CPageAccess)
+    ON_BN_CLICKED(BEdit, OnBEdit)
+    ON_BN_CLICKED(BNew, OnBNew)
+    ON_BN_CLICKED(BDelete, OnBDelete)
+    ON_BN_CLICKED(BAdd, OnBAdd)
+    ON_BN_CLICKED(BRemove, OnBRemove)
+    ON_BN_CLICKED(BDown, OnBDown)
+    ON_BN_CLICKED(BUp, OnBUp)
+    ON_NOTIFY(NM_DBLCLK, LGlobalAccess, OnDblclkLGlobalAccess)
+    ON_NOTIFY(LVN_BEGINDRAG, LGlobalAccess, OnBegindragLGlobalAccess)
+    ON_WM_SETCURSOR()
+    ON_NOTIFY(LVN_ITEMCHANGED, LAssignedAccess, OnItemchangedLAssignedAccess)
+    ON_NOTIFY(LVN_BEGINDRAG, LAssignedAccess, OnBegindragLAssignedAccess)
+    ON_NOTIFY(LVN_ITEMCHANGED, LGlobalAccess, OnItemchangedLGlobalAccess)
+    ON_NOTIFY(NM_SETFOCUS, LGlobalAccess, OnSetfocusLGlobalAccess)
+    ON_NOTIFY(NM_SETFOCUS, LAssignedAccess, OnSetfocusLAssignedAccess)
+    ON_BN_CLICKED(BEditCopy, OnBEditCopy)
+    ON_NOTIFY(NM_KILLFOCUS, LGlobalAccess, OnKillfocusLGlobalAccess)
+    ON_NOTIFY(NM_KILLFOCUS, LAssignedAccess, OnKillfocusLAssignedAccess)
+    ON_NOTIFY(NM_CLICK, LGlobalAccess, OnClickLGlobalAccess)
+ON_NOTIFY(NM_CLICK, LAssignedAccess, OnClickLAssignedAccess)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageAccess message handlers
-
-BOOL CPageAccess::OnInitDialog() 
+BOOL CPageAccess::OnInitDialog()
 {
 	CPropertyPage::OnInitDialog();
 	CRect rect;
 
 	// Create and attach the LED image list to the assigned list control.
 	m_AssignedImageList.Create(IDB_LED, ACCESS_ICON_SIZE, ACCESS_ICON_EXPAND, ASSIGNED_ACCESS_ICON_BGCOLOR);
-	m_LAssignedAccess.SetImageList( &m_AssignedImageList, LVSIL_SMALL );
+	m_LAssignedAccess.SetImageList(&m_AssignedImageList, LVSIL_SMALL);
 
 	// Create and attach the default assignment image list to the global list control.
 	m_GlobalImageList.Create(IDB_ACCESS_ICONS, ACCESS_ICON_SIZE, ACCESS_ICON_EXPAND, GLOBAL_ACCESS_ICON_BGCOLOR);
-	m_LGlobalAccess.SetImageList( &m_GlobalImageList, LVSIL_SMALL );
+	m_LGlobalAccess.SetImageList(&m_GlobalImageList, LVSIL_SMALL);
 
 	// modify list controls to always show the selection, even when they don't have the focus.
-	m_LAssignedAccess.ModifyStyle( NULL, LVS_SHOWSELALWAYS );
-	m_LGlobalAccess.ModifyStyle( NULL, LVS_SHOWSELALWAYS );
+	m_LAssignedAccess.ModifyStyle(NULL, LVS_SHOWSELALWAYS);
+	m_LGlobalAccess.ModifyStyle(NULL, LVS_SHOWSELALWAYS);
 
 	// Creates a single column the width of the list control.
 	// for the assigned list.
-	m_LAssignedAccess.GetClientRect( &rect );
-	m_LAssignedAccess.InsertColumn( 0, "", LVCFMT_LEFT, rect.Width() );
+	m_LAssignedAccess.GetClientRect(&rect);
+	m_LAssignedAccess.InsertColumn(0, "", LVCFMT_LEFT, rect.Width());
 	// for the global list.
-	m_LGlobalAccess.GetClientRect( &rect );
-	m_LGlobalAccess.InsertColumn( 0, "", LVCFMT_LEFT, rect.Width() );
-		
-	UpdateData( FALSE );
+	m_LGlobalAccess.GetClientRect(&rect);
+	m_LGlobalAccess.InsertColumn(0, "", LVCFMT_LEFT, rect.Width());
 
+	UpdateData(FALSE);
+
 	// Display the global access list.
 	ShowGlobalAccess();
 
 	// Disable the assigned-specific items in the GUI.
-	SetAssignedButtons( FALSE );
-	SetAssignedAccess( FALSE ); 
+	SetAssignedButtons(FALSE);
+	SetAssignedAccess(FALSE);
 
-	return TRUE;  // return TRUE unless you set the focus to a control
-	              // EXCEPTION: OCX Property Pages should return FALSE
+	return TRUE;		// return TRUE unless you set the focus to a control
+	// EXCEPTION: OCX Property Pages should return FALSE
 }
 
-
 void CPageAccess::ShowGlobalAccess()
 {
 	int spec_count;
-	Test_Spec	*spec;
+	Test_Spec *spec;
 
 	m_LGlobalAccess.DeleteAllItems();
 	// Display the contents of the access spec list.
 	spec_count = theApp.access_spec_list.Count();
-	for ( int i = 0; i < spec_count; i++ )
-	{
-		spec = theApp.access_spec_list.Get( i );
+	for (int i = 0; i < spec_count; i++) {
+		spec = theApp.access_spec_list.Get(i);
 		// Insert the Spec into the GUI.
 		// Set the data portion to the index of the access spec in 
 		// the access spec list.  Do not set the state to selected, since the
 		// list box allows multiple selection.
-		m_LGlobalAccess.InsertItem( LVIF_STATE | LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
-			i,						
-			spec->name,
-			NULL, LVIS_SELECTED,
-			spec->default_assignment,
-			(ULONG_PTR)spec );						
+		m_LGlobalAccess.InsertItem(LVIF_STATE | LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
+					   i,
+					   spec->name, NULL, LVIS_SELECTED, spec->default_assignment, (ULONG_PTR) spec);
 	}
 }
 
-
 //
 // Create a new access spec object and add it to the gui.
 //
-void CPageAccess::OnBNew() 
+void CPageAccess::OnBNew()
 {
 	// Create a new access spec object and store the returned pointer.
 	Test_Spec *spec;
+
 	spec = theApp.access_spec_list.New();
-	
+
 	// Check for validity of returned index before adding anything to GUI.
-	if ( !spec )
+	if (!spec)
 		return;
 
 	// Clear any selection in the global list.
-	int i = m_LGlobalAccess.GetNextItem( -1, LVIS_SELECTED );
-	while ( i != NOTHING )
-	{
-		m_LGlobalAccess.SetItemState( i, NULL, LVIS_SELECTED );
-		i = m_LGlobalAccess.GetNextItem( i, LVIS_SELECTED );
+	int i = m_LGlobalAccess.GetNextItem(-1, LVIS_SELECTED);
+
+	while (i != NOTHING) {
+		m_LGlobalAccess.SetItemState(i, NULL, LVIS_SELECTED);
+		i = m_LGlobalAccess.GetNextItem(i, LVIS_SELECTED);
 	}
 
 	// Add the Access Spec to the global list view.
 	// Set the data portion to the index of the access spec in the access spec
 	// list. Select the newly added item.
-	m_LGlobalAccess.InsertItem( LVIF_STATE | LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
-		theApp.access_spec_list.IndexByRef( spec ), spec->name,
-		LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED,
-		AssignNone, (ULONG_PTR)spec );
+	m_LGlobalAccess.InsertItem(LVIF_STATE | LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
+				   theApp.access_spec_list.IndexByRef(spec), spec->name,
+				   LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED,
+				   AssignNone, (ULONG_PTR) spec);
 
 	// Automatically call the edit function for the new spec.
 	// Deletes the spec if editing was cancelled.
-	if ( !Edit() )
+	if (!Edit())
 		Delete();
 
 	// Set the focus to the ListCtrl
 	m_LGlobalAccess.SetFocus();
 }
 
-
 //
 // Edit button handler.
 //
-void CPageAccess::OnBEdit() 
+void CPageAccess::OnBEdit()
 {
 	Edit();
 	m_LGlobalAccess.SetFocus();
 }
 
-
 //
 // Pops up an edit form for the currently selected item in the global list.
 //
 BOOL CPageAccess::Edit()
 {
 	// Get currently selected spec.
-	int item_index = m_LGlobalAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
-	if ( item_index == NOTHING || item_index == IDLE_SPEC )
+	int item_index = m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
+
+	if (item_index == NOTHING || item_index == IDLE_SPEC)
 		return FALSE;
 
-	Test_Spec *spec = (Test_Spec*)m_LGlobalAccess.GetItemData( item_index );
+	Test_Spec *spec = (Test_Spec *) m_LGlobalAccess.GetItemData(item_index);
 
 	// Create access spec edit dialog and pass currently selected item's index.
-	CAccessDialog EditDlg( spec );
+	CAccessDialog EditDlg(spec);
 
-	if ( EditDlg.DoModal() == IDCANCEL )
+	if (EditDlg.DoModal() == IDCANCEL)
 		return FALSE;
 
 	// Display the correct default assignment icon for the new access spec.
-	m_LGlobalAccess.SetItem( item_index, 0, LVIF_IMAGE, NULL,
-							 spec->default_assignment, NULL, NULL, NULL );
+	m_LGlobalAccess.SetItem(item_index, 0, LVIF_IMAGE, NULL, spec->default_assignment, NULL, NULL, NULL);
 
 	// Update a name change
-	m_LGlobalAccess.SetItemText( item_index, 0, spec->name );
+	m_LGlobalAccess.SetItemText(item_index, 0, spec->name);
 	ShowAssignedAccess();
 
 	return TRUE;
 }
 
-
 //
 // Deletes the selected access spec.
 //
@@ -304,9 +289,9 @@
 	m_LGlobalAccess.SetFocus();
 }
 
-void CPageAccess::Delete() 
+void CPageAccess::Delete()
 {
-	int item_index = m_LGlobalAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
+	int item_index = m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
 
 	// Keep track of the first selected item so the highlight
 	// will remain on the same index after item removal.
@@ -314,50 +299,46 @@
 
 	LockWindowUpdate();
 	// Loop through all the selected list items and delete them.
-	while ( item_index != NOTHING )
-	{
+	while (item_index != NOTHING) {
 		// Only delete the item if it isn't the idle spec.
-		if ( item_index != IDLE_SPEC )
-		{
-			theApp.access_spec_list.Delete( 
-				(Test_Spec*)m_LGlobalAccess.GetItemData( item_index ) );
+		if (item_index != IDLE_SPEC) {
+			theApp.access_spec_list.Delete((Test_Spec *) m_LGlobalAccess.GetItemData(item_index));
 		}
-		item_index = m_LGlobalAccess.GetNextItem( item_index, LVNI_SELECTED );
+		item_index = m_LGlobalAccess.GetNextItem(item_index, LVNI_SELECTED);
 	}
 	// Display the global access specs.
 	ShowGlobalAccess();
 
 	// Make sure the item selection won't be beyond the end of the list.
-	if ( new_selected >= m_LGlobalAccess.GetItemCount() )
+	if (new_selected >= m_LGlobalAccess.GetItemCount())
 		new_selected = m_LGlobalAccess.GetItemCount() - 1;
-	
+
 	// Make a selection in the list.
-	m_LGlobalAccess.SetItemState( new_selected, LVNI_SELECTED, LVNI_SELECTED );
-	
+	m_LGlobalAccess.SetItemState(new_selected, LVNI_SELECTED, LVNI_SELECTED);
+
 	// Update the assigned access specs in case we just deleted one.
 	ShowAssignedAccess();
 	UnlockWindowUpdate();
 }
 
-
 //
 // Adds the selected access spec from the global list to the selected assigned (all managers, manager, or worker).
 //
-void CPageAccess::OnBAdd() 
+void CPageAccess::OnBAdd()
 {
 	CPoint point;
-	GetCursorPos( &point );
+
+	GetCursorPos(&point);
 	// Add button has same functionality as dragging from the global list.
 	global_dragging = TRUE;
-	Insert( point );
+	Insert(point);
 	m_LAssignedAccess.SetFocus();
 }
 
-
 //
 // Removes the selected items from the worker's assigned access specs.
 //
-void CPageAccess::OnBRemove() 
+void CPageAccess::OnBRemove()
 {
 	Remove();
 	// Set the focus to the assigned access spec list so that the buttons do
@@ -365,7 +346,6 @@
 	m_LAssignedAccess.SetFocus();
 }
 
-
 //
 // Removes the item at item_index from the assigned list.
 //
@@ -378,11 +358,11 @@
 	int item_index, old_item_index;
 
 	// Check to make sure something was selected.
-	if ( m_LAssignedAccess.GetSelectedCount() == 0 )
+	if (m_LAssignedAccess.GetSelectedCount() == 0)
 		return;
 
 	// Store the first selected index as the index to be selected after removal.
-	new_selection = m_LAssignedAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
+	new_selection = m_LAssignedAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
 
 	// Store the manager/worker selection type since it is used inside the while loop.
 	selected_type = theApp.pView->m_pWorkerView->GetSelectedType();
@@ -398,47 +378,40 @@
 	// See the comment within the removal loop below.
 
 	// See if the last item in the list is selected.
-	if ( m_LAssignedAccess.GetItemState(
-						m_LAssignedAccess.GetItemCount() - 1, LVNI_SELECTED) )
-	{
+	if (m_LAssignedAccess.GetItemState(m_LAssignedAccess.GetItemCount() - 1, LVNI_SELECTED)) {
 		// It is.
 		item_index = m_LAssignedAccess.GetItemCount() - 1;
-	}
-	else
-	{
+	} else {
 		// It isn't.  Find the next highest selected item.
-		item_index = m_LAssignedAccess.GetNextItem(
-						m_LAssignedAccess.GetItemCount() - 1,
-						LVNI_ABOVE | LVNI_SELECTED );
+		item_index = m_LAssignedAccess.GetNextItem(m_LAssignedAccess.GetItemCount() - 1,
+							   LVNI_ABOVE | LVNI_SELECTED);
 	}
 
 	// Loop through all the selected list items and remove them.
-	while ( item_index != NOTHING )
-	{
+	while (item_index != NOTHING) {
 		// Remove the entry from the selected assigned (all managers,
 		// manager, or worker).  There is no point in updating the
 		// GUI since we will just refresh the contents when we are done
 		// deleting.
-		switch ( selected_type )
-		{
-		// Nothing is actually removed from the GUI until the call to
-		// ShowAssignedAccess(), below.  This is why we have to remove
-		// the list items from the bottom up.
+		switch (selected_type) {
+			// Nothing is actually removed from the GUI until the call to
+			// ShowAssignedAccess(), below.  This is why we have to remove
+			// the list items from the bottom up.
 		case ALL_MANAGERS:
-			theApp.manager_list.RemoveAccessSpecAt( item_index );
+			theApp.manager_list.RemoveAccessSpecAt(item_index);
 			break;
 		case MANAGER:
-			manager->RemoveAccessSpecAt( item_index );
+			manager->RemoveAccessSpecAt(item_index);
 			break;
 		case WORKER:
-			worker->RemoveAccessSpecAt( item_index );
+			worker->RemoveAccessSpecAt(item_index);
 			break;
 		}
 
 		// Keep track of the last item we removed.
 		old_item_index = item_index;
 		// Find the next selected item above it.
-		item_index = m_LAssignedAccess.GetNextItem( old_item_index, LVNI_ABOVE | LVNI_SELECTED );
+		item_index = m_LAssignedAccess.GetNextItem(old_item_index, LVNI_ABOVE | LVNI_SELECTED);
 		// If the values are the same, we're at the top of the list.
 		// (The CListCtrl should return -1, but doesn't.)
 		if (item_index == old_item_index)
@@ -448,16 +421,14 @@
 	ShowAssignedAccess();
 
 	// See if the selected item is beyond the end of the list now.
-	if ( new_selection >= m_LAssignedAccess.GetItemCount() )
+	if (new_selection >= m_LAssignedAccess.GetItemCount())
 		new_selection = m_LAssignedAccess.GetItemCount() - 1;
 
-	m_LAssignedAccess.SetItemState( new_selection, LVNI_SELECTED, LVNI_SELECTED );
+	m_LAssignedAccess.SetItemState(new_selection, LVNI_SELECTED, LVNI_SELECTED);
 
 	UnlockWindowUpdate();
 }
 
-
-
 //
 // This function is called whenever the selection in the WorkerView changes.
 // If the selection changes to a worker, it displays that worker's access
@@ -465,51 +436,46 @@
 //
 void CPageAccess::ShowAssignedAccess()
 {
-	int		m, w, s, mgr_count, wkr_count, spec_count;
-	Manager	*mgr;
-	Worker	*wkr = NULL;
+	int m, w, s, mgr_count, wkr_count, spec_count;
+	Manager *mgr;
+	Worker *wkr = NULL;
 	Test_Spec *spec;
 
 	// Clear the list of assigned access specs.
 	m_LAssignedAccess.DeleteAllItems();
 
 	// find out who is selected: All managers, a manager, or a worker.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case ALL_MANAGERS:
 		// Disable the Assigned Access Spec listbox if there are no workers.
-		if ( !theApp.manager_list.WorkerCount() )
-		{
-			SetAssignedAccess( FALSE );
+		if (!theApp.manager_list.WorkerCount()) {
+			SetAssignedAccess(FALSE);
 			return;
 		}
-
 		// Enable the Assigned Access Spec listbox.
-		SetAssignedAccess( TRUE );
+		SetAssignedAccess(TRUE);
 
 		// Only display items in the listbox if all the descended workers
 		// have the same access spec list.
-		if ( !theApp.manager_list.AreAccessSpecsIdentical() )
+		if (!theApp.manager_list.AreAccessSpecsIdentical())
 			return;
 
 		// All access specs are the same.  Show the specs stored by any worker.
 
 		// Find a manager with any non-client workers.
 		mgr_count = theApp.manager_list.ManagerCount();
-		for ( m = 0; m < mgr_count; m++ )
-		{
-			mgr = theApp.manager_list.GetManager( m );
+		for (m = 0; m < mgr_count; m++) {
+			mgr = theApp.manager_list.GetManager(m);
 			wkr_count = mgr->WorkerCount();
-			if ( wkr_count > mgr->WorkerCount( GenericClientType ) )
+			if (wkr_count > mgr->WorkerCount(GenericClientType))
 				break;
 		}
 
 		// Find the manager's first non-client worker.
-		for ( w = 0; w < wkr_count; w++ )
-		{
+		for (w = 0; w < wkr_count; w++) {
 			// Find the first non-client worker.
-			wkr = mgr->GetWorker( w );
-			if ( !IsType( wkr->Type(), GenericClientType ) )
+			wkr = mgr->GetWorker(w);
+			if (!IsType(wkr->Type(), GenericClientType))
 				break;
 		}
 		break;
@@ -519,27 +485,24 @@
 		wkr_count = mgr->WorkerCount();
 
 		// Disable the access spec list if there are no non-client workers.
-		if ( wkr_count == mgr->WorkerCount( GenericClientType ) )
-		{
-			SetAssignedAccess( FALSE );
+		if (wkr_count == mgr->WorkerCount(GenericClientType)) {
+			SetAssignedAccess(FALSE);
 			return;
 		}
-
 		// Enable the Assigned Access Spec listbox.
-		SetAssignedAccess( TRUE );
+		SetAssignedAccess(TRUE);
 
 		// Only display items in the listbox if all the descended workers
 		// have the same access spec list.
-		if ( !mgr->AreAccessSpecsIdentical() )
+		if (!mgr->AreAccessSpecsIdentical())
 			return;
 
 		// All the access specs are the same.
 
 		// Find the first non-client worker.
-		for ( w = 0; w < wkr_count; w++ )
-		{
-			wkr = mgr->GetWorker( w );
-			if ( !IsType( wkr->Type(), GenericClientType ) )
+		for (w = 0; w < wkr_count; w++) {
+			wkr = mgr->GetWorker(w);
+			if (!IsType(wkr->Type(), GenericClientType))
 				break;
 		}
 		break;
@@ -548,53 +511,43 @@
 
 		wkr = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
-		if ( IsType( wkr->Type(), GenericClientType ) )
-		{
+		if (IsType(wkr->Type(), GenericClientType)) {
 			// Worker is a net client.  Display it's net server's spec 
 			// assignment, but disable the view.
 			wkr = wkr->net_partner;
-			SetAssignedAccess( FALSE );
+			SetAssignedAccess(FALSE);
+		} else {
+			SetAssignedAccess(TRUE);
 		}
-		else
-		{
-			SetAssignedAccess( TRUE );
-		}
 		break;
 	}
-	if ( !wkr )
-	{
-		ErrorMessage( "No valid worker in CPageAccess::ShowAssignedAccess()." );
+	if (!wkr) {
+		ErrorMessage("No valid worker in CPageAccess::ShowAssignedAccess().");
 		return;
 	}
-
 	// Add the Access Spec to the assigned access spec list view.
 	spec_count = wkr->AccessSpecCount();
-	for ( s = 0; s < spec_count; s++ )
-	{
-		spec = wkr->GetAccessSpec( s );
+	for (s = 0; s < spec_count; s++) {
+		spec = wkr->GetAccessSpec(s);
 		// Set the data portion to pointer to the access spec in the
 		// worker's access spec list.
-		m_LAssignedAccess.InsertItem( LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
-			s, spec->name, NULL, LVIS_SELECTED, BLUE, 
-			(ULONG_PTR)spec );
+		m_LAssignedAccess.InsertItem(LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
+					     s, spec->name, NULL, LVIS_SELECTED, BLUE, (ULONG_PTR) spec);
 	}
 }
 
-
-
 //
 // Enables the assigned list and add button based on the input variable.
 // Verifies that enabling is allowed before enabling.
 //
-void CPageAccess::SetAssignedAccess( BOOL enable )
+void CPageAccess::SetAssignedAccess(BOOL enable)
 {
-	Manager	*mgr;
-	Worker	*wkr;
-	BOOL	enabling_worker;
+	Manager *mgr;
+	Worker *wkr;
+	BOOL enabling_worker;
 
 	// Get the currently selected manager and worker.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case ALL_MANAGERS:
 		// Allow enabling if there are any workers,
 		enabling_worker = theApp.manager_list.WorkerCount();
@@ -604,129 +557,119 @@
 		mgr = theApp.pView->m_pWorkerView->GetSelectedManager();
 
 		// Allow enabling if there are non-client workers.
-		enabling_worker = ( mgr->WorkerCount() > 
-			mgr->WorkerCount( GenericClientType ) );
+		enabling_worker = (mgr->WorkerCount() > mgr->WorkerCount(GenericClientType));
 		break;
 
 	case WORKER:
 		wkr = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
 		// Allow enabling if it's not a client.
-		enabling_worker = !IsType( wkr->Type(), GenericClientType ); 
+		enabling_worker = !IsType(wkr->Type(), GenericClientType);
 		break;
 	}
 
+	m_LAssignedAccess.EnableWindow(enable && enabling_worker && theApp.test_state == TestIdle);
 
-	m_LAssignedAccess.EnableWindow( enable && enabling_worker &&
-									theApp.test_state == TestIdle );
+	m_BAdd.EnableWindow(enable && enabling_worker && theApp.test_state == TestIdle &&
+			    (m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED) != -1));
 
-	m_BAdd.EnableWindow( enable && enabling_worker && theApp.test_state == TestIdle &&
-		( m_LGlobalAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED ) != -1 ) );
-
 	m_LAssignedAccess.RedrawWindow();
 	m_BAdd.RedrawWindow();
 }
 
-
-
 //
 // Called by both the up and down button handlers.  This function actually moves the things around
 // in both the GUI and the selected assigned's access spec list.
 //
-void CPageAccess::Move( int desired_index )
+void CPageAccess::Move(int desired_index)
 {
 	Manager *manager;
 	Worker *worker;
-	int item_index = m_LAssignedAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
+	int item_index = m_LAssignedAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
 
 	// Check to make sure something was selected.
-	if ( m_LAssignedAccess.GetSelectedCount() == 0 )
+	if (m_LAssignedAccess.GetSelectedCount() == 0)
 		return;
 
 	LockWindowUpdate();
 	// Move the access spec referred to by the selected item.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case ALL_MANAGERS:
-		theApp.manager_list.MoveAccessSpec( item_index, desired_index );
+		theApp.manager_list.MoveAccessSpec(item_index, desired_index);
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		manager->MoveAccessSpec( item_index, desired_index );
+		manager->MoveAccessSpec(item_index, desired_index);
 		break;
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		worker->MoveAccessSpec( item_index, desired_index );
+		worker->MoveAccessSpec(item_index, desired_index);
 		break;
 	}
 	ShowAssignedAccess();
 	// Select the moved item so that the move buttons are still enabled.
-	m_LAssignedAccess.SetItemState( desired_index, LVNI_SELECTED, LVNI_SELECTED );
+	m_LAssignedAccess.SetItemState(desired_index, LVNI_SELECTED, LVNI_SELECTED);
 	UnlockWindowUpdate();
 }
 
-
 //
 // Moves the selected item up/down in the assigned's list of access specs.
 //
-void CPageAccess::OnBDown() 
+void CPageAccess::OnBDown()
 {
 	// Get the currently selected item from the workers ListCtrl.
-	int item_index = m_LAssignedAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
-	Move( item_index + 1 );
+	int item_index = m_LAssignedAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
+
+	Move(item_index + 1);
 	m_LAssignedAccess.SetFocus();
 }
 
-void CPageAccess::OnBUp() 
+void CPageAccess::OnBUp()
 {
 	// Get the currently selected item from the workers ListCtrl.
-	int item_index = m_LAssignedAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
-	Move( item_index - 1 );
+	int item_index = m_LAssignedAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
+
+	Move(item_index - 1);
 	m_LAssignedAccess.SetFocus();
 }
 
-
 //
 // Enables or disable the Up, Down, and Remove buttons.
 //
-void CPageAccess::SetAssignedButtons( BOOL enable )
+void CPageAccess::SetAssignedButtons(BOOL enable)
 {
-	int item_index = m_LAssignedAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
-	BOOL net_client_selected = ( theApp.pView->m_pWorkerView->GetSelectedWorkerType() 
-		== GenericClientType );
+	int item_index = m_LAssignedAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
+	BOOL net_client_selected = (theApp.pView->m_pWorkerView->GetSelectedWorkerType()
+				    == GenericClientType);
 
 	// Enables the Up Button when the selected item is at least the second entry
-	m_BUp.EnableWindow( enable && 
-						item_index > 0 && 
-						!net_client_selected && 
-						m_LAssignedAccess.GetSelectedCount() == 1 &&
-						theApp.test_state == TestIdle && 
-						GetFocus() == &m_LAssignedAccess );
+	m_BUp.EnableWindow(enable &&
+			   item_index > 0 &&
+			   !net_client_selected &&
+			   m_LAssignedAccess.GetSelectedCount() == 1 &&
+			   theApp.test_state == TestIdle && GetFocus() == &m_LAssignedAccess);
 	// Enables the Down Button when the selected item is not the last entry.
-	m_BDown.EnableWindow( enable && 
-						  item_index < m_LAssignedAccess.GetItemCount() - 1 &&
-						  item_index >= 0 &&
-						  !net_client_selected &&
-						  m_LAssignedAccess.GetSelectedCount() == 1 &&
-						  theApp.test_state == TestIdle &&
-						  GetFocus() == &m_LAssignedAccess );
+	m_BDown.EnableWindow(enable &&
+			     item_index < m_LAssignedAccess.GetItemCount() - 1 &&
+			     item_index >= 0 &&
+			     !net_client_selected &&
+			     m_LAssignedAccess.GetSelectedCount() == 1 &&
+			     theApp.test_state == TestIdle && GetFocus() == &m_LAssignedAccess);
 	// Remove Button when any item is selected.
-	m_BRemove.EnableWindow( enable && 
-							item_index != NOTHING && 
-							!net_client_selected && 
-							theApp.test_state == TestIdle &&
-							GetFocus() == &m_LAssignedAccess );
+	m_BRemove.EnableWindow(enable &&
+			       item_index != NOTHING &&
+			       !net_client_selected &&
+			       theApp.test_state == TestIdle && GetFocus() == &m_LAssignedAccess);
 
 	m_BUp.RedrawWindow();
 	m_BDown.RedrawWindow();
 	m_BRemove.RedrawWindow();
 }
 
-
 //
 // Edits an access spec when the user double clicks on it in the global list.
 //
-void CPageAccess::OnDblclkLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnDblclkLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	Edit();
 	m_LGlobalAccess.SetFocus();
@@ -734,144 +677,123 @@
 	*pResult = 0;
 }
 
-
 //
 // The user is beginning a drag operation from the global list.
 //
-void CPageAccess::OnBegindragLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnBegindragLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	// check that input parameter is valid and that we are allowed to drag.
-	if ( !pNMHDR
-			|| theApp.test_state != TestIdle
-			|| theApp.pView->m_pWorkerView->GetSelectedWorkerType() 
-			== GenericClientType
-			|| !m_LAssignedAccess.IsWindowEnabled() )
-	{
+	if (!pNMHDR || theApp.test_state != TestIdle || theApp.pView->m_pWorkerView->GetSelectedWorkerType()
+	    == GenericClientType || !m_LAssignedAccess.IsWindowEnabled()) {
 		return;
 	}
-
 	// Select the item to drag.
-	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
+	NM_LISTVIEW *pNMListView = (NM_LISTVIEW *) pNMHDR;
 
 	// Set flag indicating that a drag operation is underway.
-	global_dragging = TRUE;	
+	global_dragging = TRUE;
 	CPoint point;
-	p_DragImage = m_LGlobalAccess.CreateDragImage( pNMListView->iItem, &point );
 
+	p_DragImage = m_LGlobalAccess.CreateDragImage(pNMListView->iItem, &point);
+
 	// set hot spot to middle of 16x16 icon
 	point.x = 8;
 	point.y = 8;
 
 	// set drag icon to icon of current selection
-	p_DragImage->BeginDrag( 0, point );
+	p_DragImage->BeginDrag(0, point);
 
 	*pResult = 0;
 }
 
-
 //
 // The user is beginning a drag operation from the assigned list.
 //
-void CPageAccess::OnBegindragLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnBegindragLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	// check that input parameter is valid
-	if ( !pNMHDR
-			|| theApp.test_state != TestIdle
-			|| theApp.pView->m_pWorkerView->GetSelectedWorkerType() 
-			== GenericClientType
-			|| !m_LAssignedAccess.IsWindowEnabled() )
-	{
+	if (!pNMHDR || theApp.test_state != TestIdle || theApp.pView->m_pWorkerView->GetSelectedWorkerType()
+	    == GenericClientType || !m_LAssignedAccess.IsWindowEnabled()) {
 		return;
 	}
-	
 	// Set focus to assigned access list.
 	m_LAssignedAccess.SetFocus();
 
 	// Select the item to drag.
-	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
+	NM_LISTVIEW *pNMListView = (NM_LISTVIEW *) pNMHDR;
 
 	// Set flag indicating that a drag operation is underway.
-	assigned_dragging = TRUE;	
+	assigned_dragging = TRUE;
 	CPoint point;
-	p_DragImage = m_LAssignedAccess.CreateDragImage( pNMListView->iItem, &point );
 
+	p_DragImage = m_LAssignedAccess.CreateDragImage(pNMListView->iItem, &point);
+
 	// set hot spot to middle of 16x16 icon
 	point.x = 24;
 	point.y = 8;
 
 	// set drag icon to icon of current selection
-	p_DragImage->BeginDrag( 0, point );
+	p_DragImage->BeginDrag(0, point);
 
 	*pResult = 0;
 }
 
-
 //
 // Updates the cursor during a drag operation.
 //
-BOOL CPageAccess::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
+BOOL CPageAccess::OnSetCursor(CWnd * pWnd, UINT nHitTest, UINT message)
 {
-	CPoint	point;
-	CRect	global_rect, assigned_rect;
+	CPoint point;
+	CRect global_rect, assigned_rect;
 
 	// Get the areas of the two list controls.
-	m_LAssignedAccess.GetWindowRect( &assigned_rect );
-	m_LGlobalAccess.GetWindowRect( &global_rect );
+	m_LAssignedAccess.GetWindowRect(&assigned_rect);
+	m_LGlobalAccess.GetWindowRect(&global_rect);
 
 	// Normalize these areas so that we have no negative widths or heights.
 	assigned_rect.NormalizeRect();
 	global_rect.NormalizeRect();
 
 	// Check to see if the mouse is moved during a drag event.
-	if ( message == WM_MOUSEMOVE && ( global_dragging || assigned_dragging ) )
-	{
+	if (message == WM_MOUSEMOVE && (global_dragging || assigned_dragging)) {
 		// Get current curser position.
-		GetCursorPos( &point );
+		GetCursorPos(&point);
 
 		// Set the curser to either the arrow or the crossed circle.
-		if ( global_dragging && !assigned_rect.PtInRect( point ) && 
-			!global_rect.PtInRect( point ) )
-			SetCursor( LoadCursor( NULL, IDC_NO ) );
+		if (global_dragging && !assigned_rect.PtInRect(point) && !global_rect.PtInRect(point))
+			SetCursor(LoadCursor(NULL, IDC_NO));
 		else
-			SetCursor( LoadCursor( NULL, IDC_ARROW ) );
+			SetCursor(LoadCursor(NULL, IDC_ARROW));
 
 		// Show the drag image in addition to the cursor.
-		p_DragImage->DragShowNolock( TRUE );
-		p_DragImage->DragMove( point );
+		p_DragImage->DragShowNolock(TRUE);
+		p_DragImage->DragMove(point);
 
 		return TRUE;
 	}
-
 	// Check to see if the button up mouse event happened after a drag event.
-	if ( ( message == WM_LBUTTONUP || message == WM_LBUTTONDOWN ) && 
-		( global_dragging || assigned_dragging ) )
-	{
+	if ((message == WM_LBUTTONUP || message == WM_LBUTTONDOWN) && (global_dragging || assigned_dragging)) {
 		p_DragImage->EndDrag();
 
 		delete p_DragImage;
-		
+
 		// Return the cursor to the Arrow.
-		SetCursor( LoadCursor( NULL, IDC_ARROW ) );
+		SetCursor(LoadCursor(NULL, IDC_ARROW));
 
-		GetCursorPos( &point );
+		GetCursorPos(&point);
 
 		// dragging within the assigned list?
-		if ( assigned_dragging )
-		{
-			if ( assigned_rect.PtInRect( point ) )
-			{	// dropped within the assigned list.
-				if ( m_LAssignedAccess.GetSelectedCount() == 1 )
-					Insert( point );
-			}
-			else
-			{	// dropped outside the assigned list.
+		if (assigned_dragging) {
+			if (assigned_rect.PtInRect(point)) {	// dropped within the assigned list.
+				if (m_LAssignedAccess.GetSelectedCount() == 1)
+					Insert(point);
+			} else {	// dropped outside the assigned list.
 				Remove();
 			}
 		}
 		// dragging from the global list to the assigned list?
-		else if ( global_dragging && assigned_rect.PtInRect( point ) )
-		{
-			Insert( point );
+		else if (global_dragging && assigned_rect.PtInRect(point)) {
+			Insert(point);
 			m_LAssignedAccess.SetFocus();
 		}
 
@@ -883,79 +805,71 @@
 	return CPropertyPage::OnSetCursor(pWnd, nHitTest, message);
 }
 
-
 //
 // Handle the item selection changing in the assigned list.
 //
-void CPageAccess::OnItemchangedLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnItemchangedLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
+	NM_LISTVIEW *pNMListView = (NM_LISTVIEW *) pNMHDR;
 
 	// Set buttons correctly.
-	SetAssignedButtons( TRUE );
+	SetAssignedButtons(TRUE);
 
 	m_LAssignedAccess.RedrawWindow();
 	*pResult = 0;
 }
 
-
 //
 // Inserts an item into the assigned list before the currently selected item.
 //
-void CPageAccess::Insert( CPoint point )
+void CPageAccess::Insert(CPoint point)
 {
 	int move_to_index, global_index;
 	Manager *manager;
 	Worker *worker;
 
-	global_index = m_LGlobalAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
+	global_index = m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
 
-	if ( global_dragging && global_index == NOTHING )
+	if (global_dragging && global_index == NOTHING)
 		return;
 
 	// find out who is selected: All managers, a manager, or a worker.
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
 	worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-	
+
 	// Set all spec LED's to their initial state.
 	Reset();
 
 	// If this is a new selection, any additions to all managers or to a manager
 	// will clear all their children workers' access spec settings.
-	if ( !worker && m_LAssignedAccess.GetItemCount() == 0 )
-	{
+	if (!worker && m_LAssignedAccess.GetItemCount() == 0) {
 		// There is nothing in the GUI.  The Add will replace
 		// all the children workers' selection.
-		if ( !manager )
+		if (!manager)
 			theApp.manager_list.RemoveAllAccessSpecs();
 		else
 			manager->RemoveAllAccessSpecs();
 	}
-
 	// Find the item being hovered over.
-	m_LAssignedAccess.ScreenToClient( &point );
-	move_to_index = m_LAssignedAccess.HitTest( point );
-	if ( move_to_index == -1 )
+	m_LAssignedAccess.ScreenToClient(&point);
+	move_to_index = m_LAssignedAccess.HitTest(point);
+	if (move_to_index == -1)
 		move_to_index = m_LAssignedAccess.GetItemCount();
 
-	if ( global_dragging )
-	{
-		InsertAt( move_to_index );
-	}
-	else if ( assigned_dragging )
-	{
-		Move( move_to_index );
+	if (global_dragging) {
+		InsertAt(move_to_index);
+	} else if (assigned_dragging) {
+		Move(move_to_index);
 
 		assigned_dragging = FALSE;	// Reset assigned dragging flag.
 	}
 }
 
-
-void CPageAccess::InsertAt( int insert_index )
+void CPageAccess::InsertAt(int insert_index)
 {
 	Test_Spec *spec;
 	int inserted_count = 0;
-	int global_index = m_LGlobalAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
+	int global_index = m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
 
 	// find out who is selected: All managers, a manager, or a worker.
 	Manager *manager = theApp.pView->m_pWorkerView->GetSelectedManager();
@@ -964,254 +878,236 @@
 	LockWindowUpdate();
 	// Loop through all the selected list items from the global list
 	// and add them to the assigned list.
-	while ( global_index != NOTHING )
-	{
-		spec = (Test_Spec*)m_LGlobalAccess.GetItemData( global_index );
-		switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-		{
+	while (global_index != NOTHING) {
+		spec = (Test_Spec *) m_LGlobalAccess.GetItemData(global_index);
+		switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 		case ALL_MANAGERS:
 			// Insert access spec to all managers
-			if ( !theApp.manager_list.InsertAccessSpec( spec, 
-				insert_index + inserted_count++ ) )
-			{
+			if (!theApp.manager_list.InsertAccessSpec(spec, insert_index + inserted_count++)) {
 				UnlockWindowUpdate();
-				ErrorMessage( "Failed to add the selected access spec to all managers in CPageAccess::Insert()." );
+				ErrorMessage
+				    ("Failed to add the selected access spec to all managers in CPageAccess::Insert().");
 				return;
 			}
 			break;
 		case MANAGER:
 			// Insert access spec to a manager
-			if ( !manager->InsertAccessSpec( spec,
-				insert_index + inserted_count++ ) )
-			{
+			if (!manager->InsertAccessSpec(spec, insert_index + inserted_count++)) {
 				UnlockWindowUpdate();
-				ErrorMessage( "Failed to add the selected access spec to the selected managers in CPageAccess::Insert()." );
+				ErrorMessage
+				    ("Failed to add the selected access spec to the selected managers in CPageAccess::Insert().");
 				return;
 			}
 			break;
 		case WORKER:
 			// Insert acces spec to a worker
-			if ( !worker->InsertAccessSpec( spec,
-				insert_index + inserted_count++ ) )
-			{
+			if (!worker->InsertAccessSpec(spec, insert_index + inserted_count++)) {
 				UnlockWindowUpdate();
-				ErrorMessage( "Failed to add the selected access spec to the selected worker in CPageAccess::Insert()." );
+				ErrorMessage
+				    ("Failed to add the selected access spec to the selected worker in CPageAccess::Insert().");
 				return;
 			}
 			break;
 		}
-		global_index = m_LGlobalAccess.GetNextItem( global_index, LVNI_SELECTED );
+		global_index = m_LGlobalAccess.GetNextItem(global_index, LVNI_SELECTED);
 	}
 	ShowAssignedAccess();
 	UnlockWindowUpdate();
 	global_dragging = FALSE;	// Reset global dragging flag.
 }
 
-void CPageAccess::OnItemchangedLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnItemchangedLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
-	
-	SetAssignedAccess( TRUE );
-	
+	NM_LISTVIEW *pNMListView = (NM_LISTVIEW *) pNMHDR;
+
+	SetAssignedAccess(TRUE);
+
 	// Disable delete and edit buttons for the Idle Spec
-	SetGlobalButtons( pNMListView->iItem != IDLE_SPEC && (pNMListView->uNewState && LVIS_SELECTED) );
-	
+	SetGlobalButtons(pNMListView->iItem != IDLE_SPEC && (pNMListView->uNewState && LVIS_SELECTED));
+
 	*pResult = 0;
 }
 
-
 //
 // Enables the apropriate window objects after test run.
 //
-void CPageAccess::EnableWindow( BOOL enable )
+void CPageAccess::EnableWindow(BOOL enable)
 {
 	// Enables the assigned list and the add button unless the selected worker is a TCPClient.
-	SetAssignedAccess( enable );
+	SetAssignedAccess(enable);
 
-	m_BNew.EnableWindow( enable );
+	m_BNew.EnableWindow(enable);
 	m_BNew.RedrawWindow();
 
-	m_LGlobalAccess.EnableWindow( enable );
+	m_LGlobalAccess.EnableWindow(enable);
 	m_LGlobalAccess.RedrawWindow();
 }
 
-
 //
 // Resets all the LED's to BLUE
 //
 void CPageAccess::Reset()
 {
-	for ( int i = 0; i < m_LAssignedAccess.GetItemCount(); i++ )
-		MarkAccess( i, BLUE );
+	for (int i = 0; i < m_LAssignedAccess.GetItemCount(); i++)
+		MarkAccess(i, BLUE);
 }
 
-
 //
 // Mark given spec given color.
 //
-void CPageAccess::MarkAccess( int access_index, int color )
+void CPageAccess::MarkAccess(int access_index, int color)
 {
-	m_LAssignedAccess.SetItem( access_index,	// item index
-							 NULL,			// subitem index
-							 LVIF_IMAGE,	// mask
-							 NULL,			// text
-							 color,			// image
-							 NULL,			// state
-							 NULL,			// state mask
-							 NULL);			// data
+	m_LAssignedAccess.SetItem(access_index,	// item index
+				  NULL,	// subitem index
+				  LVIF_IMAGE,	// mask
+				  NULL,	// text
+				  color,	// image
+				  NULL,	// state
+				  NULL,	// state mask
+				  NULL);	// data
 
 }
 
-
 //
 // Set the LEDs for the currently displayed access specs based on the 
 // currently running spec.
 //
-void CPageAccess::MarkAccesses( int current_access )
+void CPageAccess::MarkAccesses(int current_access)
 {
-	for ( int i = 0; i < m_LAssignedAccess.GetItemCount(); i++ )
-	{
-		if ( (theApp.test_state == TestIdle) || (theApp.test_state == TestPreparing) || i > current_access ) {
-			MarkAccess( i, BLUE );
-		}
-		else {
-			if ( i == current_access ) {
-				MarkAccess( i, GREEN );
-				m_LAssignedAccess.EnsureVisible( i, FALSE );
+	for (int i = 0; i < m_LAssignedAccess.GetItemCount(); i++) {
+		if ((theApp.test_state == TestIdle) || (theApp.test_state == TestPreparing) || i > current_access) {
+			MarkAccess(i, BLUE);
+		} else {
+			if (i == current_access) {
+				MarkAccess(i, GREEN);
+				m_LAssignedAccess.EnsureVisible(i, FALSE);
+			} else {
+				MarkAccess(i, RED);
 			}
-			else {
-				MarkAccess( i, RED );
-			}
 		}
 	}
 }
 
-
 //
 // Enables the edit and delete buttons for the global access spec list.
 //
-void CPageAccess::SetGlobalButtons( BOOL enable )
+void CPageAccess::SetGlobalButtons(BOOL enable)
 {
-	int global_index = m_LGlobalAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED );
-	m_BEdit.EnableWindow( enable && 
-		global_index != IDLE_SPEC && 
-		GetFocus() == &m_LGlobalAccess && 
-		m_LGlobalAccess.GetSelectedCount() == 1  );
-	m_BEditCopy.EnableWindow( enable && 
-		global_index != IDLE_SPEC && 
-		GetFocus() == &m_LGlobalAccess &&
-		m_LGlobalAccess.GetSelectedCount() == 1 );
-	m_BDelete.EnableWindow( enable && global_index != IDLE_SPEC 
-		&& GetFocus() == &m_LGlobalAccess && global_index != NOTHING );
+	int global_index = m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED);
 
+	m_BEdit.EnableWindow(enable &&
+			     global_index != IDLE_SPEC &&
+			     GetFocus() == &m_LGlobalAccess && m_LGlobalAccess.GetSelectedCount() == 1);
+	m_BEditCopy.EnableWindow(enable &&
+				 global_index != IDLE_SPEC &&
+				 GetFocus() == &m_LGlobalAccess && m_LGlobalAccess.GetSelectedCount() == 1);
+	m_BDelete.EnableWindow(enable && global_index != IDLE_SPEC
+			       && GetFocus() == &m_LGlobalAccess && global_index != NOTHING);
+
 	m_BEdit.RedrawWindow();
 	m_BEditCopy.RedrawWindow();
 	m_BDelete.RedrawWindow();
 }
 
-
 /////////////////////////////////////////////////////////////////////////
 //
 // The following functions enable and disable GUI buttons
 // based on the input focus.
 //
 /////////////////////////////////////////////////////////////////////////
-void CPageAccess::OnKillfocusLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnKillfocusLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	CPoint	point;
-	CRect	frame_rect, button_rect;
+	CPoint point;
+	CRect frame_rect, button_rect;
 
-	GetCursorPos( &point );
+	GetCursorPos(&point);
 
 	// Get the area of the global list controls.
-	m_GGlobalFrame.GetWindowRect( &frame_rect );
-	m_BAdd.GetWindowRect( &button_rect );
+	m_GGlobalFrame.GetWindowRect(&frame_rect);
+	m_BAdd.GetWindowRect(&button_rect);
 
 	// Normalize the area so that we have no negative widths or heights.
 	frame_rect.NormalizeRect();
 	button_rect.NormalizeRect();
 
-	frame_rect.UnionRect( frame_rect, button_rect );
+	frame_rect.UnionRect(frame_rect, button_rect);
 
-	if ( !frame_rect.PtInRect( point ) )
-		SetGlobalButtons( FALSE );
+	if (!frame_rect.PtInRect(point))
+		SetGlobalButtons(FALSE);
 }
 
-void CPageAccess::OnKillfocusLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnKillfocusLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	CPoint	point;
-	CRect	frame_rect, button_rect;
+	CPoint point;
+	CRect frame_rect, button_rect;
 
-	GetCursorPos( &point );
+	GetCursorPos(&point);
 
 	// Get the area of the global list controls.
-	m_GAssignedFrame.GetWindowRect( &frame_rect );
-	m_BRemove.GetWindowRect( &button_rect );
+	m_GAssignedFrame.GetWindowRect(&frame_rect);
+	m_BRemove.GetWindowRect(&button_rect);
 
 	// Normalize the area so that we have no negative widths or heights.
 	frame_rect.NormalizeRect();
 	button_rect.NormalizeRect();
 
-	frame_rect.UnionRect( frame_rect, button_rect );
+	frame_rect.UnionRect(frame_rect, button_rect);
 
-	if ( !frame_rect.PtInRect( point ) )
-		SetAssignedButtons( FALSE );
+	if (!frame_rect.PtInRect(point))
+		SetAssignedButtons(FALSE);
 }
 
-void CPageAccess::OnSetfocusLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnSetfocusLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	SetGlobalButtons( TRUE );
+	SetGlobalButtons(TRUE);
 	*pResult = 0;
 }
 
-void CPageAccess::OnSetfocusLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnSetfocusLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	SetAssignedButtons( TRUE );
+	SetAssignedButtons(TRUE);
 	*pResult = 0;
 }
 
-void CPageAccess::OnBEditCopy() 
+void CPageAccess::OnBEditCopy()
 {
 	Test_Spec *spec;
 
 	// Get the selected access spec's index into the global list.
-	spec = (Test_Spec*)m_LGlobalAccess.GetItemData( 
-		m_LGlobalAccess.GetNextItem( FIND_FIRST, LVNI_SELECTED ) );
+	spec = (Test_Spec *) m_LGlobalAccess.GetItemData(m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED));
 	// Create the copy of the spec object.
-	spec = theApp.access_spec_list.Copy( spec );
-	
+	spec = theApp.access_spec_list.Copy(spec);
+
 	// Check for validity of returned index before adding anything to GUI.
-	if ( !spec )
+	if (!spec)
 		return;
 
 	// Add the Access Spec to the global list view.
 	// Set the data portion to the index of the access spec in the access spec list.
 	// Select the newly added item and remove the selection from the previous
 	// selected item.
-	m_LGlobalAccess.SetItemState( m_LGlobalAccess.GetNextItem( FIND_FIRST, 
-		LVNI_SELECTED ), NULL, LVIS_SELECTED );
-	m_LGlobalAccess.InsertItem( LVIF_STATE | LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
-		m_LGlobalAccess.GetItemCount(), spec->name,
-		LVIS_SELECTED, LVIS_SELECTED, AssignNone, (ULONG_PTR)spec );						
+	m_LGlobalAccess.SetItemState(m_LGlobalAccess.GetNextItem(FIND_FIRST, LVNI_SELECTED), NULL, LVIS_SELECTED);
+	m_LGlobalAccess.InsertItem(LVIF_STATE | LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
+				   m_LGlobalAccess.GetItemCount(), spec->name,
+				   LVIS_SELECTED, LVIS_SELECTED, AssignNone, (ULONG_PTR) spec);
 
 	// Automatically call the edit function for the new spec.
 	// Deletes the spec if editing was cancelled.
-	if ( !Edit() )
+	if (!Edit())
 		Delete();
 
 	// Set the focus to the ListCtrl
 	m_LGlobalAccess.SetFocus();
 }
 
-
-void CPageAccess::OnClickLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnClickLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	SetGlobalButtons( TRUE );
+	SetGlobalButtons(TRUE);
 	*pResult = 0;
 }
 
-void CPageAccess::OnClickLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageAccess::OnClickLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	SetAssignedButtons( TRUE );	
+	SetAssignedButtons(TRUE);
 	*pResult = 0;
 }

Modified: branches/IOMETER-restruct/iometer/src/PageAccess.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageAccess.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageAccess.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,14 +60,12 @@
 #ifndef PAGEACCESS_DEFINED
 #define PAGEACCESS_DEFINED
 
-
 #include "GalileoApp.h"
 #include "IOTest.h"
 
-
 // Info for access spec image list (LED's and default assignment)
 #define ACCESS_ICON_SIZE			15
-#define ACCESS_ICON_EXPAND			10 // number of icons to add to ImageList when expanding
+#define ACCESS_ICON_EXPAND			10	// number of icons to add to ImageList when expanding
 #define GLOBAL_ACCESS_ICON_BGCOLOR		0x00ff00ff
 #define ASSIGNED_ACCESS_ICON_BGCOLOR		0x00ffffff
 
@@ -81,76 +79,78 @@
 #define FIND_FIRST	-1	// Used when searching through a list control.  Indicates that the first item
 						// that matches the criteria should be returned.
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageAccess dialog
 
-class CPageAccess : public CPropertyPage
-{
+class CPageAccess:public CPropertyPage {
 	DECLARE_DYNCREATE(CPageAccess)
-
 // Construction
-public:
+      public:
 	CPageAccess();
-	~CPageAccess() {};
+	~CPageAccess() {
+	};
 
-protected:
+      protected:
 // Dialog Data
 	//{{AFX_DATA(CPageAccess)
 	enum { IDD = IDD_ACCESS };
-	CButton	m_GGlobalFrame;
-	CButton	m_GAssignedFrame;
-	CButton	m_BEditCopy;
-	CListCtrl	m_LAssignedAccess;
-	CButton	m_BUp;
-	CListCtrl	m_LGlobalAccess;
-	CButton	m_BRemove;
-	CButton	m_BNew;
-	CButton	m_BEdit;
-	CButton	m_BDown;
-	CButton	m_BAdd;
-	CButton	m_BDelete;
+	CButton m_GGlobalFrame;
+	CButton m_GAssignedFrame;
+	CButton m_BEditCopy;
+	CListCtrl m_LAssignedAccess;
+	CButton m_BUp;
+	CListCtrl m_LGlobalAccess;
+	CButton m_BRemove;
+	CButton m_BNew;
+	CButton m_BEdit;
+	CButton m_BDown;
+	CButton m_BAdd;
+	CButton m_BDelete;
+
 	//}}AFX_DATA
 
-public:
+      public:
 
-	void		ShowAssignedAccess();
-	void		ShowGlobalAccess();
-	void		EnableWindow( BOOL enable = TRUE );
-	void		Reset();
-	
-	void		MarkAccess( int access_index, int color );
-	void		MarkAccesses( int current_access );
+	void ShowAssignedAccess();
+	void ShowGlobalAccess();
+	void EnableWindow(BOOL enable = TRUE);
+	void Reset();
 
+	void MarkAccess(int access_index, int color);
+	void MarkAccesses(int current_access);
+
 // Overrides
 	// ClassWizard generate virtual function overrides
 	//{{AFX_VIRTUAL(CPageAccess)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
+
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 
-	void		SetGlobalButtons( BOOL enable = TRUE );
-	void		SetAssignedButtons( BOOL enable = TRUE );
-	void		SetAssignedAccess( BOOL enable = TRUE );
-	void		Move( int desired_index );
+	void SetGlobalButtons(BOOL enable = TRUE);
+	void SetAssignedButtons(BOOL enable = TRUE);
+	void SetAssignedAccess(BOOL enable = TRUE);
+	void Move(int desired_index);
 
-	void		Insert( CPoint point );		// Inserts an item into the assigned list before the currently selected item.
-	void		InsertAt( int insert_index );
-	void		Remove();	// Removes the item in the assigned list specified by item_index.
-	BOOL		Edit();
-	void		Delete();
+	void Insert(CPoint point);	// Inserts an item into the assigned list before the currently selected item.
+	void InsertAt(int insert_index);
+	void Remove();		// Removes the item in the assigned list specified by item_index.
+	BOOL Edit();
+	void Delete();
 
-	CImageList	m_AssignedImageList;	// LEDs indicate which access spec has run, is running, and will run.
-	CImageList	m_GlobalImageList;		// Icons indicate which access specs get assigned by default to which type of worker.
-	CImageList*	p_DragImage;
-	BOOL		global_dragging;	// indicates that an item is being dragged 
-									// from the global list to the assigned list.
-	BOOL		assigned_dragging;	// indicates that an item is being dragged 
-									// within the assigned list.
+	CImageList m_AssignedImageList;	// LEDs indicate which access spec has run, is running, and will run.
+	CImageList m_GlobalImageList;	// Icons indicate which access specs get assigned by default to which type of worker.
+	CImageList *p_DragImage;
+	BOOL global_dragging;	// indicates that an item is being dragged 
 
+	// from the global list to the assigned list.
+	BOOL assigned_dragging;	// indicates that an item is being dragged 
+
+	// within the assigned list.
+
 	// Generated message map functions
 	//{{AFX_MSG(CPageAccess)
 	virtual BOOL OnInitDialog();
@@ -161,23 +161,23 @@
 	afx_msg void OnBRemove();
 	afx_msg void OnBDown();
 	afx_msg void OnBUp();
-	afx_msg void OnDblclkLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnBegindragLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
-	afx_msg void OnItemchangedLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnBegindragLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnItemchangedLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnSetfocusLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnSetfocusLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnDblclkLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnBegindragLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg BOOL OnSetCursor(CWnd * pWnd, UINT nHitTest, UINT message);
+	afx_msg void OnItemchangedLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnBegindragLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnItemchangedLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnSetfocusLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnSetfocusLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnBEditCopy();
-	afx_msg void OnKillfocusLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnKillfocusLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnClickLGlobalAccess(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnClickLAssignedAccess(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnKillfocusLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnKillfocusLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnClickLGlobalAccess(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnClickLAssignedAccess(NMHDR * pNMHDR, LRESULT * pResult);
+
 	//}}AFX_MSG
 	DECLARE_MESSAGE_MAP()
 
 };
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/PageDisk.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageDisk.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageDisk.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,13 +64,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "PageDisk.h"
 #include "ManagerList.h"
 #include "GalileoView.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -81,20 +79,19 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageDisk property page
 
 IMPLEMENT_DYNCREATE(CPageDisk, CPropertyPage)
 
-CPageDisk::CPageDisk() : CPropertyPage(CPageDisk::IDD)
+CPageDisk::CPageDisk():CPropertyPage(CPageDisk::IDD)
 {
 	//{{AFX_DATA_INIT(CPageDisk)
 	//}}AFX_DATA_INIT
@@ -104,7 +101,7 @@
 {
 }
 
-void CPageDisk::DoDataExchange(CDataExchange* pDX)
+void CPageDisk::DoDataExchange(CDataExchange * pDX)
 {
 	CPropertyPage::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CPageDisk)
@@ -118,48 +115,43 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CPageDisk, CPropertyPage)
-	//{{AFX_MSG_MAP(CPageDisk)
-	ON_EN_KILLFOCUS(EQueueDepth, OnKillfocusEQueueDepth)
-	ON_EN_KILLFOCUS(EDiskSize, OnKillfocusEDiskSize)
-	ON_EN_KILLFOCUS(EDiskStart, OnKillfocusEDiskStart)
-	ON_EN_SETFOCUS(EQueueDepth, OnSetfocusEQueueDepth)
-	ON_EN_SETFOCUS(EDiskSize, OnSetfocusEDiskSize)
-	ON_EN_SETFOCUS(EDiskStart, OnSetfocusEDiskStart)
-	ON_NOTIFY(TVN_KEYDOWN, TTargets, OnKeydownTTargets)
-	ON_NOTIFY(NM_CLICK, TTargets, OnClickTTargets)
-	ON_EN_KILLFOCUS(EConnectionRate, OnKillfocusEConnectionRate)
-	ON_EN_SETFOCUS(EConnectionRate, OnSetfocusEConnectionRate)
-	ON_NOTIFY(UDN_DELTAPOS, SConnectionRate, OnDeltaposSConnectionRate)
-	ON_BN_CLICKED(CConnectionRate, OnCConnectionRate)
-	ON_NOTIFY(NM_SETFOCUS, TTargets, OnSetfocusTTargets)
-	ON_NOTIFY(TVN_SELCHANGING, TTargets, OnSelchangingTTargets)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CPageDisk)
+    ON_EN_KILLFOCUS(EQueueDepth, OnKillfocusEQueueDepth)
+    ON_EN_KILLFOCUS(EDiskSize, OnKillfocusEDiskSize)
+    ON_EN_KILLFOCUS(EDiskStart, OnKillfocusEDiskStart)
+    ON_EN_SETFOCUS(EQueueDepth, OnSetfocusEQueueDepth)
+    ON_EN_SETFOCUS(EDiskSize, OnSetfocusEDiskSize)
+    ON_EN_SETFOCUS(EDiskStart, OnSetfocusEDiskStart)
+    ON_NOTIFY(TVN_KEYDOWN, TTargets, OnKeydownTTargets)
+    ON_NOTIFY(NM_CLICK, TTargets, OnClickTTargets)
+    ON_EN_KILLFOCUS(EConnectionRate, OnKillfocusEConnectionRate)
+    ON_EN_SETFOCUS(EConnectionRate, OnSetfocusEConnectionRate)
+    ON_NOTIFY(UDN_DELTAPOS, SConnectionRate, OnDeltaposSConnectionRate)
+    ON_BN_CLICKED(CConnectionRate, OnCConnectionRate)
+    ON_NOTIFY(NM_SETFOCUS, TTargets, OnSetfocusTTargets)
+ON_NOTIFY(TVN_SELCHANGING, TTargets, OnSelchangingTTargets)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageDisk message handlers
-
-BOOL CPageDisk::OnInitDialog() 
+BOOL CPageDisk::OnInitDialog()
 {
 	CPropertyPage::OnInitDialog();
 
 	// Associate the image list with the TTargets tree control
-	m_ImageList.Create( IDB_TARGET_ICONS, TARGET_ICON_SIZE, TARGET_ICON_EXPAND, TARGET_ICON_BGCOLOR );
-	m_TTargets.SetImageList( &m_ImageList, TVSIL_NORMAL );
-	m_TTargets.SetImageList( &m_ImageList, TVSIL_STATE ); // Use the same image list for state images
+	m_ImageList.Create(IDB_TARGET_ICONS, TARGET_ICON_SIZE, TARGET_ICON_EXPAND, TARGET_ICON_BGCOLOR);
+	m_TTargets.SetImageList(&m_ImageList, TVSIL_NORMAL);
+	m_TTargets.SetImageList(&m_ImageList, TVSIL_STATE);	// Use the same image list for state images
 
 	// Set the spin control to translate an up click into a positive movement.
-	m_SConnectionRate.SetRange( 0, UD_MAXVAL );
+	m_SConnectionRate.SetRange(0, UD_MAXVAL);
 
 	Reset();
-	return TRUE;  // return TRUE unless you set the focus to a control
-	              // EXCEPTION: OCX Property Pages should return FALSE
+	return TRUE;		// return TRUE unless you set the focus to a control
+	// EXCEPTION: OCX Property Pages should return FALSE
 }
 
-
-
 //
 // Resetting contents of display.
 //
@@ -167,7 +159,7 @@
 {
 	// Clear the target list.
 	m_TTargets.DeleteAllItems();
-	
+
 	// Display the conneciton rate and disk settings.
 	ShowConnectionRate();
 	ShowSettings();
@@ -178,118 +170,107 @@
 	EnableWindow();
 }
 
-
-
 //
 // Enabling controls on the form for user access.
 //
-void CPageDisk::EnableWindow( BOOL enable )
+void CPageDisk::EnableWindow(BOOL enable)
 {
-	Manager	*manager;
-	Worker	*worker;
-	CWnd	*last_focused;
+	Manager *manager;
+	Worker *worker;
+	CWnd *last_focused;
 
 	// Only enable things if a test is not running.
-	if ( theApp.test_state != TestIdle )
+	if (theApp.test_state != TestIdle)
 		return;
 
 	// Get the current worker and manager selections.
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
 	worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		// Enable the target list only if the selected worker is a disk worker.
-		enable = enable && IsType( worker->Type(), GenericDiskType );
-		m_TTargets.EnableWindow( enable );
+		enable = enable && IsType(worker->Type(), GenericDiskType);
+		m_TTargets.EnableWindow(enable);
 
 		// If the selected worker is not a disk worker, switch to the network
 		// target page.
-		if ( !IsType( worker->Type(), GenericDiskType ) && 
-			theApp.pView->m_pPropSheet->GetActiveIndex() == DISK_PAGE )
-		{
+		if (!IsType(worker->Type(), GenericDiskType) &&
+		    theApp.pView->m_pPropSheet->GetActiveIndex() == DISK_PAGE) {
 			last_focused = GetFocus();
-			theApp.pView->m_pPropSheet->SetActivePage( NETWORK_PAGE );
-			if ( last_focused )
+			theApp.pView->m_pPropSheet->SetActivePage(NETWORK_PAGE);
+			if (last_focused)
 				last_focused->SetFocus();
 		}
 		break;
 	case MANAGER:
 		// Enable the target list only if the selected manager has a 
 		// disk worker.
-		enable = enable && manager->WorkerCount( GenericDiskType );
-		m_TTargets.EnableWindow( enable );
+		enable = enable && manager->WorkerCount(GenericDiskType);
+		m_TTargets.EnableWindow(enable);
 
 		// If the selected manager has no disk workers but has network server
 		// workers, switch to the network target page.
-		if ( !manager->WorkerCount( GenericDiskType ) && 
-			manager->WorkerCount( GenericServerType ) && 
-			theApp.pView->m_pPropSheet->GetActiveIndex() == DISK_PAGE )
-		{
+		if (!manager->WorkerCount(GenericDiskType) &&
+		    manager->WorkerCount(GenericServerType) &&
+		    theApp.pView->m_pPropSheet->GetActiveIndex() == DISK_PAGE) {
 			enable = FALSE;
 			last_focused = GetFocus();
-			theApp.pView->m_pPropSheet->SetActivePage( NETWORK_PAGE );
-			if ( last_focused )
+			theApp.pView->m_pPropSheet->SetActivePage(NETWORK_PAGE);
+			if (last_focused)
 				last_focused->SetFocus();
 		}
 		break;
 	case ALL_MANAGERS:
 		// Only enable the connection rate controls if there exists a
 		// GenericDiskType worker.
-		enable = enable && theApp.manager_list.WorkerCount( GenericDiskType );
-		
+		enable = enable && theApp.manager_list.WorkerCount(GenericDiskType);
+
 		// The target list is disabled for all managers.
-		m_TTargets.EnableWindow( FALSE );
+		m_TTargets.EnableWindow(FALSE);
 	}
 
 	// Enable the connection rate check box.
-	m_CConnectionRate.EnableWindow( enable );
+	m_CConnectionRate.EnableWindow(enable);
 
 	// Enable the connection rate edit box and spin control if the connection 
 	// rate check box is checked.
-	m_EConnectionRate.EnableWindow( enable &&
-		m_CConnectionRate.GetCheck() == 1 );
-	m_SConnectionRate.EnableWindow( enable &&
-		m_CConnectionRate.GetCheck() == 1 );
+	m_EConnectionRate.EnableWindow(enable && m_CConnectionRate.GetCheck() == 1);
+	m_SConnectionRate.EnableWindow(enable && m_CConnectionRate.GetCheck() == 1);
 
 	// Enable the disk parameter controls.
-	m_EDiskStart.EnableWindow( enable );
-	m_EDiskSize.EnableWindow( enable );
-	m_EQueueDepth.EnableWindow( enable );
-		
+	m_EDiskStart.EnableWindow(enable);
+	m_EDiskSize.EnableWindow(enable);
+	m_EQueueDepth.EnableWindow(enable);
+
 	// The spin button sometimes needs to be redrawn even if it didn't change
 	// when the edit box was partially redrawn.
-	m_SConnectionRate.Invalidate( TRUE );
+	m_SConnectionRate.Invalidate(TRUE);
 
 	// Redraw the page.  Note that all the child windows will be redrawn too.
 	// Also note that only windows that have already been invalidated will get
 	// redrawn, avoiding much flicker.
-	RedrawWindow( NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE );
+	RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE);
 }
 
-
-
 //
 // Displays the values from memory in the GUI.
 //
 void CPageDisk::ShowData()
 {
-	Manager	*manager;
-	Worker	*worker;
+	Manager *manager;
+	Worker *worker;
 
 	// Only enable the display if a disk worker or a manager with disk 
 	// interfaces is selected.
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
 	worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-	if (( theApp.pView->m_pWorkerView->GetSelectedType() == ALL_MANAGERS) ||
-		( manager && !manager->InterfaceCount( GenericDiskType ) ) ||
-		( worker && !IsType( worker->Type(), GenericDiskType ) ) )
-	{
+	if ((theApp.pView->m_pWorkerView->GetSelectedType() == ALL_MANAGERS) ||
+	    (manager && !manager->InterfaceCount(GenericDiskType)) ||
+	    (worker && !IsType(worker->Type(), GenericDiskType))) {
 		Reset();
 		return;
 	}
-
 	// This is a new view of the target assignment.  
 	// It has not been modified.
 	selected = NULL;
@@ -308,24 +289,21 @@
 	EnableWindow();
 }
 
-
-
 //
 // Fill in the target list.
 //
 void CPageDisk::ShowTargets()
 {
-	int				i, iface_count;
-	Manager			*manager;
-	Target_Spec		*disk;
-	TV_INSERTSTRUCT	tvstruct;
+	int i, iface_count;
+	Manager *manager;
+	Target_Spec *disk;
+	TV_INSERTSTRUCT tvstruct;
 
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-	if ( !manager )
+	if (!manager)
 		return;
 
-	tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | 
-		TVIF_STATE;
+	tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_STATE;
 	// Set the state mask to indicate that the state parameter refers to the
 	// index of the state image in the state image list.
 	tvstruct.item.stateMask = TVIS_STATEIMAGEMASK;
@@ -337,81 +315,71 @@
 	// Clear the contents.
 	m_TTargets.DeleteAllItems();
 
-	iface_count = manager->InterfaceCount( GenericDiskType );
-	for ( i = 0; i < iface_count; i++ )
-	{
+	iface_count = manager->InterfaceCount(GenericDiskType);
+	for (i = 0; i < iface_count; i++) {
 		// name the disk
-		disk = manager->GetInterface( i, GenericDiskType );
+		disk = manager->GetInterface(i, GenericDiskType);
 		tvstruct.item.pszText = disk->name;
 
 		// set the icon associated with the disk
-		switch ( disk->type )
-		{
+		switch (disk->type) {
 		case PhysicalDiskType:
 			tvstruct.item.iImage = TARGET_ICON_PHYSDISK;
 			tvstruct.item.iSelectedImage = TARGET_ICON_PHYSDISK;
 			break;
 		case LogicalDiskType:
-			if ( disk->disk_info.ready )
-			{
+			if (disk->disk_info.ready) {
 				tvstruct.item.iImage = TARGET_ICON_LOGDISK_PREPARED;
 				tvstruct.item.iSelectedImage = TARGET_ICON_LOGDISK_PREPARED;
-			}
-			else
-			{
+			} else {
 				tvstruct.item.iImage = TARGET_ICON_LOGDISK_UNPREPARED;
 				tvstruct.item.iSelectedImage = TARGET_ICON_LOGDISK_UNPREPARED;
 			}
 			break;
 		default:
-			ErrorMessage( "Unexpected disk type in CPageDisk::ShowTargets()");
+			ErrorMessage("Unexpected disk type in CPageDisk::ShowTargets()");
 			return;
 		}
 
-		tvstruct.item.state = INDEXTOSTATEIMAGEMASK ( TARGET_STATE_UNKNOWN );
+		tvstruct.item.state = INDEXTOSTATEIMAGEMASK(TARGET_STATE_UNKNOWN);
 
 		// finally, insert the disk into the tree control
-		if ( m_TTargets.InsertItem( &tvstruct ) == NULL )
-		{
+		if (m_TTargets.InsertItem(&tvstruct) == NULL) {
 			ErrorMessage("InsertItem() failed in CPageDisk::ShowTargets()");
 			return;
 		}
 	}
 }
 
-
-
 void CPageDisk::ShowTargetSelection()
 {
-	Manager			*manager;
-	Worker			*worker;
-	HTREEITEM		hiface;
-	int				w, i, expected_worker, iface_count, wkr_count;
-	TargetSelType	state;
-	Target_Spec		target_info;
+	Manager *manager;
+	Worker *worker;
+	HTREEITEM hiface;
+	int w, i, expected_worker, iface_count, wkr_count;
+	TargetSelType state;
+	Target_Spec target_info;
 
 	// Get the selected manager.
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
 	// Get the first disk item from the target tree.
 	hiface = m_TTargets.GetRootItem();
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		// A worker is selected, show its assigned targets.
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
 		// Loop through the manager's disks, and mark which ones are selected
 		// for the worker.
-		iface_count = manager->InterfaceCount( GenericDiskType );
-		for ( i = 0; i < iface_count; i++ )
-		{
-			if ( worker->IsTargetAssigned( manager->GetInterface(i, GenericDiskType)))
-				SetSelectionCheck( hiface, TargetChecked );
+		iface_count = manager->InterfaceCount(GenericDiskType);
+		for (i = 0; i < iface_count; i++) {
+			if (worker->IsTargetAssigned(manager->GetInterface(i, GenericDiskType)))
+				SetSelectionCheck(hiface, TargetChecked);
 			else
-				SetSelectionCheck( hiface, TargetUnChecked );
+				SetSelectionCheck(hiface, TargetUnChecked);
 
-			hiface = m_TTargets.GetNextSiblingItem( hiface );
+			hiface = m_TTargets.GetNextSiblingItem(hiface);
 		}
 		break;
 
@@ -421,44 +389,35 @@
 
 		// Loop through the manager's disks, and see if they are assigned
 		// to the expected worker.  If not, gray all of them and return.
-		iface_count = manager->InterfaceCount( GenericDiskType );
-		wkr_count = manager->WorkerCount( GenericDiskType );
-		for ( i = 0; i < iface_count; i++ )
-		{
-			memcpy( &target_info, manager->GetInterface( i, GenericDiskType ), 
-				sizeof( Target_Spec ) );
+		iface_count = manager->InterfaceCount(GenericDiskType);
+		wkr_count = manager->WorkerCount(GenericDiskType);
+		for (i = 0; i < iface_count; i++) {
+			memcpy(&target_info, manager->GetInterface(i, GenericDiskType), sizeof(Target_Spec));
 			state = TargetUnChecked;
-			for ( w = 0; w < wkr_count; w++ )
-			{
+			for (w = 0; w < wkr_count; w++) {
 				// If the disk is selected by any other than expected
 				// worker, all the disk check boxes are grayed.
-				if ( manager->GetWorker(w, GenericDiskType)->IsTargetAssigned(
-					&target_info ) )
-				{
-					if ( w != expected_worker || state != TargetUnChecked )
-					{
-						SetAllCheck( TargetGrayed );
+				if (manager->GetWorker(w, GenericDiskType)->IsTargetAssigned(&target_info)) {
+					if (w != expected_worker || state != TargetUnChecked) {
+						SetAllCheck(TargetGrayed);
 						return;
 					}
 					state = TargetChecked;
-					if ( ++expected_worker == wkr_count )
-					{
+					if (++expected_worker == wkr_count) {
 						expected_worker = 0;
 					}
 				}
 			}
-			SetSelectionCheck( hiface, state );
-			hiface = m_TTargets.GetNextSiblingItem( hiface );
+			SetSelectionCheck(hiface, state);
+			hiface = m_TTargets.GetNextSiblingItem(hiface);
 		}
 		break;
 	default:
-		SetAllCheck( TargetGrayed );
+		SetAllCheck(TargetGrayed);
 		break;
 	}
 }
 
-
-
 //
 // Displays the connection rate settings for the current selection in the
 // worker view.  If the selection is a manager or all managers, displays
@@ -466,179 +425,142 @@
 //
 void CPageDisk::ShowConnectionRate()
 {
-	Manager	*manager;
-	Worker	*worker;
-	int trans_per_conn=0;
-	int test_connection_rate=0;
+	Manager *manager;
+	Worker *worker;
+	int trans_per_conn = 0;
+	int test_connection_rate = 0;
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		// update controls with worker's data
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		if ( IsType( worker->Type(), GenericDiskType ) )
-		{
-			trans_per_conn = worker->GetTransPerConn( GenericDiskType );
-			test_connection_rate = worker->GetConnectionRate( GenericDiskType );
+		if (IsType(worker->Type(), GenericDiskType)) {
+			trans_per_conn = worker->GetTransPerConn(GenericDiskType);
+			test_connection_rate = worker->GetConnectionRate(GenericDiskType);
 		}
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		trans_per_conn = 
-			manager->GetTransPerConn( GenericDiskType );
-		test_connection_rate = 
-			manager->GetConnectionRate( GenericDiskType );
+		trans_per_conn = manager->GetTransPerConn(GenericDiskType);
+		test_connection_rate = manager->GetConnectionRate(GenericDiskType);
 		break;
 	default:
-		trans_per_conn = 
-			theApp.manager_list.GetTransPerConn( GenericDiskType );
-		test_connection_rate = 
-			theApp.manager_list.GetConnectionRate( GenericDiskType );
+		trans_per_conn = theApp.manager_list.GetTransPerConn(GenericDiskType);
+		test_connection_rate = theApp.manager_list.GetConnectionRate(GenericDiskType);
 		break;
 	}
 	// If the test connection rate settings are different between a manager's
 	// workers, set the state of the check box to AUTO3STATE and disable the
 	// edit box and spin control.
-	SetDlgItemInt( EConnectionRate, trans_per_conn );
-	if ( test_connection_rate == AMBIGUOUS_VALUE )
-	{
-		m_CConnectionRate.SetButtonStyle( BS_AUTO3STATE );
-		m_EConnectionRate.SetPasswordChar( 32 );
-		m_EConnectionRate.Invalidate( TRUE );
+	SetDlgItemInt(EConnectionRate, trans_per_conn);
+	if (test_connection_rate == AMBIGUOUS_VALUE) {
+		m_CConnectionRate.SetButtonStyle(BS_AUTO3STATE);
+		m_EConnectionRate.SetPasswordChar(32);
+		m_EConnectionRate.Invalidate(TRUE);
 
 		// Set check box to undetermined state.
-		CheckDlgButton( CConnectionRate, 2 );
-	}
-	else
-	{
-		m_CConnectionRate.SetButtonStyle( BS_AUTOCHECKBOX );
-		CheckDlgButton( CConnectionRate, test_connection_rate );
+		CheckDlgButton(CConnectionRate, 2);
+	} else {
+		m_CConnectionRate.SetButtonStyle(BS_AUTOCHECKBOX);
+		CheckDlgButton(CConnectionRate, test_connection_rate);
 
-		if ( test_connection_rate == ENABLED_VALUE && trans_per_conn != 
-			AMBIGUOUS_VALUE )
-		{
-			m_EConnectionRate.SetPasswordChar( 0 );
-		}
-		else
-		{
-			m_EConnectionRate.SetPasswordChar( 32 );
+		if (test_connection_rate == ENABLED_VALUE && trans_per_conn != AMBIGUOUS_VALUE) {
+			m_EConnectionRate.SetPasswordChar(0);
+		} else {
+			m_EConnectionRate.SetPasswordChar(32);
 			m_EConnectionRate.Invalidate();
 		}
 	}
 }
 
-
-
 //
 // Shows the selected item's disk starting sector, size, and queue depth.
 //
 void CPageDisk::ShowSettings()
 {
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
 	int disk_size;
 	int disk_start;
 	int queue_depth;
 
 	// Get the values for the disk settings from memory.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		disk_size = worker->GetDiskSize( GenericDiskType );
-		disk_start = worker->GetDiskStart( GenericDiskType );
-		queue_depth = worker->GetQueueDepth( GenericDiskType );
+		disk_size = worker->GetDiskSize(GenericDiskType);
+		disk_start = worker->GetDiskStart(GenericDiskType);
+		queue_depth = worker->GetQueueDepth(GenericDiskType);
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		disk_size = manager->GetDiskSize( GenericDiskType );
-		disk_start = manager->GetDiskStart( GenericDiskType );
-		queue_depth = manager->GetQueueDepth( GenericDiskType );
+		disk_size = manager->GetDiskSize(GenericDiskType);
+		disk_start = manager->GetDiskStart(GenericDiskType);
+		queue_depth = manager->GetQueueDepth(GenericDiskType);
 		break;
 	default:
-		disk_size = theApp.manager_list.GetDiskSize( GenericDiskType );
-		disk_start = theApp.manager_list.GetDiskStart( GenericDiskType );
-		queue_depth = theApp.manager_list.GetQueueDepth( GenericDiskType );
+		disk_size = theApp.manager_list.GetDiskSize(GenericDiskType);
+		disk_start = theApp.manager_list.GetDiskStart(GenericDiskType);
+		queue_depth = theApp.manager_list.GetQueueDepth(GenericDiskType);
 	}
 	// If there is a displayable value, display it.  Otherwise, hide the content
 	// of the edit box.
-	if ( disk_size == AMBIGUOUS_VALUE )
-	{
-		m_EDiskSize.SetPasswordChar( 32 );
+	if (disk_size == AMBIGUOUS_VALUE) {
+		m_EDiskSize.SetPasswordChar(32);
 		m_EDiskSize.Invalidate();
+	} else {
+		m_EDiskSize.SetPasswordChar(0);
+		SetDlgItemInt(EDiskSize, disk_size);
 	}
-	else
-	{
-		m_EDiskSize.SetPasswordChar( 0 );
-		SetDlgItemInt( EDiskSize, disk_size );
-	}
 
-	if ( disk_start == AMBIGUOUS_VALUE )
-	{
-		m_EDiskStart.SetPasswordChar( 32 );
+	if (disk_start == AMBIGUOUS_VALUE) {
+		m_EDiskStart.SetPasswordChar(32);
 		m_EDiskStart.Invalidate();
+	} else {
+		m_EDiskStart.SetPasswordChar(0);
+		SetDlgItemInt(EDiskStart, disk_start);
 	}
-	else
-	{
-		m_EDiskStart.SetPasswordChar( 0 );
-		SetDlgItemInt( EDiskStart, disk_start );
-	}
-	
-	if ( queue_depth == AMBIGUOUS_VALUE )
-	{
-		m_EQueueDepth.SetPasswordChar( 32 );
+
+	if (queue_depth == AMBIGUOUS_VALUE) {
+		m_EQueueDepth.SetPasswordChar(32);
 		m_EQueueDepth.Invalidate();
+	} else {
+		m_EQueueDepth.SetPasswordChar(0);
+		SetDlgItemInt(EQueueDepth, queue_depth);
 	}
-	else
-	{
-		m_EQueueDepth.SetPasswordChar( 0 );
-		SetDlgItemInt( EQueueDepth, queue_depth );
-	}
 }
 
-
-
 //
 // Sets the focus to the item specified by cursor movement.
 //
 void CPageDisk::ShowFocus()
 {
-	for ( HTREEITEM hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = 
-		m_TTargets.GetNextSiblingItem( hdisk ) )
-	{
-		if ( hdisk == highlighted )
-		{
-			m_TTargets.SetItemState( hdisk, TVIS_SELECTED, TVIS_SELECTED );
+	for (HTREEITEM hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = m_TTargets.GetNextSiblingItem(hdisk)) {
+		if (hdisk == highlighted) {
+			m_TTargets.SetItemState(hdisk, TVIS_SELECTED, TVIS_SELECTED);
+		} else {
+			m_TTargets.SetItemState(hdisk, NULL, TVIS_SELECTED);
 		}
-		else
-		{
-			m_TTargets.SetItemState( hdisk, NULL, TVIS_SELECTED );
-		}
 	}
 }
 
-
-
 //
 // Used to select one or more targets.  May or may not clear any pervious
 // selection depending on the replace parameter.
 //
-void CPageDisk::SelectRange( HTREEITEM hstart, HTREEITEM hend, BOOL replace,
-	TargetSelType state )
+void CPageDisk::SelectRange(HTREEITEM hstart, HTREEITEM hend, BOOL replace, TargetSelType state)
 {
 	HTREEITEM hdisk;
 	BOOL in_range;
 
-	if ( !hstart || !hend )
-	{
-		ErrorMessage( "Unexpectedly found start or end point of selection"
-			" range equal NULL in CPageDisk::SelectRange()." );
+	if (!hstart || !hend) {
+		ErrorMessage("Unexpectedly found start or end point of selection"
+			     " range equal NULL in CPageDisk::SelectRange().");
 		return;
 	}
-
 	// Clear all the check boxes if forced to or if a multiple selection occurs.
-	if ( replace )
-		SetAllCheck( TargetUnChecked );
+	if (replace)
+		SetAllCheck(TargetUnChecked);
 
 	// The last selection is the start point.
 	selected = hstart;
@@ -646,12 +568,10 @@
 
 	// Note that if both endpoints are the same, other selections will be 
 	// unchecked depending on the value of the 'replace' variable.
-	if ( hstart == hend )
-	{
-		SetSelectionCheck( hstart, state );
+	if (hstart == hend) {
+		SetSelectionCheck(hstart, state);
 		return;
 	}
-
 	// Since we don't know the relationship between the clicked item
 	// and the last selection (up or down), we do not know what
 	// direction to select targets in.  Do a linear seach of the target tree
@@ -659,55 +579,47 @@
 	// all the targets the specified selection type until we reach the end or
 	// start (whichever we didn't get before).
 	in_range = FALSE;
-	for ( hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = 
-		m_TTargets.GetNextSiblingItem( hdisk ) )
-	{
+	for (hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = m_TTargets.GetNextSiblingItem(hdisk)) {
 		// Do we have either the previously selected item or the
-		// clicked item?  			
-		if ( hdisk == hstart || hdisk == hend )
+		// clicked item?                        
+		if (hdisk == hstart || hdisk == hend)
 			in_range = !in_range;
 
-		if ( in_range || hdisk == hstart || hdisk == hend )
-			SetSelectionCheck( hdisk, state );
+		if (in_range || hdisk == hstart || hdisk == hend)
+			SetSelectionCheck(hdisk, state);
 	}
 }
 
-
-
 //
 // Sets the specified tree item's check box to the specified state.
 //
-void CPageDisk::SetSelectionCheck( HTREEITEM hitem, TargetSelType selection )
+void CPageDisk::SetSelectionCheck(HTREEITEM hitem, TargetSelType selection)
 {
 	UINT state;
-	switch ( selection )
-	{
+
+	switch (selection) {
 	case TargetUnChecked:
-		state = INDEXTOSTATEIMAGEMASK( TARGET_STATE_UNCHECKED );
+		state = INDEXTOSTATEIMAGEMASK(TARGET_STATE_UNCHECKED);
 		break;
 	case TargetChecked:
-		state = INDEXTOSTATEIMAGEMASK( TARGET_STATE_CHECKED );
+		state = INDEXTOSTATEIMAGEMASK(TARGET_STATE_CHECKED);
 		break;
 	case TargetGrayed:
 	default:
-		state = INDEXTOSTATEIMAGEMASK( TARGET_STATE_UNKNOWN );
+		state = INDEXTOSTATEIMAGEMASK(TARGET_STATE_UNKNOWN);
 		break;
 	}
 	// set the interface icon's associated state icon
-	if ( !m_TTargets.SetItemState( hitem, state, TVIS_STATEIMAGEMASK ) )
+	if (!m_TTargets.SetItemState(hitem, state, TVIS_STATEIMAGEMASK))
 		ErrorMessage("SetItemState() failed in CPageDisk::SetSelectionCheck()");
 }
 
-
-
 //
 // Retrieves the target's check box state.
 //
-TargetSelType CPageDisk::GetSelectionCheck( HTREEITEM hitem )
+TargetSelType CPageDisk::GetSelectionCheck(HTREEITEM hitem)
 {
-	switch ( STATEIMAGEMASKTOINDEX(
-		m_TTargets.GetItemState( hitem, TVIS_STATEIMAGEMASK ) ) )
-	{
+	switch (STATEIMAGEMASKTOINDEX(m_TTargets.GetItemState(hitem, TVIS_STATEIMAGEMASK))) {
 	case TARGET_STATE_CHECKED:
 		return TargetChecked;
 	case TARGET_STATE_UNCHECKED:
@@ -718,61 +630,49 @@
 	}
 }
 
-
-
 //
 // Sets all the interface's check box to the specified state.
 //
-void CPageDisk::SetAllCheck( TargetSelType selection )
+void CPageDisk::SetAllCheck(TargetSelType selection)
 {
-	HTREEITEM	hdisk;
+	HTREEITEM hdisk;
 
 	// Get the first manager item of the target tree
-	for ( hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = 
-		m_TTargets.GetNextSiblingItem( hdisk ) )
-	{
-		SetSelectionCheck( hdisk, selection );
+	for (hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = m_TTargets.GetNextSiblingItem(hdisk)) {
+		SetSelectionCheck(hdisk, selection);
 	}
 }
 
-
-
 //
 // Updates the queue depth if necessary.
 //
-void CPageDisk::OnKillfocusEQueueDepth() 
+void CPageDisk::OnKillfocusEQueueDepth()
 {
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
+
 	// If the disk queue was left blank, use the previous value
-	if ( !m_EQueueDepth.LineLength() )
-	{
+	if (!m_EQueueDepth.LineLength()) {
 		ShowSettings();
 	}
 	// Verify that the queue depth is > 0.
-	else if ( GetDlgItemInt( EQueueDepth ) <= 0 )
-	{
-		ErrorMessage( "# of Outstanding I/Os cannot be 0." );
+	else if (GetDlgItemInt(EQueueDepth) <= 0) {
+		ErrorMessage("# of Outstanding I/Os cannot be 0.");
 		ShowSettings();
 		return;
-	}
-	else
-	{
+	} else {
 		// Seeing what kind of item is selected.
-		switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-		{
+		switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 		case WORKER:
 			worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-			worker->SetQueueDepth( GetDlgItemInt( EQueueDepth ) );
+			worker->SetQueueDepth(GetDlgItemInt(EQueueDepth));
 			break;
 		case MANAGER:
 			manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-			manager->SetQueueDepth( GetDlgItemInt( EQueueDepth ), 
-				GenericDiskType );
+			manager->SetQueueDepth(GetDlgItemInt(EQueueDepth), GenericDiskType);
 			break;
 		case ALL_MANAGERS:
-			theApp.manager_list.SetQueueDepth( GetDlgItemInt( EQueueDepth ),
-				GenericDiskType );
+			theApp.manager_list.SetQueueDepth(GetDlgItemInt(EQueueDepth), GenericDiskType);
 			break;
 		}
 	}
@@ -780,125 +680,119 @@
 	EnableWindow();
 }
 
-
 //
 // Updates the disk size to access if necessary.
 //
-void CPageDisk::OnKillfocusEDiskSize() 
+void CPageDisk::OnKillfocusEDiskSize()
 {
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
+
 	// If the disk size was left blank, use the previous value.
-	if ( !m_EDiskSize.LineLength() )
+	if (!m_EDiskSize.LineLength())
 		ShowSettings();
 	else
-	// Seeing what kind of item is selected.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
-	case WORKER:
-		// Recording disk attributes.
-		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		worker->SetDiskSize( GetDlgItemInt( EDiskSize ) );
-		break;
-	case MANAGER:
-		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		manager->SetDiskSize( GetDlgItemInt( EDiskSize ) );
-		break;
-	case ALL_MANAGERS:
-		theApp.manager_list.SetDiskSize( GetDlgItemInt( EDiskSize ) );
-		break;
-	}
+		// Seeing what kind of item is selected.
+		switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
+		case WORKER:
+			// Recording disk attributes.
+			worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
+			worker->SetDiskSize(GetDlgItemInt(EDiskSize));
+			break;
+		case MANAGER:
+			manager = theApp.pView->m_pWorkerView->GetSelectedManager();
+			manager->SetDiskSize(GetDlgItemInt(EDiskSize));
+			break;
+		case ALL_MANAGERS:
+			theApp.manager_list.SetDiskSize(GetDlgItemInt(EDiskSize));
+			break;
+		}
 
 	EnableWindow();
 }
 
-
 //
 // Updates the starting sector if necessary.
 //
-void CPageDisk::OnKillfocusEDiskStart() 
+void CPageDisk::OnKillfocusEDiskStart()
 {
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
+
 	// If the disk starting sector was left blank, use the previous value.
-	if ( !m_EDiskStart.LineLength() )
+	if (!m_EDiskStart.LineLength())
 		ShowSettings();
 	else
-	// Seeing what kind of item is selected.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
-	case WORKER:
-		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		worker->SetDiskStart( GetDlgItemInt( EDiskStart ) );
-		break;
-	case MANAGER:
-		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		manager->SetDiskStart( GetDlgItemInt( EDiskStart ) );
-		break;
-	case ALL_MANAGERS:
-		theApp.manager_list.SetDiskStart( GetDlgItemInt( EDiskStart ) );
-		break;
-	}
+		// Seeing what kind of item is selected.
+		switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
+		case WORKER:
+			worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
+			worker->SetDiskStart(GetDlgItemInt(EDiskStart));
+			break;
+		case MANAGER:
+			manager = theApp.pView->m_pWorkerView->GetSelectedManager();
+			manager->SetDiskStart(GetDlgItemInt(EDiskStart));
+			break;
+		case ALL_MANAGERS:
+			theApp.manager_list.SetDiskStart(GetDlgItemInt(EDiskStart));
+			break;
+		}
 
 	EnableWindow();
 }
 
-
-
 ///////////////////////////////////////////////////////////////////////////////
 // 
 // Makes the contents of the edit boxes visible when they receive the focus.
 //
 ///////////////////////////////////////////////////////////////////////////////
-void CPageDisk::OnSetfocusEQueueDepth() 
+void CPageDisk::OnSetfocusEQueueDepth()
 {
-	EditSetfocus( &m_EQueueDepth );
+	EditSetfocus(&m_EQueueDepth);
 }
 
-void CPageDisk::OnSetfocusEDiskSize() 
+void CPageDisk::OnSetfocusEDiskSize()
 {
-	EditSetfocus( &m_EDiskSize );
+	EditSetfocus(&m_EDiskSize);
 }
 
-void CPageDisk::OnSetfocusEDiskStart() 
+void CPageDisk::OnSetfocusEDiskStart()
 {
-	EditSetfocus( &m_EDiskStart );
+	EditSetfocus(&m_EDiskStart);
 }
 
-void CPageDisk::EditSetfocus( CEdit* edit )
+void CPageDisk::EditSetfocus(CEdit * edit)
 {
-	if ( !edit->GetPasswordChar() )
+	if (!edit->GetPasswordChar())
 		return;
 
 	// Select everything in the edit box.
-	edit->SetSel( 0, -1 );
+	edit->SetSel(0, -1);
 	// Clear selection.
 	edit->Clear();
 	// Make the characters visible.
-	edit->SetPasswordChar( 0 );
+	edit->SetPasswordChar(0);
 }
 
-
-
 //
 // Mouse click handler for target tree.
 //
-void CPageDisk::OnClickTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageDisk::OnClickTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	CPoint point;
 	TV_HITTESTINFO test_info;
 	TargetSelType state;
 
 	// Get the cursor position.
-	GetCursorPos( &point );
+	GetCursorPos(&point);
 	test_info.pt = point;
-	m_TTargets.ScreenToClient( &(test_info.pt) );
+	m_TTargets.ScreenToClient(&(test_info.pt));
 
 	// Check to see whether the cursor is on an item.
-	m_TTargets.HitTest( &test_info );
+	m_TTargets.HitTest(&test_info);
 
 	// Check that we have an disk item.
-	if ( !test_info.hItem )
+	if (!test_info.hItem)
 		return;
 
 	// A new target assignment is being made.  Clear the results since they are
@@ -906,43 +800,31 @@
 	theApp.pView->ResetDisplayforNewTest();
 
 	// Toggle the selection if the control key is pressed.
-	if ( GetKeyState( VK_CONTROL ) & 0x8000 && 
-		GetSelectionCheck( test_info.hItem ) == TargetChecked )
-	{
+	if (GetKeyState(VK_CONTROL) & 0x8000 && GetSelectionCheck(test_info.hItem) == TargetChecked) {
 		state = TargetUnChecked;
-	}
-	else
-	{
+	} else {
 		state = TargetChecked;
 	}
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 	case MANAGER:
 		// A shift click extends the selection from the last selected item
 		// to the currently focused item.  When the control key is also
 		// pressed, any previous selection is not cleared.
-		if ( (GetKeyState( VK_SHIFT ) & 0x8000 ) && selected )
-		{
+		if ((GetKeyState(VK_SHIFT) & 0x8000) && selected) {
 			// We have a previous item (not the first click) and the shift
 			// key is down.
-			SelectRange( selected, test_info.hItem, 
-				!(GetKeyState( VK_CONTROL ) & 0x8000 ) );
-		}
-		else if ( GetKeyState( VK_CONTROL ) & 0x8000 )
-		{
+			SelectRange(selected, test_info.hItem, !(GetKeyState(VK_CONTROL) & 0x8000));
+		} else if (GetKeyState(VK_CONTROL) & 0x8000) {
 			// The control key is down.
-			SelectRange( test_info.hItem, test_info.hItem, FALSE, state );
+			SelectRange(test_info.hItem, test_info.hItem, FALSE, state);
+		} else {
+			SelectRange(test_info.hItem, test_info.hItem, TRUE, state);
 		}
-		else 
-		{
-			SelectRange( test_info.hItem, test_info.hItem, TRUE, state );
-		}
 		break;
 	default:
-		ErrorMessage( "Unexpected selection type in CPageNetwork::"
-			"OnClickTTargets()." );
+		ErrorMessage("Unexpected selection type in CPageNetwork::" "OnClickTTargets().");
 		return;
 	}
 
@@ -952,108 +834,92 @@
 	*pResult = 0;
 }
 
-
-
 //
 // Multi selection keyboard handler for the tree control.
 //
-void CPageDisk::KeyMultiSel( WORD wVKey )
+void CPageDisk::KeyMultiSel(WORD wVKey)
 {
-	BOOL shift = GetKeyState( VK_SHIFT ) & 0x8000;
-	BOOL control = GetKeyState( VK_CONTROL ) & 0x8000;
+	BOOL shift = GetKeyState(VK_SHIFT) & 0x8000;
+	BOOL control = GetKeyState(VK_CONTROL) & 0x8000;
 
 	// Make sure there are disks.
-	if ( !highlighted )
+	if (!highlighted)
 		return;
 
-	switch ( wVKey )
-	{
+	switch (wVKey) {
 	case VK_UP:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 		SetFocusUp();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_DOWN:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 
 		SetFocusDown();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_HOME:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 
 		SetFocusHome();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_END:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 
 		SetFocusEnd();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_SPACE:
-		if ( shift ) 
-		{
+		if (shift) {
 			// Extend the selection. Clear any other items if the control
 			// key is not pressed.
-			SelectRange( selected, highlighted, !control, TargetChecked );
-		}
-		else if ( control )	// toggle.
+			SelectRange(selected, highlighted, !control, TargetChecked);
+		} else if (control)	// toggle.
 		{
 			// Toggle the selection, but do not clear any other items.
-			if ( GetSelectionCheck( highlighted ) == TargetChecked )
-			{
-				SelectRange( highlighted, highlighted, FALSE, TargetUnChecked );
+			if (GetSelectionCheck(highlighted) == TargetChecked) {
+				SelectRange(highlighted, highlighted, FALSE, TargetUnChecked);
+			} else {
+				SelectRange(highlighted, highlighted, FALSE, TargetChecked);
 			}
-			else
-			{
-				SelectRange( highlighted, highlighted, FALSE, TargetChecked );
-			}
-		}
-		else // normal
+		} else		// normal
 		{
 			// Select only the highlighted item and clear any other.
-			SelectRange( highlighted, highlighted, TRUE, TargetChecked );
+			SelectRange(highlighted, highlighted, TRUE, TargetChecked);
 		}
 
 		ShowFocus();
 		StoreTargetSelection();
 		break;
 	case 'A':
-		if ( control )
-		{
-			SetAllCheck( TargetChecked );
+		if (control) {
+			SetAllCheck(TargetChecked);
 			StoreTargetSelection();
 		}
 	}
 }
 
-
-
 // 
 // The SetFocusUp, Down, Home, and End functions handle keyboard input for
 // the target tree and move the focus.
@@ -1062,16 +928,16 @@
 {
 	HTREEITEM hdisk;
 
-	hdisk = m_TTargets.GetPrevSiblingItem( highlighted );
+	hdisk = m_TTargets.GetPrevSiblingItem(highlighted);
 	// Does the currently selected interface have a previous sibling?
-	if ( !hdisk )
+	if (!hdisk)
 		return;
 
 	// Yes. Set the focus to the sibling.
 	highlighted = hdisk;
 
 	// Make the newly focused disk visible.
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
@@ -1079,16 +945,16 @@
 {
 	HTREEITEM hdisk;
 
-	hdisk = m_TTargets.GetNextSiblingItem( highlighted );
+	hdisk = m_TTargets.GetNextSiblingItem(highlighted);
 	// Does the currently selected disk have a next sibling?
-	if ( !hdisk )
+	if (!hdisk)
 		return;
-	
+
 	// Yes. Set the focus to the sibling.
 	highlighted = hdisk;
 
 	// Make the newly focused disk visible.
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
@@ -1097,7 +963,7 @@
 	// Set the focus to the first disk.
 	highlighted = m_TTargets.GetRootItem();
 	// Make the newly focused disk visible.
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
@@ -1109,32 +975,29 @@
 	HTREEITEM hdisk;
 
 	// Get the last disk.
-	hdisk = m_TTargets.GetRootItem(); 
-	while ( m_TTargets.GetNextSiblingItem( hdisk ) )
-		hdisk = m_TTargets.GetNextSiblingItem( hdisk);
+	hdisk = m_TTargets.GetRootItem();
+	while (m_TTargets.GetNextSiblingItem(hdisk))
+		hdisk = m_TTargets.GetNextSiblingItem(hdisk);
 
 	highlighted = hdisk;
 
 	// Make the newly focused disk visible.
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
-
-void CPageDisk::OnKeydownTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageDisk::OnKeydownTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;
+	TV_KEYDOWN *pTVKeyDown = (TV_KEYDOWN *) pNMHDR;
 
 	// A new target assignment is being made.  Clear the results since they are
 	// for a configuration we no longer have.
 	theApp.pView->ResetDisplayforNewTest();
 
-	KeyMultiSel( pTVKeyDown->wVKey );
+	KeyMultiSel(pTVKeyDown->wVKey);
 	*pResult = 0;
 }
 
-
-
 //
 // Stores the targets that have been selected by the user with the appropriate
 // worker.
@@ -1143,58 +1006,48 @@
 {
 	HTREEITEM hdisk;
 	Manager *manager;
-	Worker	*worker;
-	int		target = 0;
-	int		next_worker;
-	
+	Worker *worker;
+	int target = 0;
+	int next_worker;
+
 	// Get the selected manager and worker.
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
 	worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
 	// Make sure we have a selected manager (or worker).
-	if ( !manager )
-	{
-		ErrorMessage( "Unexpectedly found no selected manager in "
-			"CPageDisk::StoreTargetSelection." );
+	if (!manager) {
+		ErrorMessage("Unexpectedly found no selected manager in " "CPageDisk::StoreTargetSelection.");
 		return;
 	}
 
-	if ( worker )
-	{
+	if (worker) {
 		// Assign the targets to the selected worker in the order that they
 		// appear in the GUI.
-		worker->RemoveTargets( GenericDiskType );
-		for ( hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = 
-			m_TTargets.GetNextSiblingItem( hdisk ) )
-		{
-			if ( GetSelectionCheck( hdisk ) == TargetChecked )
-				worker->AddTarget( manager->GetInterface( target, GenericDiskType ) );
+		worker->RemoveTargets(GenericDiskType);
+		for (hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = m_TTargets.GetNextSiblingItem(hdisk)) {
+			if (GetSelectionCheck(hdisk) == TargetChecked)
+				worker->AddTarget(manager->GetInterface(target, GenericDiskType));
 			target++;
 		}
-	}
-	else
-	{
+	} else {
 		// Clear the assigned targets from all the manager's workers.
-		manager->RemoveTargets( GenericDiskType );
+		manager->RemoveTargets(GenericDiskType);
 
 		// Set the first worker to receive targets.
-		worker = manager->GetWorker( 0, GenericDiskType );
+		worker = manager->GetWorker(0, GenericDiskType);
 		next_worker = 0;
 
 		// Assign the targets to the workers of the selected manager.
-		for ( hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = 
-			m_TTargets.GetNextSiblingItem( hdisk ) )
-		{
+		for (hdisk = m_TTargets.GetRootItem(); hdisk; hdisk = m_TTargets.GetNextSiblingItem(hdisk)) {
 			// If the disk is selected in the GUI, assign it to the expected
 			// worker.
-			if ( GetSelectionCheck( hdisk ) == TargetChecked )
-			{
-				worker->AddTarget( manager->GetInterface( target, GenericDiskType ));
+			if (GetSelectionCheck(hdisk) == TargetChecked) {
+				worker->AddTarget(manager->GetInterface(target, GenericDiskType));
 
 				// Update who the next worker to receive a target is.
-				if ( ++next_worker >= manager->WorkerCount( GenericDiskType ) )
+				if (++next_worker >= manager->WorkerCount(GenericDiskType))
 					next_worker = 0;
-				worker = manager->GetWorker( next_worker, GenericDiskType );
+				worker = manager->GetWorker(next_worker, GenericDiskType);
 			}
 			target++;
 		}
@@ -1202,124 +1055,105 @@
 	ShowTargetSelection();
 }
 
-
-
-void CPageDisk::OnKillfocusEConnectionRate() 
+void CPageDisk::OnKillfocusEConnectionRate()
 {
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
+
 	// Restores the previous value if the edit box was left blank.
-	if ( !m_EConnectionRate.LineLength() )
-	{
+	if (!m_EConnectionRate.LineLength()) {
 		ShowConnectionRate();
 		return;
 	}
-
 	// Seeing what kind of item is selected.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		worker->SetTransPerConn( GetDlgItemInt( EConnectionRate ) );
+		worker->SetTransPerConn(GetDlgItemInt(EConnectionRate));
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		manager->SetTransPerConn( GetDlgItemInt( EConnectionRate ), 
-			GenericDiskType );
+		manager->SetTransPerConn(GetDlgItemInt(EConnectionRate), GenericDiskType);
 		break;
 	case ALL_MANAGERS:
-		theApp.manager_list.SetTransPerConn( GetDlgItemInt( EConnectionRate ),
-			GenericDiskType );
+		theApp.manager_list.SetTransPerConn(GetDlgItemInt(EConnectionRate), GenericDiskType);
 		break;
 	}
 
 	EnableWindow();
 }
 
-
-void CPageDisk::OnSetfocusEConnectionRate() 
+void CPageDisk::OnSetfocusEConnectionRate()
 {
 	// Select everything in the edit box.
-	EditSetfocus( &m_EConnectionRate );
+	EditSetfocus(&m_EConnectionRate);
 }
 
-
 //
 // Sets the focus to the first disk item.
 //
-void CPageDisk::OnSetfocusTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageDisk::OnSetfocusTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	if ( !highlighted )
-	{
+	if (!highlighted) {
 		//Find the first disk.
 		highlighted = m_TTargets.GetRootItem();
 	}
-
 	// If we found a disk, show the focus.
-	if ( highlighted )
-	{
+	if (highlighted) {
 		ShowFocus();
 	}
 	*pResult = 0;
 }
 
-
-void CPageDisk::OnDeltaposSConnectionRate(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageDisk::OnDeltaposSConnectionRate(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	int trans_per_conn = GetDlgItemInt( EConnectionRate );
-	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
-	
+	int trans_per_conn = GetDlgItemInt(EConnectionRate);
+	NM_UPDOWN *pNMUpDown = (NM_UPDOWN *) pNMHDR;
+
 	trans_per_conn += pNMUpDown->iDelta;
-	if ( trans_per_conn < 0 )
-	{
+	if (trans_per_conn < 0) {
 		trans_per_conn = 0;
 	}
-	SetDlgItemInt( EConnectionRate, trans_per_conn );
+	SetDlgItemInt(EConnectionRate, trans_per_conn);
 	*pResult = 0;
 }
 
-
 //
 // Enables and disables the connection rate edit box depending on the check box state.
-void CPageDisk::OnCConnectionRate() 
+void CPageDisk::OnCConnectionRate()
 {
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
+
 	// change the check box to true/false only (having clicked, cannot 
 	// return to intermediate state)
-	m_CConnectionRate.SetButtonStyle( BS_AUTOCHECKBOX );
-	if ( IsDlgButtonChecked( CConnectionRate ) == 1 && 
-		GetDlgItemInt( EConnectionRate ) != AMBIGUOUS_VALUE )
-	{
+	m_CConnectionRate.SetButtonStyle(BS_AUTOCHECKBOX);
+	if (IsDlgButtonChecked(CConnectionRate) == 1 && GetDlgItemInt(EConnectionRate) != AMBIGUOUS_VALUE) {
 		// Connection rate testing is enabled.  Update the edit box.
-		m_EConnectionRate.SetPasswordChar( 0 );
+		m_EConnectionRate.SetPasswordChar(0);
+	} else {
+		m_EConnectionRate.SetPasswordChar(32);
 	}
-	else
-	{
-		m_EConnectionRate.SetPasswordChar( 32 );
-	}
 	// Seeing what kind of item is selected.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		worker->SetConnectionRate( m_CConnectionRate.GetCheck() );
+		worker->SetConnectionRate(m_CConnectionRate.GetCheck());
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		manager->SetConnectionRate( m_CConnectionRate.GetCheck(), GenericDiskType );
+		manager->SetConnectionRate(m_CConnectionRate.GetCheck(), GenericDiskType);
 		break;
 	case ALL_MANAGERS:
-		theApp.manager_list.SetConnectionRate( m_CConnectionRate.GetCheck(),
-			GenericDiskType );
+		theApp.manager_list.SetConnectionRate(m_CConnectionRate.GetCheck(), GenericDiskType);
 		break;
 	}
 	EnableWindow();
 }
 
-void CPageDisk::OnSelchangingTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageDisk::OnSelchangingTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
+	NM_TREEVIEW *pNMTreeView = (NM_TREEVIEW *) pNMHDR;
 
 	theApp.pView->ResetDisplayforNewTest();
 	ShowFocus();

Modified: branches/IOMETER-restruct/iometer/src/PageDisk.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageDisk.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageDisk.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,71 +60,67 @@
 #ifndef PAGEDISK_DEFINED
 #define PAGEDISK_DEFINED
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageDisk dialog
 
 #include "GalileoApp.h"
 #include "PageTarget.h"
 
-class CPageDisk : public CPropertyPage
-{
+class CPageDisk:public CPropertyPage {
 	DECLARE_DYNCREATE(CPageDisk)
-
 // Construction
-public:
+      public:
 	CPageDisk();
 	~CPageDisk();
 
 	void Reset();
-	void EnableWindow( BOOL enable = TRUE );
+	void EnableWindow(BOOL enable = TRUE);
 	void ShowData();
 	void ShowTargets();
 // Dialog Data
 	//{{AFX_DATA(CPageDisk)
 	enum { IDD = IDD_DISKS };
-	CEdit	m_EQueueDepth;
-	CSpinButtonCtrl	m_SConnectionRate;
-	CButton	m_CConnectionRate;
-	CTreeCtrl	m_TTargets;
-	CEdit	m_EConnectionRate;
-	CEdit	m_EDiskStart;
-	CEdit	m_EDiskSize;
+	CEdit m_EQueueDepth;
+	CSpinButtonCtrl m_SConnectionRate;
+	CButton m_CConnectionRate;
+	CTreeCtrl m_TTargets;
+	CEdit m_EConnectionRate;
+	CEdit m_EDiskStart;
+	CEdit m_EDiskSize;
 	//}}AFX_DATA
 
 // Overrides
 	// ClassWizard generate virtual function overrides
 	//{{AFX_VIRTUAL(CPageDisk)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
-	void	SetFocusUp();
-	void	SetFocusDown();
-	void	SetFocusHome();
-	void	SetFocusEnd();
+      protected:
+	void SetFocusUp();
+	void SetFocusDown();
+	void SetFocusHome();
+	void SetFocusEnd();
 
-	void	ShowConnectionRate();
-	void	ShowTargetSelection();
-	void	ShowSettings();
-	void	ShowFocus();
-	void	StoreTargetSelection();
+	void ShowConnectionRate();
+	void ShowTargetSelection();
+	void ShowSettings();
+	void ShowFocus();
+	void StoreTargetSelection();
 
-	void	SelectRange( HTREEITEM hstart, HTREEITEM hend, BOOL replace = TRUE, 
-						TargetSelType state = TargetChecked );
-	void	SetSelectionCheck( HTREEITEM hitem, TargetSelType selection );
-	TargetSelType	GetSelectionCheck( HTREEITEM hitem );
-	void	SetAllCheck( TargetSelType selection );
-	void	KeyMultiSel( WORD wVKey );
+	void SelectRange(HTREEITEM hstart, HTREEITEM hend, BOOL replace = TRUE, TargetSelType state = TargetChecked);
+	void SetSelectionCheck(HTREEITEM hitem, TargetSelType selection);
+	TargetSelType GetSelectionCheck(HTREEITEM hitem);
+	void SetAllCheck(TargetSelType selection);
+	void KeyMultiSel(WORD wVKey);
 
-	void	EditSetfocus( CEdit* edit );
+	void EditSetfocus(CEdit * edit);
 
-	CImageList	m_ImageList;
-	HTREEITEM	selected;		// The last selected item, or NULL if the 
-								// selection has not changed.
-	HTREEITEM	highlighted;	// The current selection when using the keyboard.
+	CImageList m_ImageList;
+	HTREEITEM selected;	// The last selected item, or NULL if the 
+	// selection has not changed.
+	HTREEITEM highlighted;	// The current selection when using the keyboard.
 
 	// Generated message map functions
 	//{{AFX_MSG(CPageDisk)
@@ -135,18 +131,17 @@
 	afx_msg void OnSetfocusEQueueDepth();
 	afx_msg void OnSetfocusEDiskSize();
 	afx_msg void OnSetfocusEDiskStart();
-	afx_msg void OnKeydownTTargets(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnClickTTargets(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnKeydownTTargets(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnClickTTargets(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnKillfocusEConnectionRate();
 	afx_msg void OnSetfocusEConnectionRate();
-	afx_msg void OnDeltaposSConnectionRate(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnDeltaposSConnectionRate(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnCConnectionRate();
-	afx_msg void OnSetfocusTTargets(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnSelchangingTTargets(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnSetfocusTTargets(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnSelchangingTTargets(NMHDR * pNMHDR, LRESULT * pResult);
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 
 };
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/PageDisplay.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageDisplay.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageDisplay.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,13 +64,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "PageDisplay.h"
 #include "ManagerList.h"
 #include "GalileoView.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -81,22 +79,20 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageDisplay property page
 
 IMPLEMENT_DYNCREATE(CPageDisplay, CPropertyPage)
-
 //
 // Default constructor.
-CPageDisplay::CPageDisplay() : CPropertyPage(CPageDisplay::IDD)
+CPageDisplay::CPageDisplay():CPropertyPage(CPageDisplay::IDD)
 {
 	//{{AFX_DATA_INIT(CPageDisplay)
 	//}}AFX_DATA_INIT
@@ -115,13 +111,11 @@
 	delay_table[10] = 0;
 }
 
-
 CPageDisplay::~CPageDisplay()
 {
 }
 
-
-void CPageDisplay::DoDataExchange(CDataExchange* pDX)
+void CPageDisplay::DoDataExchange(CDataExchange * pDX)
 {
 	CPropertyPage::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CPageDisplay)
@@ -135,58 +129,52 @@
 	//}}AFX_DATA_MAP
 }
 
-
-BOOL CPageDisplay::OnInitDialog() 
+BOOL CPageDisplay::OnInitDialog()
 {
 	CPropertyPage::OnInitDialog();
-	
+
 	// Init all display thingies.
-	m_SUpdateDelay.SetRange( 0, (NUM_UPDATE_TIMES - 1) );
-	m_SUpdateDelay.SetPageSize( 1 );
+	m_SUpdateDelay.SetRange(0, (NUM_UPDATE_TIMES - 1));
+	m_SUpdateDelay.SetPageSize(1);
 	Initialize();		// Initialize most everything.
-	
-	return TRUE;  // return TRUE unless you set the focus to a control
-	              // EXCEPTION: OCX Property Pages should return FALSE
+
+	return TRUE;		// return TRUE unless you set the focus to a control
+	// EXCEPTION: OCX Property Pages should return FALSE
 }
 
-
 BEGIN_MESSAGE_MAP(CPageDisplay, CPropertyPage)
-	//{{AFX_MSG_MAP(CPageDisplay)
-	ON_WM_HSCROLL()
-	ON_BN_CLICKED(RAvgLastUpdate, OnRAvgLastUpdate)
-	ON_BN_CLICKED(RAvgWholeTest, OnRAvgWholeTest)
-	ON_BN_CLICKED(TWorker1, OnTWorker1)
-	ON_BN_CLICKED(TWorker2, OnTWorker2)
-	ON_BN_CLICKED(TWorker3, OnTWorker3)
-	ON_BN_CLICKED(TWorker4, OnTWorker4)
-	ON_BN_CLICKED(TWorker5, OnTWorker5)
-	ON_BN_CLICKED(TWorker6, OnTWorker6)
-	ON_BN_CLICKED(BResultType1, OnBResultType1)
-	ON_BN_CLICKED(BResultType2, OnBResultType2)
-	ON_BN_CLICKED(BResultType3, OnBResultType3)
-	ON_BN_CLICKED(BResultType4, OnBResultType4)
-	ON_BN_CLICKED(BResultType5, OnBResultType5)
-	ON_BN_CLICKED(BResultType6, OnBResultType6)
-	ON_BN_CLICKED(BBigMeter1, OnBBigMeter1)
-	ON_BN_CLICKED(BBigMeter2, OnBBigMeter2)
-	ON_BN_CLICKED(BBigMeter3, OnBBigMeter3)
-	ON_BN_CLICKED(BBigMeter4, OnBBigMeter4)
-	ON_BN_CLICKED(BBigMeter5, OnBBigMeter5)
-	ON_BN_CLICKED(BBigMeter6, OnBBigMeter6)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CPageDisplay)
+    ON_WM_HSCROLL()
+    ON_BN_CLICKED(RAvgLastUpdate, OnRAvgLastUpdate)
+    ON_BN_CLICKED(RAvgWholeTest, OnRAvgWholeTest)
+    ON_BN_CLICKED(TWorker1, OnTWorker1)
+    ON_BN_CLICKED(TWorker2, OnTWorker2)
+    ON_BN_CLICKED(TWorker3, OnTWorker3)
+    ON_BN_CLICKED(TWorker4, OnTWorker4)
+    ON_BN_CLICKED(TWorker5, OnTWorker5)
+    ON_BN_CLICKED(TWorker6, OnTWorker6)
+    ON_BN_CLICKED(BResultType1, OnBResultType1)
+    ON_BN_CLICKED(BResultType2, OnBResultType2)
+    ON_BN_CLICKED(BResultType3, OnBResultType3)
+    ON_BN_CLICKED(BResultType4, OnBResultType4)
+    ON_BN_CLICKED(BResultType5, OnBResultType5)
+    ON_BN_CLICKED(BResultType6, OnBResultType6)
+    ON_BN_CLICKED(BBigMeter1, OnBBigMeter1)
+    ON_BN_CLICKED(BBigMeter2, OnBBigMeter2)
+    ON_BN_CLICKED(BBigMeter3, OnBBigMeter3)
+    ON_BN_CLICKED(BBigMeter4, OnBBigMeter4)
+    ON_BN_CLICKED(BBigMeter5, OnBBigMeter5)
+ON_BN_CLICKED(BBigMeter6, OnBBigMeter6)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageDisplay message handlers
-
-
 void CPageDisplay::Initialize()
 {
 	// Set all of the status bars to all managers.
-	for ( int i = 0; i < NUM_STATUS_BARS; i++ )
-	{
- 		barcharts[i].results = theApp.manager_list.results;
+	for (int i = 0; i < NUM_STATUS_BARS; i++) {
+		barcharts[i].results = theApp.manager_list.results;
 		barcharts[i].name = theApp.manager_list.name;
 		barcharts[i].manager = NULL;
 		barcharts[i].worker = NULL;
@@ -194,32 +182,30 @@
 
 	// Init all display thingies.
 	selected_button = 0;
-	theApp.pView->OnMDisplay( MDisplayOpsSubmenuID, MDisplayOpsIOPS );
+	theApp.pView->OnMDisplay(MDisplayOpsSubmenuID, MDisplayOpsIOPS);
 
 	selected_button = 1;
-	theApp.pView->OnMDisplay( MDisplayMBsSubmenuID, MDisplayMBsMBPS );
+	theApp.pView->OnMDisplay(MDisplayMBsSubmenuID, MDisplayMBsMBPS);
 
 	selected_button = 2;
-	theApp.pView->OnMDisplay( MDisplayAvgSubmenuID, MDisplayAvgIO );
+	theApp.pView->OnMDisplay(MDisplayAvgSubmenuID, MDisplayAvgIO);
 
 	selected_button = 3;
-	theApp.pView->OnMDisplay( MDisplayMaxSubmenuID, MDisplayMaxIO );
+	theApp.pView->OnMDisplay(MDisplayMaxSubmenuID, MDisplayMaxIO);
 
 	selected_button = 4;
-	theApp.pView->OnMDisplay( MDisplayCPUSubmenuID, MDisplayCPUUtilization );
+	theApp.pView->OnMDisplay(MDisplayCPUSubmenuID, MDisplayCPUUtilization);
 
 	selected_button = 5;
-	theApp.pView->OnMDisplay( MDisplayErrSubmenuID, MDisplayErrIO );
+	theApp.pView->OnMDisplay(MDisplayErrSubmenuID, MDisplayErrIO);
 
-	SetUpdateDelay( 0 );
+	SetUpdateDelay(0);
 
-	SetWhichPerf( WHOLE_TEST_PERF );
+	SetWhichPerf(WHOLE_TEST_PERF);
 
 	Reset();
 }
 
-
-
 //
 // Resetting the result display.  This is usually called because a manager or worker has
 // been deleted.  Any references to the deleted item need to be removed.
@@ -227,44 +213,41 @@
 void CPageDisplay::Reset()
 {
 	// Set all of the status bars to all managers.
-	for ( int i = 0; i < NUM_STATUS_BARS; i++ )
-	{
- 		barcharts[i].results = theApp.manager_list.results;
+	for (int i = 0; i < NUM_STATUS_BARS; i++) {
+		barcharts[i].results = theApp.manager_list.results;
 		barcharts[i].name = theApp.manager_list.name;
 		barcharts[i].manager = NULL;
 		barcharts[i].worker = NULL;
 	}
 
 	// Update the display information.
-	m_PRate1.SetPos( 0 );
-	m_PRate2.SetPos( 0 );
-	m_PRate3.SetPos( 0 );
-	m_PRate4.SetPos( 0 );
-	m_PRate5.SetPos( 0 );
-	m_PRate6.SetPos( 0 );
+	m_PRate1.SetPos(0);
+	m_PRate2.SetPos(0);
+	m_PRate3.SetPos(0);
+	m_PRate4.SetPos(0);
+	m_PRate5.SetPos(0);
+	m_PRate6.SetPos(0);
 
 	// Do one update to set everything properly.
 	Update();
 }
 
-
 //
 // Sets the source for a progress bar given for a drag-drop selection.
 //
-void CPageDisplay::SetResultSource( int manager_index, int worker_index, CPoint point )
+void CPageDisplay::SetResultSource(int manager_index, int worker_index, CPoint point)
 {
-	void* drop_target;
+	void *drop_target;
 
 	// Get the pointer of the window dropped on.
-	drop_target = (void*)WindowFromPoint( point );
+	drop_target = (void *)WindowFromPoint(point);
 
 	int selected_progress_bar = IOERROR;	// init index.
-	for ( int i = 0; i < NUM_STATUS_BARS; i++ )
-	{
+
+	for (int i = 0; i < NUM_STATUS_BARS; i++) {
 		// Check to see if the drop target is one of the progress bars or Result Type buttons.
-		if ( (drop_target == (void*)GetDlgItem( PRate1 + i )) ||
-			 (drop_target == (void*)GetDlgItem( BResultType1 + i )) )
-		{
+		if ((drop_target == (void *)GetDlgItem(PRate1 + i)) ||
+		    (drop_target == (void *)GetDlgItem(BResultType1 + i))) {
 			// If so, set the index for future use.
 			selected_progress_bar = i;
 			break;
@@ -272,80 +255,67 @@
 	}
 
 	// The drop target was not a progress bar or Result Type button, so exit this function.
-	if( selected_progress_bar == IOERROR )
+	if (selected_progress_bar == IOERROR)
 		return;
 
 	// Call SetResultSource( int, int, int ) to do the rest of the job
-	SetResultSource( manager_index, worker_index, selected_progress_bar );
+	SetResultSource(manager_index, worker_index, selected_progress_bar);
 }
 
-
 //
 // Sets the source for a progress bar given for a specific progress bar.
 //
-void CPageDisplay::SetResultSource( int manager_index, int worker_index, int selected_progress_bar )
+void CPageDisplay::SetResultSource(int manager_index, int worker_index, int selected_progress_bar)
 {
-	if ( (selected_progress_bar < 0) || (selected_progress_bar >= NUM_STATUS_BARS) )
-	{
+	if ((selected_progress_bar < 0) || (selected_progress_bar >= NUM_STATUS_BARS)) {
 		ErrorMessage("Invalid selected_progress_bar value in CPageDisplay::SetResultSource()");
 		return;
 	}
 
-	if ( manager_index == ALL_MANAGERS ) // looking for all manager results
+	if (manager_index == ALL_MANAGERS)	// looking for all manager results
 	{
- 		barcharts[selected_progress_bar].results = theApp.manager_list.results;
+		barcharts[selected_progress_bar].results = theApp.manager_list.results;
 		barcharts[selected_progress_bar].name = theApp.manager_list.name;
 		barcharts[selected_progress_bar].manager = NULL;
 		barcharts[selected_progress_bar].worker = NULL;
-	}
-	else if ( worker_index == IOERROR )	// looking for a manager's results
- 	{
- 		barcharts[selected_progress_bar].results = 
-			theApp.manager_list.GetManager( manager_index )->results;
-		barcharts[selected_progress_bar].name = 
-			theApp.manager_list.GetManager( manager_index )->name;
-		barcharts[selected_progress_bar].manager = theApp.manager_list.GetManager( manager_index );
+	} else if (worker_index == IOERROR)	// looking for a manager's results
+	{
+		barcharts[selected_progress_bar].results = theApp.manager_list.GetManager(manager_index)->results;
+		barcharts[selected_progress_bar].name = theApp.manager_list.GetManager(manager_index)->name;
+		barcharts[selected_progress_bar].manager = theApp.manager_list.GetManager(manager_index);
 		barcharts[selected_progress_bar].worker = NULL;
-	}
-	else								// looking for a worker's results
+	} else			// looking for a worker's results
 	{
- 		barcharts[selected_progress_bar].results = 
-			theApp.manager_list.GetManager( manager_index )->GetWorker( worker_index )->results;
-		barcharts[selected_progress_bar].name = 
-			theApp.manager_list.GetManager( manager_index )->GetWorker( worker_index )->name;
-		barcharts[selected_progress_bar].manager = theApp.manager_list.GetManager( manager_index );
-		barcharts[selected_progress_bar].worker = 
-			theApp.manager_list.GetManager( manager_index )->GetWorker( worker_index );
+		barcharts[selected_progress_bar].results =
+		    theApp.manager_list.GetManager(manager_index)->GetWorker(worker_index)->results;
+		barcharts[selected_progress_bar].name =
+		    theApp.manager_list.GetManager(manager_index)->GetWorker(worker_index)->name;
+		barcharts[selected_progress_bar].manager = theApp.manager_list.GetManager(manager_index);
+		barcharts[selected_progress_bar].worker =
+		    theApp.manager_list.GetManager(manager_index)->GetWorker(worker_index);
 	}
 
 	// Updating the rates.
 	Update();
 }
 
-
-
-
 void CPageDisplay::Update()
 {
-	int				max_rate[NUM_STATUS_BARS];
-	CString			max_range_text;
-	double			stat_double;
-	CString			stat_string;
+	int max_rate[NUM_STATUS_BARS];
+	CString max_range_text;
+	double stat_double;
+	CString stat_string;
 
 	// Setting ranges on status bar display based on selections.
-	for ( int i = 0; i < NUM_STATUS_BARS; i++ )
-	{
-		max_rate[i] = GetMaxRange( &(barcharts[i].results[GetWhichPerf()]), barcharts[i].result_to_display );
+	for (int i = 0; i < NUM_STATUS_BARS; i++) {
+		max_rate[i] = GetMaxRange(&(barcharts[i].results[GetWhichPerf()]), barcharts[i].result_to_display);
 	}
 
 	// If the results to display are the same, giving them the same ranges for easier comparisons.
-	for ( i = 0; i < NUM_STATUS_BARS - 1; i++)
-	{
-		for ( int j = i; j < NUM_STATUS_BARS; j++ )
-		{
-			if ( barcharts[i].result_to_display == barcharts[j].result_to_display )
-			{
-				if ( max_rate[i] > max_rate[j] )
+	for (i = 0; i < NUM_STATUS_BARS - 1; i++) {
+		for (int j = i; j < NUM_STATUS_BARS; j++) {
+			if (barcharts[i].result_to_display == barcharts[j].result_to_display) {
+				if (max_rate[i] > max_rate[j])
 					max_rate[j] = max_rate[i];
 				else
 					max_rate[i] = max_rate[j];
@@ -354,159 +324,152 @@
 	}
 
 	// Setting ranges on status bar and displaying range value.
-	for ( i = 0; i < NUM_STATUS_BARS; i++ )
-	{
-		( (CProgressCtrl*)GetDlgItem( PRate1 + i ) )->SetRange( 0, max_rate[i] );
+	for (i = 0; i < NUM_STATUS_BARS; i++) {
+		((CProgressCtrl *) GetDlgItem(PRate1 + i))->SetRange(0, max_rate[i]);
 
 		// See if results are displaying a percentage.
-		if ( ( barcharts[i].result_to_display >= CPU_UTILIZATION_RESULT ) && 
-			( barcharts[i].result_to_display <= IRQ_UTILIZATION_RESULT ) )
-		{
-			max_range_text.Format( "%d %%", max_rate[i] );		// display % sign
-			( (CStatic*)GetDlgItem( TRate1MAX + i ) )->SetWindowText( max_range_text );
+		if ((barcharts[i].result_to_display >= CPU_UTILIZATION_RESULT) &&
+		    (barcharts[i].result_to_display <= IRQ_UTILIZATION_RESULT)) {
+			max_range_text.Format("%d %%", max_rate[i]);	// display % sign
+			((CStatic *) GetDlgItem(TRate1MAX + i))->SetWindowText(max_range_text);
+		} else {
+			max_range_text.Format("%d", max_rate[i]);	// displaying a rate
+			((CStatic *) GetDlgItem(TRate1MAX + i))->SetWindowText(max_range_text);
 		}
-		else
-		{
-			max_range_text.Format( "%d", max_rate[i] );			// displaying a rate
-			( (CStatic*)GetDlgItem( TRate1MAX + i ) )->SetWindowText( max_range_text );
-		}
 
 		// Update the name.
-		SetDlgItemText( TWorker1 + i, barcharts[i].name );
+		SetDlgItemText(TWorker1 + i, barcharts[i].name);
 
 		// Get the performance data to display (a number and a string)
-		GetDisplayData(	&(barcharts[i].results[GetWhichPerf()]), 
-			barcharts[i].result_to_display, &stat_double, &stat_string );
+		GetDisplayData(&(barcharts[i].results[GetWhichPerf()]),
+			       barcharts[i].result_to_display, &stat_double, &stat_string);
 
 		// Update the appropriate progress bar
-		((CProgressCtrl *) GetDlgItem( PRate1 + i ))->SetPos( (int) stat_double );
+		((CProgressCtrl *) GetDlgItem(PRate1 + i))->SetPos((int)stat_double);
 
 		// Display the new value to the user
-		((CStatic *) GetDlgItem( TRate1 + i ))->SetWindowText( stat_string );
+		((CStatic *) GetDlgItem(TRate1 + i))->SetWindowText(stat_string);
 	}
 
 	// Update the data.
 	UpdateWindow();
 
 	// Update the big meter dialog, if it exists.
-	if ( m_dlgBigMeter.is_displayed )
+	if (m_dlgBigMeter.is_displayed)
 		m_dlgBigMeter.UpdateDisplay();
 }
 
-
-
 //
 // Get Maximum Range:
 //
 // Finds and returns the maximum range that a status bar should be set to based on
 // what data is to be displayed.
 //
-unsigned int CPageDisplay::GetMaxRange( Results* results, int result_type )
+unsigned int CPageDisplay::GetMaxRange(Results * results, int result_type)
 {
-	switch ( result_type )
-	{
+	switch (result_type) {
 	case MBPS_RESULT:
-		return ReportMaxRange( (double) results->MBps );
+		return ReportMaxRange((double)results->MBps);
 		break;
 	case READ_MBPS_RESULT:
-		return ReportMaxRange( (double) results->read_MBps );
+		return ReportMaxRange((double)results->read_MBps);
 		break;
 	case WRITE_MBPS_RESULT:
-		return ReportMaxRange( (double) results->write_MBps );
+		return ReportMaxRange((double)results->write_MBps);
 		break;
 
 	case IOPS_RESULT:
-		return ReportMaxRange( (double) results->IOps );
+		return ReportMaxRange((double)results->IOps);
 		break;
 	case READ_IOPS_RESULT:
-		return ReportMaxRange( (double) results->read_IOps );
+		return ReportMaxRange((double)results->read_IOps);
 		break;
 	case WRITE_IOPS_RESULT:
-		return ReportMaxRange( (double) results->write_IOps );
+		return ReportMaxRange((double)results->write_IOps);
 		break;
 
 	case CONNECTION_PER_SEC_RESULT:
-		return ReportMaxRange( (double) results->connections_per_second );
+		return ReportMaxRange((double)results->connections_per_second);
 		break;
 	case AVG_CONNECTION_LATENCY_RESULT:
-		return ReportMaxRange( (double) results->ave_connection_latency );
+		return ReportMaxRange((double)results->ave_connection_latency);
 		break;
 	case MAX_CONNECTION_LATENCY_RESULT:
-		return ReportMaxRange( (double) results->max_connection_latency );
+		return ReportMaxRange((double)results->max_connection_latency);
 		break;
 
 	case MAX_LATENCY_RESULT:
-		return ReportMaxRange( (double) results->max_latency );
+		return ReportMaxRange((double)results->max_latency);
 		break;
 	case MAX_READ_LATENCY_RESULT:
-		return ReportMaxRange( (double) results->max_read_latency );
+		return ReportMaxRange((double)results->max_read_latency);
 		break;
 	case MAX_WRITE_LATENCY_RESULT:
-		return ReportMaxRange( (double) results->max_write_latency );
+		return ReportMaxRange((double)results->max_write_latency);
 		break;
 
 	case AVG_LATENCY_RESULT:
-		return ReportMaxRange( ( double) results->ave_latency );
+		return ReportMaxRange((double)results->ave_latency);
 		break;
 	case AVG_READ_LATENCY_RESULT:
-		return ReportMaxRange( ( double) results->ave_read_latency );
+		return ReportMaxRange((double)results->ave_read_latency);
 		break;
 	case AVG_WRITE_LATENCY_RESULT:
-		return ReportMaxRange( ( double) results->ave_write_latency );
+		return ReportMaxRange((double)results->ave_write_latency);
 		break;
 
 	case TRANSACTION_PER_SEC_RESULT:
-		return ReportMaxRange( (double) results->transactions_per_second );
+		return ReportMaxRange((double)results->transactions_per_second);
 		break;
 	case MAX_TRANSACTION_LATENCY_RESULT:
-		return ReportMaxRange( (double) results->max_transaction_latency );
+		return ReportMaxRange((double)results->max_transaction_latency);
 		break;
 	case AVG_TRANSACTION_LATENCY_RESULT:
-		return ReportMaxRange( ( double) results->ave_transaction_latency );
+		return ReportMaxRange((double)results->ave_transaction_latency);
 		break;
 
 	case ERROR_RESULT:
-		return ReportMaxRange( (double) results->total_errors );
+		return ReportMaxRange((double)results->total_errors);
 		break;
 	case READ_ERROR_RESULT:
-		return ReportMaxRange( (double) results->raw.read_errors );
+		return ReportMaxRange((double)results->raw.read_errors);
 		break;
 	case WRITE_ERROR_RESULT:
-		return ReportMaxRange( (double) results->raw.write_errors );
+		return ReportMaxRange((double)results->raw.write_errors);
 		break;
 
 	case CPU_UTILIZATION_RESULT:
-		return ReportMaxRange( (double) results->CPU_utilization[CPU_TOTAL_UTILIZATION] );
+		return ReportMaxRange((double)results->CPU_utilization[CPU_TOTAL_UTILIZATION]);
 		break;
 	case USER_UTILIZATION_RESULT:
-		return ReportMaxRange( (double) results->CPU_utilization[CPU_USER_UTILIZATION] );
+		return ReportMaxRange((double)results->CPU_utilization[CPU_USER_UTILIZATION]);
 		break;
 	case PRIVILEGED_UTILIZATION_RESULT:
-		return ReportMaxRange( (double) results->CPU_utilization[CPU_PRIVILEGED_UTILIZATION] );
+		return ReportMaxRange((double)results->CPU_utilization[CPU_PRIVILEGED_UTILIZATION]);
 		break;
 	case DPC_UTILIZATION_RESULT:
-		return ReportMaxRange( (double) results->CPU_utilization[CPU_DPC_UTILIZATION] );
+		return ReportMaxRange((double)results->CPU_utilization[CPU_DPC_UTILIZATION]);
 		break;
 	case IRQ_UTILIZATION_RESULT:
-		return ReportMaxRange( (double) results->CPU_utilization[CPU_IRQ_UTILIZATION] );
+		return ReportMaxRange((double)results->CPU_utilization[CPU_IRQ_UTILIZATION]);
 		break;
 
 	case CPU_INTERRUPT_RESULT:
-		return ReportMaxRange( (double) results->CPU_utilization[CPU_IRQ] );
+		return ReportMaxRange((double)results->CPU_utilization[CPU_IRQ]);
 		break;
 
 	case CPU_EFFECTIVENESS_RESULT:
-		return ReportMaxRange( (double) results->CPU_effectiveness );
+		return ReportMaxRange((double)results->CPU_effectiveness);
 		break;
 
 	case NI_PACKET_RESULT:
-		return ReportMaxRange( (double) results->ni_statistics[NI_PACKETS] );
+		return ReportMaxRange((double)results->ni_statistics[NI_PACKETS]);
 		break;
 	case NI_ERROR_RESULT:
-		return ReportMaxRange( (double) results->ni_statistics[NI_ERRORS] );
+		return ReportMaxRange((double)results->ni_statistics[NI_ERRORS]);
 		break;
 	case TCP_SEGMENT_RESULT:
-		return ReportMaxRange( (double) results->tcp_statistics[TCP_SEGMENTS_RESENT] );
+		return ReportMaxRange((double)results->tcp_statistics[TCP_SEGMENTS_RESENT]);
 		break;
 
 	default:
@@ -514,177 +477,173 @@
 	}
 }
 
-
 //
 // Report Maximum Range:
 // 
 // Returns the value that the maximum range for a status bar should be set to based 
 // on what's needed.
 //
-unsigned int CPageDisplay::ReportMaxRange( double max_range_needed )
+unsigned int CPageDisplay::ReportMaxRange(double max_range_needed)
 {
-	double max_rate = (double) 10;					// Start the max range at 1.0,
+	double max_rate = (double)10;	// Start the max range at 1.0,
 
-	while ( max_rate < max_range_needed )			// and continue to grow it in increments
-	{												// of 10x until the need is met.
-		if ( max_rate * (double) 10 < max_rate )	// Trap overflow.
+	while (max_rate < max_range_needed)	// and continue to grow it in increments
+	{			// of 10x until the need is met.
+		if (max_rate * (double)10 < max_rate)	// Trap overflow.
 			break;
-		max_rate *= (double) 10;
+		max_rate *= (double)10;
 	}
 
 	// The maximum range for the progress bar is 64K.
-	if ( max_rate > 60000 )
+	if (max_rate > 60000)
 		max_rate = 60000;
 
-	return (unsigned int) max_rate;
+	return (unsigned int)max_rate;
 }
 
-
 //
 // Pass in a results structure and the ID# of the statistic you want.
 //
 // GetDisplayData will fill in these values:
-//		result_value - the performance number (64.566 IOps) requested
-//		result_text - the user-friendly text version of that result
+//              result_value - the performance number (64.566 IOps) requested
+//              result_text - the user-friendly text version of that result
 //
-BOOL CPageDisplay::GetDisplayData(	Results* results, int result_type,
-									double *result_value, CString *result_text )
+BOOL CPageDisplay::GetDisplayData(Results * results, int result_type, double *result_value, CString * result_text)
 {
-	switch ( result_type )
-	{
+	switch (result_type) {
 	case MBPS_RESULT:
 		*result_value = results->MBps;
-		result_text->Format("%.2f", results->MBps );
+		result_text->Format("%.2f", results->MBps);
 		break;
 	case READ_MBPS_RESULT:
 		*result_value = results->read_MBps;
-		result_text->Format("%.2f", results->read_MBps );
+		result_text->Format("%.2f", results->read_MBps);
 		break;
 	case WRITE_MBPS_RESULT:
 		*result_value = results->write_MBps;
-		result_text->Format("%.2f", results->write_MBps );
+		result_text->Format("%.2f", results->write_MBps);
 		break;
 
 	case IOPS_RESULT:
 		*result_value = results->IOps;
-		result_text->Format("%.2f", results->IOps );
+		result_text->Format("%.2f", results->IOps);
 		break;
 	case READ_IOPS_RESULT:
 		*result_value = results->read_IOps;
-		result_text->Format("%.2f", results->read_IOps );
+		result_text->Format("%.2f", results->read_IOps);
 		break;
 	case WRITE_IOPS_RESULT:
 		*result_value = results->write_IOps;
-		result_text->Format("%.2f", results->write_IOps );
+		result_text->Format("%.2f", results->write_IOps);
 		break;
 
 	case CONNECTION_PER_SEC_RESULT:
 		*result_value = results->connections_per_second;
-		result_text->Format("%.2f", results->connections_per_second );
+		result_text->Format("%.2f", results->connections_per_second);
 		break;
 	case AVG_CONNECTION_LATENCY_RESULT:
 		*result_value = results->ave_connection_latency;
-		result_text->Format("%.4f", results->ave_connection_latency );
+		result_text->Format("%.4f", results->ave_connection_latency);
 		break;
 	case MAX_CONNECTION_LATENCY_RESULT:
 		*result_value = results->max_connection_latency;
-		result_text->Format("%.4f", results->max_connection_latency );
+		result_text->Format("%.4f", results->max_connection_latency);
 		break;
 
 	case MAX_LATENCY_RESULT:
 		*result_value = results->max_latency;
-		result_text->Format("%.4f", results->max_latency );
+		result_text->Format("%.4f", results->max_latency);
 		break;
 	case MAX_READ_LATENCY_RESULT:
 		*result_value = results->max_read_latency;
-		result_text->Format("%.4f", results->max_read_latency );
+		result_text->Format("%.4f", results->max_read_latency);
 		break;
 	case MAX_WRITE_LATENCY_RESULT:
 		*result_value = results->max_write_latency;
-		result_text->Format("%.4f", results->max_write_latency );
+		result_text->Format("%.4f", results->max_write_latency);
 		break;
 
 	case AVG_LATENCY_RESULT:
 		*result_value = results->ave_latency;
-		result_text->Format("%.4f", results->ave_latency );
+		result_text->Format("%.4f", results->ave_latency);
 		break;
 	case AVG_READ_LATENCY_RESULT:
 		*result_value = results->ave_read_latency;
-		result_text->Format("%.4f", results->ave_read_latency );
+		result_text->Format("%.4f", results->ave_read_latency);
 		break;
 	case AVG_WRITE_LATENCY_RESULT:
 		*result_value = results->ave_write_latency;
-		result_text->Format("%.4f", results->ave_write_latency );
+		result_text->Format("%.4f", results->ave_write_latency);
 		break;
 
 	case TRANSACTION_PER_SEC_RESULT:
 		*result_value = results->transactions_per_second;
-		result_text->Format("%.2f", results->transactions_per_second );
+		result_text->Format("%.2f", results->transactions_per_second);
 		break;
 	case MAX_TRANSACTION_LATENCY_RESULT:
 		*result_value = results->max_transaction_latency;
-		result_text->Format("%.4f", results->max_transaction_latency );
+		result_text->Format("%.4f", results->max_transaction_latency);
 		break;
 	case AVG_TRANSACTION_LATENCY_RESULT:
 		*result_value = results->ave_transaction_latency;
-		result_text->Format("%.4f", results->ave_transaction_latency );
+		result_text->Format("%.4f", results->ave_transaction_latency);
 		break;
 
 	case ERROR_RESULT:
 		*result_value = results->total_errors;
-		result_text->Format("%d", results->total_errors );
+		result_text->Format("%d", results->total_errors);
 		break;
 	case READ_ERROR_RESULT:
 		*result_value = results->raw.read_errors;
-		result_text->Format("%d", results->raw.read_errors );
+		result_text->Format("%d", results->raw.read_errors);
 		break;
 	case WRITE_ERROR_RESULT:
 		*result_value = results->raw.write_errors;
-		result_text->Format("%d", results->raw.write_errors );
+		result_text->Format("%d", results->raw.write_errors);
 		break;
 
 	case CPU_UTILIZATION_RESULT:
 		*result_value = results->CPU_utilization[CPU_TOTAL_UTILIZATION];
-		result_text->Format("%.2f %%", results->CPU_utilization[CPU_TOTAL_UTILIZATION] );
+		result_text->Format("%.2f %%", results->CPU_utilization[CPU_TOTAL_UTILIZATION]);
 		break;
 	case USER_UTILIZATION_RESULT:
 		*result_value = results->CPU_utilization[CPU_USER_UTILIZATION];
-		result_text->Format("%.2f %%", results->CPU_utilization[CPU_USER_UTILIZATION] );
+		result_text->Format("%.2f %%", results->CPU_utilization[CPU_USER_UTILIZATION]);
 		break;
 	case PRIVILEGED_UTILIZATION_RESULT:
 		*result_value = results->CPU_utilization[CPU_PRIVILEGED_UTILIZATION];
-		result_text->Format("%.2f %%", results->CPU_utilization[CPU_PRIVILEGED_UTILIZATION] );
+		result_text->Format("%.2f %%", results->CPU_utilization[CPU_PRIVILEGED_UTILIZATION]);
 		break;
 	case DPC_UTILIZATION_RESULT:
 		*result_value = results->CPU_utilization[CPU_DPC_UTILIZATION];
-		result_text->Format("%.2f %%", results->CPU_utilization[CPU_DPC_UTILIZATION] );
+		result_text->Format("%.2f %%", results->CPU_utilization[CPU_DPC_UTILIZATION]);
 		break;
 	case IRQ_UTILIZATION_RESULT:
 		*result_value = results->CPU_utilization[CPU_IRQ_UTILIZATION];
-		result_text->Format("%.2f %%", results->CPU_utilization[CPU_IRQ_UTILIZATION] );
+		result_text->Format("%.2f %%", results->CPU_utilization[CPU_IRQ_UTILIZATION]);
 		break;
 
 	case CPU_INTERRUPT_RESULT:
 		*result_value = results->CPU_utilization[CPU_IRQ];
-		result_text->Format("%.2f", results->CPU_utilization[CPU_IRQ] );
+		result_text->Format("%.2f", results->CPU_utilization[CPU_IRQ]);
 		break;
 
 	case CPU_EFFECTIVENESS_RESULT:
 		*result_value = results->CPU_effectiveness;
-		result_text->Format("%.2f", results->CPU_effectiveness );
+		result_text->Format("%.2f", results->CPU_effectiveness);
 		break;
 
 	case NI_PACKET_RESULT:
 		*result_value = results->ni_statistics[NI_PACKETS];
-		result_text->Format("%.2f", results->ni_statistics[NI_PACKETS] );
+		result_text->Format("%.2f", results->ni_statistics[NI_PACKETS]);
 		break;
 	case NI_ERROR_RESULT:
 		*result_value = results->ni_statistics[NI_ERRORS];
-		result_text->Format("%.2f", results->ni_statistics[NI_ERRORS] );
+		result_text->Format("%.2f", results->ni_statistics[NI_ERRORS]);
 		break;
 	case TCP_SEGMENT_RESULT:
 		*result_value = results->tcp_statistics[TCP_SEGMENTS_RESENT];
-		result_text->Format("%.2f", results->tcp_statistics[TCP_SEGMENTS_RESENT] );
+		result_text->Format("%.2f", results->tcp_statistics[TCP_SEGMENTS_RESENT]);
 		break;
 	default:
 		return FALSE;
@@ -693,77 +652,60 @@
 	return TRUE;
 }
 
-
 UINT CPageDisplay::GetUpdateDelay()
 {
 	// We know that the slider value will be in the range 0..(NUM_UPDATE_TIMES - 1)
-	return( delay_table[ m_SUpdateDelay.GetPos() ] );
+	return (delay_table[m_SUpdateDelay.GetPos()]);
 }
 
-
-void CPageDisplay::SetUpdateDelay( UINT new_delay )
+void CPageDisplay::SetUpdateDelay(UINT new_delay)
 {
 	int i;
-	int new_setting = (NUM_UPDATE_TIMES - 1); // Default if new_delay is not found in delay_table
+	int new_setting = (NUM_UPDATE_TIMES - 1);	// Default if new_delay is not found in delay_table
 
-	for ( i = 0; i < NUM_UPDATE_TIMES; i++ )
-	{
-		if ( (new_delay * 1000) == delay_table[i] )
-		{
+	for (i = 0; i < NUM_UPDATE_TIMES; i++) {
+		if ((new_delay * 1000) == delay_table[i]) {
 			new_setting = i;
 			break;
 		}
 	}
 
-	m_SUpdateDelay.SetPos( new_setting );
+	m_SUpdateDelay.SetPos(new_setting);
 }
 
-
 int CPageDisplay::GetWhichPerf()
 {
-	if ( GetCheckedRadioButton( RAvgWholeTest, RAvgLastUpdate ) == RAvgLastUpdate )
-	{
+	if (GetCheckedRadioButton(RAvgWholeTest, RAvgLastUpdate) == RAvgLastUpdate) {
 		return LAST_UPDATE_PERF;
-	}
-	else
-	{
+	} else {
 		return WHOLE_TEST_PERF;
 	}
 }
 
-
-
-void CPageDisplay::SetWhichPerf( int which_perf )
+void CPageDisplay::SetWhichPerf(int which_perf)
 {
-	if ( which_perf == LAST_UPDATE_PERF )
-	{
-		CheckRadioButton( RAvgWholeTest, RAvgLastUpdate, RAvgLastUpdate );
+	if (which_perf == LAST_UPDATE_PERF) {
+		CheckRadioButton(RAvgWholeTest, RAvgLastUpdate, RAvgLastUpdate);
+	} else {
+		CheckRadioButton(RAvgWholeTest, RAvgLastUpdate, RAvgWholeTest);
 	}
-	else
-	{
-		CheckRadioButton( RAvgWholeTest, RAvgLastUpdate, RAvgWholeTest );
-	}
 }
 
-
-void CPageDisplay::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
+void CPageDisplay::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar * pScrollBar)
 {
 	// Treat moving the update frequency scroll bar as if the timer had expired.
-	if ( pScrollBar == (CScrollBar*)&m_SUpdateDelay && nSBCode == SB_ENDSCROLL &&
-		(theApp.test_state == TestRecording) )
-	{
-		theApp.pView->SetTimer( DISPLAY_TIMER, 0, NULL );
+	if (pScrollBar == (CScrollBar *) & m_SUpdateDelay && nSBCode == SB_ENDSCROLL &&
+	    (theApp.test_state == TestRecording)) {
+		theApp.pView->SetTimer(DISPLAY_TIMER, 0, NULL);
 	}
 	CPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
 }
 
-
-
 //
 // Generic handler for press on any BResultType button.  
 // Records which button was pressed, then pops up the result type menu.
 // 
-void CPageDisplay::OnBResultType( int which_button ) 
+void CPageDisplay::OnBResultType(int which_button)
 {
 	CMenu menu;
 	CRect button_rect;
@@ -774,25 +716,24 @@
 	selected_button = which_button;
 
 	// This prevents the menu from popping up if the user is "unchecking" the button.
-	if ( ( (CButton*)GetDlgItem( BResultType1 + selected_button ) )->GetCheck() ) 
-	{
-		( (CButton*)GetDlgItem( BResultType1 + selected_button ) )->
-			SetCheck( FALSE );
+	if (((CButton *) GetDlgItem(BResultType1 + selected_button))->GetCheck()) {
+		((CButton *) GetDlgItem(BResultType1 + selected_button))->SetCheck(FALSE);
 		return;
 	}
-
 	// Create the popup menu from the resource.
 	VERIFY(menu.LoadMenu(IDR_POPUP_DISPLAY_LIST));
-	CMenu* pPopup = menu.GetSubMenu(0);
+	CMenu *pPopup = menu.GetSubMenu(0);
+
 	ASSERT(pPopup != NULL);
 
 	// Find the first non-child window to be the popup's parent.
-	CWnd* pWndPopupOwner = this;
+	CWnd *pWndPopupOwner = this;
+
 	while (pWndPopupOwner->GetStyle() & WS_CHILD)
 		pWndPopupOwner = pWndPopupOwner->GetParent();
 
 	// Get the screen coordinates of the button that was pressed.
-	GetDlgItem( BResultType1 + selected_button )->GetWindowRect( &button_rect );
+	GetDlgItem(BResultType1 + selected_button)->GetWindowRect(&button_rect);
 
 	// Position the menu with its upper left corner at the lower left corner of the button.
 	menu_x = button_rect.TopLeft().x;
@@ -800,14 +741,11 @@
 
 	// If the menu would go off the bottom of the screen, make it go *up* from the button instead.
 	menu_height = GetSystemMetrics(SM_CYMENUSIZE) * MDisplayNumSubmenus;
-	if ( SystemParametersInfo( SPI_GETWORKAREA, 0, &screen_rect, 0) && 
-		(menu_y + menu_height > screen_rect.bottom) )
-	{
+	if (SystemParametersInfo(SPI_GETWORKAREA, 0, &screen_rect, 0) && (menu_y + menu_height > screen_rect.bottom)) {
 		menu_y = button_rect.TopLeft().y - menu_height + 1;
 	}
-
 	// Set the button's visual state to "pressed" as long as the menu is popped up.
-	( (CButton*)GetDlgItem( BResultType1 + selected_button ) )->SetCheck( TRUE );
+	((CButton *) GetDlgItem(BResultType1 + selected_button))->SetCheck(TRUE);
 
 	// Pop up the menu.
 	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON, menu_x, menu_y, pWndPopupOwner);
@@ -816,11 +754,9 @@
 	// CGalileoView::OnMDisplay...() functions, which will in turn call CPageDisplay::OnMDisplay().
 
 	// Set the button's visual state to "not pressed" after the menu is dismissed.
-	( (CButton*)GetDlgItem( BResultType1 + selected_button ) )->SetState( FALSE );
+	((CButton *) GetDlgItem(BResultType1 + selected_button))->SetState(FALSE);
 }
 
-
-
 //
 // Generic handler for any selection from the IDR_POPUP_DISPLAY_LIST menu.  
 // (The specific handlers for each selection are members of the CGalileoView class;
@@ -836,95 +772,90 @@
 // of the *_RESULT constants from PageDisplay.h, and determines which result will
 // be displayed by the status bar associated with the selected_button.
 // 
-void CPageDisplay::OnMDisplay( int submenu_id, int menu_item, int result_code )
+void CPageDisplay::OnMDisplay(int submenu_id, int menu_item, int result_code)
 {
-	if ( (selected_button < 0) || (selected_button >= NUM_STATUS_BARS) )
-	{
+	if ((selected_button < 0) || (selected_button >= NUM_STATUS_BARS)) {
 		ErrorMessage("Invalid selected_button value in CPageDisplay::OnMDisplay()");
 		return;
 	}
-	if ( (submenu_id < 0) || (submenu_id >= MDisplayNumSubmenus) )
-	{
+	if ((submenu_id < 0) || (submenu_id >= MDisplayNumSubmenus)) {
 		ErrorMessage("Invalid submenu_id value in CPageDisplay::OnMDisplay()");
 		return;
 	}
-	if ( (result_code < 0) || (result_code >= NUM_RESULTS) )
-	{
+	if ((result_code < 0) || (result_code >= NUM_RESULTS)) {
 		ErrorMessage("Invalid result_code value in CPageDisplay::OnMDisplay()");
 		return;
 	}
-
 	// store the selected result for later use
 	barcharts[selected_button].result_to_display = result_code;
 
 	// get the selected menu item's title and store it in the selected button
 	CMenu menu;
+
 	VERIFY(menu.LoadMenu(IDR_POPUP_DISPLAY_LIST));
 
-	CMenu* pPopup = menu.GetSubMenu(0);
-	ASSERT(pPopup != NULL); // we can use ASSERT here because this should work every time if it works at all
+	CMenu *pPopup = menu.GetSubMenu(0);
 
-	CMenu* pSubPopup = pPopup->GetSubMenu( submenu_id );
-	if ( pSubPopup == NULL )
-	{
+	ASSERT(pPopup != NULL);	// we can use ASSERT here because this should work every time if it works at all
+
+	CMenu *pSubPopup = pPopup->GetSubMenu(submenu_id);
+
+	if (pSubPopup == NULL) {
 		ErrorMessage("Could not get submenu in CPageDisplay::OnMDisplay()");
 		return;
 	}
 
 	CString title;
-	pSubPopup->GetMenuString( menu_item, title, MF_BYCOMMAND );
 
-	GetDlgItem( BResultType1 + selected_button )->SetWindowText( title );
-	( (CButton*)GetDlgItem( BResultType1 + selected_button ) )->SetCheck( FALSE );
+	pSubPopup->GetMenuString(menu_item, title, MF_BYCOMMAND);
 
+	GetDlgItem(BResultType1 + selected_button)->SetWindowText(title);
+	((CButton *) GetDlgItem(BResultType1 + selected_button))->SetCheck(FALSE);
+
 	Update();
 }
 
-
-
 //
 // Find a statistic by its name (as stored in result file) and select it
 // as though it had been selected from the menu.
 // 
-void CPageDisplay::SelectStatisticByName( int button, const char *statistic_name )
+void CPageDisplay::SelectStatisticByName(int button, const char *statistic_name)
 {
 	unsigned int submenu_id, menu_item;
 
-	if ( (button < 0) || (button >= NUM_STATUS_BARS) )
-	{
+	if ((button < 0) || (button >= NUM_STATUS_BARS)) {
 		ErrorMessage("Invalid button value in CPageDisplay::SelectStatisticByName()");
 		return;
 	}
-	if ( !statistic_name )
-	{
+	if (!statistic_name) {
 		ErrorMessage("Invalid string in CPageDisplay::SelectStatisticByName()");
 		return;
 	}
 
 	CMenu menu;
+
 	VERIFY(menu.LoadMenu(IDR_POPUP_DISPLAY_LIST));
 
-	CMenu* pPopup = menu.GetSubMenu(0);
-	ASSERT(pPopup != NULL); // we can use ASSERT here because this should work every time if it works at all
+	CMenu *pPopup = menu.GetSubMenu(0);
 
-	for ( submenu_id = 0; submenu_id < MDisplayNumSubmenus; submenu_id++ )
-	{
-		CMenu* pSubPopup = pPopup->GetSubMenu( submenu_id );
-		if ( pSubPopup == NULL )
-		{
+	ASSERT(pPopup != NULL);	// we can use ASSERT here because this should work every time if it works at all
+
+	for (submenu_id = 0; submenu_id < MDisplayNumSubmenus; submenu_id++) {
+		CMenu *pSubPopup = pPopup->GetSubMenu(submenu_id);
+
+		if (pSubPopup == NULL) {
 			ErrorMessage("Could not get submenu in CPageDisplay::SelectStatisticByName()");
 			return;
 		}
 
-		for ( menu_item = 0; menu_item < pSubPopup->GetMenuItemCount(); menu_item++ )
-		{
+		for (menu_item = 0; menu_item < pSubPopup->GetMenuItemCount(); menu_item++) {
 			CString title;
-			pSubPopup->GetMenuString( menu_item, title, MF_BYPOSITION );
 
-			if ( title.CompareNoCase(statistic_name) == 0 )
-			{
+			pSubPopup->GetMenuString(menu_item, title, MF_BYPOSITION);
+
+			if (title.CompareNoCase(statistic_name) == 0) {
 				selected_button = button;
-				theApp.pView->OnMDisplay( submenu_id, pSubPopup->GetMenuItemID( menu_item ) );
+				theApp.pView->OnMDisplay(submenu_id, pSubPopup->GetMenuItemID(menu_item));
 				return;
 			}
 		}
@@ -933,131 +864,101 @@
 	return;
 }
 
-
-
 //
 // Find a manager by its name (as stored in result file) and select it
 // as though it had been dragged.
 // 
-void CPageDisplay::SelectManagerByName( int button, const char *mgr_name, const int mgr_id )
+void CPageDisplay::SelectManagerByName(int button, const char *mgr_name, const int mgr_id)
 {
 	Manager *mgr;
 
-	if ( !mgr_name )
-	{
-		ErrorMessage( "Invalid string in CPageDisplay::SelectManagerByName()" );
+	if (!mgr_name) {
+		ErrorMessage("Invalid string in CPageDisplay::SelectManagerByName()");
 		return;
 	}
 
-	if ( strlen( mgr_name ) )
-	{
+	if (strlen(mgr_name)) {
 		// The manager name is non-empty; get a pointer to the
 		// first manager with the specified name
-		mgr = theApp.manager_list.GetManagerByName( mgr_name, mgr_id );
-		
-		if ( mgr )
-		{
+		mgr = theApp.manager_list.GetManagerByName(mgr_name, mgr_id);
+
+		if (mgr) {
 			// A manager with the specified name was found in the ManagerList; use it
-			SetResultSource( mgr->GetIndex(), IOERROR, button );
-		}
-		else
-		{
+			SetResultSource(mgr->GetIndex(), IOERROR, button);
+		} else {
 			// No manager with the specified name was found
-			if ( theApp.manager_list.ManagerCount() == 1 )
-			{
+			if (theApp.manager_list.ManagerCount() == 1) {
 				// There is only one manager; use it (ignoring its name)
-				SetResultSource( 0, IOERROR, button );
-			}
-			else
-			{
+				SetResultSource(0, IOERROR, button);
+			} else {
 				// More than one manager; default to ALL_MANAGERS
-				SetResultSource( ALL_MANAGERS, IOERROR, button );
+				SetResultSource(ALL_MANAGERS, IOERROR, button);
 			}
 		}
-	}
-	else
-	{
+	} else {
 		// The manager name is an empty string; use ALL_MANAGERS
-		SetResultSource( ALL_MANAGERS, IOERROR, button );
+		SetResultSource(ALL_MANAGERS, IOERROR, button);
 	}
 }
 
-
-
 //
 // Find a worker by its name (as stored in result file) and select it
 // as though it had been dragged.
 // 
-void CPageDisplay::SelectWorkerByName( int button, const char *wkr_name, const int wkr_id )
+void CPageDisplay::SelectWorkerByName(int button, const char *wkr_name, const int wkr_id)
 {
 	Manager *mgr;
 	Worker *wkr;
 
-	if ( !wkr_name )
-	{
-		ErrorMessage( "Invalid string in CPageDisplay::SelectWorkerByName()" );
+	if (!wkr_name) {
+		ErrorMessage("Invalid string in CPageDisplay::SelectWorkerByName()");
 		return;
 	}
-
 	// Get a pointer to the button's currently assigned manager
 	mgr = barcharts[button].manager;
-	if ( mgr )
-	{
+	if (mgr) {
 		// The specified button already has a manager (probably was just assigned by 
 		// the previous line in the config file, but even if not we'll use it anyway).
 
-		if ( strlen( wkr_name ) )
-		{
+		if (strlen(wkr_name)) {
 			// The worker name is non-empty; get a pointer to the
 			// first worker with the specified name within the current manager
-			wkr = mgr->GetWorkerByName( wkr_name, wkr_id );
-			
-			if ( wkr )
-			{
+			wkr = mgr->GetWorkerByName(wkr_name, wkr_id);
+
+			if (wkr) {
 				// A worker with the specified name was found; use it
-				SetResultSource( mgr->GetIndex(), wkr->GetIndex(), button );
-			}
-			else
-			{
+				SetResultSource(mgr->GetIndex(), wkr->GetIndex(), button);
+			} else {
 				// No worker with the specified name was found
-				if ( mgr->WorkerCount() == 1 )
-				{
+				if (mgr->WorkerCount() == 1) {
 					// There is only one worker; use it (ignoring its name)
-					SetResultSource( mgr->GetIndex(), 0, button );
-				}
-				else
-				{
+					SetResultSource(mgr->GetIndex(), 0, button);
+				} else {
 					// More than one worker; default to all workers
-					SetResultSource( mgr->GetIndex(), IOERROR, button );
+					SetResultSource(mgr->GetIndex(), IOERROR, button);
 				}
 			}
-		}
-		else
-		{
+		} else {
 			// The worker name is an empty string; use all workers
-			SetResultSource( mgr->GetIndex(), IOERROR, button );
+			SetResultSource(mgr->GetIndex(), IOERROR, button);
 		}
 	}
 	// Else: the specified button does not have a manager, ignore the specified worker name
 }
 
-
 //
 // Called by OnTWorker1 - OnTWorker6 in response to left mouse button
 // clicks on the worker/manager name above the result display bars.
 //
-void CPageDisplay::SelectWorkerViewItem(const int bar_number) 
+void CPageDisplay::SelectWorkerViewItem(const int bar_number)
 {
 	// Highlight the manager/worker/whatever being monitored by the chosen bar.
-	theApp.pView->m_pWorkerView->SelectItem(
-		barcharts[bar_number].manager,
-		barcharts[bar_number].worker );
+	theApp.pView->m_pWorkerView->SelectItem(barcharts[bar_number].manager, barcharts[bar_number].worker);
 }
 
-
 void CPageDisplay::ClearCheckButton()
 {
-	CButton* button;
+	CButton *button;
 	CRect button_rect;
 	CPoint point;
 
@@ -1065,9 +966,9 @@
 	// not on the button that poped the popup up, Windows handles removing the
 	// menu.  We have to handle unchecking the button.
 
-	button = (CButton*)GetDlgItem( BResultType1 + selected_button );
-	button->GetWindowRect( &button_rect );
-	GetCursorPos( &point );
+	button = (CButton *) GetDlgItem(BResultType1 + selected_button);
+	button->GetWindowRect(&button_rect);
+	GetCursorPos(&point);
 
 	// Note that we only reset the state of the check button if the cursor is
 	// not within the button's bounding rectangle.  If the cursor is within
@@ -1075,86 +976,74 @@
 	// Button handler will take care of unchecking the button, and will not
 	// display the menu.  This allows the button to toggle the menu.
 
-	if ( button->GetCheck() && !button_rect.PtInRect( point ) )
-		button->SetCheck( FALSE );
+	if (button->GetCheck() && !button_rect.PtInRect(point))
+		button->SetCheck(FALSE);
 
 	// If the Big Meter display is open, the WM_EXITMENULOOP message may have
 	// been intended for that dialog box.  Uncheck its ResultType button.
 
-	if ( m_dlgBigMeter.is_displayed )
+	if (m_dlgBigMeter.is_displayed)
 		m_dlgBigMeter.ClearCheckButton();
 }
 
-
-
 //
 // Show the big performance meter for a given performance bar.
 //
-void CPageDisplay::ShowBigMeter( int performance_bar )
+void CPageDisplay::ShowBigMeter(int performance_bar)
 {
 	CString stat_title, worker_title;
 
 	// Get the name of the result we are displaying from the appropriate performance bar.
-	GetDlgItem( BResultType1 + performance_bar )->GetWindowText( stat_title );
+	GetDlgItem(BResultType1 + performance_bar)->GetWindowText(stat_title);
 	// Get the name of the worker (or manager or All Managers) being watched.
-	GetDlgItem( TWorker1 + performance_bar )->GetWindowText( worker_title );
+	GetDlgItem(TWorker1 + performance_bar)->GetWindowText(worker_title);
 
 	// Create the big performance meter dialog for the given performance bar.
-	m_dlgBigMeter.Create( performance_bar, (CString)"Iometer " + theApp.GetVersionString()
-		+ " " + theApp.pView->m_pPageSetup->test_name, stat_title, worker_title );
+	m_dlgBigMeter.Create(performance_bar, (CString) "Iometer " + theApp.GetVersionString()
+			     + " " + theApp.pView->m_pPageSetup->test_name, stat_title, worker_title);
 }
 
-
-
 //
 // Save the current settings of the page to a file.
 //
-BOOL CPageDisplay::SaveConfig( ostream& outfile )
+BOOL CPageDisplay::SaveConfig(ostream & outfile)
 {
 	int i;
 	CString statistic;
 
 	// Update memory variables with data located on GUI.
-	UpdateData( TRUE );
+	UpdateData(TRUE);
 
 	// Save settings for page as a whole.
-	outfile << "'RESULTS DISPLAY ======================="
-			   "========================================" << endl;
+	outfile << "'RESULTS DISPLAY =======================" "========================================" << endl;
 
-	outfile << "'Update Frequency,Update Type" << endl
-			<< "\t" << GetUpdateDelay() / 1000;
-	
-	if ( GetWhichPerf() == LAST_UPDATE_PERF )
+	outfile << "'Update Frequency,Update Type" << endl << "\t" << GetUpdateDelay() / 1000;
+
+	if (GetWhichPerf() == LAST_UPDATE_PERF)
 		outfile << "," << "LAST_UPDATE" << endl;
 	else
 		outfile << "," << "WHOLE_TEST" << endl;
 
 	// Save bar chart settings.
-	for ( i = 0; i < NUM_STATUS_BARS; i++ )
-	{
+	for (i = 0; i < NUM_STATUS_BARS; i++) {
 		// Get the name of the result we are displaying.
-		GetDlgItem( BResultType1 + i )->GetWindowText( statistic );
+		GetDlgItem(BResultType1 + i)->GetWindowText(statistic);
 
 		// Output settings for this bar chart (each setting gets a line to itself
 		// because these names can contain spaces and commas)
 
 		// Record which statistic is being monitored.
-		outfile << "'Bar chart " << (i + 1) << " statistic" << endl
-				<< "\t" << (LPCTSTR) statistic << endl;
+		outfile << "'Bar chart " << (i + 1) << " statistic" << endl << "\t" << (LPCTSTR) statistic << endl;
 
 		// Is a specific manager being monitored?
-		if ( barcharts[i].manager )
-		{
+		if (barcharts[i].manager) {
 			outfile << "'Bar chart " << (i + 1) << " manager ID, manager name" << endl
-					<< "\t" << barcharts[i].manager->id
-					<< "," << barcharts[i].manager->name << endl;
+			    << "\t" << barcharts[i].manager->id << "," << barcharts[i].manager->name << endl;
 
 			// Is a specific worker on that manager being monitored?
-			if ( barcharts[i].worker )
-			{
+			if (barcharts[i].worker) {
 				outfile << "'Bar chart " << (i + 1) << " worker ID, worker name" << endl
-						<< "\t" << barcharts[i].worker->id
-						<< "," << barcharts[i].worker->name << endl;
+				    << "\t" << barcharts[i].worker->id << "," << barcharts[i].worker->name << endl;
 			}
 		}
 	}
@@ -1165,12 +1054,10 @@
 	return TRUE;
 }
 
-
-
 //
 // Load the settings of the page from a file.
 //
-BOOL CPageDisplay::LoadConfig( const CString& infilename )
+BOOL CPageDisplay::LoadConfig(const CString & infilename)
 {
 	long version;
 	CString key, value;
@@ -1179,60 +1066,50 @@
 	version = infile.GetVersion();
 	if (version == -1)
 		return FALSE;
-	if ( !infile.SkipTo("'RESULTS DISPLAY") )
+	if (!infile.SkipTo("'RESULTS DISPLAY"))
 		return TRUE;	// no results display to restore (this is OK)
 
-	while (1)
-	{
-		if ( !infile.GetPair(key, value) )
-		{
+	while (1) {
+		if (!infile.GetPair(key, value)) {
 			ErrorMessage("File is improperly formatted.  Expected results "
-				"display data or \"END results display\".");
+				     "display data or \"END results display\".");
 			return FALSE;
 		}
 
-		if ( key.CompareNoCase("'END results display") == 0 )
-		{
+		if (key.CompareNoCase("'END results display") == 0) {
 			break;
-		}
-		else if ( key.CompareNoCase("'Update Frequency,Update Type") == 0 )
-		{
+		} else if (key.CompareNoCase("'Update Frequency,Update Type") == 0) {
 			int update_frequency;
 			CString update_type;
 
-			if ( !ICF_ifstream::ExtractFirstInt(value, update_frequency) )
-			{
+			if (!ICF_ifstream::ExtractFirstInt(value, update_frequency)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Update frequency\" should be specified as an integer value.");
+					     "\"Update frequency\" should be specified as an integer value.");
 				return FALSE;
 			}
 
 			update_type = value;
 			update_type.TrimRight();
 
-			SetUpdateDelay( update_frequency );
+			SetUpdateDelay(update_frequency);
 
-			if ( update_type.CompareNoCase("LAST_UPDATE") == 0 )
-				SetWhichPerf( LAST_UPDATE_PERF );
-			else if ( update_type.CompareNoCase("WHOLE_TEST") == 0 )
-				SetWhichPerf( WHOLE_TEST_PERF );
-			else
-			{
+			if (update_type.CompareNoCase("LAST_UPDATE") == 0)
+				SetWhichPerf(LAST_UPDATE_PERF);
+			else if (update_type.CompareNoCase("WHOLE_TEST") == 0)
+				SetWhichPerf(WHOLE_TEST_PERF);
+			else {
 				ErrorMessage("File is improperly formatted.  In RESULTS "
-					"DISPLAY section, Update Frequency was not followed by "
-					"an appropriate Update Type string.");
+					     "DISPLAY section, Update Frequency was not followed by "
+					     "an appropriate Update Type string.");
 				return FALSE;
 			}
-		}
-		else if ( key.Left((int)(strlen("'Bar chart"))).CompareNoCase("'Bar chart") == 0 )
-		{
+		} else if (key.Left((int)(strlen("'Bar chart"))).CompareNoCase("'Bar chart") == 0) {
 			int bar_number;
 			CString bar_item;
 
-			if ( !ICF_ifstream::ExtractFirstInt(key, bar_number) )
-			{
+			if (!ICF_ifstream::ExtractFirstInt(key, bar_number)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Bar chart\" should be followed by an integer value.");
+					     "\"Bar chart\" should be followed by an integer value.");
 				return FALSE;
 			}
 
@@ -1240,68 +1117,56 @@
 			bar_item.TrimLeft();
 			bar_item.TrimRight();
 
-			if ( bar_number < 1 || bar_number > NUM_STATUS_BARS )
-			{
-				ErrorMessage( "Invalid bar chart number in RESULTS DISPLAY "
-					"section.  Ignoring this bar setting." );
+			if (bar_number < 1 || bar_number > NUM_STATUS_BARS) {
+				ErrorMessage("Invalid bar chart number in RESULTS DISPLAY "
+					     "section.  Ignoring this bar setting.");
 				continue;
 			}
 
 			bar_number--;	// convert from one-based to zero-based index
 
-			if ( bar_item.CompareNoCase("statistic") == 0 )
-			{
-				SelectStatisticByName( bar_number, value );
-			}
-			else if ( bar_item.CompareNoCase("manager ID, manager name") == 0 )
-			{
+			if (bar_item.CompareNoCase("statistic") == 0) {
+				SelectStatisticByName(bar_number, value);
+			} else if (bar_item.CompareNoCase("manager ID, manager name") == 0) {
 				CString mgr_name;
 				int mgr_id;
 
-				if ( !ICF_ifstream::ExtractFirstInt(value, mgr_id) )
-				{
+				if (!ICF_ifstream::ExtractFirstInt(value, mgr_id)) {
 					ErrorMessage("Error while reading file.  "
-						"Expected a manager ID integer after \"manager ID, manager name\""
-						"comment in RESULTS DISPLAY section.");
+						     "Expected a manager ID integer after \"manager ID, manager name\""
+						     "comment in RESULTS DISPLAY section.");
 					return FALSE;
 				}
 
 				mgr_name = value;
 
-				SelectManagerByName( bar_number, mgr_name, mgr_id );
-			}
-			else if ( bar_item.CompareNoCase("worker ID, worker name") == 0 )
-			{
+				SelectManagerByName(bar_number, mgr_name, mgr_id);
+			} else if (bar_item.CompareNoCase("worker ID, worker name") == 0) {
 				CString wkr_name;
 				int wkr_id;
 
-				if ( !ICF_ifstream::ExtractFirstInt(value, wkr_id) )
-				{
+				if (!ICF_ifstream::ExtractFirstInt(value, wkr_id)) {
 					ErrorMessage("Error while reading file.  "
-						"Expected a worker ID integer after \"worker ID, worker name\""
-						"comment in RESULTS DISPLAY section.");
+						     "Expected a worker ID integer after \"worker ID, worker name\""
+						     "comment in RESULTS DISPLAY section.");
 					return FALSE;
 				}
 
 				wkr_name = value;
 
-				SelectWorkerByName( bar_number, wkr_name, wkr_id );
-			}
-			else
-			{
+				SelectWorkerByName(bar_number, wkr_name, wkr_id);
+			} else {
 				CString str;
-				str.Format("%d",bar_number);
-				ErrorMessage( "Invalid bar chart item name \""
-					+ bar_item + "\" for bar #" + str 
-					+ " in RESULTS DISPLAY section.  Ignoring this bar "
-					+ "setting." );
+
+				str.Format("%d", bar_number);
+				ErrorMessage("Invalid bar chart item name \""
+					     + bar_item + "\" for bar #" + str
+					     + " in RESULTS DISPLAY section.  Ignoring this bar " + "setting.");
 				continue;
 			}
-		}
-		else
-		{
+		} else {
 			ErrorMessage("File is improperly formatted.  RESULTS DISPLAY "
-				"section contained an unrecognized \"" + key + "\" comment.");
+				     "section contained an unrecognized \"" + key + "\" comment.");
 			return FALSE;
 		}
 	}
@@ -1309,21 +1174,21 @@
 	infile.close();
 
 	// Update the GUI with the values read in from the file.
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 
 	return TRUE;
 }
 
-void CPageDisplay::OnRAvgLastUpdate() 
+void CPageDisplay::OnRAvgLastUpdate()
 {
-	if ( theApp.test_state == TestRecording )
-		theApp.manager_list.UpdateResults( LAST_UPDATE_PERF );
+	if (theApp.test_state == TestRecording)
+		theApp.manager_list.UpdateResults(LAST_UPDATE_PERF);
 	Update();
 }
 
-void CPageDisplay::OnRAvgWholeTest() 
+void CPageDisplay::OnRAvgWholeTest()
 {
-	if ( theApp.test_state == TestRecording )
-		theApp.manager_list.UpdateResults( WHOLE_TEST_PERF );
+	if (theApp.test_state == TestRecording)
+		theApp.manager_list.UpdateResults(WHOLE_TEST_PERF);
 	Update();
 }

Modified: branches/IOMETER-restruct/iometer/src/PageDisplay.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageDisplay.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageDisplay.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,8 +60,6 @@
 #ifndef PAGEDISPLAY_DEFINED
 #define PAGEDISPLAY_DEFINED
 
-
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageDisplay dialog
 
@@ -71,7 +69,6 @@
 #define NUM_STATUS_BARS				6
 #define NUM_UPDATE_TIMES			11
 
-
 // Types of results which may be displayed.
 #define ERROR_RESULT				0
 #define READ_ERROR_RESULT			1
@@ -116,7 +113,6 @@
 
 #define NUM_RESULTS				31
 
-
 // Submenu codes for the IDR_POPUP_DISPLAY_LIST pop-up menu
 enum {
 	MDisplayOpsSubmenuID = 0,
@@ -130,119 +126,148 @@
 
 const int MDisplayNumSubmenus = 7;
 
-
-class CPageDisplay : public CPropertyPage
-{
+class CPageDisplay:public CPropertyPage {
 	DECLARE_DYNCREATE(CPageDisplay)
-
-	// CBigMeter needs access to many of CPageDisplay's private members
+	    // CBigMeter needs access to many of CPageDisplay's private members
 	friend class CBigMeter;
 
 // Construction
-public:
-	CPageDisplay();
+      public:
+	 CPageDisplay();
 	~CPageDisplay();
- 	void Update();				// Updates the display using with the current results.
-	UINT GetUpdateDelay();		// Reports the update delay in milliseconds based on the slider position.
-	void SetUpdateDelay( UINT new_delay ); // Sets the slider based on the update delay in milliseconds.
-	int GetWhichPerf();			// Reports the current setting of the WholeTest / StartOfTest control.
-	void SetWhichPerf( int which_perf ); // Sets the WholeTest/StartOfTest control.
-	void Initialize();			// Set the display to an initial state.
-	void Reset();				// Resets the display.
+	void Update();		// Updates the display using with the current results.
+	UINT GetUpdateDelay();	// Reports the update delay in milliseconds based on the slider position.
+	void SetUpdateDelay(UINT new_delay);	// Sets the slider based on the update delay in milliseconds.
+	int GetWhichPerf();	// Reports the current setting of the WholeTest / StartOfTest control.
+	void SetWhichPerf(int which_perf);	// Sets the WholeTest/StartOfTest control.
+	void Initialize();	// Set the display to an initial state.
+	void Reset();		// Resets the display.
 	void ClearCheckButton();
-	void SetResultSource( int manager_index, int worker_index, CPoint point );	// to any worker or manager.
-	void SetResultSource( int manager_index, int worker_index, int selected_progress_bar );	
-	void OnMDisplay( int submenu_id, int menu_item, int result_code );	// Handle a menu item hit
-	void ShowBigMeter( int performance_bar );	// Show the big performance meter.
-	BOOL SaveConfig( ostream& outfile );		// Save current settings to a file.
-	BOOL LoadConfig( const CString& infilename );	// Load current settings from a file.
-	void SelectStatisticByName( int button, const char *statistic_name );
-	void SelectManagerByName( int button, const char *mgr_name, const int mgr_id );
-	void SelectWorkerByName( int button, const char *wkr_name, const int wkr_id );
-	void SelectWorkerViewItem( const int bar_number );
+	void SetResultSource(int manager_index, int worker_index, CPoint point);	// to any worker or manager.
+	void SetResultSource(int manager_index, int worker_index, int selected_progress_bar);
+	void OnMDisplay(int submenu_id, int menu_item, int result_code);	// Handle a menu item hit
+	void ShowBigMeter(int performance_bar);	// Show the big performance meter.
+	BOOL SaveConfig(ostream & outfile);	// Save current settings to a file.
+	BOOL LoadConfig(const CString & infilename);	// Load current settings from a file.
+	void SelectStatisticByName(int button, const char *statistic_name);
+	void SelectManagerByName(int button, const char *mgr_name, const int mgr_id);
+	void SelectWorkerByName(int button, const char *wkr_name, const int wkr_id);
+	void SelectWorkerViewItem(const int bar_number);
 // Dialog Data
 	//{{AFX_DATA(CPageDisplay)
 	enum { IDD = IDD_DISPLAY };
-	CSliderCtrl	m_SUpdateDelay;
-	CProgressCtrl	m_PRate1;
-	CProgressCtrl	m_PRate2;
-	CProgressCtrl	m_PRate3;
-	CProgressCtrl	m_PRate4;
-	CProgressCtrl	m_PRate5;
-	CProgressCtrl	m_PRate6;
+	CSliderCtrl m_SUpdateDelay;
+	CProgressCtrl m_PRate1;
+	CProgressCtrl m_PRate2;
+	CProgressCtrl m_PRate3;
+	CProgressCtrl m_PRate4;
+	CProgressCtrl m_PRate5;
+	CProgressCtrl m_PRate6;
 	//}}AFX_DATA
 
 	// Big Meter dialog box
-	CBigMeter		m_dlgBigMeter;
+	CBigMeter m_dlgBigMeter;
 
 // Overrides
 	// ClassWizard generate virtual function overrides
 	//{{AFX_VIRTUAL(CPageDisplay)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 	// Generated message map functions
 	//{{AFX_MSG(CPageDisplay)
-	virtual BOOL OnInitDialog();						// Inits everything.
-	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);	// Update the display when
+	 virtual BOOL OnInitDialog();	// Inits everything.
+	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar * pScrollBar);	// Update the display when
 	afx_msg void OnRAvgLastUpdate();
 	afx_msg void OnRAvgWholeTest();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
+	    // The OnBResultType[1..6]() functions are called in response to a click on one of the result
+	    // type selection buttons.  We need 6 separate functions since a button press handler does
+	    // not receive any parameters indicating which button was pressed.  Each one just calls 
+	    // OnBResultType() to pop up the result type menu, with a numeric parameter indicating 
+	    // which button was pressed.
+	afx_msg void OnBResultType1() {
+		OnBResultType(0);
+	} afx_msg void OnBResultType2() {
+		OnBResultType(1);
+	}
+	afx_msg void OnBResultType3() {
+		OnBResultType(2);
+	}
+	afx_msg void OnBResultType4() {
+		OnBResultType(3);
+	}
+	afx_msg void OnBResultType5() {
+		OnBResultType(4);
+	}
+	afx_msg void OnBResultType6() {
+		OnBResultType(5);
+	}
 
-	// The OnBResultType[1..6]() functions are called in response to a click on one of the result
-	// type selection buttons.  We need 6 separate functions since a button press handler does
-	// not receive any parameters indicating which button was pressed.  Each one just calls 
-	// OnBResultType() to pop up the result type menu, with a numeric parameter indicating 
-	// which button was pressed.
-	afx_msg void OnBResultType1() { OnBResultType( 0 ); }
-	afx_msg void OnBResultType2() { OnBResultType( 1 ); }
-	afx_msg void OnBResultType3() { OnBResultType( 2 ); }
-	afx_msg void OnBResultType4() { OnBResultType( 3 ); }
-	afx_msg void OnBResultType5() { OnBResultType( 4 ); }
-	afx_msg void OnBResultType6() { OnBResultType( 5 ); }
-
 	// Inline BBigMeterX button click handlers
-	afx_msg void OnBBigMeter1() { ShowBigMeter( 0 ); }
-	afx_msg void OnBBigMeter2() { ShowBigMeter( 1 ); }
-	afx_msg void OnBBigMeter3() { ShowBigMeter( 2 ); }
-	afx_msg void OnBBigMeter4() { ShowBigMeter( 3 ); }
-	afx_msg void OnBBigMeter5() { ShowBigMeter( 4 ); }
-	afx_msg void OnBBigMeter6() { ShowBigMeter( 5 ); }
+	afx_msg void OnBBigMeter1() {
+		ShowBigMeter(0);
+	}
+	afx_msg void OnBBigMeter2() {
+		ShowBigMeter(1);
+	}
+	afx_msg void OnBBigMeter3() {
+		ShowBigMeter(2);
+	}
+	afx_msg void OnBBigMeter4() {
+		ShowBigMeter(3);
+	}
+	afx_msg void OnBBigMeter5() {
+		ShowBigMeter(4);
+	}
+	afx_msg void OnBBigMeter6() {
+		ShowBigMeter(5);
+	}
 
 	// Called when user clicks on worker/manager name above each result bar.
-	afx_msg void OnTWorker1() { SelectWorkerViewItem( 0 ); }
-	afx_msg void OnTWorker2() { SelectWorkerViewItem( 1 ); }
-	afx_msg void OnTWorker3() { SelectWorkerViewItem( 2 ); }
-	afx_msg void OnTWorker4() { SelectWorkerViewItem( 3 ); }
-	afx_msg void OnTWorker5() { SelectWorkerViewItem( 4 ); }
-	afx_msg void OnTWorker6() { SelectWorkerViewItem( 5 ); }
+	afx_msg void OnTWorker1() {
+		SelectWorkerViewItem(0);
+	}
+	afx_msg void OnTWorker2() {
+		SelectWorkerViewItem(1);
+	}
+	afx_msg void OnTWorker3() {
+		SelectWorkerViewItem(2);
+	}
+	afx_msg void OnTWorker4() {
+		SelectWorkerViewItem(3);
+	}
+	afx_msg void OnTWorker5() {
+		SelectWorkerViewItem(4);
+	}
+	afx_msg void OnTWorker6() {
+		SelectWorkerViewItem(5);
+	}
 
-	void			OnBResultType( int which_button );
-	unsigned int	GetMaxRange( Results* results, int result_type );
-	unsigned int	ReportMaxRange( double max_range_needed );
+	void OnBResultType(int which_button);
+	unsigned int GetMaxRange(Results * results, int result_type);
+	unsigned int ReportMaxRange(double max_range_needed);
 
 	// Returns the appropriate result value in a double and a CString
-	BOOL			GetDisplayData(	Results* results, int result_type,
-									double *result_value, CString *result_text );
+	BOOL GetDisplayData(Results * results, int result_type, double *result_value, CString * result_text);
 
-private:
+      private:
 
 	struct {
-		int		result_to_display;
-		char	*name;
-		Results	*results; // Pointer to base of results[MAX_UPDATE] array
-		Manager	*manager;
-		Worker	*worker;
+		int result_to_display;
+		char *name;
+		Results *results;	// Pointer to base of results[MAX_UPDATE] array
+		Manager *manager;
+		Worker *worker;
 	} barcharts[NUM_STATUS_BARS];
 
-	int			selected_button;
+	int selected_button;
 
-	UINT		delay_table[NUM_UPDATE_TIMES];
+	UINT delay_table[NUM_UPDATE_TIMES];
 };
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/PageNetwork.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageNetwork.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageNetwork.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,12 +64,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "PageNetwork.h"
 #include "GalileoView.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -80,31 +78,30 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageNetwork property page
 
 IMPLEMENT_DYNCREATE(CPageNetwork, CPropertyPage)
 
-CPageNetwork::CPageNetwork() : CPropertyPage(CPageNetwork::IDD)
+CPageNetwork::CPageNetwork():CPropertyPage(CPageNetwork::IDD)
 {
 	//{{AFX_DATA_INIT(CPageNetwork)
-		// NOTE: the ClassWizard will add member initialization here
+	// NOTE: the ClassWizard will add member initialization here
 	//}}AFX_DATA_INIT
-} 
+}
 
 CPageNetwork::~CPageNetwork()
 {
 }
 
-void CPageNetwork::DoDataExchange(CDataExchange* pDX)
+void CPageNetwork::DoDataExchange(CDataExchange * pDX)
 {
 	CPropertyPage::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CPageNetwork)
@@ -117,46 +114,40 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CPageNetwork, CPropertyPage)
-	//{{AFX_MSG_MAP(CPageNetwork)
-	ON_NOTIFY(NM_CLICK, TTargets, OnClickTTargets)
-	ON_BN_CLICKED(CConnectionRate, OnCConnectionRate)
-	ON_NOTIFY(UDN_DELTAPOS, SConnectionRate, OnDeltaposSConnectionRate)
-	ON_EN_SETFOCUS(EConnectionRate, OnSetfocusEConnectionRate)
-	ON_NOTIFY(TVN_SELCHANGING, TTargets, OnSelchangingTTargets)
-	ON_CBN_SELCHANGE(DInterface, OnSelchangeDInterface)
-	ON_EN_KILLFOCUS(EConnectionRate, OnKillfocusEConnectionRate)
-	ON_NOTIFY(TVN_KEYDOWN, TTargets, OnKeydownTTargets)
-	ON_NOTIFY(NM_DBLCLK, TTargets, OnDblclkTTargets)
-	ON_NOTIFY(NM_SETFOCUS, TTargets, OnSetfocusTTargets)
-	ON_EN_KILLFOCUS(EMaxSends, OnKillfocusEMaxSends)
-	ON_EN_SETFOCUS(EMaxSends, OnSetfocusEMaxSends)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CPageNetwork)
+    ON_NOTIFY(NM_CLICK, TTargets, OnClickTTargets)
+    ON_BN_CLICKED(CConnectionRate, OnCConnectionRate)
+    ON_NOTIFY(UDN_DELTAPOS, SConnectionRate, OnDeltaposSConnectionRate)
+    ON_EN_SETFOCUS(EConnectionRate, OnSetfocusEConnectionRate)
+    ON_NOTIFY(TVN_SELCHANGING, TTargets, OnSelchangingTTargets)
+    ON_CBN_SELCHANGE(DInterface, OnSelchangeDInterface)
+    ON_EN_KILLFOCUS(EConnectionRate, OnKillfocusEConnectionRate)
+    ON_NOTIFY(TVN_KEYDOWN, TTargets, OnKeydownTTargets)
+    ON_NOTIFY(NM_DBLCLK, TTargets, OnDblclkTTargets)
+    ON_NOTIFY(NM_SETFOCUS, TTargets, OnSetfocusTTargets)
+    ON_EN_KILLFOCUS(EMaxSends, OnKillfocusEMaxSends)
+ON_EN_SETFOCUS(EMaxSends, OnSetfocusEMaxSends)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageNetwork message handlers
-
-
-BOOL CPageNetwork::OnInitDialog() 
+BOOL CPageNetwork::OnInitDialog()
 {
 	CPropertyPage::OnInitDialog();
 
 	// Associate the image list with the TTargets tree control
-	m_ImageList.Create( IDB_TARGET_ICONS, TARGET_ICON_SIZE, TARGET_ICON_EXPAND, TARGET_ICON_BGCOLOR );
-	m_TTargets.SetImageList( &m_ImageList, TVSIL_NORMAL );
-	m_TTargets.SetImageList( &m_ImageList, TVSIL_STATE ); // Use the same image list for state images
+	m_ImageList.Create(IDB_TARGET_ICONS, TARGET_ICON_SIZE, TARGET_ICON_EXPAND, TARGET_ICON_BGCOLOR);
+	m_TTargets.SetImageList(&m_ImageList, TVSIL_NORMAL);
+	m_TTargets.SetImageList(&m_ImageList, TVSIL_STATE);	// Use the same image list for state images
 
 	// Set the spin control to translate an up click into a positive movement.
-	m_SConnectionRate.SetRange( 0, UD_MAXVAL );
+	m_SConnectionRate.SetRange(0, UD_MAXVAL);
 
 	Reset();
 	return TRUE;
 }
 
-
-
 //
 // Grays out the check boxes in the target list, clears the interface
 // selection, sets the conneciton rate check box to it's 3rd state,
@@ -180,41 +171,37 @@
 	EnableWindow();
 }
 
-
-
 //
 // Enable or disable the tab's windows, if apropriate.
 //
-void CPageNetwork::EnableWindow( BOOL enable )
+void CPageNetwork::EnableWindow(BOOL enable)
 {
-	Manager	*manager;
-	Worker	*worker;
-	int		selected_type;
-	CWnd	*last_focused;
-	BOOL	enable_max_sends = false;
+	Manager *manager;
+	Worker *worker;
+	int selected_type;
+	CWnd *last_focused;
+	BOOL enable_max_sends = false;
 
 	// Only enable thingies if a test is not running.
-	if ( theApp.test_state != TestIdle )
+	if (theApp.test_state != TestIdle)
 		return;
 
 	selected_type = theApp.pView->m_pWorkerView->GetSelectedType();
-	switch ( selected_type )
-	{
+	switch (selected_type) {
 	case WORKER:
 		// Get the current worker selection.
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
-		enable = enable && IsType( worker->Type(), GenericServerType );
-		enable_max_sends = enable && IsType( worker->Type(), VIServerType );
+		enable = enable && IsType(worker->Type(), GenericServerType);
+		enable_max_sends = enable && IsType(worker->Type(), VIServerType);
 
 		// If the selected worker is a disk worker,
 		// switch to the disk targets page.
-		if ( IsType( worker->Type(), GenericDiskType ) && 
-			theApp.pView->m_pPropSheet->GetActiveIndex() == NETWORK_PAGE )
-		{
+		if (IsType(worker->Type(), GenericDiskType) &&
+		    theApp.pView->m_pPropSheet->GetActiveIndex() == NETWORK_PAGE) {
 			last_focused = GetFocus();
-			theApp.pView->m_pPropSheet->SetActivePage( DISK_PAGE );
-			if ( last_focused )
+			theApp.pView->m_pPropSheet->SetActivePage(DISK_PAGE);
+			if (last_focused)
 				last_focused->SetFocus();
 		}
 		break;
@@ -222,84 +209,76 @@
 		// Get the current manager selection.
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
 
-		enable = enable && manager->WorkerCount( GenericServerType );
-		enable_max_sends = enable && manager->WorkerCount( VIServerType );
+		enable = enable && manager->WorkerCount(GenericServerType);
+		enable_max_sends = enable && manager->WorkerCount(VIServerType);
 
 		// If the selected manager has no network servers but has disk workers,
 		// switch to the disk targets page.
-		if ( !manager->WorkerCount( GenericServerType ) && 
-			manager->WorkerCount( GenericDiskType ) &&
-			theApp.pView->m_pPropSheet->GetActiveIndex() == NETWORK_PAGE )
-		{
+		if (!manager->WorkerCount(GenericServerType) &&
+		    manager->WorkerCount(GenericDiskType) &&
+		    theApp.pView->m_pPropSheet->GetActiveIndex() == NETWORK_PAGE) {
 			enable = FALSE;
 			last_focused = GetFocus();
-			theApp.pView->m_pPropSheet->SetActivePage( DISK_PAGE );
-			if ( last_focused )
+			theApp.pView->m_pPropSheet->SetActivePage(DISK_PAGE);
+			if (last_focused)
 				last_focused->SetFocus();
 		}
 		break;
 	case ALL_MANAGERS:
 		// Only enable the connection rate controls if there exists a
 		// server worker.
-		enable = enable && theApp.manager_list.WorkerCount( GenericServerType );
-		enable_max_sends = enable && (theApp.manager_list.WorkerCount( VIServerType ));
+		enable = enable && theApp.manager_list.WorkerCount(GenericServerType);
+		enable_max_sends = enable && (theApp.manager_list.WorkerCount(VIServerType));
 	}
 
 	// Do not enable the target list for all managers.
-	m_TTargets.EnableWindow( enable && selected_type != ALL_MANAGERS );
-	m_DInterface.EnableWindow( enable && selected_type != ALL_MANAGERS );
+	m_TTargets.EnableWindow(enable && selected_type != ALL_MANAGERS);
+	m_DInterface.EnableWindow(enable && selected_type != ALL_MANAGERS);
 
-	m_EMaxSends.EnableWindow( enable_max_sends );
+	m_EMaxSends.EnableWindow(enable_max_sends);
 
 	// Enable the connection rate check box.
-	m_CConnectionRate.EnableWindow( enable );
+	m_CConnectionRate.EnableWindow(enable);
 
 	// Enable the connection rate edit box and spin control if the connection 
 	// rate check box is checked.
-	m_EConnectionRate.EnableWindow( enable &&
-		m_CConnectionRate.GetCheck() == 1 );
-	m_SConnectionRate.EnableWindow( enable &&
-		m_CConnectionRate.GetCheck() == 1 );
-		
+	m_EConnectionRate.EnableWindow(enable && m_CConnectionRate.GetCheck() == 1);
+	m_SConnectionRate.EnableWindow(enable && m_CConnectionRate.GetCheck() == 1);
+
 	// The spin button sometimes needs to be redrawn even if it didn't change
 	// when the edit box was partially redrawn.
-	m_SConnectionRate.Invalidate( TRUE );
+	m_SConnectionRate.Invalidate(TRUE);
 
 	// Redraw the page.  Note that all the child windows will be redrawn too.
 	// Also note that only windows that have already been invalidated will get
 	// redrawn, avoiding much flicker.
-	RedrawWindow( NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE );
+	RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE);
 }
 
-
-
 //
 // Adds a manager and it's interfaces to the tree view.
 //
-void CPageNetwork::AddManager( Manager *manager )
+void CPageNetwork::AddManager(Manager * manager)
 {
-	TV_INSERTSTRUCT		tvstruct;
-	HTREEITEM			hmgr, hifc;
-	Manager				*sel_mgr;
+	TV_INSERTSTRUCT tvstruct;
+	HTREEITEM hmgr, hifc;
+	Manager *sel_mgr;
 
 	// Do not add the manager if it doesn't have any interfaces that are
 	// accessible from the selected manager.
-	if ( !(sel_mgr = theApp.pView->m_pWorkerView->GetSelectedManager()) )
+	if (!(sel_mgr = theApp.pView->m_pWorkerView->GetSelectedManager()))
 		return;
-	
+
 	// First see if it has any interfaces, if not, don't add it.
-	if (( !sel_mgr->InterfaceCount( GenericNetType ) ) ||
-		// Next see if the selected manager only has TCP interfaces, but the
-		// manager to add has none.
-		( (sel_mgr->InterfaceCount( GenericTCPType ) ==
-			sel_mgr->InterfaceCount( GenericNetType )) &&
-			!manager->InterfaceCount( GenericTCPType ) ) ||	
-		// Next see if the selected manager only has VI interfaces, but the
-		// manager to add has none.
-		( (sel_mgr->InterfaceCount( GenericVIType ) ==
-			sel_mgr->InterfaceCount( GenericNetType )) &&
-			!manager->InterfaceCount( GenericVIType ) ) )
-	{
+	if ((!sel_mgr->InterfaceCount(GenericNetType)) ||
+	    // Next see if the selected manager only has TCP interfaces, but the
+	    // manager to add has none.
+	    ((sel_mgr->InterfaceCount(GenericTCPType) ==
+	      sel_mgr->InterfaceCount(GenericNetType)) && !manager->InterfaceCount(GenericTCPType)) ||
+	    // Next see if the selected manager only has VI interfaces, but the
+	    // manager to add has none.
+	    ((sel_mgr->InterfaceCount(GenericVIType) ==
+	      sel_mgr->InterfaceCount(GenericNetType)) && !manager->InterfaceCount(GenericVIType))) {
 		return;
 	}
 	// At least one of the manager's interfaces are accessible.
@@ -320,13 +299,11 @@
 	// note: manager has no state (check box) icon!
 
 	// Insert the manager into the tree control.
-	hmgr = m_TTargets.InsertItem( &tvstruct );
-	if ( hmgr == NULL )
-	{
+	hmgr = m_TTargets.InsertItem(&tvstruct);
+	if (hmgr == NULL) {
 		ErrorMessage("InsertItem() for target manager failed in CPageNetwork::AddManager()");
 		return;
 	}
-
 	// Set the interface item properties here.  The only property that changes
 	// is the name.
 	// Set the mask to indicate that the image, selected image, text, and state
@@ -348,144 +325,113 @@
 	// either checked or cleared (it should be cleared).  Default to cleared
 	// if this is the first manager.  This needs to be done in case a manager
 	// logs in while we are already displaying a selection.
-	tvstruct.item.state = INDEXTOSTATEIMAGEMASK( TARGET_STATE_UNCHECKED );
+	tvstruct.item.state = INDEXTOSTATEIMAGEMASK(TARGET_STATE_UNCHECKED);
 
 	// insert the manager's network interfaces as its children in the tree
-	for ( int n = 0; n < manager->InterfaceCount( GenericNetType ); n++ )
-	{
+	for (int n = 0; n < manager->InterfaceCount(GenericNetType); n++) {
 		// Only add interfaces that are accessible.
-		if ( !sel_mgr->InterfaceCount( manager->GetInterface( n, 
-			GenericNetType )->type ) )
-		{
+		if (!sel_mgr->InterfaceCount(manager->GetInterface(n, GenericNetType)->type)) {
 			continue;
 		}
-
 		// name the interface
-		tvstruct.item.pszText = manager->GetInterface( n, GenericNetType )->name;
+		tvstruct.item.pszText = manager->GetInterface(n, GenericNetType)->name;
 
 		// insert the interface into the tree control
-		hifc = m_TTargets.InsertItem( &tvstruct );
-		if ( hifc == NULL )
-		{
+		hifc = m_TTargets.InsertItem(&tvstruct);
+		if (hifc == NULL) {
 			ErrorMessage("InsertItem() for interface failed in CPageNetwork::AddManager()");
 			return;
 		}
 	}
 
 	// make the manager's child icons visible
-	if ( n && !m_TTargets.Expand( tvstruct.hParent, TVE_EXPAND ) )
-	{
+	if (n && !m_TTargets.Expand(tvstruct.hParent, TVE_EXPAND)) {
 		ErrorMessage("Expand() for target manager failed in CPageNetwork::AddManager()");
 	}
 }
 
-
-
 //
 // Takes a given manager and its interfaces out of the tree.
 //
-void CPageNetwork::RemoveManager( Manager *manager )
+void CPageNetwork::RemoveManager(Manager * manager)
 {
 	HTREEITEM hmgr;
 
 	// Walk the tree until we find the given manager.
-	for ( hmgr = m_TTargets.GetRootItem(); hmgr;
-		hmgr = m_TTargets.GetNextSiblingItem( hmgr ) )
-	{
-		if ( m_TTargets.GetItemData( hmgr ) == (DWORD_PTR)manager )
-		{
-			m_TTargets.DeleteItem( hmgr );
+	for (hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
+		if (m_TTargets.GetItemData(hmgr) == (DWORD_PTR) manager) {
+			m_TTargets.DeleteItem(hmgr);
 			break;
 		}
 	}
 }
 
-
-
 //
 // Fill in the target list.
 //
 void CPageNetwork::ShowTargets()
 {
-	Manager		*manager;
-	int			mgr_no = 0;
+	Manager *manager;
+	int mgr_no = 0;
 
 	m_TTargets.DeleteAllItems();
 
 	// Determine what interfaces are visible to the selected item.
-	if ( theApp.pView->m_pWorkerView->GetSelectedType() == ALL_MANAGERS )
+	if (theApp.pView->m_pWorkerView->GetSelectedType() == ALL_MANAGERS)
 		return;
 
 	// Loop through the managers and add them to the tree view.
-	while ( manager = theApp.manager_list.GetManager( mgr_no++ ) )
-	{
+	while (manager = theApp.manager_list.GetManager(mgr_no++)) {
 		// Add all accessible interfaces to the target list.
-		AddManager( manager );
+		AddManager(manager);
 	}
 }
 
-
-
 void CPageNetwork::ShowTargetSelection()
 {
-	Manager		*manager, *partner_manager;
-	Worker		*worker, *partner_worker;
-	char		*remote_address;
-	HTREEITEM	hmgr;
-	HTREEITEM	hifc;
-	int			i, expected_worker;
-	TargetSelType		state;
+	Manager *manager, *partner_manager;
+	Worker *worker, *partner_worker;
+	char *remote_address;
+	HTREEITEM hmgr;
+	HTREEITEM hifc;
+	int i, expected_worker;
+	TargetSelType state;
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
 		// Get the interface to check.
-		if ( IsType( worker->Type(), GenericServerType ) )
-		{
-			if ( !worker->net_partner )
-			{
+		if (IsType(worker->Type(), GenericServerType)) {
+			if (!worker->net_partner) {
 				partner_manager = NULL;
-			}
-			else
-			{
+			} else {
 				partner_manager = worker->net_partner->manager;
-				if ( IsType( worker->GetTarget( 0 )->spec.type, TCPClientType ) )
-					remote_address = worker->GetTarget( 0 )->spec.tcp_info.remote_address;
-				else if ( IsType( worker->GetTarget( 0 )->spec.type, VIClientType ) )
-					remote_address = worker->GetTarget( 0 )->spec.vi_info.remote_nic_name;
-				else
-				{
-					ErrorMessage( "Invalid client target type in CPageNetwork::"
-						"ShowTargetSelection()." );
+				if (IsType(worker->GetTarget(0)->spec.type, TCPClientType))
+					remote_address = worker->GetTarget(0)->spec.tcp_info.remote_address;
+				else if (IsType(worker->GetTarget(0)->spec.type, VIClientType))
+					remote_address = worker->GetTarget(0)->spec.vi_info.remote_nic_name;
+				else {
+					ErrorMessage("Invalid client target type in CPageNetwork::"
+						     "ShowTargetSelection().");
 					return;
 				}
 			}
-		}
-		else if ( IsType( worker->Type(), GenericClientType ) )
-		{
+		} else if (IsType(worker->Type(), GenericClientType)) {
 			partner_manager = worker->net_partner->manager;
 			remote_address = worker->net_partner->spec.name;
-		}
-		else
-		{
+		} else {
 			return;
 		}
 
 		// Walk the target tree to find the correct partner manager.
-		for ( hmgr = m_TTargets.GetRootItem(); hmgr;
-			hmgr = m_TTargets.GetNextSiblingItem( hmgr ) )
-		{
-			if ( m_TTargets.GetItemData( hmgr ) == (DWORD_PTR)partner_manager )
-			{
+		for (hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
+			if (m_TTargets.GetItemData(hmgr) == (DWORD_PTR) partner_manager) {
 				// Check the appropriate interface on the partner manager.
-				CheckInterface( hmgr, remote_address );
-			}
-			else
-			{
+				CheckInterface(hmgr, remote_address);
+			} else {
 				// Clear all check marks for this manager's interfaces.
-				CheckInterface( hmgr, NULL );
+				CheckInterface(hmgr, NULL);
 			}
 		}
 		break;
@@ -495,42 +441,33 @@
 		expected_worker = 0;
 
 		// Loop through all the target tree items.
-		for ( hmgr = m_TTargets.GetRootItem(); hmgr;
-			hmgr = m_TTargets.GetNextSiblingItem( hmgr ) )
-		{
+		for (hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
 			// Get the possible partner manager from the tree.
-			partner_manager = (Manager*)m_TTargets.GetItemData( hmgr );
+			partner_manager = (Manager *) m_TTargets.GetItemData(hmgr);
 
 			// Loop through that manager item's interfaces.
-			for ( hifc = m_TTargets.GetChildItem( hmgr ); hifc;
-				hifc = m_TTargets.GetNextSiblingItem( hifc ) )
-			{
+			for (hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
 				// Initialize the state.  It may or may not be changed, 
 				// depending on whether we find it selected by a worker.
 				state = TargetUnChecked;
 
 				// Check the interface for selection by any of the manager's
 				// workers
-				for ( i = 0; i < manager->WorkerCount( GenericServerType ); i++ )
-				{
+				for (i = 0; i < manager->WorkerCount(GenericServerType); i++) {
 					// Get the net partner of the expected worker.
-					partner_worker = manager->GetWorker( i, 
-						GenericServerType )->net_partner;
+					partner_worker = manager->GetWorker(i, GenericServerType)->net_partner;
 
 					// If the partner worker exists and it's manager is the
 					// same as the manager in the target tree that we are
 					// currently looking at and..
-					if ( partner_worker && 
-						partner_worker->manager == partner_manager )
-					{
+					if (partner_worker && partner_worker->manager == partner_manager) {
 						// if the net addresses match but..
-						if ( m_TTargets.GetItemText( hifc ) == partner_worker->GetLocalNetworkInterface() )
-						{
+						if (m_TTargets.GetItemText(hifc) ==
+						    partner_worker->GetLocalNetworkInterface()) {
 							// the worker is not the expected worker..
-							if ( i != expected_worker || state != TargetUnChecked )
-							{
+							if (i != expected_worker || state != TargetUnChecked) {
 								// gray the selection
-								SetAllCheck( TargetGrayed );
+								SetAllCheck(TargetGrayed);
 								return;
 							}
 							state = TargetChecked;
@@ -538,38 +475,33 @@
 						}
 					}
 				}
-				SetSelectionCheck( hifc, state );
+				SetSelectionCheck(hifc, state);
 			}
 		}
 		break;
 	default:
-		SetAllCheck( TargetGrayed );
+		SetAllCheck(TargetGrayed);
 		break;
 	}
 }
 
-
-
 //
 // Used to select one or more targets.  May or may not clear any previous
 // selection depending on the replace parameter.
 //
-void CPageNetwork::SelectRange( HTREEITEM hstart, HTREEITEM hend, BOOL replace,
-							   TargetSelType state )
+void CPageNetwork::SelectRange(HTREEITEM hstart, HTREEITEM hend, BOOL replace, TargetSelType state)
 {
 	HTREEITEM hmgr, hifc;
 	BOOL in_range;
 
-	if ( !hstart || !hend )
-	{
-		ErrorMessage( "Unexpectedly found start or end point of selection"
-			" range equal NULL in CPageNetwork::SelectRange()." );
+	if (!hstart || !hend) {
+		ErrorMessage("Unexpectedly found start or end point of selection"
+			     " range equal NULL in CPageNetwork::SelectRange().");
 		return;
 	}
-
 	// Clear all the check boxes if forced to or if a multiple selection occurs.
-	if ( replace )
-		SetAllCheck( TargetUnChecked );
+	if (replace)
+		SetAllCheck(TargetUnChecked);
 
 	// The last selection is the start point.
 	selected = hstart;
@@ -577,12 +509,10 @@
 
 	// Note that if both endpoints are the same, other selections will be 
 	// unchecked depending on the value of the 'replace' variable.
-	if ( hstart == hend )
-	{
-		SetSelectionCheck( hstart, state );
+	if (hstart == hend) {
+		SetSelectionCheck(hstart, state);
 		return;
 	}
-
 	// Since we don't know the relationship between the clicked item
 	// and the last selection (up or down), we do not know what
 	// direction to select targets in.  Do a linear seach of the target tree
@@ -590,153 +520,114 @@
 	// all the targets the specified selection type until we reach the end or
 	// start (whichever we didn't get before).
 	in_range = FALSE;
-	for ( hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = 
-		m_TTargets.GetNextSiblingItem( hmgr ) )
-	{
-		for ( hifc = m_TTargets.GetChildItem( hmgr ); hifc; hifc = 
-			m_TTargets.GetNextSiblingItem( hifc ) )
-		{
+	for (hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
+		for (hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
 			// Do we have either the previously selected item or the
-			// clicked item?  			
-			if ( hifc == hstart || hifc == hend )
+			// clicked item?                        
+			if (hifc == hstart || hifc == hend)
 				in_range = !in_range;
 
 			// If we are between the start and end point, set the state.
-			if ( in_range || hifc == hstart || hifc == hend )
-				SetSelectionCheck( hifc, state );
+			if (in_range || hifc == hstart || hifc == hend)
+				SetSelectionCheck(hifc, state);
 		}
 	}
 }
 
-
-
 //
 // Sets the specified tree item's check box to the specified state.
 //
-void CPageNetwork::SetSelectionCheck( HTREEITEM hitem, TargetSelType selection )
+void CPageNetwork::SetSelectionCheck(HTREEITEM hitem, TargetSelType selection)
 {
 	// set the interface icon's associated state icon
-	if ( !m_TTargets.SetItemState( hitem, INDEXTOSTATEIMAGEMASK( selection ), 
-		TVIS_STATEIMAGEMASK ) )
-	{
-		ErrorMessage( "SetItemState() failed in CPageNetwork::"
-			"SetSelectionCheck()" );
+	if (!m_TTargets.SetItemState(hitem, INDEXTOSTATEIMAGEMASK(selection), TVIS_STATEIMAGEMASK)) {
+		ErrorMessage("SetItemState() failed in CPageNetwork::" "SetSelectionCheck()");
 	}
 }
 
-
-
 //
 // Retrieves the target's check box state.
 //
-TargetSelType CPageNetwork::GetSelectionCheck( HTREEITEM hitem )
+TargetSelType CPageNetwork::GetSelectionCheck(HTREEITEM hitem)
 {
-	return (TargetSelType)STATEIMAGEMASKTOINDEX(
-		m_TTargets.GetItemState( hitem, TVIS_STATEIMAGEMASK ));
+	return (TargetSelType) STATEIMAGEMASKTOINDEX(m_TTargets.GetItemState(hitem, TVIS_STATEIMAGEMASK));
 }
 
-
-
 //
 // Uniquely selects an interface given a manager and a string representing
 // the desired interface.  
 //
-void CPageNetwork::CheckInterface( HTREEITEM hmgr, char *net_address )
+void CPageNetwork::CheckInterface(HTREEITEM hmgr, char *net_address)
 {
 	HTREEITEM hifc;
 
-	if ( !hmgr )
-	{
+	if (!hmgr) {
 		ErrorMessage("invalid tree item in CPageNetwork::CheckInterface()");
 		return;
 	}
-
 	// walk through its list of interfaces
-	for ( hifc = m_TTargets.GetChildItem( hmgr ); hifc;
-		hifc = m_TTargets.GetNextSiblingItem( hifc ) )
-	{
+	for (hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
 		// check to see if the current interface should have a check mark
-		if ( net_address && !strcmp( m_TTargets.GetItemText(hifc), net_address ) )
-		{
+		if (net_address && !strcmp(m_TTargets.GetItemText(hifc), net_address)) {
 			// found it!  set its check mark
-			SetSelectionCheck( hifc, TargetChecked );
-		}
-		else
-		{
+			SetSelectionCheck(hifc, TargetChecked);
+		} else {
 			// not the one.  clear its check mark
-			SetSelectionCheck( hifc, TargetUnChecked );
+			SetSelectionCheck(hifc, TargetUnChecked);
 		}
 	}
 }
 
-
-
 //
 // Sets all the interface's check box to the specified state.
 //
-void CPageNetwork::SetAllCheck( TargetSelType selection )
+void CPageNetwork::SetAllCheck(TargetSelType selection)
 {
-	HTREEITEM	hmgr;
-	HTREEITEM	hifc;
+	HTREEITEM hmgr;
+	HTREEITEM hifc;
 
 	// Get the first manager item of the target tree
-	for ( hmgr = m_TTargets.GetRootItem(); hmgr;
-		hmgr = m_TTargets.GetNextSiblingItem( hmgr ) )
-	{
+	for (hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
 		// walk through its list of interfaces
-		for ( hifc = m_TTargets.GetChildItem( hmgr ); hifc;
-			hifc = m_TTargets.GetNextSiblingItem( hifc ) )
-		{
-			SetSelectionCheck( hifc, selection );
+		for (hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
+			SetSelectionCheck(hifc, selection);
 		}
 	}
 }
 
-
-
 //
 // Fills in the list of interfaces and displays a selection
 // if all children workers have the same interface.
 //
 void CPageNetwork::ShowInterface()
 {
-	Manager		*manager;
-	Worker		*worker;
+	Manager *manager;
+	Worker *worker;
 
 	m_DInterface.ResetContent();
 
 	// Check that either a manager or a worker is selected.
-	if ( !(manager = theApp.pView->m_pWorkerView->GetSelectedManager()) )
-	{
+	if (!(manager = theApp.pView->m_pWorkerView->GetSelectedManager())) {
 		return;
 	}
-
 	// Put the manager's network interfaces into the DInterface combo box
-	for ( int i = 0; i < manager->InterfaceCount( GenericNetType ); i++ )
-	{
-		if ( m_DInterface.AddString( 
-			manager->GetInterface( i, GenericNetType )->name ) != i )
-		{
+	for (int i = 0; i < manager->InterfaceCount(GenericNetType); i++) {
+		if (m_DInterface.AddString(manager->GetInterface(i, GenericNetType)->name) != i) {
 			ErrorMessage("AddString() for interface failed in CPageNetwork::SetTargetSelection()");
 			return;
 		}
 	}
 
 	// Select (in the combo box) the worker's or manager's selected interface.
-	if ( worker = theApp.pView->m_pWorkerView->GetSelectedWorker() )
-	{
+	if (worker = theApp.pView->m_pWorkerView->GetSelectedWorker()) {
 		// select the current interface (if any) in the combo box
-		m_DInterface.SelectString( -1, worker->GetLocalNetworkInterface() );
-	}
-	else
-	{
+		m_DInterface.SelectString(-1, worker->GetLocalNetworkInterface());
+	} else {
 		// select the current interface (if any) in the combo box
-		m_DInterface.SelectString( -1, manager->GetLocalNetworkInterface() );
+		m_DInterface.SelectString(-1, manager->GetLocalNetworkInterface());
 	}
 }
 
-
-
 //
 // Displays the connection rate settings for the current selection in the
 // worker view.  If the selection is a manager or all managers, displays
@@ -745,112 +636,88 @@
 void CPageNetwork::ShowConnectionRate()
 {
 	Manager *manager;
-	Worker	*worker;
-	int		trans_per_conn=0;
-	int		test_connection_rate=0;
+	Worker *worker;
+	int trans_per_conn = 0;
+	int test_connection_rate = 0;
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
 		// update controls with worker's data
-		if ( IsType( worker->Type(), GenericNetType ) )
-		{
-			trans_per_conn = worker->GetTransPerConn( GenericNetType );
-			test_connection_rate = worker->GetConnectionRate( GenericNetType );
+		if (IsType(worker->Type(), GenericNetType)) {
+			trans_per_conn = worker->GetTransPerConn(GenericNetType);
+			test_connection_rate = worker->GetConnectionRate(GenericNetType);
 		}
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		trans_per_conn = manager->GetTransPerConn( GenericServerType );
-		test_connection_rate = manager->GetConnectionRate( GenericServerType );
+		trans_per_conn = manager->GetTransPerConn(GenericServerType);
+		test_connection_rate = manager->GetConnectionRate(GenericServerType);
 		break;
 	default:
-		trans_per_conn = 
-			theApp.manager_list.GetTransPerConn( GenericServerType );
-		test_connection_rate = 
-			theApp.manager_list.GetConnectionRate( GenericServerType );
+		trans_per_conn = theApp.manager_list.GetTransPerConn(GenericServerType);
+		test_connection_rate = theApp.manager_list.GetConnectionRate(GenericServerType);
 		break;
 	}
 	// If the test connection rate settings are different between a manager's
 	// workers, set the state of the check box to AUTO3STATE and disable the
 	// edit box and spin control.
-	SetDlgItemInt( EConnectionRate, trans_per_conn );
-	if ( test_connection_rate == AMBIGUOUS_VALUE )
-	{
-		m_CConnectionRate.SetButtonStyle( BS_AUTO3STATE );
-		m_EConnectionRate.SetPasswordChar( 32 );
-		m_EConnectionRate.Invalidate( TRUE );
+	SetDlgItemInt(EConnectionRate, trans_per_conn);
+	if (test_connection_rate == AMBIGUOUS_VALUE) {
+		m_CConnectionRate.SetButtonStyle(BS_AUTO3STATE);
+		m_EConnectionRate.SetPasswordChar(32);
+		m_EConnectionRate.Invalidate(TRUE);
 
 		// Set check box to undetermined state.
-		CheckDlgButton( CConnectionRate, 2 );
-	}
-	else
-	{
-		m_CConnectionRate.SetButtonStyle( BS_AUTOCHECKBOX );
-		CheckDlgButton( CConnectionRate, test_connection_rate );
+		CheckDlgButton(CConnectionRate, 2);
+	} else {
+		m_CConnectionRate.SetButtonStyle(BS_AUTOCHECKBOX);
+		CheckDlgButton(CConnectionRate, test_connection_rate);
 
-		if ( test_connection_rate == ENABLED_VALUE && trans_per_conn != 
-			AMBIGUOUS_VALUE )
-		{
-			m_EConnectionRate.SetPasswordChar( 0 );
-		}
-		else
-		{
-			m_EConnectionRate.SetPasswordChar( 32 );
+		if (test_connection_rate == ENABLED_VALUE && trans_per_conn != AMBIGUOUS_VALUE) {
+			m_EConnectionRate.SetPasswordChar(0);
+		} else {
+			m_EConnectionRate.SetPasswordChar(32);
 			m_EConnectionRate.Invalidate();
 		}
 	}
 }
 
-
-
 //
 // Sets the focus to the list item specified by cursor movement or mouse event.
 //
 void CPageNetwork::ShowFocus()
 {
-	for ( HTREEITEM hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = 
-		m_TTargets.GetNextSiblingItem( hmgr ) )
-	{
-		for ( HTREEITEM hifc = m_TTargets.GetChildItem( hmgr ); hifc; hifc =
-			m_TTargets.GetNextSiblingItem( hifc ) )
-		{
-			if ( hifc == highlighted )
-			{
-				m_TTargets.SetItemState( hifc, TVIS_SELECTED, TVIS_SELECTED );
+	for (HTREEITEM hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
+		for (HTREEITEM hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
+			if (hifc == highlighted) {
+				m_TTargets.SetItemState(hifc, TVIS_SELECTED, TVIS_SELECTED);
+			} else {
+				m_TTargets.SetItemState(hifc, NULL, TVIS_SELECTED);
 			}
-			else
-			{
-				m_TTargets.SetItemState( hifc, NULL, TVIS_SELECTED );
-			}
 		}
 	}
 }
 
-
-
 //
 // Displays the values from memory in the GUI.
 //
 void CPageNetwork::ShowData()
 {
-	Manager	*manager;
-	Worker	*worker;
+	Manager *manager;
+	Worker *worker;
 
 	// Only enable the display if a network worker or a manager with a 
 	// network worker is selected.
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
 	worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
 
-	if (( theApp.pView->m_pWorkerView->GetSelectedType() == ALL_MANAGERS) ||
-		( manager && !manager->InterfaceCount( GenericNetType ) ) ||
-		( worker && !IsType( worker->Type(), GenericNetType ) ) )
-	{
+	if ((theApp.pView->m_pWorkerView->GetSelectedType() == ALL_MANAGERS) ||
+	    (manager && !manager->InterfaceCount(GenericNetType)) ||
+	    (worker && !IsType(worker->Type(), GenericNetType))) {
 		Reset();
 		return;
 	}
-	
 	// This is a new view of the target assignment.  
 	// It has not been modified.
 	selected = NULL;
@@ -871,28 +738,26 @@
 	EnableWindow();
 }
 
-
-
 //
 // Process mouse click in the target list.  For a worker, assign the selected
 // target.  For a manager, distribute the assigned targets among its net servers.
 //
-void CPageNetwork::OnClickTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageNetwork::OnClickTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	CPoint point;
 	TV_HITTESTINFO test_info;
 	TargetSelType state;
 
 	// Get the cursor position.
-	GetCursorPos( &point );
+	GetCursorPos(&point);
 	test_info.pt = point;
-	m_TTargets.ScreenToClient( &(test_info.pt) );
+	m_TTargets.ScreenToClient(&(test_info.pt));
 
 	// Check to see whether the cursor is on an item.
-	m_TTargets.HitTest( &test_info );
+	m_TTargets.HitTest(&test_info);
 
 	// Check that we have an interface item.
-	if ( !test_info.hItem || !m_TTargets.GetParentItem( test_info.hItem ) )
+	if (!test_info.hItem || !m_TTargets.GetParentItem(test_info.hItem))
 		return;
 
 	// A new target assignment is being made.  Clear the results since they are
@@ -900,46 +765,34 @@
 	theApp.pView->ResetDisplayforNewTest();
 
 	// Toggle the selection if the control key is pressed.
-	if ( GetKeyState( VK_CONTROL ) & 0x8000 && 
-		GetSelectionCheck( test_info.hItem ) == TargetChecked )
-	{
+	if (GetKeyState(VK_CONTROL) & 0x8000 && GetSelectionCheck(test_info.hItem) == TargetChecked) {
 		state = TargetUnChecked;
-	}
-	else
-	{
+	} else {
 		state = TargetChecked;
 	}
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		// All clicks work the same for the worker.
-		SelectRange( test_info.hItem, test_info.hItem, TRUE, state );
+		SelectRange(test_info.hItem, test_info.hItem, TRUE, state);
 		break;
 	case MANAGER:
 		// A shift click extends the selection from the last selected item
 		// to the currently focused item.  When the control key is also
 		// pressed, any previous selection is not cleared.
-		if ( (GetKeyState( VK_SHIFT ) & 0x8000 ) && selected )
-		{
+		if ((GetKeyState(VK_SHIFT) & 0x8000) && selected) {
 			// We have a previous item (not the first click) and the shift
 			// key is down.
-			SelectRange( selected, test_info.hItem, 
-				!(GetKeyState( VK_CONTROL ) & 0x8000) );
-		}
-		else if ( GetKeyState( VK_CONTROL ) & 0x8000 )
-		{
+			SelectRange(selected, test_info.hItem, !(GetKeyState(VK_CONTROL) & 0x8000));
+		} else if (GetKeyState(VK_CONTROL) & 0x8000) {
 			// The control key is down.
-			SelectRange( test_info.hItem, test_info.hItem, FALSE, state );
+			SelectRange(test_info.hItem, test_info.hItem, FALSE, state);
+		} else {
+			SelectRange(test_info.hItem, test_info.hItem, TRUE, state);
 		}
-		else 
-		{
-			SelectRange( test_info.hItem, test_info.hItem, TRUE, state );
-		}
 		break;
 	default:
-		ErrorMessage( "Unexpected selection type in CPageNetwork::"
-			"OnClickTTargets()." );
+		ErrorMessage("Unexpected selection type in CPageNetwork::" "OnClickTTargets().");
 		return;
 	}
 
@@ -951,135 +804,108 @@
 	*pResult = 0;
 }
 
-
-
 void CPageNetwork::StoreTargetSelection()
 {
 	HTREEITEM hmgr, hifc;
 	Manager *manager;
-	Worker	*worker;
-	Target_Spec	new_target;
-	int		local_interface_no;
-	int		interface_no;
-	int		target_count = 0;
-	int		expected_worker = 0;
+	Worker *worker;
+	Target_Spec new_target;
+	int local_interface_no;
+	int interface_no;
+	int target_count = 0;
+	int expected_worker = 0;
 
 	// Make sure we have a selected manager (or worker).
 	manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-	if ( !manager )
-	{
-		ErrorMessage( "Unexpectedly found no selected manager in "
-			"CPageNetwork::StoreTargetSelection." );
+	if (!manager) {
+		ErrorMessage("Unexpectedly found no selected manager in " "CPageNetwork::StoreTargetSelection.");
 		return;
 	}
-	
 	// Count the number of assigned targets.
-	for ( hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = 
-		m_TTargets.GetNextSiblingItem( hmgr ) )
-	{
-		for ( hifc = m_TTargets.GetChildItem( hmgr ); hifc; hifc =
-			m_TTargets.GetNextSiblingItem( hifc ) )
-		{
-			if ( GetSelectionCheck( hifc ) == TargetChecked )
+	for (hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
+		for (hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
+			if (GetSelectionCheck(hifc) == TargetChecked)
 				target_count++;
 		}
 	}
 
 	// Make sure we are not assigning more targets than we have workers.
-	if ( target_count > manager->WorkerCount( GenericServerType ) )
-	{
-		ErrorMessage( "You do not have enough network workers to assign all "
-			"the selected targets." );
+	if (target_count > manager->WorkerCount(GenericServerType)) {
+		ErrorMessage("You do not have enough network workers to assign all " "the selected targets.");
 		// Restore the last selection.
 		ShowTargetSelection();
 		// Set the focus to the target list.
-		::SetFocus( m_TTargets );
+		::SetFocus(m_TTargets);
 		return;
 	}
-
 	// The selection will succeed.  Remove current network clients.
-	if ( worker = theApp.pView->m_pWorkerView->GetSelectedWorker() )
-		worker->RemoveTargets( GenericNetType );
+	if (worker = theApp.pView->m_pWorkerView->GetSelectedWorker())
+		worker->RemoveTargets(GenericNetType);
 	else
-		manager->RemoveTargets( GenericNetType );
+		manager->RemoveTargets(GenericNetType);
 
 	// Get the assigned local interface to use for the connection.
 	local_interface_no = m_DInterface.GetCurSel();
 
 	// Assign the targets.
 	// Loop through all managers.
-	for ( hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = 
-		m_TTargets.GetNextSiblingItem( hmgr ) )
-	{
+	for (hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
 		// Loop through all interfaces of a manager.
 		interface_no = 0;
-		for ( hifc = m_TTargets.GetChildItem( hmgr ); hifc; hifc =
-			m_TTargets.GetNextSiblingItem( hifc ) )
-		{
-			if ( GetSelectionCheck( hifc ) == TargetChecked )
-			{
+		for (hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
+			if (GetSelectionCheck(hifc) == TargetChecked) {
 				// Are we dealing with a worker or a manager?
-				if ( !worker )
-				{
+				if (!worker) {
 					// A manager is selected.  Get the next available 
 					// network server worker.
-					worker = manager->GetWorker( expected_worker++, GenericServerType );
+					worker = manager->GetWorker(expected_worker++, GenericServerType);
 
 				}
 				// Get the interface of the selected target from the manager
 				// whose interface is selected.
-				memcpy( &new_target, ((Manager*)m_TTargets.GetItemData( 
-					hmgr ))->GetInterface( interface_no, GenericNetType ), 
-					sizeof( Target_Spec ) );
+				memcpy(&new_target,
+				       ((Manager *) m_TTargets.GetItemData(hmgr))->GetInterface(interface_no,
+												GenericNetType),
+				       sizeof(Target_Spec));
 
 				// Set the local and remote addresses of the connection.
 				// The remote address used by the server is stored as the local
 				// address for some manager's interface.
-				if ( IsType( new_target.type, TCPClientType ) )
-				{
-					strcpy( new_target.tcp_info.remote_address, new_target.name );
+				if (IsType(new_target.type, TCPClientType)) {
+					strcpy(new_target.tcp_info.remote_address, new_target.name);
 
 					// Verify that the locally assigned interface matches the
 					// selected target's interface.
-					if ( local_interface_no >= manager->InterfaceCount( 
-						GenericTCPType ) )
-					{
+					if (local_interface_no >= manager->InterfaceCount(GenericTCPType)) {
 						// Use the first TCP interface.
 						local_interface_no = 0;
-						m_DInterface.SetCurSel( local_interface_no );
+						m_DInterface.SetCurSel(local_interface_no);
 					}
-				}
-				else if ( IsType( new_target.type, VIClientType ) )
-				{
-					strcpy( new_target.vi_info.remote_nic_name, 
-						new_target.name );
-					memcpy( &new_target.vi_info.remote_address, 
-						&new_target.vi_info.local_address, VI_ADDRESS_SIZE );
+				} else if (IsType(new_target.type, VIClientType)) {
+					strcpy(new_target.vi_info.remote_nic_name, new_target.name);
+					memcpy(&new_target.vi_info.remote_address,
+					       &new_target.vi_info.local_address, VI_ADDRESS_SIZE);
 
 					// Verify that the locally assigned interface matches the
 					// selected target's interface.
-					if ( local_interface_no <= manager->InterfaceCount( 
-						GenericTCPType ) )
-					{
+					if (local_interface_no <= manager->InterfaceCount(GenericTCPType)) {
 						// Use the first VI interface.
-						local_interface_no = manager->InterfaceCount( GenericTCPType );
-						m_DInterface.SetCurSel( local_interface_no );
+						local_interface_no = manager->InterfaceCount(GenericTCPType);
+						m_DInterface.SetCurSel(local_interface_no);
 					}
+				} else {
+					ErrorMessage("Invalid target type for new target in "
+						     "CPageNetwork::StoreTargetSelection().");
 				}
-				else
-				{
-					ErrorMessage( "Invalid target type for new target in "
-						"CPageNetwork::StoreTargetSelection()." );
-				}
-				worker->AddTarget( &new_target );
-				
+				worker->AddTarget(&new_target);
+
 				// Record information about what local interface the server
 				// should use.
-				worker->SetLocalNetworkInterface( local_interface_no );
+				worker->SetLocalNetworkInterface(local_interface_no);
 
 				// Create the corresponding network client.
-				worker->CreateNetClient( (Manager*) 
-					m_TTargets.GetItemData( hmgr ), new_target.type );
+				worker->CreateNetClient((Manager *)
+							m_TTargets.GetItemData(hmgr), new_target.type);
 
 				// Clear the worker pointer so that the next iteration
 				// through the loop (for a manager with multiple selected
@@ -1091,98 +917,77 @@
 	}
 }
 
-
-
-void CPageNetwork::OnCConnectionRate() 
+void CPageNetwork::OnCConnectionRate()
 {
-	Manager*	manager;
-	Worker*		worker;
+	Manager *manager;
+	Worker *worker;
 
 	// change the check box to true/false only (having clicked, cannot 
 	// return to intermediate state)
-	m_CConnectionRate.SetButtonStyle( BS_AUTOCHECKBOX );
-	if ( IsDlgButtonChecked( CConnectionRate ) == 1 )
-	{
-		m_EConnectionRate.SetPasswordChar( 0 );
-		if ( GetDlgItemInt( EConnectionRate ) == AMBIGUOUS_VALUE )
-			SetDlgItemInt( EConnectionRate, 0 );
+	m_CConnectionRate.SetButtonStyle(BS_AUTOCHECKBOX);
+	if (IsDlgButtonChecked(CConnectionRate) == 1) {
+		m_EConnectionRate.SetPasswordChar(0);
+		if (GetDlgItemInt(EConnectionRate) == AMBIGUOUS_VALUE)
+			SetDlgItemInt(EConnectionRate, 0);
+	} else {
+		m_EConnectionRate.SetPasswordChar(32);
 	}
-	else
-	{
-		m_EConnectionRate.SetPasswordChar( 32 );
-	}
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		worker->SetConnectionRate( m_CConnectionRate.GetCheck() );
+		worker->SetConnectionRate(m_CConnectionRate.GetCheck());
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		manager->SetConnectionRate( m_CConnectionRate.GetCheck(),
-			GenericServerType );
+		manager->SetConnectionRate(m_CConnectionRate.GetCheck(), GenericServerType);
 		break;
 	case ALL_MANAGERS:
-		theApp.manager_list.SetConnectionRate( m_CConnectionRate.GetCheck(), 
-			GenericServerType );
+		theApp.manager_list.SetConnectionRate(m_CConnectionRate.GetCheck(), GenericServerType);
 		break;
 	}
 	EnableWindow();
 }
 
-
-
-void CPageNetwork::OnDeltaposSConnectionRate(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageNetwork::OnDeltaposSConnectionRate(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	int trans_per_conn = GetDlgItemInt( EConnectionRate );
-	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
-	
+	int trans_per_conn = GetDlgItemInt(EConnectionRate);
+	NM_UPDOWN *pNMUpDown = (NM_UPDOWN *) pNMHDR;
+
 	trans_per_conn += pNMUpDown->iDelta;
-	if ( trans_per_conn < 0 )
-	{
+	if (trans_per_conn < 0) {
 		trans_per_conn = 0;
+	} else {
+		SetDlgItemInt(EConnectionRate, trans_per_conn);
 	}
-	else
-	{
-		SetDlgItemInt( EConnectionRate, trans_per_conn );
-	}
 	*pResult = 0;
 }
 
-
-
-void CPageNetwork::EditSetfocus( CEdit* edit )
+void CPageNetwork::EditSetfocus(CEdit * edit)
 {
-	if ( !edit->GetPasswordChar() )
+	if (!edit->GetPasswordChar())
 		return;
 
 	// Select everything in the edit box.
-	edit->SetSel( 0, -1 );
+	edit->SetSel(0, -1);
 	// Clear selection.
 	edit->Clear();
 	// Make the characters visible.
-	edit->SetPasswordChar( 0 );
+	edit->SetPasswordChar(0);
 }
 
-
-
-void CPageNetwork::OnSetfocusEConnectionRate() 
+void CPageNetwork::OnSetfocusEConnectionRate()
 {
-	EditSetfocus( &m_EConnectionRate );
+	EditSetfocus(&m_EConnectionRate);
 }
 
-
-
-void CPageNetwork::OnSetfocusEMaxSends() 
+void CPageNetwork::OnSetfocusEMaxSends()
 {
-	EditSetfocus( &m_EMaxSends );
+	EditSetfocus(&m_EMaxSends);
 }
 
-
-
-void CPageNetwork::OnSelchangingTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageNetwork::OnSelchangingTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
+	NM_TREEVIEW *pNMTreeView = (NM_TREEVIEW *) pNMHDR;
 
 	theApp.pView->ResetDisplayforNewTest();
 	ShowFocus();
@@ -1192,22 +997,19 @@
 	*pResult = 1;
 }
 
-
-
-void CPageNetwork::OnSelchangeDInterface() 
+void CPageNetwork::OnSelchangeDInterface()
 {
-	Manager*	manager;
-	Worker*		worker;
+	Manager *manager;
+	Worker *worker;
 
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		worker->SetLocalNetworkInterface( m_DInterface.GetCurSel() );
+		worker->SetLocalNetworkInterface(m_DInterface.GetCurSel());
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		manager->SetLocalNetworkInterface( m_DInterface.GetCurSel() );
+		manager->SetLocalNetworkInterface(m_DInterface.GetCurSel());
 		break;
 	}
 
@@ -1217,40 +1019,32 @@
 	EnableWindow();
 }
 
-
-
-void CPageNetwork::OnKillfocusEConnectionRate() 
+void CPageNetwork::OnKillfocusEConnectionRate()
 {
-	Manager*	manager;
-	Worker*		worker;
+	Manager *manager;
+	Worker *worker;
 
 	// Restores the previous value if the edit box was left blank.
-	if ( !m_EConnectionRate.LineLength() )
+	if (!m_EConnectionRate.LineLength())
 		ShowConnectionRate();
-	else
-	{
-		switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-		{
+	else {
+		switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 		case WORKER:
 			worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-			worker->SetTransPerConn( GetDlgItemInt( EConnectionRate ) );
+			worker->SetTransPerConn(GetDlgItemInt(EConnectionRate));
 			break;
 		case MANAGER:
 			manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-			manager->SetTransPerConn( GetDlgItemInt( EConnectionRate ),
-				GenericServerType );
+			manager->SetTransPerConn(GetDlgItemInt(EConnectionRate), GenericServerType);
 			break;
 		case ALL_MANAGERS:
-			theApp.manager_list.SetTransPerConn( 
-				GetDlgItemInt( EConnectionRate ), GenericServerType );
+			theApp.manager_list.SetTransPerConn(GetDlgItemInt(EConnectionRate), GenericServerType);
 			break;
-			}
 		}
+	}
 	EnableWindow();
 }
 
-
-
 //
 // Keyboard handler for the target tree control:
 // 
@@ -1281,90 +1075,79 @@
 // workers to allow selecting multiple interfaces from the manager, whereas
 // workers are currently restricted to a single selection for network targets.
 // 
-void CPageNetwork::OnKeydownTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageNetwork::OnKeydownTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;
+	TV_KEYDOWN *pTVKeyDown = (TV_KEYDOWN *) pNMHDR;
 
 	// A new target assignment is being made.  Clear the results since they are
 	// for a configuration we no longer have.
 	theApp.pView->ResetDisplayforNewTest();
 
-	if ( theApp.pView->m_pWorkerView->GetSelectedType() == MANAGER )
-		KeyMultiSel( pTVKeyDown->wVKey );
+	if (theApp.pView->m_pWorkerView->GetSelectedType() == MANAGER)
+		KeyMultiSel(pTVKeyDown->wVKey);
 	else
-		KeySingleSel( pTVKeyDown->wVKey );
+		KeySingleSel(pTVKeyDown->wVKey);
 	*pResult = 0;
 }
 
-
-
 //
 // Single selection keyboard handler for the tree control.
 //
-void CPageNetwork::KeySingleSel( WORD wVKey )
+void CPageNetwork::KeySingleSel(WORD wVKey)
 {
-	BOOL shift = GetKeyState( VK_SHIFT ) & 0x8000;
-	BOOL control = GetKeyState( VK_CONTROL ) & 0x8000;
+	BOOL shift = GetKeyState(VK_SHIFT) & 0x8000;
+	BOOL control = GetKeyState(VK_CONTROL) & 0x8000;
 
 	// Make sure there are interfaces.
-	if ( !highlighted )
+	if (!highlighted)
 		return;
 
-	switch ( wVKey )
-	{
+	switch (wVKey) {
 	case VK_UP:
 		SetFocusUp();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( highlighted, highlighted, TRUE, TargetChecked );
+		if (shift) {
+			SelectRange(highlighted, highlighted, TRUE, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_DOWN:
 		SetFocusDown();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( highlighted, highlighted, TRUE, TargetChecked );
+		if (shift) {
+			SelectRange(highlighted, highlighted, TRUE, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_HOME:
 		SetFocusHome();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( highlighted, highlighted, TRUE, TargetChecked );
+		if (shift) {
+			SelectRange(highlighted, highlighted, TRUE, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_END:
 		SetFocusEnd();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( highlighted, highlighted, TRUE, TargetChecked );
+		if (shift) {
+			SelectRange(highlighted, highlighted, TRUE, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_SPACE:
-		if ( control )	// toggle.
+		if (control)	// toggle.
 		{
 			// Toggle the selection, but do not clear any other items.
-			if ( GetSelectionCheck( highlighted ) == TargetChecked )
-			{
-				SelectRange( highlighted, highlighted, FALSE, TargetUnChecked );
+			if (GetSelectionCheck(highlighted) == TargetChecked) {
+				SelectRange(highlighted, highlighted, FALSE, TargetUnChecked);
+			} else {
+				SelectRange(highlighted, highlighted, FALSE, TargetChecked);
 			}
-			else
-			{
-				SelectRange( highlighted, highlighted, FALSE, TargetChecked );
-			}
-		}
-		else // normal selection.
+		} else		// normal selection.
 		{
 			// Extend the selection and clear any other items.
-			SelectRange( highlighted, highlighted, TRUE, TargetChecked );
+			SelectRange(highlighted, highlighted, TRUE, TargetChecked);
 		}
 
 		ShowFocus();
@@ -1375,101 +1158,87 @@
 	EnableWindow();
 }
 
-
-
 //
 // Multi selection keyboard handler for the tree control.
 //
-void CPageNetwork::KeyMultiSel( WORD wVKey )
+void CPageNetwork::KeyMultiSel(WORD wVKey)
 {
-	BOOL shift = GetKeyState( VK_SHIFT ) & 0x8000;
-	BOOL control = GetKeyState( VK_CONTROL ) & 0x8000;
+	BOOL shift = GetKeyState(VK_SHIFT) & 0x8000;
+	BOOL control = GetKeyState(VK_CONTROL) & 0x8000;
 
 	// Make sure there are interfaces.
-	if ( !highlighted )
+	if (!highlighted)
 		return;
 
-	switch ( wVKey )
-	{
+	switch (wVKey) {
 	case VK_UP:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 		SetFocusUp();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_DOWN:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 
 		SetFocusDown();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_HOME:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 
 		SetFocusHome();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_END:
-		if ( !selected && shift )
+		if (!selected && shift)
 			selected = highlighted;
 
 		SetFocusEnd();
 		// Only select items if the shift key is pressed.
-		if ( shift )
-		{
-			SelectRange( selected, highlighted, !control, TargetChecked );
+		if (shift) {
+			SelectRange(selected, highlighted, !control, TargetChecked);
 			StoreTargetSelection();
 		}
 		break;
 	case VK_SPACE:
-		if ( shift )
-		{
+		if (shift) {
 			// Extend the selection. Clear any other items if the control
 			// key is not pressed.
-			SelectRange( selected, highlighted, !control, TargetChecked );
-		}
-		else if ( control )	// toggle.
+			SelectRange(selected, highlighted, !control, TargetChecked);
+		} else if (control)	// toggle.
 		{
 			// Toggle the selection, but do not clear any other items.
-			if ( GetSelectionCheck( highlighted ) == TargetChecked )
-			{
-				SelectRange( highlighted, highlighted, FALSE, TargetUnChecked );
+			if (GetSelectionCheck(highlighted) == TargetChecked) {
+				SelectRange(highlighted, highlighted, FALSE, TargetUnChecked);
+			} else {
+				SelectRange(highlighted, highlighted, FALSE, TargetChecked);
 			}
-			else
-			{
-				SelectRange( highlighted, highlighted, FALSE, TargetChecked );
-			}
-		}
-		else // normal
+		} else		// normal
 		{
 			// Uniquely select the item with the focus.
-			SelectRange( highlighted, highlighted, TRUE, TargetChecked );
+			SelectRange(highlighted, highlighted, TRUE, TargetChecked);
 		}
 
 		ShowFocus();
 		StoreTargetSelection();
 		break;
 	case 'A':
-		if ( control )
-		{
-			SetAllCheck( TargetChecked );
+		if (control) {
+			SetAllCheck(TargetChecked);
 			StoreTargetSelection();
 		}
 	}
@@ -1477,8 +1246,6 @@
 	EnableWindow();
 }
 
-
-
 // 
 // The SetFocusUp, Down, Home, and End functions handle keyboard input for
 // the target tree.
@@ -1487,61 +1254,49 @@
 {
 	HTREEITEM hmgr, hifc;
 
-	hifc = m_TTargets.GetPrevSiblingItem( highlighted );
+	hifc = m_TTargets.GetPrevSiblingItem(highlighted);
 	// Does the currently selected interface have a previous sibling?
-	if ( hifc )
-	{
+	if (hifc) {
 		// Yes. Set the focus to the sibling.
 		highlighted = hifc;
-	}
-	else
-	{
+	} else {
 		// No.  Set the focus to the last interface on the first manager with 
 		// interfaces in the tree before the currently focused interface's 
 		// manager.
-		hmgr = m_TTargets.GetParentItem( highlighted );
-		while ( hmgr = m_TTargets.GetPrevSiblingItem( hmgr ) )
-		{
-			if ( hifc = m_TTargets.GetChildItem( hmgr ) )
+		hmgr = m_TTargets.GetParentItem(highlighted);
+		while (hmgr = m_TTargets.GetPrevSiblingItem(hmgr)) {
+			if (hifc = m_TTargets.GetChildItem(hmgr))
 				break;
 		}
-		while ( hifc )
-		{
+		while (hifc) {
 			highlighted = hifc;
-			hifc = m_TTargets.GetNextSiblingItem( hifc );
+			hifc = m_TTargets.GetNextSiblingItem(hifc);
 		}
 	}
 
 	// Make sure the focused interface is visible, and if possible,
 	// also its manager.
-	m_TTargets.EnsureVisible( m_TTargets.GetParentItem( highlighted ) );
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(m_TTargets.GetParentItem(highlighted));
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
-
-
 void CPageNetwork::SetFocusDown()
 {
 	HTREEITEM hmgr, hifc;
 
-	hifc = m_TTargets.GetNextSiblingItem( highlighted );
+	hifc = m_TTargets.GetNextSiblingItem(highlighted);
 	// Does the currently focused interface have a next sibling?
-	if ( hifc )
-	{
+	if (hifc) {
 		// Yes. Set the focus to the sibling.
 		highlighted = hifc;
-	}
-	else
-	{
+	} else {
 		// No.  Set the focus to the first interface on the first manager with 
 		// interfaces in the tree after the currently focused interface's 
 		// manager.
-		hmgr = m_TTargets.GetParentItem( highlighted );
-		while ( hmgr = m_TTargets.GetNextSiblingItem( hmgr ) )
-		{
-			if ( hifc = m_TTargets.GetChildItem( hmgr ) )
-			{
+		hmgr = m_TTargets.GetParentItem(highlighted);
+		while (hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
+			if (hifc = m_TTargets.GetChildItem(hmgr)) {
 				highlighted = hifc;
 				break;
 			}
@@ -1550,28 +1305,24 @@
 
 	// Make the focused interface visible, and if possible,
 	// also its manager.
-	m_TTargets.EnsureVisible( m_TTargets.GetParentItem( highlighted ) );
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(m_TTargets.GetParentItem(highlighted));
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
-
-
 //
 // Highlight the first interface of the first manager;
 //
 void CPageNetwork::SetFocusHome()
 {
-	highlighted = m_TTargets.GetChildItem( m_TTargets.GetRootItem() );
+	highlighted = m_TTargets.GetChildItem(m_TTargets.GetRootItem());
 
 	// Make sure the first manager item is visible.
-	m_TTargets.EnsureVisible( m_TTargets.GetRootItem() );
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(m_TTargets.GetRootItem());
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
-
-
 //
 // Highlight the last interface of the last manager with an interface.
 //
@@ -1580,48 +1331,39 @@
 	HTREEITEM hmgr, hifc;
 
 	// Get the last manager.
-	hmgr = m_TTargets.GetRootItem(); 
-	while ( m_TTargets.GetNextSiblingItem( hmgr ) )
-		hmgr = m_TTargets.GetNextSiblingItem( hmgr );
+	hmgr = m_TTargets.GetRootItem();
+	while (m_TTargets.GetNextSiblingItem(hmgr))
+		hmgr = m_TTargets.GetNextSiblingItem(hmgr);
 
 	// Loop through it's interfaces.
-	for ( hifc = m_TTargets.GetChildItem( hmgr ); hifc; hifc = 
-		m_TTargets.GetNextSiblingItem( hifc ) )
-	{
+	for (hifc = m_TTargets.GetChildItem(hmgr); hifc; hifc = m_TTargets.GetNextSiblingItem(hifc)) {
 		// Set the highlighted item to the last non-null interface.
 		highlighted = hifc;
 	}
 
 	// Make sure the last item is visible.
-	m_TTargets.EnsureVisible( highlighted );
+	m_TTargets.EnsureVisible(highlighted);
 	ShowFocus();
 }
 
-
 // 
 // Disable collapsing the tree item when double clicking.
 //
-void CPageNetwork::OnDblclkTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageNetwork::OnDblclkTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	*pResult = 1;
 }
 
-
-
 //
 // Sets the highlighted item to the first interface.
 //
-void CPageNetwork::OnSetfocusTTargets(NMHDR* pNMHDR, LRESULT* pResult) 
+void CPageNetwork::OnSetfocusTTargets(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	if ( !highlighted )
-	{
+	if (!highlighted) {
 		//Find the first interface.
-		for ( HTREEITEM hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = 
-			m_TTargets.GetNextSiblingItem( hmgr ) )
-		{
-			highlighted = m_TTargets.GetChildItem( hmgr );
-			if ( highlighted )
-			{
+		for (HTREEITEM hmgr = m_TTargets.GetRootItem(); hmgr; hmgr = m_TTargets.GetNextSiblingItem(hmgr)) {
+			highlighted = m_TTargets.GetChildItem(hmgr);
+			if (highlighted) {
 				ShowFocus();
 				break;
 			}
@@ -1630,84 +1372,71 @@
 	*pResult = 0;
 }
 
-
-
 //
 // Shows the selected item's network settings.
 //
 void CPageNetwork::ShowSettings()
 {
 	Manager *manager;
-	Worker	*worker;
-	int		max_sends;
+	Worker *worker;
+	int max_sends;
 
 	// Get the values for the network settings from memory.
-	switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-	{
+	switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 	case WORKER:
 		worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-		max_sends = worker->GetMaxSends( VIServerType );
+		max_sends = worker->GetMaxSends(VIServerType);
 		break;
 	case MANAGER:
 		manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-		max_sends = manager->GetMaxSends( VIServerType );
+		max_sends = manager->GetMaxSends(VIServerType);
 		break;
 	default:
-		max_sends = theApp.manager_list.GetMaxSends( VIServerType );
+		max_sends = theApp.manager_list.GetMaxSends(VIServerType);
 	}
 
 	// If there is a displayable value, display it.  Otherwise, hide the content
 	// of the edit box.
-	if ( max_sends == AMBIGUOUS_VALUE )
-	{
-		m_EMaxSends.SetPasswordChar( 32 );
+	if (max_sends == AMBIGUOUS_VALUE) {
+		m_EMaxSends.SetPasswordChar(32);
 		m_EMaxSends.Invalidate();
+	} else {
+		m_EMaxSends.SetPasswordChar(0);
+		SetDlgItemInt(EMaxSends, max_sends);
 	}
-	else
-	{
-		m_EMaxSends.SetPasswordChar( 0 );
-		SetDlgItemInt( EMaxSends, max_sends );
-	}
 }
 
-
-
 //
 // Updates the maximum number of sends if necessary that can be outstanding.
 // Currently this only applies to VI network servers.
 //
-void CPageNetwork::OnKillfocusEMaxSends() 
+void CPageNetwork::OnKillfocusEMaxSends()
 {
 	Manager *manager;
-	Worker	*worker;
+	Worker *worker;
 
 	// If max sends was left blank, use the previous value
-	if ( !m_EMaxSends.LineLength() )
-	{
+	if (!m_EMaxSends.LineLength()) {
 		ShowSettings();
 	}
 	// Verify that the max sends is > 0.
-	else if ( GetDlgItemInt( EMaxSends ) <= 0 )
-	{
-		ErrorMessage( "Maximum # of Outstanding Sends cannot be 0." );
+	else if (GetDlgItemInt(EMaxSends) <= 0) {
+		ErrorMessage("Maximum # of Outstanding Sends cannot be 0.");
 		ShowSettings();
 		return;
-	}
-	else
-	{
+	} else {
 		// Seeing what kind of item is selected.
-		switch ( theApp.pView->m_pWorkerView->GetSelectedType() )
-		{
+		switch (theApp.pView->m_pWorkerView->GetSelectedType()) {
 		case WORKER:
 			worker = theApp.pView->m_pWorkerView->GetSelectedWorker();
-			worker->SetMaxSends( GetDlgItemInt( EMaxSends ) );
+			worker->SetMaxSends(GetDlgItemInt(EMaxSends));
 			break;
 		case MANAGER:
 			manager = theApp.pView->m_pWorkerView->GetSelectedManager();
-			manager->SetMaxSends( GetDlgItemInt( EMaxSends ) );
+			manager->SetMaxSends(GetDlgItemInt(EMaxSends));
 			break;
 		case ALL_MANAGERS:
-			theApp.manager_list.SetMaxSends( GetDlgItemInt( EMaxSends ) );
+			theApp.manager_list.SetMaxSends(GetDlgItemInt(EMaxSends));
 			break;
 		}
 	}

Modified: branches/IOMETER-restruct/iometer/src/PageNetwork.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageNetwork.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageNetwork.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,10 +60,9 @@
 #ifndef PAGENETWORK_DEFINED
 #define PAGENETWORK_DEFINED
 
-
 #if _MSC_VER >= 1000
 #pragma once
-#endif // _MSC_VER >= 1000
+#endif				// _MSC_VER >= 1000
 
 /////////////////////////////////////////////////////////////////////////////
 // CPageNetwork dialog
@@ -71,93 +70,90 @@
 #include "GalileoApp.h"
 #include "PageTarget.h"
 
-class CPageNetwork : public CPropertyPage
-{
+class CPageNetwork:public CPropertyPage {
 	DECLARE_DYNCREATE(CPageNetwork)
-
 // Construction
-public:
+      public:
 	CPageNetwork();
 	~CPageNetwork();
 
-	void	EnableWindow( BOOL enable = TRUE );
-	void	AddManager( Manager *manager );
-	void	RemoveManager( Manager *manager );
-	void	ShowData();
-	void	ShowTargets();
-	void	Reset();
+	void EnableWindow(BOOL enable = TRUE);
+	void AddManager(Manager * manager);
+	void RemoveManager(Manager * manager);
+	void ShowData();
+	void ShowTargets();
+	void Reset();
 
 // Dialog Data
 	//{{AFX_DATA(CPageNetwork)
 	enum { IDD = IDD_NETWORKS };
-	CEdit	m_EMaxSends;
-	CButton	m_CConnectionRate;
-	CComboBox	m_DInterface;
-	CEdit	m_EConnectionRate;
-	CSpinButtonCtrl	m_SConnectionRate;
-	CTreeCtrl	m_TTargets;
+	CEdit m_EMaxSends;
+	CButton m_CConnectionRate;
+	CComboBox m_DInterface;
+	CEdit m_EConnectionRate;
+	CSpinButtonCtrl m_SConnectionRate;
+	CTreeCtrl m_TTargets;
 	//}}AFX_DATA
 
 // Overrides
 	// ClassWizard generate virtual function overrides
 	//{{AFX_VIRTUAL(CPageNetwork)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
-	void	StoreTargetSelection();
+      protected:
+	void StoreTargetSelection();
 
-	void	ShowTargetSelection();
-	void	ShowFocus();
-	void	ShowConnectionRate();
-	void	ShowInterface();
-	void	ShowSettings();
+	void ShowTargetSelection();
+	void ShowFocus();
+	void ShowConnectionRate();
+	void ShowInterface();
+	void ShowSettings();
 
 	// Functions that move the highlight.
-	void	SetFocusUp();
-	void	SetFocusDown();
-	void	SetFocusHome();
-	void	SetFocusEnd();
+	void SetFocusUp();
+	void SetFocusDown();
+	void SetFocusHome();
+	void SetFocusEnd();
 
-	void	SelectRange( HTREEITEM hstart, HTREEITEM hend, BOOL replace = TRUE, 
-						TargetSelType state = TargetChecked );
-	void	SetSelectionCheck( HTREEITEM hitem, TargetSelType selection );
-	TargetSelType	GetSelectionCheck( HTREEITEM hitem );
-	void	SetAllCheck( TargetSelType selection );
-	void	CheckInterface( HTREEITEM hmanager, char *net_address = NULL );
-	void	KeySingleSel( WORD wVKey );	// Single selection keyboard handler
-	void	KeyMultiSel( WORD wVKey );	// Multi selection keyboard handler
+	void SelectRange(HTREEITEM hstart, HTREEITEM hend, BOOL replace = TRUE, TargetSelType state = TargetChecked);
+	void SetSelectionCheck(HTREEITEM hitem, TargetSelType selection);
+	TargetSelType GetSelectionCheck(HTREEITEM hitem);
+	void SetAllCheck(TargetSelType selection);
+	void CheckInterface(HTREEITEM hmanager, char *net_address = NULL);
+	void KeySingleSel(WORD wVKey);	// Single selection keyboard handler
+	void KeyMultiSel(WORD wVKey);	// Multi selection keyboard handler
 
-	void	EditSetfocus( CEdit* edit );
+	void EditSetfocus(CEdit * edit);
 
-	CImageList	m_ImageList;
-	HTREEITEM	selected;		// The last selected item, or NULL if the 
-								// selection has not changed.
-	HTREEITEM	highlighted;	// The current selection when using the keyboard.
+	CImageList m_ImageList;
+	HTREEITEM selected;	// The last selected item, or NULL if the 
+	// selection has not changed.
+	HTREEITEM highlighted;	// The current selection when using the keyboard.
 
 	// Generated message map functions
 	//{{AFX_MSG(CPageNetwork)
-	afx_msg void OnClickTTargets(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnClickTTargets(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnCConnectionRate();
-	afx_msg void OnDeltaposSConnectionRate(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnDeltaposSConnectionRate(NMHDR * pNMHDR, LRESULT * pResult);
 	virtual BOOL OnInitDialog();
 	afx_msg void OnSetfocusEConnectionRate();
-	afx_msg void OnSelchangingTTargets(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnSelchangingTTargets(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnSelchangeDInterface();
 	afx_msg void OnKillfocusEConnectionRate();
-	afx_msg void OnKeydownTTargets(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnDblclkTTargets(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnSetfocusTTargets(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnKeydownTTargets(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnDblclkTTargets(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnSetfocusTTargets(NMHDR * pNMHDR, LRESULT * pResult);
 	afx_msg void OnKillfocusEMaxSends();
 	afx_msg void OnSetfocusEMaxSends();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 
 };
 
 //{{AFX_INSERT_LOCATION}}
 // Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 
-#endif // !defined(PAGENETWORK_DEFINED)
+#endif				// !defined(PAGENETWORK_DEFINED)

Modified: branches/IOMETER-restruct/iometer/src/PageSetup.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageSetup.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageSetup.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,12 +64,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "PageSetup.h"
 #include "GalileoView.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -80,20 +78,19 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageSetup property page
 
 IMPLEMENT_DYNCREATE(CPageSetup, CPropertyPage)
 
-CPageSetup::CPageSetup() : CPropertyPage(CPageSetup::IDD)
+CPageSetup::CPageSetup():CPropertyPage(CPageSetup::IDD)
 {
 	//{{AFX_DATA_INIT(CPageSetup)
 	//}}AFX_DATA_INIT
@@ -103,7 +100,7 @@
 {
 }
 
-void CPageSetup::DoDataExchange(CDataExchange* pDX)
+void CPageSetup::DoDataExchange(CDataExchange * pDX)
 {
 	CPropertyPage::DoDataExchange(pDX);
 	DDX_Control(pDX, EWorkerStart, worker_cycling.start_box);
@@ -131,242 +128,213 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CPageSetup, CPropertyPage)
-	//{{AFX_MSG_MAP(CPageSetup)
-	ON_EN_CHANGE(EDiskWorkerCount, OnChangeEDiskWorkerCount)
-	ON_EN_CHANGE(ENetWorkerCount, OnChangeENetWorkerCount)
-	ON_CBN_SELCHANGE(CDStepType, OnSelchangeCDStepType)
-	ON_CBN_SELCHANGE(CWStepType, OnSelchangeCWStepType)
-	ON_CBN_SELCHANGE(CQStepType, OnSelchangeCQStepType)
-	ON_EN_KILLFOCUS(EDiskStart, OnKillfocusEDiskStart)
-	ON_EN_KILLFOCUS(EDiskStep, OnKillfocusEDiskStep)
-	ON_EN_KILLFOCUS(EQueueEnd, OnKillfocusEQueueEnd)
-	ON_EN_KILLFOCUS(EQueueStart, OnKillfocusEQueueStart)
-	ON_EN_KILLFOCUS(EQueueStep, OnKillfocusEQueueStep)
-	ON_EN_KILLFOCUS(ERampTime, OnKillfocusERampTime)
-	ON_EN_KILLFOCUS(ERunTimeHours, OnKillfocusERunTimeHours)
-	ON_EN_KILLFOCUS(ERunTimeMinutes, OnKillfocusERunTimeMinutes)
-	ON_EN_KILLFOCUS(ERunTimeSeconds, OnKillfocusERunTimeSeconds)
-	ON_EN_KILLFOCUS(EDiskWorkerCount, OnKillfocusEDiskWorkerCount)
-	ON_EN_KILLFOCUS(ENetWorkerCount, OnKillfocusENetWorkerCount)
-	ON_EN_KILLFOCUS(EWorkerStart, OnKillfocusEWorkerStart)
-	ON_EN_KILLFOCUS(EWorkerStep, OnKillfocusEWorkerStep)
-	ON_CBN_SELCHANGE(CResultType, OnSelchangeCResultType)
-	ON_CBN_SELCHANGE(CTestType, OnSelchangeCTestType)
-	ON_BN_CLICKED(RDiskSpawnCPUs, OnRDiskSpawnCPUs)
-	ON_BN_CLICKED(RDiskSpawnUser, OnRDiskSpawnUser)
-	ON_BN_CLICKED(RNetSpawnCPUs, OnRNetSpawnCPUs)
-	ON_BN_CLICKED(RNetSpawnUser, OnRNetSpawnUser)
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CPageSetup)
+    ON_EN_CHANGE(EDiskWorkerCount, OnChangeEDiskWorkerCount)
+    ON_EN_CHANGE(ENetWorkerCount, OnChangeENetWorkerCount)
+    ON_CBN_SELCHANGE(CDStepType, OnSelchangeCDStepType)
+    ON_CBN_SELCHANGE(CWStepType, OnSelchangeCWStepType)
+    ON_CBN_SELCHANGE(CQStepType, OnSelchangeCQStepType)
+    ON_EN_KILLFOCUS(EDiskStart, OnKillfocusEDiskStart)
+    ON_EN_KILLFOCUS(EDiskStep, OnKillfocusEDiskStep)
+    ON_EN_KILLFOCUS(EQueueEnd, OnKillfocusEQueueEnd)
+    ON_EN_KILLFOCUS(EQueueStart, OnKillfocusEQueueStart)
+    ON_EN_KILLFOCUS(EQueueStep, OnKillfocusEQueueStep)
+    ON_EN_KILLFOCUS(ERampTime, OnKillfocusERampTime)
+    ON_EN_KILLFOCUS(ERunTimeHours, OnKillfocusERunTimeHours)
+    ON_EN_KILLFOCUS(ERunTimeMinutes, OnKillfocusERunTimeMinutes)
+    ON_EN_KILLFOCUS(ERunTimeSeconds, OnKillfocusERunTimeSeconds)
+    ON_EN_KILLFOCUS(EDiskWorkerCount, OnKillfocusEDiskWorkerCount)
+    ON_EN_KILLFOCUS(ENetWorkerCount, OnKillfocusENetWorkerCount)
+    ON_EN_KILLFOCUS(EWorkerStart, OnKillfocusEWorkerStart)
+    ON_EN_KILLFOCUS(EWorkerStep, OnKillfocusEWorkerStep)
+    ON_CBN_SELCHANGE(CResultType, OnSelchangeCResultType)
+    ON_CBN_SELCHANGE(CTestType, OnSelchangeCTestType)
+    ON_BN_CLICKED(RDiskSpawnCPUs, OnRDiskSpawnCPUs)
+    ON_BN_CLICKED(RDiskSpawnUser, OnRDiskSpawnUser)
+    ON_BN_CLICKED(RNetSpawnCPUs, OnRNetSpawnCPUs)
+ON_BN_CLICKED(RNetSpawnUser, OnRNetSpawnUser)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageSetup message handlers
-
-BOOL CPageSetup::OnInitDialog() 
+BOOL CPageSetup::OnInitDialog()
 {
 	CPropertyPage::OnInitDialog();
-	
+
 	// Set run time.
 	minutes = 0;
 	seconds = 0;
 	hours = 0;
 	ramp_time = 0;
 
-	test_name = _T("");		// blank test description
+	test_name = _T("");	// blank test description
 
-	SetDlgItemInt( EDiskWorkerCount, 0 ); // Display a number.
-	SetDlgItemInt( ENetWorkerCount, 0 ); // Display a number.
-		disk_worker_count = -1;	// default number of disk workers		
-	#if _DEBUG
-		net_worker_count = -1;	// create network workers for debug
-	#else
-		net_worker_count = 0;	// default number of network workers
-	#endif
-	test_type = 0;			// normal test by default, disable cycling info below
+	SetDlgItemInt(EDiskWorkerCount, 0);	// Display a number.
+	SetDlgItemInt(ENetWorkerCount, 0);	// Display a number.
+	disk_worker_count = -1;	// default number of disk workers               
+#if _DEBUG
+	net_worker_count = -1;	// create network workers for debug
+#else
+	net_worker_count = 0;	// default number of network workers
+#endif
+	test_type = 0;		// normal test by default, disable cycling info below
 
 	// Set worker cycling stepping.
-	SetCyclingInfo( &worker_cycling, FALSE, 1, IOERROR, 1, StepLinear );
+	SetCyclingInfo(&worker_cycling, FALSE, 1, IOERROR, 1, StepLinear);
 	OnSelchangeCWStepType();
-	SetCyclingInfo( &target_cycling, FALSE, 1, IOERROR, 1, StepLinear );
+	SetCyclingInfo(&target_cycling, FALSE, 1, IOERROR, 1, StepLinear);
 	OnSelchangeCDStepType();
-	SetCyclingInfo( &queue_cycling, FALSE, 1, 32, 2, StepExponential );
+	SetCyclingInfo(&queue_cycling, FALSE, 1, 32, 2, StepExponential);
 	OnSelchangeCQStepType();
 
-	#if _DEBUG
-		result_type = RecordNone;	// don't save results for debug code
-	#else
-		result_type = RecordAll;	// save all results for release code
-	#endif
+#if _DEBUG
+	result_type = RecordNone;	// don't save results for debug code
+#else
+	result_type = RecordAll;	// save all results for release code
+#endif
 
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 
-	return TRUE;  // return TRUE unless you set the focus to a control
-	              // EXCEPTION: OCX Property Pages should return FALSE
+	return TRUE;		// return TRUE unless you set the focus to a control
+	// EXCEPTION: OCX Property Pages should return FALSE
 }
 
-
-
 //
 // Enable or disable the display for user access.
 //
-void CPageSetup::EnableWindow( BOOL enable )
+void CPageSetup::EnableWindow(BOOL enable)
 {
 	// All the windows are enabled or disabled at the same time.
 	// Don't bother enabling the windows if they allready are.
-	if ( (theApp.test_state != TestIdle) || (m_CResultType.IsWindowEnabled() == enable) )
+	if ((theApp.test_state != TestIdle) || (m_CResultType.IsWindowEnabled() == enable))
 		return;
 
-	m_CResultType.EnableWindow( enable );
+	m_CResultType.EnableWindow(enable);
 	m_CResultType.RedrawWindow();
-	m_CTestType.EnableWindow( enable );
+	m_CTestType.EnableWindow(enable);
 	m_CTestType.RedrawWindow();
 
-	EnableCyclingInfo( &worker_cycling, enable );
-	EnableCyclingInfo( &target_cycling, enable );
-	EnableCyclingInfo( &queue_cycling, enable );
+	EnableCyclingInfo(&worker_cycling, enable);
+	EnableCyclingInfo(&target_cycling, enable);
+	EnableCyclingInfo(&queue_cycling, enable);
 
-	m_ERampTime.EnableWindow( enable );
-	m_ERunTimeHours.EnableWindow( enable );
-	m_ERunTimeMinutes.EnableWindow( enable );
-	m_ERunTimeSeconds.EnableWindow( enable );
-	m_EDiskWorkerCount.EnableWindow( enable );
-	m_ENetWorkerCount.EnableWindow( enable );
-	m_ETestName.EnableWindow( enable );
+	m_ERampTime.EnableWindow(enable);
+	m_ERunTimeHours.EnableWindow(enable);
+	m_ERunTimeMinutes.EnableWindow(enable);
+	m_ERunTimeSeconds.EnableWindow(enable);
+	m_EDiskWorkerCount.EnableWindow(enable);
+	m_ENetWorkerCount.EnableWindow(enable);
+	m_ETestName.EnableWindow(enable);
 
-	GetDlgItem( RDiskSpawnCPUs )->EnableWindow( enable );
-	GetDlgItem( RDiskSpawnUser )->EnableWindow( enable );
-	GetDlgItem( RNetSpawnCPUs )->EnableWindow( enable );
-	GetDlgItem( RNetSpawnUser )->EnableWindow( enable );
+	GetDlgItem(RDiskSpawnCPUs)->EnableWindow(enable);
+	GetDlgItem(RDiskSpawnUser)->EnableWindow(enable);
+	GetDlgItem(RNetSpawnCPUs)->EnableWindow(enable);
+	GetDlgItem(RNetSpawnUser)->EnableWindow(enable);
 
 	UpdateWindow();
 }
 
-
-
 //
 // Enable or disable cycling information on the GUI.  This is usually done as a result 
 // of the selected test type. 
 //
-void CPageSetup::EnableCyclingInfo( Cycling_Info *cycling_info, BOOL enable )
+void CPageSetup::EnableCyclingInfo(Cycling_Info * cycling_info, BOOL enable)
 {
 	// Do not enable the GUI unless its cycling type is selected.
-	if ( enable && !cycling_info->selected )
+	if (enable && !cycling_info->selected)
 		return;
 
-	cycling_info->start_box.EnableWindow( enable );
+	cycling_info->start_box.EnableWindow(enable);
 	cycling_info->start_box.RedrawWindow();
 
 	// Make sure that an end cycling number is supported.
-	if ( cycling_info->end != IOERROR )
-	{
+	if (cycling_info->end != IOERROR) {
 		// End edit box exists, so update it.
-		cycling_info->end_box.EnableWindow( enable );
+		cycling_info->end_box.EnableWindow(enable);
 		cycling_info->end_box.RedrawWindow();
 	}
 
-	cycling_info->step_box.EnableWindow( enable );
+	cycling_info->step_box.EnableWindow(enable);
 	cycling_info->step_box.RedrawWindow();
 
-	cycling_info->step_sel_box.EnableWindow( enable );
+	cycling_info->step_sel_box.EnableWindow(enable);
 	cycling_info->step_sel_box.RedrawWindow();
 }
 
-
-
 //
 // Set cycling information.
 //
-void CPageSetup::SetCyclingInfo(Cycling_Info *cycle_info, BOOL selected,
-	int start, int end, int step, int cycle_type )
+void CPageSetup::SetCyclingInfo(Cycling_Info * cycle_info, BOOL selected, int start, int end, int step, int cycle_type)
 {
 	cycle_info->selected = selected;
 	cycle_info->start = start;
 	cycle_info->end = end;
 	cycle_info->step = step;
 	cycle_info->step_type = cycle_type;
-	cycle_info->step_sel_box.SetCurSel( cycle_type );
+	cycle_info->step_sel_box.SetCurSel(cycle_type);
 
-	EnableCyclingInfo( cycle_info, selected );
+	EnableCyclingInfo(cycle_info, selected);
 
 	UpdateWindow();
 }
 
-
-
 //
 // Saving test setup and its starting time to a file.
 //
-void CPageSetup::SaveResults( ostream* file )
+void CPageSetup::SaveResults(ostream * file)
 {
-	struct _timeb  tb;
-	struct tm     *ptm;
+	struct _timeb tb;
+	struct tm *ptm;
 	char acDummy[64];
 
 	(*file) << "'Test Type,Test Description" << endl
-		<< m_CTestType.GetCurSel() << "," << (LPCTSTR) test_name << endl;
+	    << m_CTestType.GetCurSel() << "," << (LPCTSTR) test_name << endl;
 
-	(*file) << "'Version" << endl
-		<< theApp.GetVersionString (TRUE) << endl;
-	
+	(*file) << "'Version" << endl << theApp.GetVersionString(TRUE) << endl;
+
 	// Write current timestamp into the result file
 	(*file) << "'Time Stamp" << endl;
-	_ftime( &tb );
-	ptm = localtime( &tb.time );
-	sprintf( acDummy, "%04d-%02d-%02d %02d:%02d:%02d:%003d", ptm->tm_year + 1900,
-	                                                         ptm->tm_mon + 1,
-								 ptm->tm_mday,
-								 ptm->tm_hour,
-								 ptm->tm_min,
-								 ptm->tm_sec,
-								 tb.millitm );
+	_ftime(&tb);
+	ptm = localtime(&tb.time);
+	sprintf(acDummy, "%04d-%02d-%02d %02d:%02d:%02d:%003d", ptm->tm_year + 1900,
+		ptm->tm_mon + 1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, tb.millitm);
 	(*file) << acDummy << endl;
 }
 
-
-
 //
 // Saving test setup information to a file.
 //
-BOOL CPageSetup::SaveConfig( ostream& outfile )
+BOOL CPageSetup::SaveConfig(ostream & outfile)
 {
 	// Update memory variables with data located on GUI.
-	UpdateData( TRUE );
+	UpdateData(TRUE);
 
 	// Save test setup information.
-	outfile << "'TEST SETUP ============================"
-			"========================================" << endl;
+	outfile << "'TEST SETUP ============================" "========================================" << endl;
 
-	outfile << "'Test Description" << endl
-			<< "\t" << (LPCTSTR)test_name << endl;
+	outfile << "'Test Description" << endl << "\t" << (LPCTSTR) test_name << endl;
 
 	// Save run time information.
 
-	outfile << setiosflags( ios::left );
+	outfile << setiosflags(ios::left);
 
 	outfile << "'Run Time" << endl
-			<< "'\t" << setw(11) << "hours"
-				<< setw(11) << "minutes"
-				<< "seconds" << endl
-			<< "\t" << setw(11) << hours
-				<< setw(11) << minutes
-				<< seconds << endl;
+	    << "'\t" << setw(11) << "hours"
+	    << setw(11) << "minutes"
+	    << "seconds" << endl << "\t" << setw(11) << hours << setw(11) << minutes << seconds << endl;
 
 	// Save miscellaneous information.
-	outfile << "'Ramp Up Time (s)" << endl
-			<< "\t" << ramp_time << endl;
+	outfile << "'Ramp Up Time (s)" << endl << "\t" << ramp_time << endl;
 
-	outfile << "'Default Disk Workers to Spawn" << endl
-			<< "\t";
-	
+	outfile << "'Default Disk Workers to Spawn" << endl << "\t";
+
 	if (disk_worker_count == -1)
 		outfile << "NUMBER_OF_CPUS" << endl;
 	else
 		outfile << disk_worker_count << endl;
 
-	outfile << "'Default Network Workers to Spawn" << endl
-			<< "\t";
+	outfile << "'Default Network Workers to Spawn" << endl << "\t";
 
 	if (net_worker_count == -1)
 		outfile << "NUMBER_OF_CPUS" << endl;
@@ -375,8 +343,7 @@
 
 	outfile << "'Record Results" << endl << "\t";
 
-	switch (result_type)
-	{
+	switch (result_type) {
 	case RecordAll:
 		outfile << "ALL" << endl;
 		break;
@@ -394,21 +361,18 @@
 		break;
 	default:
 		ErrorMessage("Error while saving test setup information.  "
-			"Record Results setting in Test Setup tab is invalid.  "
-			"Please report this as an Iometer bug.");
+			     "Record Results setting in Test Setup tab is invalid.  "
+			     "Please report this as an Iometer bug.");
 		return FALSE;
 	}
 
 	// Save worker cycling information.
 	outfile << "'Worker Cycling" << endl
-			<< "'\t" << setw(11) << "start"
-				<< setw(11) << "step"
-				<< "step type" << endl
-			<< "\t" << setw(11) << worker_cycling.start
-				<< setw(11) << worker_cycling.step;
+	    << "'\t" << setw(11) << "start"
+	    << setw(11) << "step"
+	    << "step type" << endl << "\t" << setw(11) << worker_cycling.start << setw(11) << worker_cycling.step;
 
-	switch (worker_cycling.step_type)
-	{
+	switch (worker_cycling.step_type) {
 	case StepLinear:
 		outfile << "LINEAR" << endl;
 		break;
@@ -417,20 +381,17 @@
 		break;
 	default:
 		ErrorMessage("Error saving test setup data.  Worker cycling step type "
-						"is neither StepLinear nor StepExponential.");
+			     "is neither StepLinear nor StepExponential.");
 		return FALSE;
 	}
 
 	// Save disk cycling information.
 	outfile << "'Disk Cycling" << endl
-			<< "'\t" << setw(11) << "start"
-				<< setw(11) << "step"
-				<< "step type" << endl
-			<< "\t" << setw(11)	<< target_cycling.start
-				<< setw(11) << target_cycling.step;
+	    << "'\t" << setw(11) << "start"
+	    << setw(11) << "step"
+	    << "step type" << endl << "\t" << setw(11) << target_cycling.start << setw(11) << target_cycling.step;
 
-	switch (target_cycling.step_type)
-	{
+	switch (target_cycling.step_type) {
 	case StepLinear:
 		outfile << "LINEAR" << endl;
 		break;
@@ -439,22 +400,20 @@
 		break;
 	default:
 		ErrorMessage("Error saving test setup data.  Disk cycling step type "
-						"is neither StepLinear nor StepExponential.");
+			     "is neither StepLinear nor StepExponential.");
 		return FALSE;
 	}
 
 	// Save queue cycling information.
 	outfile << "'Queue Depth Cycling" << endl
-			<< "'\t" << setw(11) << "start"
-				<< setw(11) << "end"
-				<< setw(11) << "step"
-				<< "step type" << endl
-			<< "\t" << setw(11) << queue_cycling.start
-				<< setw(11) << queue_cycling.end
-				<< setw(11) << queue_cycling.step;
+	    << "'\t" << setw(11) << "start"
+	    << setw(11) << "end"
+	    << setw(11) << "step"
+	    << "step type" << endl
+	    << "\t" << setw(11) << queue_cycling.start
+	    << setw(11) << queue_cycling.end << setw(11) << queue_cycling.step;
 
-	switch (queue_cycling.step_type)
-	{
+	switch (queue_cycling.step_type) {
 	case StepLinear:
 		outfile << "LINEAR" << endl;
 		break;
@@ -463,15 +422,14 @@
 		break;
 	default:
 		ErrorMessage("Error saving test setup data.  Queue depth cycling step type "
-						"is neither LINEAR nor EXPONENTIAL.");
+			     "is neither LINEAR nor EXPONENTIAL.");
 		return FALSE;
 	}
 
 	// Save test type.
 	outfile << "'Test Type" << endl << "\t";
 
-	switch (test_type)
-	{
+	switch (test_type) {
 	case CyclingTargets:
 		outfile << "CYCLE_TARGETS" << endl;
 		break;
@@ -497,22 +455,20 @@
 		outfile << "NORMAL" << endl;
 		break;
 	}
-		
+
 	// Mark end of test setup information.
 	outfile << "'END test setup" << endl;
 
-	return TRUE;	// no errors (FALSE indicates an error)
+	return TRUE;		// no errors (FALSE indicates an error)
 }
 
-
-
 //
 // Loading test setup information.
 //
-BOOL CPageSetup::LoadConfig( const CString& infilename )
+BOOL CPageSetup::LoadConfig(const CString & infilename)
 {
 	long version;
-	CString	key, value;
+	CString key, value;
 	CString token;
 	ICF_ifstream infile(infilename);
 
@@ -520,223 +476,176 @@
 	version = infile.GetVersion();
 	if (version == -1)
 		return FALSE;
-	if ( !infile.SkipTo("'TEST SETUP") )
+	if (!infile.SkipTo("'TEST SETUP"))
 		return TRUE;	// no test setup to restore (this is OK)
 
-	while (1)
-	{
-		if ( !infile.GetPair(key, value) )
-		{
+	while (1) {
+		if (!infile.GetPair(key, value)) {
 			ErrorMessage("File is improperly formatted.  Expected "
-				"test setup data or \"END test setup\".");
+				     "test setup data or \"END test setup\".");
 			return FALSE;
 		}
 
-		if ( key.CompareNoCase("'END test setup") == 0 )
-		{
+		if (key.CompareNoCase("'END test setup") == 0) {
 			break;
-		}
-		else if ( key.CompareNoCase("'Test Description") == 0 )
-		{
+		} else if (key.CompareNoCase("'Test Description") == 0) {
 			test_name = value;
-		}
-		else if ( key.CompareNoCase("'Run Time") == 0 )
-		{
-			if ( !ICF_ifstream::ExtractFirstInt(value, hours)
-				|| !ICF_ifstream::ExtractFirstInt(value, minutes)
-				|| !ICF_ifstream::ExtractFirstInt(value, seconds) )
-			{	
+		} else if (key.CompareNoCase("'Run Time") == 0) {
+			if (!ICF_ifstream::ExtractFirstInt(value, hours)
+			    || !ICF_ifstream::ExtractFirstInt(value, minutes)
+			    || !ICF_ifstream::ExtractFirstInt(value, seconds)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Run time\" should be specified as three integer values "
-					"(hours, minutes, seconds).");
+					     "\"Run time\" should be specified as three integer values "
+					     "(hours, minutes, seconds).");
 				return FALSE;
 			}
-		}
-		else if ( key.Left((int)(strlen("'Ramp Up Time"))).CompareNoCase("'Ramp Up Time") == 0 )
-		{
-			if ( !ICF_ifstream::ExtractFirstInt(value, ramp_time) )
-			{
+		} else if (key.Left((int)(strlen("'Ramp Up Time"))).CompareNoCase("'Ramp Up Time") == 0) {
+			if (!ICF_ifstream::ExtractFirstInt(value, ramp_time)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Ramp up time\" should be specified as an integer value.");
+					     "\"Ramp up time\" should be specified as an integer value.");
 				return FALSE;
 			}
 		}
 		// For backward compatibility...
-		else if ( key.CompareNoCase("'Default Workers to Spawn") == 0 )
-		{
-			if ( !ICF_ifstream::ExtractFirstInt(value, disk_worker_count) )
-			{
+		else if (key.CompareNoCase("'Default Workers to Spawn") == 0) {
+			if (!ICF_ifstream::ExtractFirstInt(value, disk_worker_count)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Default workers to spawn\" should be "
-					"specified as an integer value.");
+					     "\"Default workers to spawn\" should be "
+					     "specified as an integer value.");
 				return FALSE;
 			}
 
-			if ( disk_worker_count == 0 )	// "# of CPUs" used to be rep.
-				disk_worker_count = -1;		// as 0 internally, now it is -1.
-		}
-		else if ( key.CompareNoCase("'Default Disk Workers to Spawn") == 0 )
-		{
+			if (disk_worker_count == 0)	// "# of CPUs" used to be rep.
+				disk_worker_count = -1;	// as 0 internally, now it is -1.
+		} else if (key.CompareNoCase("'Default Disk Workers to Spawn") == 0) {
 			token = ICF_ifstream::ExtractFirstToken(value);
 
-			if ( token.CompareNoCase("NUMBER_OF_CPUS") == 0 )
+			if (token.CompareNoCase("NUMBER_OF_CPUS") == 0)
 				disk_worker_count = -1;
-			else // all other values are stored as an integer
-				disk_worker_count = atoi( (LPCTSTR)token );
-		}
-		else if ( key.CompareNoCase("'Default Network Workers to Spawn") == 0 )
-		{
+			else	// all other values are stored as an integer
+				disk_worker_count = atoi((LPCTSTR) token);
+		} else if (key.CompareNoCase("'Default Network Workers to Spawn") == 0) {
 			token = ICF_ifstream::ExtractFirstToken(value);
 
-			if ( token.CompareNoCase("NUMBER_OF_CPUS") == 0 )
+			if (token.CompareNoCase("NUMBER_OF_CPUS") == 0)
 				net_worker_count = -1;
-			else // all other values are stored as an integer
-				net_worker_count = atoi( (LPCTSTR)token );
-		}
-		else if ( key.CompareNoCase("'Record Results") == 0 )
-		{
+			else	// all other values are stored as an integer
+				net_worker_count = atoi((LPCTSTR) token);
+		} else if (key.CompareNoCase("'Record Results") == 0) {
 			value.TrimLeft();
 			value.TrimRight();
 
-			if ( value.CompareNoCase("ALL") == 0 )
+			if (value.CompareNoCase("ALL") == 0)
 				result_type = RecordAll;
-			else if ( value.CompareNoCase("NO_TARGETS") == 0 )
+			else if (value.CompareNoCase("NO_TARGETS") == 0)
 				result_type = RecordNoTargets;
-			else if ( value.CompareNoCase("NO_WORKERS") == 0 )
+			else if (value.CompareNoCase("NO_WORKERS") == 0)
 				result_type = RecordNoWorkers;
-			else if ( value.CompareNoCase("NO_MANAGERS") == 0 )
+			else if (value.CompareNoCase("NO_MANAGERS") == 0)
 				result_type = RecordNoManagers;
-			else if ( value.CompareNoCase("NONE") == 0 )
+			else if (value.CompareNoCase("NONE") == 0)
 				result_type = RecordNone;
 			// This value used to be stored as an integer.
 			// If no string match occured, restore the value as an integer.
-			else if ( !ICF_ifstream::ExtractFirstInt(value, result_type) )
-			{
+			else if (!ICF_ifstream::ExtractFirstInt(value, result_type)) {
 				ErrorMessage("Error while reading file.  "
-					"For \"Record results\", expected a legal identifier or an "
-					"integer value.  See the documentation for details.");
+					     "For \"Record results\", expected a legal identifier or an "
+					     "integer value.  See the documentation for details.");
 				return FALSE;
 			}
-		}
-		else if ( key.CompareNoCase("'Worker Cycling") == 0 )
-		{
-			if ( !ICF_ifstream::ExtractFirstInt(value, worker_cycling.start)
-				|| !ICF_ifstream::ExtractFirstInt(value, worker_cycling.step) )
-			{
+		} else if (key.CompareNoCase("'Worker Cycling") == 0) {
+			if (!ICF_ifstream::ExtractFirstInt(value, worker_cycling.start)
+			    || !ICF_ifstream::ExtractFirstInt(value, worker_cycling.step)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Worker cycling\" start and step should be specified as "
-					"integer values.");
+					     "\"Worker cycling\" start and step should be specified as "
+					     "integer values.");
 				return FALSE;
 			}
 
 			token = ICF_ifstream::ExtractFirstToken(value);
 
-			if ( token.CompareNoCase("LINEAR") == 0 )
-			{
+			if (token.CompareNoCase("LINEAR") == 0) {
 				worker_cycling.step_type = StepLinear;
-			}
-			else if ( token.CompareNoCase("EXPONENTIAL") == 0 )
-			{
+			} else if (token.CompareNoCase("EXPONENTIAL") == 0) {
 				worker_cycling.step_type = StepExponential;
-			}
-			else // value used to be stored as an integer
+			} else	// value used to be stored as an integer
 			{
-				worker_cycling.step_type = atoi( (LPCTSTR)token );
+				worker_cycling.step_type = atoi((LPCTSTR) token);
 			}
-		}
-		else if ( key.CompareNoCase("'Disk Cycling") == 0 )
-		{
-			if ( !ICF_ifstream::ExtractFirstInt(value, target_cycling.start)
-				|| !ICF_ifstream::ExtractFirstInt(value, target_cycling.step) )
-			{
+		} else if (key.CompareNoCase("'Disk Cycling") == 0) {
+			if (!ICF_ifstream::ExtractFirstInt(value, target_cycling.start)
+			    || !ICF_ifstream::ExtractFirstInt(value, target_cycling.step)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Disk cycling\" start and step should be specified as "
-					"integer values.");
+					     "\"Disk cycling\" start and step should be specified as "
+					     "integer values.");
 				return FALSE;
 			}
 
 			token = ICF_ifstream::ExtractFirstToken(value);
 
-			if ( token.CompareNoCase("LINEAR") == 0 )
-			{
+			if (token.CompareNoCase("LINEAR") == 0) {
 				target_cycling.step_type = StepLinear;
-			}
-			else if ( token.CompareNoCase("EXPONENTIAL") == 0 )
-			{
+			} else if (token.CompareNoCase("EXPONENTIAL") == 0) {
 				target_cycling.step_type = StepExponential;
-			}
-			else // value used to be stored as an integer
+			} else	// value used to be stored as an integer
 			{
-				target_cycling.step_type = atoi( (LPCTSTR)token );
+				target_cycling.step_type = atoi((LPCTSTR) token);
 			}
-		}
-		else if ( key.CompareNoCase("'Queue Depth Cycling") == 0 )
-		{
-			if ( !ICF_ifstream::ExtractFirstInt(value, queue_cycling.start)
-				|| !ICF_ifstream::ExtractFirstInt(value, queue_cycling.end)
-				|| !ICF_ifstream::ExtractFirstInt(value, queue_cycling.step) )
-			{
+		} else if (key.CompareNoCase("'Queue Depth Cycling") == 0) {
+			if (!ICF_ifstream::ExtractFirstInt(value, queue_cycling.start)
+			    || !ICF_ifstream::ExtractFirstInt(value, queue_cycling.end)
+			    || !ICF_ifstream::ExtractFirstInt(value, queue_cycling.step)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Queue depth cycling\" start, end, and step should be "
-					"specified as integer values.");
+					     "\"Queue depth cycling\" start, end, and step should be "
+					     "specified as integer values.");
 				return FALSE;
 			}
 
 			token = ICF_ifstream::ExtractFirstToken(value);
 
-			if ( token.CompareNoCase("LINEAR") == 0 )
-			{
+			if (token.CompareNoCase("LINEAR") == 0) {
 				queue_cycling.step_type = StepLinear;
-			}
-			else if ( token.CompareNoCase("EXPONENTIAL") == 0 )
-			{
+			} else if (token.CompareNoCase("EXPONENTIAL") == 0) {
 				queue_cycling.step_type = StepExponential;
-			}
-			else // value used to be stored as an integer
+			} else	// value used to be stored as an integer
 			{
-				queue_cycling.step_type = atoi( (LPCTSTR)token );
+				queue_cycling.step_type = atoi((LPCTSTR) token);
 			}
-		}
-		else if ( key.CompareNoCase("'Test Type") == 0 )
-		{
+		} else if (key.CompareNoCase("'Test Type") == 0) {
 			value.TrimLeft();
 			value.TrimRight();
 
-			if ( value.CompareNoCase("NORMAL") == 0 )
+			if (value.CompareNoCase("NORMAL") == 0)
 				test_type = 0;
-			else if ( value.CompareNoCase("CYCLE_TARGETS") == 0 )
+			else if (value.CompareNoCase("CYCLE_TARGETS") == 0)
 				test_type = CyclingTargets;
-			else if ( value.CompareNoCase("CYCLE_WORKERS") == 0 )
+			else if (value.CompareNoCase("CYCLE_WORKERS") == 0)
 				test_type = CyclingWorkers;
-			else if ( value.CompareNoCase("INCREMENT_TARGETS_PARALLEL") == 0 )
+			else if (value.CompareNoCase("INCREMENT_TARGETS_PARALLEL") == 0)
 				test_type = CyclingIncTargetsParallel;
-			else if ( value.CompareNoCase("INCREMENT_TARGETS_SERIAL") == 0 )
+			else if (value.CompareNoCase("INCREMENT_TARGETS_SERIAL") == 0)
 				test_type = CyclingIncTargetsSerial;
-			else if ( value.CompareNoCase("CYCLE_WORKERS_AND_TARGETS") == 0 )
+			else if (value.CompareNoCase("CYCLE_WORKERS_AND_TARGETS") == 0)
 				test_type = CyclingWorkersTargets;
-			else if ( value.CompareNoCase("CYCLE_OUTSTANDING_IOS") == 0 )
+			else if (value.CompareNoCase("CYCLE_OUTSTANDING_IOS") == 0)
 				test_type = CyclingQueue;
-			else if ( value.CompareNoCase("CYCLE_OUTSTANDING_IOS_AND_TARGETS") == 0 )
+			else if (value.CompareNoCase("CYCLE_OUTSTANDING_IOS_AND_TARGETS") == 0)
 				test_type = CyclingQueueTargets;
 			// This value used to be stored as an integer.
 			// If no string match occured, restore the value as an integer.
-			else if ( !ICF_ifstream::ExtractFirstInt(value, test_type) )
-			{
+			else if (!ICF_ifstream::ExtractFirstInt(value, test_type)) {
 				ErrorMessage("Error while reading file.  "
-					"For \"Test type\", expected a legal identifier or an "
-					"integer value.  See the documentation for details.");
+					     "For \"Test type\", expected a legal identifier or an "
+					     "integer value.  See the documentation for details.");
 				return FALSE;
 			}
-		}
-		else	// Unrecognized comment 
+		} else		// Unrecognized comment 
 		{
-			if (version >= 19990217)
-			{
+			if (version >= 19990217) {
 				ErrorMessage("File is improperly formatted.  TEST SETUP "
-					"section contained an unrecognized \"" + key + "\" comment.");
+					     "section contained an unrecognized \"" + key + "\" comment.");
 				return FALSE;
 			}
-
 			// For backward compatibility reasons, we can't count on
 			// "'Test Setup" having a corresponding "'End test setup"
 			// because versions as recent as 1998.10.08 didn't follow
@@ -750,32 +659,28 @@
 	infile.close();
 
 	// Update the GUI with the values read in from the file.
-	UpdateData( FALSE );
+	UpdateData(FALSE);
 
 	return TRUE;
 }
 
-
 //
 // Retrieve the specified run time from the GUI and return it (in ms).
 //
 int CPageSetup::GetRunTime()
 {
-	return( 1000 *		// ms per second x 
-		( hours * 3600	// ( seconds per hour
-		+ minutes * 60	// + seconds per minute
-		+ seconds ) );	// + seconds )
+	return (1000 *		// ms per second x 
+		(hours * 3600	// ( seconds per hour
+		 + minutes * 60	// + seconds per minute
+		 + seconds));	// + seconds )
 }
 
-
-
 //
-//	Updating either the GUI with data in memory or vice versa.
+//      Updating either the GUI with data in memory or vice versa.
 //
-void CPageSetup::UpdateData( BOOL save_from_window )
+void CPageSetup::UpdateData(BOOL save_from_window)
 {
-	if( save_from_window )
-	{
+	if (save_from_window) {
 		// Update all the combo box selections.
 		result_type = m_CResultType.GetCurSel();
 		test_type = m_CTestType.GetCurSel();
@@ -783,171 +688,158 @@
 		target_cycling.step_type = target_cycling.step_sel_box.GetCurSel();
 		queue_cycling.step_type = queue_cycling.step_sel_box.GetCurSel();
 
-		CheckData( ERunTimeHours, &hours );
-		CheckData( ERunTimeMinutes, &minutes );
-		CheckData( ERunTimeSeconds, &seconds );
-		CheckData( ERampTime, &ramp_time );
-		CheckData( EWorkerStep, &(worker_cycling.step), TRUE );
-		CheckData( EDiskStep, &(target_cycling.step), TRUE );
-		CheckData( EQueueStep, &(queue_cycling.step), TRUE );
-		CheckData( EWorkerStart, &(worker_cycling.start), TRUE );
-		CheckData( EDiskStart, &(target_cycling.start), TRUE );
-		CheckData( EQueueStart, &(queue_cycling.start), TRUE );
-		CheckData( EQueueEnd, &(queue_cycling.end), TRUE );
+		CheckData(ERunTimeHours, &hours);
+		CheckData(ERunTimeMinutes, &minutes);
+		CheckData(ERunTimeSeconds, &seconds);
+		CheckData(ERampTime, &ramp_time);
+		CheckData(EWorkerStep, &(worker_cycling.step), TRUE);
+		CheckData(EDiskStep, &(target_cycling.step), TRUE);
+		CheckData(EQueueStep, &(queue_cycling.step), TRUE);
+		CheckData(EWorkerStart, &(worker_cycling.start), TRUE);
+		CheckData(EDiskStart, &(target_cycling.start), TRUE);
+		CheckData(EQueueStart, &(queue_cycling.start), TRUE);
+		CheckData(EQueueEnd, &(queue_cycling.end), TRUE);
 
-		if ( GetCheckedRadioButton( RDiskSpawnCPUs, RDiskSpawnUser ) == RDiskSpawnCPUs )
+		if (GetCheckedRadioButton(RDiskSpawnCPUs, RDiskSpawnUser) == RDiskSpawnCPUs)
 			disk_worker_count = -1;
 		else
-			CheckData( EDiskWorkerCount, &disk_worker_count, FALSE );
+			CheckData(EDiskWorkerCount, &disk_worker_count, FALSE);
 
-		if ( GetCheckedRadioButton( RNetSpawnCPUs, RNetSpawnUser ) == RNetSpawnCPUs )
+		if (GetCheckedRadioButton(RNetSpawnCPUs, RNetSpawnUser) == RNetSpawnCPUs)
 			net_worker_count = -1;
 		else
-			CheckData( ENetWorkerCount, &net_worker_count, FALSE );
+			CheckData(ENetWorkerCount, &net_worker_count, FALSE);
 
-		GetDlgItemText( ETestName, test_name );
-	}
-	else
-	{
+		GetDlgItemText(ETestName, test_name);
+	} else {
 		// Update all the combo box selections.
-		m_CResultType.SetCurSel( result_type );
-		m_CTestType.SetCurSel( test_type );
-		worker_cycling.step_sel_box.SetCurSel( worker_cycling.step_type );
-		target_cycling.step_sel_box.SetCurSel( target_cycling.step_type );
-		queue_cycling.step_sel_box.SetCurSel( queue_cycling.step_type );
+		m_CResultType.SetCurSel(result_type);
+		m_CTestType.SetCurSel(test_type);
+		worker_cycling.step_sel_box.SetCurSel(worker_cycling.step_type);
+		target_cycling.step_sel_box.SetCurSel(target_cycling.step_type);
+		queue_cycling.step_sel_box.SetCurSel(queue_cycling.step_type);
 
 		// Enable/disable and label cycling controls.
 		OnSelchangeCTestType();
-		SetStepTypeLabel( TWorkerStep, worker_cycling.step_type );
-		SetStepTypeLabel( TDiskStep, target_cycling.step_type );
-		SetStepTypeLabel( TQueueStep, queue_cycling.step_type );
+		SetStepTypeLabel(TWorkerStep, worker_cycling.step_type);
+		SetStepTypeLabel(TDiskStep, target_cycling.step_type);
+		SetStepTypeLabel(TQueueStep, queue_cycling.step_type);
 
 		// Update the run time and other default information.
-		SetDlgItemInt( ERunTimeHours, hours, FALSE );
-		SetDlgItemInt( ERunTimeMinutes, minutes, FALSE );
-		SetDlgItemInt( ERunTimeSeconds, seconds, FALSE );
+		SetDlgItemInt(ERunTimeHours, hours, FALSE);
+		SetDlgItemInt(ERunTimeMinutes, minutes, FALSE);
+		SetDlgItemInt(ERunTimeSeconds, seconds, FALSE);
 
-		if ( disk_worker_count == -1 )
-		{
-			CheckRadioButton( RDiskSpawnCPUs, RDiskSpawnUser, RDiskSpawnCPUs );
-			m_EDiskWorkerCount.EnableWindow( FALSE );
+		if (disk_worker_count == -1) {
+			CheckRadioButton(RDiskSpawnCPUs, RDiskSpawnUser, RDiskSpawnCPUs);
+			m_EDiskWorkerCount.EnableWindow(FALSE);
+		} else {
+			CheckRadioButton(RDiskSpawnCPUs, RDiskSpawnUser, RDiskSpawnUser);
+			m_EDiskWorkerCount.EnableWindow(TRUE);
+			SetDlgItemInt(EDiskWorkerCount, disk_worker_count, FALSE);
 		}
-		else
-		{
-			CheckRadioButton( RDiskSpawnCPUs, RDiskSpawnUser, RDiskSpawnUser );
-			m_EDiskWorkerCount.EnableWindow( TRUE );
-			SetDlgItemInt( EDiskWorkerCount, disk_worker_count, FALSE );
-		}
 
-		if ( net_worker_count == -1 )
-		{
-			CheckRadioButton( RNetSpawnCPUs, RNetSpawnUser, RNetSpawnCPUs );
-			m_ENetWorkerCount.EnableWindow( FALSE );
+		if (net_worker_count == -1) {
+			CheckRadioButton(RNetSpawnCPUs, RNetSpawnUser, RNetSpawnCPUs);
+			m_ENetWorkerCount.EnableWindow(FALSE);
+		} else {
+			CheckRadioButton(RNetSpawnCPUs, RNetSpawnUser, RNetSpawnUser);
+			m_ENetWorkerCount.EnableWindow(TRUE);
+			SetDlgItemInt(ENetWorkerCount, net_worker_count, FALSE);
 		}
-		else
-		{
-			CheckRadioButton( RNetSpawnCPUs, RNetSpawnUser, RNetSpawnUser );
-			m_ENetWorkerCount.EnableWindow( TRUE );
-			SetDlgItemInt( ENetWorkerCount, net_worker_count, FALSE );
-		}
 
-		SetDlgItemInt( ERampTime, ramp_time, FALSE );
+		SetDlgItemInt(ERampTime, ramp_time, FALSE);
 
 		// Set the displayed value for the step size and start values.
-		SetDlgItemInt( EWorkerStep, worker_cycling.step, FALSE );
-		SetDlgItemInt( EDiskStep, target_cycling.step, FALSE );
-		SetDlgItemInt( EQueueStep, queue_cycling.step, FALSE );
-		SetDlgItemInt( EWorkerStart, worker_cycling.start, FALSE );
-		SetDlgItemInt( EDiskStart, target_cycling.start, FALSE );
-		SetDlgItemInt( EQueueStart, queue_cycling.start, FALSE );
-		SetDlgItemInt( EQueueEnd, queue_cycling.end, FALSE );
+		SetDlgItemInt(EWorkerStep, worker_cycling.step, FALSE);
+		SetDlgItemInt(EDiskStep, target_cycling.step, FALSE);
+		SetDlgItemInt(EQueueStep, queue_cycling.step, FALSE);
+		SetDlgItemInt(EWorkerStart, worker_cycling.start, FALSE);
+		SetDlgItemInt(EDiskStart, target_cycling.start, FALSE);
+		SetDlgItemInt(EQueueStart, queue_cycling.start, FALSE);
+		SetDlgItemInt(EQueueEnd, queue_cycling.end, FALSE);
 
 		// Set the test name.
-		SetDlgItemText( ETestName, test_name );
+		SetDlgItemText(ETestName, test_name);
 
 		UpdateWindow();
 	}
 }
 
-
-void CPageSetup::CheckData( UINT item_id, int* var, BOOL no_zero )
+void CPageSetup::CheckData(UINT item_id, int *var, BOOL no_zero)
 {
-	if ( ( *var == 0 ) && no_zero )
-	{
+	if ((*var == 0) && no_zero) {
 		*var = 1;
-		SetDlgItemInt( item_id, *var, FALSE );
+		SetDlgItemInt(item_id, *var, FALSE);
 	}
 }
 
-
-void CPageSetup::OnChangeEDiskWorkerCount() 
+void CPageSetup::OnChangeEDiskWorkerCount()
 {
 	CString buffer;
-	m_EDiskWorkerCount.GetWindowText( buffer );
-	if ( !buffer.IsEmpty() )
-		disk_worker_count = GetDlgItemInt( EDiskWorkerCount, NULL, FALSE );
+
+	m_EDiskWorkerCount.GetWindowText(buffer);
+	if (!buffer.IsEmpty())
+		disk_worker_count = GetDlgItemInt(EDiskWorkerCount, NULL, FALSE);
 }
 
-
-void CPageSetup::OnChangeENetWorkerCount() 
+void CPageSetup::OnChangeENetWorkerCount()
 {
 	CString buffer;
-	m_ENetWorkerCount.GetWindowText( buffer );
-	if ( !buffer.IsEmpty() )
-		net_worker_count = GetDlgItemInt( ENetWorkerCount, NULL, FALSE );
+
+	m_ENetWorkerCount.GetWindowText(buffer);
+	if (!buffer.IsEmpty())
+		net_worker_count = GetDlgItemInt(ENetWorkerCount, NULL, FALSE);
 }
 
-
-
 //
 // Set the label for the step edit box based on the step type.
 //
-void CPageSetup::SetStepTypeLabel( int text_id, int step_type ) 
+void CPageSetup::SetStepTypeLabel(int text_id, int step_type)
 {
-	if ( step_type == StepLinear )
-		SetDlgItemText( text_id, "Step" );
+	if (step_type == StepLinear)
+		SetDlgItemText(text_id, "Step");
 	else
-		SetDlgItemText( text_id, "Power of" );
+		SetDlgItemText(text_id, "Power of");
 	UpdateWindow();
 }
 
 // Worker step type has changed.
-void CPageSetup::OnSelchangeCWStepType() 
+void CPageSetup::OnSelchangeCWStepType()
 {
 	worker_cycling.step_type = worker_cycling.step_sel_box.GetCurSel();
-	SetStepTypeLabel( TWorkerStep, worker_cycling.step_type );
+	SetStepTypeLabel(TWorkerStep, worker_cycling.step_type);
 }
 
 // Disk step type has changed.
-void CPageSetup::OnSelchangeCDStepType() 
+void CPageSetup::OnSelchangeCDStepType()
 {
 	target_cycling.step_type = target_cycling.step_sel_box.GetCurSel();
-	SetStepTypeLabel( TDiskStep, target_cycling.step_type );
+	SetStepTypeLabel(TDiskStep, target_cycling.step_type);
 }
 
 // Queue depth step type has changed.
-void CPageSetup::OnSelchangeCQStepType() 
+void CPageSetup::OnSelchangeCQStepType()
 {
 	queue_cycling.step_type = queue_cycling.step_sel_box.GetCurSel();
-	SetStepTypeLabel( TQueueStep, queue_cycling.step_type );
+	SetStepTypeLabel(TQueueStep, queue_cycling.step_type);
 }
 
-
-
 // 
 // When an edit box loses the input focus, reverts to the previous
 // value if left blank, otherwise saves the value.
 //
-void CPageSetup::Killfocus( int edit_ID, int* value )
+void CPageSetup::Killfocus(int edit_ID, int *value)
 {
 	CString buffer;
+
 	// Get the window's text to check content.
-	GetDlgItem( edit_ID )->GetWindowText( buffer );
-	if ( buffer.IsEmpty() )
+	GetDlgItem(edit_ID)->GetWindowText(buffer);
+	if (buffer.IsEmpty())
 		// If blank revert to previous value.
-		SetDlgItemInt( edit_ID, *value, FALSE );
+		SetDlgItemInt(edit_ID, *value, FALSE);
 	else
-		*value = GetDlgItemInt( edit_ID );
+		*value = GetDlgItemInt(edit_ID);
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -957,129 +849,124 @@
 //
 /////////////////////////////////////////////////////////////////////////////
 
-void CPageSetup::OnKillfocusEDiskStart() 
+void CPageSetup::OnKillfocusEDiskStart()
 {
-	Killfocus( EDiskStart, &(target_cycling.start) );	
+	Killfocus(EDiskStart, &(target_cycling.start));
 }
 
-void CPageSetup::OnKillfocusEDiskStep() 
+void CPageSetup::OnKillfocusEDiskStep()
 {
-	Killfocus( EDiskStep, &(target_cycling.step) );
+	Killfocus(EDiskStep, &(target_cycling.step));
 }
 
-void CPageSetup::OnKillfocusEQueueEnd() 
+void CPageSetup::OnKillfocusEQueueEnd()
 {
-	Killfocus( EQueueEnd, &(queue_cycling.end) );	
+	Killfocus(EQueueEnd, &(queue_cycling.end));
 }
 
-void CPageSetup::OnKillfocusEQueueStart() 
+void CPageSetup::OnKillfocusEQueueStart()
 {
-	Killfocus( EQueueStart, &(queue_cycling.start) );	
+	Killfocus(EQueueStart, &(queue_cycling.start));
 }
 
-void CPageSetup::OnKillfocusEQueueStep() 
+void CPageSetup::OnKillfocusEQueueStep()
 {
-	Killfocus( EQueueStep, &(queue_cycling.step) );	
+	Killfocus(EQueueStep, &(queue_cycling.step));
 }
 
-void CPageSetup::OnKillfocusERampTime() 
+void CPageSetup::OnKillfocusERampTime()
 {
-	Killfocus( ERampTime, &ramp_time );	
+	Killfocus(ERampTime, &ramp_time);
 }
 
-void CPageSetup::OnKillfocusERunTimeHours() 
+void CPageSetup::OnKillfocusERunTimeHours()
 {
-	Killfocus( ERunTimeHours, &hours );	
+	Killfocus(ERunTimeHours, &hours);
 }
 
-void CPageSetup::OnKillfocusERunTimeMinutes() 
+void CPageSetup::OnKillfocusERunTimeMinutes()
 {
-	Killfocus( ERunTimeMinutes, &minutes );	
+	Killfocus(ERunTimeMinutes, &minutes);
 }
 
-void CPageSetup::OnKillfocusERunTimeSeconds() 
+void CPageSetup::OnKillfocusERunTimeSeconds()
 {
-	Killfocus( ERunTimeSeconds, &seconds );	
+	Killfocus(ERunTimeSeconds, &seconds);
 }
 
-void CPageSetup::OnKillfocusEDiskWorkerCount() 
+void CPageSetup::OnKillfocusEDiskWorkerCount()
 {
-	Killfocus( EDiskWorkerCount, &disk_worker_count );	
+	Killfocus(EDiskWorkerCount, &disk_worker_count);
 }
 
-void CPageSetup::OnKillfocusENetWorkerCount() 
+void CPageSetup::OnKillfocusENetWorkerCount()
 {
-	Killfocus( ENetWorkerCount, &net_worker_count );	
+	Killfocus(ENetWorkerCount, &net_worker_count);
 }
 
-void CPageSetup::OnKillfocusEWorkerStart() 
+void CPageSetup::OnKillfocusEWorkerStart()
 {
-	Killfocus( EWorkerStart, &(worker_cycling.start) );	
+	Killfocus(EWorkerStart, &(worker_cycling.start));
 }
 
-void CPageSetup::OnKillfocusEWorkerStep() 
+void CPageSetup::OnKillfocusEWorkerStep()
 {
-	Killfocus( EWorkerStep, &(worker_cycling.step) );	
+	Killfocus(EWorkerStep, &(worker_cycling.step));
 }
 
-
-
-void CPageSetup::OnSelchangeCResultType() 
+void CPageSetup::OnSelchangeCResultType()
 {
 	result_type = m_CResultType.GetCurSel();
 }
 
-
-
 //
 // The desired test cycling type has changed.  Enable/disable the
 // display appropriately.
 //
-void CPageSetup::OnSelchangeCTestType() 
+void CPageSetup::OnSelchangeCTestType()
 {
 	test_type = m_CTestType.GetCurSel();
 
 	// Determine if a particular cycling type is selected.
-	worker_cycling.selected = ( test_type == CyclingWorkers || test_type == CyclingWorkersTargets );
-	target_cycling.selected = ( test_type == CyclingTargets || test_type == CyclingWorkersTargets ||
-		test_type == CyclingIncTargetsParallel || test_type == CyclingIncTargetsSerial || 
-		test_type == CyclingQueueTargets );
-	queue_cycling.selected = ( test_type == CyclingQueue || 
-		test_type == CyclingQueueTargets );
+	worker_cycling.selected = (test_type == CyclingWorkers || test_type == CyclingWorkersTargets);
+	target_cycling.selected = (test_type == CyclingTargets || test_type == CyclingWorkersTargets ||
+				   test_type == CyclingIncTargetsParallel || test_type == CyclingIncTargetsSerial ||
+				   test_type == CyclingQueueTargets);
+	queue_cycling.selected = (test_type == CyclingQueue || test_type == CyclingQueueTargets);
 
 	// Enable/disable the display.
-	EnableCyclingInfo( &worker_cycling, worker_cycling.selected );
-	EnableCyclingInfo( &target_cycling, target_cycling.selected );
-	EnableCyclingInfo( &queue_cycling, queue_cycling.selected );
+	EnableCyclingInfo(&worker_cycling, worker_cycling.selected);
+	EnableCyclingInfo(&target_cycling, target_cycling.selected);
+	EnableCyclingInfo(&queue_cycling, queue_cycling.selected);
 
 	// If queue depth cycling is enabled, disable the target's queue depth and
 	// vice-versa.  Do not enable the queue depth if there are no managers logged
 	// in.
-	theApp.pView->m_pPageDisk->m_EQueueDepth.EnableWindow( !queue_cycling.selected && 
-		theApp.manager_list.ManagerCount() );
+	theApp.pView->m_pPageDisk->m_EQueueDepth.EnableWindow(!queue_cycling.selected &&
+							      theApp.manager_list.ManagerCount());
 	theApp.pView->m_pPageDisk->m_EQueueDepth.RedrawWindow();
 }
 
-void CPageSetup::OnRDiskSpawnCPUs() 
+void CPageSetup::OnRDiskSpawnCPUs()
 {
-	m_EDiskWorkerCount.EnableWindow( FALSE );
+	m_EDiskWorkerCount.EnableWindow(FALSE);
 	disk_worker_count = -1;
 }
 
-void CPageSetup::OnRDiskSpawnUser() 
+void CPageSetup::OnRDiskSpawnUser()
 {
-	m_EDiskWorkerCount.EnableWindow( TRUE );
-	disk_worker_count = GetDlgItemInt( EDiskWorkerCount, NULL, FALSE );
+	m_EDiskWorkerCount.EnableWindow(TRUE);
+	disk_worker_count = GetDlgItemInt(EDiskWorkerCount, NULL, FALSE);
 }
 
-void CPageSetup::OnRNetSpawnCPUs() 
+void CPageSetup::OnRNetSpawnCPUs()
 {
-	m_ENetWorkerCount.EnableWindow( FALSE );
+	m_ENetWorkerCount.EnableWindow(FALSE);
 	net_worker_count = -1;
 }
 
-void CPageSetup::OnRNetSpawnUser() 
+void CPageSetup::OnRNetSpawnUser()
 {
-	m_ENetWorkerCount.EnableWindow( TRUE );
-	net_worker_count = GetDlgItemInt( ENetWorkerCount, NULL, FALSE );
+	m_ENetWorkerCount.EnableWindow(TRUE);
+	net_worker_count = GetDlgItemInt(ENetWorkerCount, NULL, FALSE);
 }

Modified: branches/IOMETER-restruct/iometer/src/PageSetup.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageSetup.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageSetup.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,14 +60,12 @@
 #ifndef	PAGESETUP_DEFINED
 #define PAGESETUP_DEFINED
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CPageSetup dialog
 
 #include "GalileoApp.h"
 #include "IOTest.h"
 
-
 enum {
 	CyclingTargets = 1,
 	CyclingWorkers,
@@ -78,102 +76,93 @@
 	CyclingQueueTargets
 };
 
-
 // Used to determine cycling step incrementing.
 enum {
 	StepLinear = 0,
 	StepExponential
 };
 
-
 // Information needed by the page to display cycling information.
-struct Cycling_Info
-{
-	BOOL		selected;	// if selected test type uses this cycling
+struct Cycling_Info {
+	BOOL selected;		// if selected test type uses this cycling
 
-	int			start;		// starting cycle value (e.g. 1)	1-100, step 10
-	int			end;		// ending cycle value (e.g. 100)
-	int			step;		// step of cycle value (e.g. 10)
-	int			step_type;	// indicates linear or exponential stepping
+	int start;		// starting cycle value (e.g. 1)        1-100, step 10
+	int end;		// ending cycle value (e.g. 100)
+	int step;		// step of cycle value (e.g. 10)
+	int step_type;		// indicates linear or exponential stepping
 
-	int			step_text;	// ID of text describing stepping option
+	int step_text;		// ID of text describing stepping option
 
-	CEdit		start_box;	// GUI edit boxes for above values
-	CEdit		end_box;
-	CEdit		step_box;
+	CEdit start_box;	// GUI edit boxes for above values
+	CEdit end_box;
+	CEdit step_box;
 
-	CComboBox	step_sel_box;	// drop down list of stepping options
+	CComboBox step_sel_box;	// drop down list of stepping options
 };
 
-
-
-class CPageSetup : public CPropertyPage
-{
+class CPageSetup:public CPropertyPage {
 	DECLARE_DYNCREATE(CPageSetup)
-
 // Construction
-public:
+      public:
 	CPageSetup();
 	~CPageSetup();
 
-	void	EnableWindow( BOOL enable );	// enable or disable the display
+	void EnableWindow(BOOL enable);	// enable or disable the display
 
 	// Functions that take data from the display and put it in a variable,
 	// or take the data from a variable and display it.
-	void	UpdateData( BOOL save_from_window = TRUE );	// Updates to or from the display.
-	void	CheckData( UINT item_id, int* var, BOOL no_zero = FALSE );	// Updates a value given text, and 
-																		// makes sure it is not 0 if 
-																		// no_zero is TRUE.
-	void	Killfocus( int edit_ID, int* value );		// Reverts to the previous value if left blank.
+	void UpdateData(BOOL save_from_window = TRUE);	// Updates to or from the display.
+	void CheckData(UINT item_id, int *var, BOOL no_zero = FALSE);	// Updates a value given text, and 
+	// makes sure it is not 0 if 
+	// no_zero is TRUE.
+	void Killfocus(int edit_ID, int *value);	// Reverts to the previous value if left blank.
 
+	int GetRunTime();	// Converts the run time from hh:mm:ss to seconds.
+	void SaveResults(ostream * file);	// Saves the setup data to the result file.     
+	BOOL SaveConfig(ostream & outfile);	// Save test setup to a file.
+	BOOL LoadConfig(const CString & infilename);	// Load test setup from a file.
 
-	int		GetRunTime();								// Converts the run time from hh:mm:ss to seconds.
-	void	SaveResults( ostream* file );				// Saves the setup data to the result file.	
-	BOOL	SaveConfig( ostream& outfile );		// Save test setup to a file.
-	BOOL	LoadConfig( const CString& infilename );		// Load test setup from a file.
+	int minutes;		// Test run length.
+	int seconds;		// Test run length.
+	int hours;		// Test run length.
+	int ramp_time;		// Time from when all the workers are running to when recording starts.
+	CString test_name;	// Text field for entering a test description.
+	int disk_worker_count;	// Number of disk workers to spawn for every new manager.
+	int net_worker_count;	// Number of network workers to spawn for every new manager.
+	int test_type;		// Identifies whether to cycle or not.
 
-	int		minutes;		// Test run length.
-	int		seconds;		// Test run length.
-	int		hours;			// Test run length.
-	int		ramp_time;		// Time from when all the workers are running to when recording starts.
-	CString	test_name;		// Text field for entering a test description.
-	int		disk_worker_count;	// Number of disk workers to spawn for every new manager.
-	int		net_worker_count;	// Number of network workers to spawn for every new manager.
-	int		test_type;		// Identifies whether to cycle or not.
+	Cycling_Info worker_cycling;
+	Cycling_Info target_cycling;
+	Cycling_Info queue_cycling;
 
-	Cycling_Info	worker_cycling;
-	Cycling_Info	target_cycling;
-	Cycling_Info	queue_cycling;
+	int result_type;
 
-	int		result_type;
-
 // Dialog Data
 	//{{AFX_DATA(CPageSetup)
 	enum { IDD = IDD_SETUP };
-	CComboBox	m_CResultType;
-	CEdit	m_EDiskWorkerCount;
-	CEdit	m_ENetWorkerCount;
-	CEdit	m_ETestName;
-	CEdit	m_ERunTimeSeconds;
-	CEdit	m_ERunTimeMinutes;
-	CEdit	m_ERunTimeHours;
-	CEdit	m_ERampTime;
-	CComboBox	m_CTestType;
+	CComboBox m_CResultType;
+	CEdit m_EDiskWorkerCount;
+	CEdit m_ENetWorkerCount;
+	CEdit m_ETestName;
+	CEdit m_ERunTimeSeconds;
+	CEdit m_ERunTimeMinutes;
+	CEdit m_ERunTimeHours;
+	CEdit m_ERampTime;
+	CComboBox m_CTestType;
 	//}}AFX_DATA
 
-
 // Overrides
 	// ClassWizard generate virtual function overrides
 	//{{AFX_VIRTUAL(CPageSetup)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 	// Generated message map functions
 	//{{AFX_MSG(CPageSetup)
-	virtual BOOL OnInitDialog();
+	 virtual BOOL OnInitDialog();
 	afx_msg void OnChangeEDiskWorkerCount();
 	afx_msg void OnChangeENetWorkerCount();
 	afx_msg void OnSelchangeCDStepType();
@@ -199,18 +188,16 @@
 	afx_msg void OnRNetSpawnCPUs();
 	afx_msg void OnRNetSpawnUser();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
-	void SetStepTypeLabel( int text_id, int step_type );
+	 DECLARE_MESSAGE_MAP()
+	void SetStepTypeLabel(int text_id, int step_type);
 
-private:
+      private:
 
 	// Update cycling values.
-	void	SetCyclingInfo( Cycling_Info *cycle_info, BOOL selected, 
-				int start, int end, int step, int cycle_type);
+	void SetCyclingInfo(Cycling_Info * cycle_info, BOOL selected, int start, int end, int step, int cycle_type);
 
 	// Enable/Disable cycling information.
-	void	EnableCyclingInfo( Cycling_Info *cycling_info, BOOL enable );
+	void EnableCyclingInfo(Cycling_Info * cycling_info, BOOL enable);
 };
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/PageTarget.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/PageTarget.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/PageTarget.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -58,7 +58,6 @@
 #ifndef PAGETARGET_DEFINED
 #define PAGETARGET_DEFINED
 
-
 // indexes for selection updates to make recursive updates easier to do
 // for the manager list up through the workers.
 #define TARGETS			0
@@ -71,7 +70,7 @@
 
 // Info for Targets image list
 #define TARGET_ICON_SIZE	16
-#define TARGET_ICON_EXPAND	10 // number of icons to add to ImageList when expanding
+#define TARGET_ICON_EXPAND	10	// number of icons to add to ImageList when expanding
 #define TARGET_ICON_BGCOLOR	0x00ffffff
 
 // Icons for Targets pane (position of icon in bitmap)
@@ -89,11 +88,10 @@
 // Inverse of INDEXTOSTATEIMAGEMASK(). (Windows doesn't define this, but it should...)
 #define STATEIMAGEMASKTOINDEX(i) ((i) >> 12)
 
-enum TargetSelType
-{
+enum TargetSelType {
 	TargetUnChecked = TARGET_STATE_UNCHECKED,
-	TargetChecked   = TARGET_STATE_CHECKED,
-	TargetGrayed    = TARGET_STATE_UNKNOWN,
+	TargetChecked = TARGET_STATE_CHECKED,
+	TargetGrayed = TARGET_STATE_UNKNOWN,
 };
 
 #endif

Modified: branches/IOMETER-restruct/iometer/src/Pulsar.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/Pulsar.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/Pulsar.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -131,28 +131,26 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOCommon.h"
 #include "IOManager.h"
 
-
 #if defined(IOMTR_OSFAMILY_UNIX)
- #include <sys/resource.h>
- #include <ctype.h>
- #if defined(IOMTR_OS_SOLARIS)
-  #include <synch.h>
- #elif defined(IOMTR_OS_LINUX)
-  int kstatfd;
-  int procstatstyle = PROCSTATUNKNOWN;  
- #elif defined(IOMTR_OS_OSX)
+#include <sys/resource.h>
+#include <ctype.h>
+#if defined(IOMTR_OS_SOLARIS)
+#include <synch.h>
+#elif defined(IOMTR_OS_LINUX)
+int kstatfd;
+int procstatstyle = PROCSTATUNKNOWN;
+#elif defined(IOMTR_OS_OSX)
   // nop
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
+#endif
 
 #if defined(IOMTR_OS_NETWARE)
- #include <ctype.h>
+#include <ctype.h>
 #endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
@@ -171,9 +169,10 @@
 /////////////////////////////////////////////////////////////////////////////
 // Forward declarations
 /////////////////////////////////////////////////////////////////////////////
-static void Syntax( const char* errmsg = NULL );
+static void Syntax(const char *errmsg = NULL);
 
 static void ParseParam(int argc, char *argv[], struct dynamo_param *param);
+
 /////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////
 
@@ -184,10 +183,11 @@
 int InitIoctlInterface(void)
 {
 	int res;
-        res = open("/dev/iomtr_kstat", O_RDONLY);
+
+	res = open("/dev/iomtr_kstat", O_RDONLY);
 	if (res < 0)
 		cerr << "Fail to open kstat device file. You can ignore this warning" << endl;
-		cerr << "unless you are running dynamo on XSCALE CPU." << endl;
+	cerr << "unless you are running dynamo on XSCALE CPU." << endl;
 	return res;
 }
 
@@ -226,7 +226,7 @@
 int InitCCNTInterface(void)
 {
 	int res;
-	
+
 	res = open("/dev/ccnt", O_RDONLY);
 	if (res < 0) {
 		cerr << "Fail to find CCNT interface." << endl;
@@ -242,16 +242,14 @@
 		close(fd);
 }
 
-#endif // IOMTR_CPU_XSCALE
-#endif // IOMTR_OS_LINUX
+#endif				// IOMTR_CPU_XSCALE
+#endif				// IOMTR_OS_LINUX
 
-
-
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 int check_dev(char *devname)
 {
 	struct stat buf;
-	
+
 	if (strlen(devname) >= MAX_NAME) {
 		return -1;
 	}
@@ -264,21 +262,21 @@
 	return 0;
 }
 #elif defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	// nop	
+	// nop  
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 #if defined(IOMTR_SETTING_CPU_AFFINITY)
 static int iomtr_set_cpu_affinity(unsigned long affinity_mask)
 {
 	int res = -1;
-	
+
 #if defined(IOMTR_OS_LINUX)
 	cpu_set_t s;
 	int i, j;
 	unsigned long t = 1;
-	
+
 	if (!affinity_mask) {
 		affinity_mask = 1;
 	}
@@ -286,7 +284,7 @@
 	if (i > CPU_SETSIZE) {
 		i = CPU_SETSIZE;
 	}
-	CPU_ZERO (&s);
+	CPU_ZERO(&s);
 	for (j = 0; j < i; j++)
 		if ((t << j) & affinity_mask) {
 			CPU_SET(j, &s);
@@ -313,7 +311,6 @@
 	if (!affinity_mask) {
 		affinity_mask = 1;
 	}
-
 	// not &affinity_mask, MSDN API Doc error.
 	res = SetProcessAffinityMask(GetCurrentProcess(), affinity_mask);
 	if (!res) {
@@ -323,9 +320,9 @@
 		res = SetProcessAffinityMask(GetCurrentProcess(), 1);
 	}
 #elif defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_SOLARIS)
-	// nop	
+	// nop  
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	return res;
 }
@@ -342,10 +339,10 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-int CDECL main( int argc, char *argv[] )
+int CDECL main(int argc, char *argv[])
 {
-	Manager	manager;
-	char	iometer[MAX_NETWORK_NAME];
+	Manager manager;
+	char iometer[MAX_NETWORK_NAME];
 	struct dynamo_param param;
 
 #if defined(IOMTR_OS_LINUX)
@@ -368,19 +365,19 @@
 #endif
 #endif
 
-	iometer[0]                 = 0;
-	manager.manager_name[0]    = 0;
+	iometer[0] = 0;
+	manager.manager_name[0] = 0;
 	manager.exclude_filesys[0] = 0;
 
 	//provide a temporary global ptr to the version string for Syntax() to use
 	g_pVersionStringWithDebug = manager.GetVersionString(TRUE);
-	
-	param.iometer 		    = iometer;
-	param.manager_name 	    = manager.manager_name;
+
+	param.iometer = iometer;
+	param.manager_name = manager.manager_name;
 	param.manager_computer_name = manager.prt->network_name;
-	param.manager_exclude_fs    = manager.exclude_filesys;
-	param.blkdevlist 	    = &manager.blkdevlist;
-	
+	param.manager_exclude_fs = manager.exclude_filesys;
+	param.blkdevlist = &manager.blkdevlist;
+
 	ParseParam(argc, argv, &param);
 
 	g_pVersionStringWithDebug = NULL;	//should use manager object after this...
@@ -388,136 +385,117 @@
 	iomtr_set_cpu_affinity(param.cpu_affinity);
 
 	// If there were command line parameters, indicate that they were recognized.
-	if ( iometer[0] || manager.manager_name[0] )
-	{
+	if (iometer[0] || manager.manager_name[0]) {
 		cout << "\nCommand line parameter(s):" << endl;
 
-		if ( iometer[0] ) {
+		if (iometer[0]) {
 			cout << "   Looking for Iometer on \"" << iometer << "\"" << endl;
 		}
-		if ( manager.manager_name[0] ) {
+		if (manager.manager_name[0]) {
 			cout << "   New manager name is \"" << manager.manager_name << "\"" << endl;
 		}
 	}
-	if ( manager.exclude_filesys[0] )
-        {
-      		cout << "\nExcluding the following filesystem types:" << endl;
-        	cout << "   \"" << manager.exclude_filesys << "\"" << endl;
-        }
-        else
-        {
-        	strcpy(manager.exclude_filesys, DEFAULT_EXCLUDE_FILESYS);
-        }
+	if (manager.exclude_filesys[0]) {
+		cout << "\nExcluding the following filesystem types:" << endl;
+		cout << "   \"" << manager.exclude_filesys << "\"" << endl;
+	} else {
+		strcpy(manager.exclude_filesys, DEFAULT_EXCLUDE_FILESYS);
+	}
 	cout << endl;
 
 #if defined(IOMTR_OSFAMILY_UNIX)
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX)
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX)
 	signal(SIGALRM, SIG_IGN);
- #elif defined(IOMTR_OS_SOLARIS)
+#elif defined(IOMTR_OS_SOLARIS)
 	sigignore(SIGALRM);
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif 
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 
 	// Initialize the lock on UNIX platforms.
-	if (pthread_mutex_init(&lock_mt, NULL))
-	{
-		cout <<"unable to init the lock" << endl;
+	if (pthread_mutex_init(&lock_mt, NULL)) {
+		cout << "unable to init the lock" << endl;
 		exit(1);
 	}
-
 	// Block SIGPIPE signal. Needed to ensure that Network worker
 	// threads don't exit due to a broken pipe signal.
 	sigset_t sigset;
+
 	sigemptyset(&sigset);
 	sigaddset(&sigset, SIGPIPE);
-	if (sigprocmask(SIG_BLOCK, &sigset, NULL) < 0)
-	{
+	if (sigprocmask(SIG_BLOCK, &sigset, NULL) < 0) {
 		cout << "sigprocmask() call failed." << endl;
 		cout << "dynamo could be unstable" << endl;
 	}
-
 	//
 	// the number of file descriptors a process may create can be a small value like 64.
 	//
 	struct rlimit rlimitp;
-	if (getrlimit(RLIMIT_NOFILE, &rlimitp) < 0)
-	{
+
+	if (getrlimit(RLIMIT_NOFILE, &rlimitp) < 0) {
 		cout << "error " << errno << " trying to get rlimit (# file descriptors)" << endl;
-	}
-	else
-	{
+	} else {
 		// it succeeded. We leave out atleast 25 file descriptors for non-targets
 		// and compare with the hard limit.
 		unsigned int targets = MAX_TARGETS + 25;
-		if ( rlimitp.rlim_max < targets )
-		{
+
+		if (rlimitp.rlim_max < targets) {
 			cout << "Only " << rlimitp.rlim_max << " file descriptors available" << endl;
 			rlimitp.rlim_cur = rlimitp.rlim_max;
-		}
-		else
-		{
+		} else {
 			// set the soft limit to the required value.
 			rlimitp.rlim_cur = targets;
 		}
-		if (setrlimit(RLIMIT_NOFILE, &rlimitp) < 0)
-		{
+		if (setrlimit(RLIMIT_NOFILE, &rlimitp) < 0) {
 			cout << "error " << errno << " trying to set rlimit (# file descriptors)" << endl;
 		}
 	}
 
 	// Check for super-user permissions. If not super-user, we
 	// cannot get many of the info from the kernel.
-	if (getuid() || geteuid())
-	{
+	if (getuid() || geteuid()) {
 		cout << "Dynamo not running as super-user." << endl;
 		cout << "       All available disks might not be reported " << endl;
 		cout << "       Cannot get TCP statistics from the kernel " << endl;
 	}
-
 #ifdef IOMTR_SETTING_OVERRIDE_FS
 	// No command line args specifies destructive testing. Check to see if there
 	// are any environment variables specifying the same. We need to warn the user.
-	if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL)
-	{
+	if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
 		cout << "       ************ WARNING **************" << endl;
 		cout << "       dynamo running in Destructive mode." << endl;
-		cout << "         (overriding the not mounted fs)"   << endl;		
+		cout << "         (overriding the not mounted fs)" << endl;
 		cout << "       ************ WARNING **************" << endl;
 	}
-#endif // IOMTR_SETTING_OVERRIDE_FS
-#endif // IOMTR_OSFAMILY_UNIX
+#endif				// IOMTR_SETTING_OVERRIDE_FS
+#endif				// IOMTR_OSFAMILY_UNIX
 #if defined(IOMTR_OSFAMILY_NETWARE)
 	// Initialize the lock on NetWare platforms.
-	if (pthread_mutex_init(&lock_mt, NULL))
-	{
-		cout <<"unable to init the lock" << endl;
+	if (pthread_mutex_init(&lock_mt, NULL)) {
+		cout << "unable to init the lock" << endl;
 		exit(1);
 	}
 #endif
 
 	// Ensure, that the endian type of the CPU is detectable
-	if ( (IsBigEndian() != 0) && (IsBigEndian() != 1) )
-	{
+	if ((IsBigEndian() != 0) && (IsBigEndian() != 1)) {
 		cout << "===> ERROR: Endian type of the CPU couldn't be detected." << endl;
 		cout << "     [main() in " << __FILE__ << " line " << __LINE__ << "]" << endl;
 		exit(1);
 	}
-
 	// Entering infinite loop to allow Dynamo to run multiple tests.  Outer while loop allows
 	// Dynamo to be reset from Iometer.  If everything works smoothly, resets should be rare.
-	while (TRUE)
-	{
+	while (TRUE) {
 		// Initializing worker and logging into Iometer director.
-		if ( !manager.Login( iometer ) )
+		if (!manager.Login(iometer))
 			break;
 
 		// Manager will continue to run until an error, or stopped by Iometer.
-		if ( !manager.Run() )
-			break;		// Stop running when the manager is done.
+		if (!manager.Run())
+			break;	// Stop running when the manager is done.
 	}
 	cout << "Ending execution." << endl;
-	Sleep( 1000 );
+	Sleep(1000);
 
 #if defined(IOMTR_OS_LINUX)
 	CleanupIoctlInterface(kstatfd);
@@ -525,23 +503,19 @@
 	CleanupCCNTInterface(ccntfd);
 #endif
 #endif
-	return(0);
+	return (0);
 }
 
-
-
 /* ######################################################################### */
 /* ##                                                                     ## */
 /* ##   S Y N T A X ( )                                                   ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-void Syntax( const char* errmsg /*=NULL*/ )
+void Syntax(const char *errmsg /*=NULL*/ )
 {
-	if ( errmsg )
-	{
-		cout << endl
-			 << "*** Error processing the command line." << endl;
+	if (errmsg) {
+		cout << endl << "*** Error processing the command line." << endl;
 		cout << "*** " << errmsg << endl;
 	}
 
@@ -550,7 +524,7 @@
 	cout << endl;
 	cout << "SYNTAX" << endl;
 	cout << endl;
-	
+
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX)
 	cout << "dynamo -?" << endl;
 #elif defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
@@ -559,7 +533,7 @@
 	// Solaris 2.7 must have the switch (? is used for its own purpose).
 	cout << "dynamo \\?" << endl;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 #if defined(IOMTR_OS_LINUX)
@@ -576,7 +550,7 @@
 	cout << "dynamo [/i iometer_computer_name /m manager_computer_name] [/n manager_name]" << endl;
 	cout << "       [/x excluded_volumes] [/c cpu_affinity]" << endl;
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 	cout << endl;
@@ -595,11 +569,11 @@
 	cout << "      This name or IP address is the one Iometer will use to communicate" << endl;
 	cout << "      with this manager. The default is the IP adress of the host's first" << endl;
 	cout << "      NIC." << endl;
-        cout << "      Make sure iometer box can ping this name successfully, otherwise dynamo" << endl;
-        cout << "      and iometer will hang a long time during login." << endl;
+	cout << "      Make sure iometer box can ping this name successfully, otherwise dynamo" << endl;
+	cout << "      and iometer will hang a long time during login." << endl;
 	cout << endl;
 
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	cout << "   excluded_fs_type - type of filesystems to exclude from device search" << endl;
 	cout << "      This string should contain the filesystem types that are not reported" << endl;
 	cout << "      to Iometer. The default is \"" << DEFAULT_EXCLUDE_FILESYS << "\"." << endl;
@@ -613,31 +587,29 @@
 	cout << "      You MUST use absolute path for device name here." << endl;
 	cout << endl;
 	cout << "   -l - to record events in syslog, default is /var/log/messages." << endl;
-	cout << endl;	
- #elif defined(IOMTR_OSFAMILY_NETWARE)
+	cout << endl;
+#elif defined(IOMTR_OSFAMILY_NETWARE)
 	cout << "   excluded_volumes - volumes to exclude from volume or device search" << endl;
 	cout << "      The default is \"" << "none" << "\"." << endl;
-	cout << endl;	
- #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	// nop	
- #else
-  #warning ===> WARNING: You have to do some coding here to get the port done!
- #endif
+	cout << endl;
+#elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
+	// nop  
+#else
+#warning ===> WARNING: You have to do some coding here to get the port done!
+#endif
 
- #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
+#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	cout << "   cpu_affinity - cpu affinity is used to bind dynamo to certain processor(s)." << endl;
 	cout << "      This is used for getting a more consistent timing value. For example, if" << endl;
 	cout << "      you want to bind to the third cpu, you should have value 4(00000100) here." << endl;
 	cout << "      If this parameter is not specified, dynamo will bind to the first CPU" << endl;
 	cout << "      in system by default." << endl;
 	cout << endl;
- #endif
- 
-	exit( 0 );
+#endif
+
+	exit(0);
 }
 
-
-
 /* ######################################################################### */
 /* ##                                                                     ## */
 /* ##   P A R S E P A R A M ( )                                           ## */
@@ -646,162 +618,158 @@
 static void ParseParam(int argc, char *argv[], struct dynamo_param *param)
 {
 	// Local variables
-	
+
 	char cSwitchKey;
-	
+
 	BOOL bParamIometer = FALSE;
-	BOOL bParamDynamo  = FALSE;
+	BOOL bParamDynamo = FALSE;
 	int count = 0;
 	ifstream devfile;
 
 	// Walk through the parameter list
 
-	for( int I = 1; I < argc; I++ ) {
+	for (int I = 1; I < argc; I++) {
 
 		// See if the user is requesting syntax help.
-		
-		if ( ( argv[I][0] == '?' ) || ( argv[I][1] == '?' ) ) {
+
+		if ((argv[I][0] == '?') || (argv[I][1] == '?')) {
 			Syntax();
 			return;
 		}
-
 		// Ensure that the each parameter has a leading switch
-		
-		if ( ( argv[I][0] != '-' ) && ( argv[I][0] != '/' ) ) {
-			Syntax( "Exactly one letter must follow a switch character.\n"
-				"Switch characters are \"-\" and \"/\"." );
-			return;			
+
+		if ((argv[I][0] != '-') && (argv[I][0] != '/')) {
+			Syntax("Exactly one letter must follow a switch character.\n"
+			       "Switch characters are \"-\" and \"/\".");
+			return;
 		}
 
-		if ( strlen( argv[I] ) != 2 ) {
-			Syntax( "Exactly one letter must follow a switch character.\n"
-				"Switch characters are \"-\" and \"/\"." );
-			return;			
+		if (strlen(argv[I]) != 2) {
+			Syntax("Exactly one letter must follow a switch character.\n"
+			       "Switch characters are \"-\" and \"/\".");
+			return;
 		}
-		
 		// Ensure that each parameter has a value following the switch
-		
-		if( ( I + 1 ) >= argc ) {
+
+		if ((I + 1) >= argc) {
 			Syntax("An additional parameter was expected after the last switch.");
 			return;
 		}
-
 		// Process the parameters based on the switch
 
-		cSwitchKey = toupper( argv[I][1] );
+		cSwitchKey = toupper(argv[I][1]);
 		I++;
-		
-		switch( cSwitchKey ) {
-			case 'I':
-				if ( bParamIometer == TRUE ) {
-					Syntax("Iometer address was specified more than once.");
-					return;
-				}
-				if ( strlen( argv[I] ) >= MAX_NETWORK_NAME ) {
-					Syntax("Iometer address parameter was too long.");
-					return;
-				}
-				strcpy( param->iometer, argv[I] );
-				bParamIometer = TRUE;
-				break;
-			case 'M':
-				// No check for more then once specification (as we have a default)
-				if ( strlen( argv[I] ) >= MAX_NETWORK_NAME ) {
-					Syntax("Manager network name parameter was too long.");
-					return;
-				}
-				strcpy( param->manager_computer_name, argv[I] );
-				bParamDynamo = TRUE;
-				break;
-			case 'N':
-				if ( param->manager_name[0] != '\0' ) {
-					Syntax("Manager name was specified more than once.");
-					return;
-				}
-				if ( strlen( argv[I] ) >= MAX_WORKER_NAME ) {
-					Syntax("Manager name parameter was too long.");
-					return;
-				}
-				strcpy( param->manager_name, argv[I] );
-				break;
+
+		switch (cSwitchKey) {
+		case 'I':
+			if (bParamIometer == TRUE) {
+				Syntax("Iometer address was specified more than once.");
+				return;
+			}
+			if (strlen(argv[I]) >= MAX_NETWORK_NAME) {
+				Syntax("Iometer address parameter was too long.");
+				return;
+			}
+			strcpy(param->iometer, argv[I]);
+			bParamIometer = TRUE;
+			break;
+		case 'M':
+			// No check for more then once specification (as we have a default)
+			if (strlen(argv[I]) >= MAX_NETWORK_NAME) {
+				Syntax("Manager network name parameter was too long.");
+				return;
+			}
+			strcpy(param->manager_computer_name, argv[I]);
+			bParamDynamo = TRUE;
+			break;
+		case 'N':
+			if (param->manager_name[0] != '\0') {
+				Syntax("Manager name was specified more than once.");
+				return;
+			}
+			if (strlen(argv[I]) >= MAX_WORKER_NAME) {
+				Syntax("Manager name parameter was too long.");
+				return;
+			}
+			strcpy(param->manager_name, argv[I]);
+			break;
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-			case 'X':
-				if ( ( strlen( argv[I] ) + strlen( param->manager_exclude_fs ) ) >= MAX_EXCLUDE_FILESYS ) {
-					Syntax("Excluded filesystem list too long.");
-					return;
-				}
-				strcat( param->manager_exclude_fs, argv[I] );
-        			strcat( param->manager_exclude_fs, " " );
-				break;
+		case 'X':
+			if ((strlen(argv[I]) + strlen(param->manager_exclude_fs)) >= MAX_EXCLUDE_FILESYS) {
+				Syntax("Excluded filesystem list too long.");
+				return;
+			}
+			strcat(param->manager_exclude_fs, argv[I]);
+			strcat(param->manager_exclude_fs, " ");
+			break;
 #endif
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-			case 'D':
-				if (check_dev(argv[I])) {
-					Syntax("Not a valid device.");
-					return;
-				}
+		case 'D':
+			if (check_dev(argv[I])) {
+				Syntax("Not a valid device.");
+				return;
+			}
+			if (count < MAX_TARGETS) {
+				strcpy((*param->blkdevlist)[count++], argv[I]);
+			} else {
+				cout << "Too many targets you want to test, skip " << argv[I] << endl;
+			}
+			break;
+		case 'F':
+			char devname[MAX_NAME];
+
+			devfile.open(argv[I]);
+			if (!devfile.is_open()) {
+				Syntax("Can not open device file list.");
+				return;
+			}
+			while (!devfile.eof()) {
+				memset(devname, 0, MAX_NAME);
+				devfile.getline(devname, MAX_NAME - 1);
+				if (check_dev(devname))
+					continue;
 				if (count < MAX_TARGETS) {
-					strcpy((*param->blkdevlist)[count++], argv[I]);
+					strcpy((*param->blkdevlist)[count++], devname);
+				} else {
+					cout << "Too many targets you want to test, skip " << devname << endl;
 				}
-				else {
-					cout << "Too many targets you want to test, skip " << argv[I] << endl;
-				}
-				break;
-			case 'F':
-				char devname[MAX_NAME];
-				
-				devfile.open(argv[I]);
-				if (!devfile.is_open()) { 
-					Syntax("Can not open device file list.");
-					return;
-				}
-				while (!devfile.eof()) {
-					memset(devname, 0, MAX_NAME);
-					devfile.getline(devname, MAX_NAME - 1);
-					if (check_dev(devname))
-						continue;
-					if (count < MAX_TARGETS) {
-						strcpy((*param->blkdevlist)[count++], devname);
-					}
-					else {
-						cout << "Too many targets you want to test, skip " << devname << endl;
-					}					
-				}
-				break;
-			case 'L':
-				do_syslog = TRUE;
-				openlog(NEW_WORKER_EXECUTABLE, 0, LOG_USER);
-				break;
+			}
+			break;
+		case 'L':
+			do_syslog = TRUE;
+			openlog(NEW_WORKER_EXECUTABLE, 0, LOG_USER);
+			break;
 #endif
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-			case 'C':
-				if (argv[I])
-					param->cpu_affinity = (unsigned long)atol(argv[I]);
-				break;
+		case 'C':
+			if (argv[I])
+				param->cpu_affinity = (unsigned long)atol(argv[I]);
+			break;
 #endif
-			default:
-				{
-					char tmpary[2] = { cSwitchKey, 0 };
+		default:
+			{
+				char tmpary[2] = { cSwitchKey, 0 };
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-					char temp_array[128];
-					strcpy(temp_array, "Unrecognized switch: ");
-					strcat(temp_array, tmpary);
-					strcat(temp_array, ".");
-					Syntax(temp_array);
+				char temp_array[128];
+
+				strcpy(temp_array, "Unrecognized switch: ");
+				strcat(temp_array, tmpary);
+				strcat(temp_array, ".");
+				Syntax(temp_array);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-					Syntax("Unrecognized switch: " + (CString)tmpary + ".");
+				Syntax("Unrecognized switch: " + (CString) tmpary + ".");
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-				}
-				break;
+			}
+			break;
 		}
 	}
 
 	// Enforce switch combinations
-	if( bParamIometer && !bParamDynamo ) {
-		Syntax( "When specifying the Iometer address, the Manager network name parameter is mandatory." );
+	if (bParamIometer && !bParamDynamo) {
+		Syntax("When specifying the Iometer address, the Manager network name parameter is mandatory.");
 	}
-	
+
 	return;
 }

Modified: branches/IOMETER-restruct/iometer/src/StdAfx.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/StdAfx.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/StdAfx.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -58,9 +58,4 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
-
-
-
-

Modified: branches/IOMETER-restruct/iometer/src/StdAfx.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/StdAfx.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/StdAfx.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -58,16 +58,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
 
-#include <afxwin.h>         // MFC core and standard components
+#include <afxwin.h>		// MFC core and standard components
 //#include <afxext.h>         // MFC extensions
 #ifndef _AFX_NO_AFXCMN_SUPPORT
-#include <afxcmn.h>			// MFC support for Windows Common Controls
-#endif // _AFX_NO_AFXCMN_SUPPORT
+#include <afxcmn.h>		// MFC support for Windows Common Controls
+#endif				// _AFX_NO_AFXCMN_SUPPORT
 //#include <afxtempl.h>
-
-
-
-

Modified: branches/IOMETER-restruct/iometer/src/TextDisplay.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/TextDisplay.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/TextDisplay.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,11 +61,9 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "TextDisplay.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -76,32 +74,26 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
+IMPLEMENT_DYNAMIC(CTextDisplay, CWnd)
 
-IMPLEMENT_DYNAMIC( CTextDisplay, CWnd )
-
-
 // Message mapping
-BEGIN_MESSAGE_MAP(CTextDisplay, CWnd)
-	//{{AFX_MSG_MAP(CTextDisplay)
-	ON_WM_PAINT()
-	ON_WM_CREATE()
-	//}}AFX_MSG_MAP
-END_MESSAGE_MAP()
+    BEGIN_MESSAGE_MAP(CTextDisplay, CWnd)
+    //{{AFX_MSG_MAP(CTextDisplay)
+    ON_WM_PAINT()
+    ON_WM_CREATE()
+    //}}AFX_MSG_MAP
+    END_MESSAGE_MAP()
 
-
-
 // Static member initialization
 BOOL CTextDisplay::registered = Register();
 
-
-
 //
 // Initialize class member variables.
 //
@@ -110,25 +102,23 @@
 	text = "";
 }
 
-
-
 //
 // Handles WM_CREATE message (Window is being created)
 //
-int CTextDisplay::OnCreate( LPCREATESTRUCT lpCreateStruct )
+int CTextDisplay::OnCreate(LPCREATESTRUCT lpCreateStruct)
 {
 	// Create the window.
-	VERIFY( CWnd::OnCreate( lpCreateStruct ) == 0 );
+	VERIFY(CWnd::OnCreate(lpCreateStruct) == 0);
 
 	// Store where the text box (rectangle) was placed.
-	GetClientRect( &text_box );
+	GetClientRect(&text_box);
 	text_alignment = TA_LEFT;
 	text_position = text_box.left;
 
 	// Initialize default font settings.
-	memset( &font_settings, 0, sizeof( LOGFONT ) );
+	memset(&font_settings, 0, sizeof(LOGFONT));
 	font_settings.lfCharSet = ANSI_CHARSET;
-    font_settings.lfOutPrecision = OUT_TT_PRECIS;
+	font_settings.lfOutPrecision = OUT_TT_PRECIS;
 	font_settings.lfClipPrecision = CLIP_DEFAULT_PRECIS;
 	font_settings.lfQuality = DEFAULT_QUALITY;
 	font_settings.lfPitchAndFamily = DEFAULT_PITCH;
@@ -136,8 +126,6 @@
 	return 0;
 }
 
-
-
 //
 // Removes used memory.  Called after response to WM_NCDESTROY
 //
@@ -146,8 +134,6 @@
 	delete this;
 }
 
-
-
 //
 // Registers the class with windows
 //
@@ -156,21 +142,18 @@
 	WNDCLASS wc;
 
 	// See if the class has already been registered.
-	if ( GetClassInfo( NULL, "CTextDisplay", &wc ) )
-	{
+	if (GetClassInfo(NULL, "CTextDisplay", &wc)) {
 		// Name already registered - ok if it was us
-		return ( wc.lpfnWndProc == (WNDPROC)TextDisplayWndProc );
+		return (wc.lpfnWndProc == (WNDPROC) TextDisplayWndProc);
 	}
-
 	// Register the window class of the control.
-	wc.style = CS_GLOBALCLASS | CS_OWNDC | CS_BYTEALIGNCLIENT |
-		CS_BYTEALIGNWINDOW;
+	wc.style = CS_GLOBALCLASS | CS_OWNDC | CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW;
 	wc.lpfnWndProc = CTextDisplay::TextDisplayWndProc;
 	wc.cbClsExtra = 0;
 	wc.cbWndExtra = 0;
 	wc.hInstance = NULL;
 	wc.hIcon = NULL;
-	wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
+	wc.hCursor =::LoadCursor(NULL, IDC_ARROW);
 	wc.hbrBackground = (HBRUSH) COLOR_WINDOW;
 	wc.lpszMenuName = NULL;
 	wc.lpszClassName = "CTextDisplay";
@@ -178,147 +161,125 @@
 	return RegisterClass(&wc);
 }
 
-
-
 //
 // Window procedure for the "CTextDisplay" window class.  This global function
 // handles the creation of new CTextDisplay objects and subclasses the 
 // objects so the MFC framework passes messages along to the CTextDisplay 
 // member functions.
 //
-LRESULT CALLBACK EXPORT CTextDisplay::TextDisplayWndProc( HWND hWnd, 
-	UINT message, WPARAM wParam, LPARAM lParam)
+LRESULT CALLBACK EXPORT CTextDisplay::TextDisplayWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
 {
-	AFX_MANAGE_STATE( AfxGetStaticModuleState() );
+	AFX_MANAGE_STATE(AfxGetStaticModuleState());
 
-	CWnd	*pWnd;
+	CWnd *pWnd;
 
 	// See if we're creating the window.
-	if ( !(pWnd = CWnd::FromHandlePermanent( hWnd )) && message == WM_NCCREATE )
-	{
+	if (!(pWnd = CWnd::FromHandlePermanent(hWnd)) && message == WM_NCCREATE) {
 		// Yes, create the object.
 		pWnd = new CTextDisplay();
-		pWnd->Attach( hWnd );
+		pWnd->Attach(hWnd);
 	}
 
-	return AfxCallWndProc( pWnd, hWnd, message, wParam, lParam );
+	return AfxCallWndProc(pWnd, hWnd, message, wParam, lParam);
 }
 
-
-
 //
 // Handles WM_PAINT message.  Displays the text in the custom control according
 // to the pre-specified font settings.
 //
 void CTextDisplay::OnPaint()
 {
-	CPaintDC	dc(this); // device context for painting
+	CPaintDC dc(this);	// device context for painting
 
 	// Display the text using the store text settings.
-	dc.SetTextAlign( text_alignment );
-	dc.SelectObject( &font );
-	dc.SetTextColor( text_color );
-	dc.SetBkMode( TRANSPARENT );
-	dc.TextOut( text_position, text_box.top, text );
+	dc.SetTextAlign(text_alignment);
+	dc.SelectObject(&font);
+	dc.SetTextColor(text_color);
+	dc.SetBkMode(TRANSPARENT);
+	dc.TextOut(text_position, text_box.top, text);
 }
 
-
-
-
 //
 // Initializing text display values.
 //
-void CTextDisplay::SetAll( CString *show_text, char *font_name, LONG font_size, 
-	TextAlignment alignment, BOOL bold, BOOL italic, BOOL underline,
-	COLORREF color )
+void CTextDisplay::SetAll(CString * show_text, char *font_name, LONG font_size,
+			  TextAlignment alignment, BOOL bold, BOOL italic, BOOL underline, COLORREF color)
 {
 	// Update all settings for the displayed text, but do not update the
 	// window until everything has been updated.
-	SetText( show_text, FALSE );
-	SetFontType( font_name, FALSE );
-	SetFontSize( font_size, FALSE );
-	SetTextAlignment( alignment, FALSE );
-	Bold( bold, FALSE );
-	Italic( italic, FALSE );
-	Underline( underline, FALSE );
-	SetTextColor( color, FALSE );
+	SetText(show_text, FALSE);
+	SetFontType(font_name, FALSE);
+	SetFontSize(font_size, FALSE);
+	SetTextAlignment(alignment, FALSE);
+	Bold(bold, FALSE);
+	Italic(italic, FALSE);
+	Underline(underline, FALSE);
+	SetTextColor(color, FALSE);
 
 	// Update the display.
 	RedrawWindow();
 }
 
-
-
 //
 // Setting what text should be displayed.  Updating the display if needed.
 //
-void CTextDisplay::SetText( CString *show_text, BOOL refresh )
+void CTextDisplay::SetText(CString * show_text, BOOL refresh)
 {
-	if ( text == *show_text )
+	if (text == *show_text)
 		return;
 
 	text = *show_text;
 
-	if ( refresh )
+	if (refresh)
 		RedrawWindow();
 }
 
-
-
 //
 // Updating the type of font used by the text display based on the recorded
 // font settings.
 //
-void CTextDisplay::UpdateFont( BOOL refresh )
+void CTextDisplay::UpdateFont(BOOL refresh)
 {
 	font.DeleteObject();
-	font.CreateFontIndirect( &font_settings );
-	SetFont( &font );
+	font.CreateFontIndirect(&font_settings);
+	SetFont(&font);
 
-	if ( refresh )
+	if (refresh)
 		RedrawWindow();
 }
 
-
-
 //
 // Setting the text's font.
 //
-void CTextDisplay::SetFontType( char *font_name, BOOL refresh )
+void CTextDisplay::SetFontType(char *font_name, BOOL refresh)
 {
-	strcpy( font_settings.lfFaceName, font_name );
+	strcpy(font_settings.lfFaceName, font_name);
 	UpdateFont();
 }
 
-
-
 //
 // Setting the size of the text to display.
 //
-void CTextDisplay::SetFontSize( LONG size, BOOL refresh )
+void CTextDisplay::SetFontSize(LONG size, BOOL refresh)
 {
 	font_settings.lfHeight = size;
 	UpdateFont();
 }
 
-
-
-void CTextDisplay::SetTextColor( COLORREF color, BOOL refresh )
+void CTextDisplay::SetTextColor(COLORREF color, BOOL refresh)
 {
 	text_color = color;
 
-	if ( refresh )
+	if (refresh)
 		RedrawWindow();
 }
 
-
-
 //
 // Setting whether the text is bold.
 //
-void CTextDisplay::Bold( BOOL enable, BOOL refresh )
+void CTextDisplay::Bold(BOOL enable, BOOL refresh)
 {
-	if ( enable )
+	if (enable)
 		font_settings.lfWeight = FW_BOLD;
 	else
 		font_settings.lfWeight = FW_NORMAL;
@@ -326,14 +287,12 @@
 	UpdateFont();
 }
 
-
-
 //
 // Setting whether the text is italic.
 //
-void CTextDisplay::Italic( BOOL enable, BOOL refresh )
+void CTextDisplay::Italic(BOOL enable, BOOL refresh)
 {
-	if ( enable )
+	if (enable)
 		font_settings.lfItalic = TRUE;
 	else
 		font_settings.lfItalic = FALSE;
@@ -341,14 +300,12 @@
 	UpdateFont();
 }
 
-
-
 //
 // Setting whether the text is underlined.
 //
-void CTextDisplay::Underline( BOOL enable, BOOL refresh )
+void CTextDisplay::Underline(BOOL enable, BOOL refresh)
 {
-	if ( enable )
+	if (enable)
 		font_settings.lfUnderline = TRUE;
 	else
 		font_settings.lfUnderline = FALSE;
@@ -356,15 +313,12 @@
 	UpdateFont();
 }
 
-
-
 //
 // Setting the text's alignment in the custom control box.
 //
-void CTextDisplay::SetTextAlignment( TextAlignment alignment, BOOL refresh )
+void CTextDisplay::SetTextAlignment(TextAlignment alignment, BOOL refresh)
 {
-	switch ( alignment )
-	{
+	switch (alignment) {
 	case AlignLeft:
 		text_alignment = TA_LEFT;
 		text_position = text_box.left;
@@ -379,6 +333,6 @@
 		break;
 	}
 
-	if ( refresh )
+	if (refresh)
 		RedrawWindow();
 }

Modified: branches/IOMETER-restruct/iometer/src/TextDisplay.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/TextDisplay.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/TextDisplay.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -59,77 +59,67 @@
 #ifndef TEXTDISPLAY_DEFINED
 #define TEXTDISPLAY_DEFINED
 
-
 #include "GalileoDefs.h"
 
-
-enum TextAlignment
-{
+enum TextAlignment {
 	AlignLeft, AlignRight, AlignCenter
 };
 
-class CTextDisplay : public CWnd
-{
-	DECLARE_DYNAMIC( CTextDisplay );
+class CTextDisplay:public CWnd {
+	DECLARE_DYNAMIC(CTextDisplay);
 
-public:
+      public:
 
 	CTextDisplay();
-	void	SetAll( CString *show_text, char *font_name, LONG font_size, 
-				TextAlignment alignment, BOOL bold, BOOL italic, 
-				BOOL underline, COLORREF color );
+	void SetAll(CString * show_text, char *font_name, LONG font_size,
+		    TextAlignment alignment, BOOL bold, BOOL italic, BOOL underline, COLORREF color);
 
-	void	SetText( CString *show_text, BOOL refresh = TRUE );
+	void SetText(CString * show_text, BOOL refresh = TRUE);
 
-	void	SetFontType( char *font_name, BOOL refresh = TRUE );
-	void	SetFontSize( LONG size, BOOL refresh = TRUE );
-	void	SetTextColor( COLORREF color, BOOL refresh = TRUE );
+	void SetFontType(char *font_name, BOOL refresh = TRUE);
+	void SetFontSize(LONG size, BOOL refresh = TRUE);
+	void SetTextColor(COLORREF color, BOOL refresh = TRUE);
 
-	void	Bold( BOOL enable = TRUE, BOOL refresh = TRUE );
-	void	Italic( BOOL enable = TRUE, BOOL refresh = TRUE );
-	void	Underline( BOOL enable = TRUE, BOOL refresh = TRUE );
+	void Bold(BOOL enable = TRUE, BOOL refresh = TRUE);
+	void Italic(BOOL enable = TRUE, BOOL refresh = TRUE);
+	void Underline(BOOL enable = TRUE, BOOL refresh = TRUE);
 
-	void	SetTextAlignment( TextAlignment alignment, BOOL refresh = TRUE );
+	void SetTextAlignment(TextAlignment alignment, BOOL refresh = TRUE);
 
-protected:
+      protected:
 	// Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CTextDisplay)
-	virtual void	PostNcDestroy();
+	 virtual void PostNcDestroy();
 	//}}AFX_VIRTUAL
 
+	CString text;
+	int text_alignment;	// left, right, center
+	int text_position;	// location of text in text box
+	COLORREF text_color;
 
-	CString		text;
-	int			text_alignment;	// left, right, center
-	int			text_position;	// location of text in text box
-	COLORREF	text_color;
+	CFont font;
+	LOGFONT font_settings;
+	void UpdateFont(BOOL refresh = TRUE);
 
-	CFont		font;
-	LOGFONT		font_settings;
-	void		UpdateFont( BOOL refresh = TRUE );
+	RECT text_box;
 
-	RECT		text_box;
-
-
 	// Used to register the custom control with windows.
-	static BOOL	registered;
-	static BOOL	Register();
+	static BOOL registered;
+	static BOOL Register();
 
-
-protected:
+      protected:
 	// Generated message map functions
 	//{{AFX_MSG(CTextDisplay)
-	afx_msg int		OnCreate( LPCREATESTRUCT lpCreateStruct );
-	afx_msg void	OnPaint();
+	 afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
+	afx_msg void OnPaint();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 
-	static LRESULT CALLBACK EXPORT 
-	TextDisplayWndProc( HWND hWnd, UINT message, WPARAM xParam, LPARAM lParam );
+	static LRESULT CALLBACK EXPORT TextDisplayWndProc(HWND hWnd, UINT message, WPARAM xParam, LPARAM lParam);
 };
 
 //{{AFX_INSERT_LOCATION}}
 // Microsoft Developer Studio will insert additional declarations immediately before the previous line.
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/VINic.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/VINic.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/VINic.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -58,65 +58,54 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
+#define VINIC_DETAILS 0		// Set to 1 for additional debugging messages.
 
-#define VINIC_DETAILS 0  // Set to 1 for additional debugging messages.
-
 #include "VINic.h"
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #include <iostream>
- using namespace std;
+#include <iostream>
+using namespace std;
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
- #include <iostream.h>
+#include <iostream.h>
 #endif
 
-
 //
 // Opening a VI NIC, recording its attributes, creating its memory protection
 // tag, and setting its memory attributes for subsequent VI connections.
 //
-BOOL VINic::Open( const char *nic_name )
+BOOL VINic::Open(const char *nic_name)
 {
 	VIP_RETURN result;
 
-	#if VINIC_DETAILS
-		cout << "Opening VI NIC " << nic_name << "." << endl;
-	#endif
+#if VINIC_DETAILS
+	cout << "Opening VI NIC " << nic_name << "." << endl;
+#endif
 
 	// Open the NIC.
-	if ( ( result = vipl.VipOpenNic( (const VIP_CHAR *)nic_name, &nic ) ) != VIP_SUCCESS )
-	{
-		#if _DEBUG
-			cout << "Unable to open VI nic " << nic_name << ": " << vipl.Error( result ) << endl;
-		#endif
+	if ((result = vipl.VipOpenNic((const VIP_CHAR *)nic_name, &nic)) != VIP_SUCCESS) {
+#if _DEBUG
+		cout << "Unable to open VI nic " << nic_name << ": " << vipl.Error(result) << endl;
+#endif
 		return FALSE;
 	}
-
 	// Record the NIC attributes.
-	if ( ( result = vipl.VipQueryNic( nic, &nic_attributes ) ) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to record attributes for VI nic " 
-			<< nic_name << ": " << vipl.Error( result ) << endl;
-		vipl.VipCloseNic( nic );
+	if ((result = vipl.VipQueryNic(nic, &nic_attributes)) != VIP_SUCCESS) {
+		cout << "*** Unable to record attributes for VI nic " << nic_name << ": " << vipl.Error(result) << endl;
+		vipl.VipCloseNic(nic);
 		return FALSE;
 	}
-
 	// Create the memory protection tag.
-	if ( ( result = vipl.VipCreatePtag( nic, &nic_mem_attributes.Ptag ) ) != VIP_SUCCESS )
-	{
-		cout << "*** Unable to create protection tag for VI nic " 
-			<< nic_name << ": " << vipl.Error( result ) << endl;
-		vipl.VipCloseNic( nic );
+	if ((result = vipl.VipCreatePtag(nic, &nic_mem_attributes.Ptag)) != VIP_SUCCESS) {
+		cout << "*** Unable to create protection tag for VI nic "
+		    << nic_name << ": " << vipl.Error(result) << endl;
+		vipl.VipCloseNic(nic);
 		return FALSE;
 	}
-
 	// Record the address for this NIC.
-	if ( !GetLocalAddress() )
-	{
-		vipl.VipCloseNic( nic );
+	if (!GetLocalAddress()) {
+		vipl.VipCloseNic(nic);
 		return FALSE;
 	}
-
 	// Set the VI NIC's memory attributes.  Disallow RDMA.
 	nic_mem_attributes.EnableRdmaRead = FALSE;
 	nic_mem_attributes.EnableRdmaWrite = FALSE;
@@ -124,8 +113,6 @@
 	return TRUE;
 }
 
-
-
 //
 // Closing the connection to the VI NIC, removing all associated memory, and
 // destroying its protection tag.
@@ -134,80 +121,71 @@
 {
 	BOOL result = TRUE;
 
-	#if VINIC_DETAILS
-		cout << "Closing VI NIC " << nic_attributes.Name << "." << endl;
-	#endif
+#if VINIC_DETAILS
+	cout << "Closing VI NIC " << nic_attributes.Name << "." << endl;
+#endif
 
 	// Destroy the Ptag.
-	if ( vipl.VipDestroyPtag( nic, nic_mem_attributes.Ptag ) != VIP_SUCCESS )
+	if (vipl.VipDestroyPtag(nic, nic_mem_attributes.Ptag) != VIP_SUCCESS)
 		result = FALSE;
-	
+
 	// Close the NIC.
-	if ( vipl.VipCloseNic( nic ) != VIP_SUCCESS )
+	if (vipl.VipCloseNic(nic) != VIP_SUCCESS)
 		result = FALSE;
 
 	return result;
 }
 
-
-
 //
 // Retrieving the network address for this VI NIC.
 //
 BOOL VINic::GetLocalAddress()
 {
-	#if VINIC_DETAILS
-		cout << "Retrieving the address for " << nic_attributes.Name <<endl;
-	#endif
+#if VINIC_DETAILS
+	cout << "Retrieving the address for " << nic_attributes.Name << endl;
+#endif
 
 	// Allocate memory for the address.  A VI network address consists of:
 	// | address length | discriminator length | address | discriminator |
-	nic_address_length = sizeof(VIP_NET_ADDRESS) + nic_attributes.NicAddressLen + 
-		nic_attributes.MaxDiscriminatorLen;
-	if ( !( nic_address = (VIP_NET_ADDRESS*)malloc(nic_address_length) ) )
-	{
+	nic_address_length = sizeof(VIP_NET_ADDRESS) + nic_attributes.NicAddressLen +
+	    nic_attributes.MaxDiscriminatorLen;
+	if (!(nic_address = (VIP_NET_ADDRESS *) malloc(nic_address_length))) {
 		cout << "*** Unable to allocate memory for VI NIC addresss." << endl;
 		return FALSE;
 	}
-
 	// Fill in the address.  Initialize the descriptor to 0.
 	nic_address->HostAddressLen = nic_attributes.NicAddressLen;
 	nic_address->DiscriminatorLen = nic_attributes.MaxDiscriminatorLen;
-	memcpy( (char*)nic_address->HostAddress, nic_attributes.LocalNicAddress,
-		nic_attributes.NicAddressLen );
-	memset( (void*)(nic_address->HostAddress + 
-		nic_attributes.NicAddressLen), 0, nic_attributes.MaxDiscriminatorLen);
+	memcpy((char *)nic_address->HostAddress, nic_attributes.LocalNicAddress, nic_attributes.NicAddressLen);
+	memset((void *)(nic_address->HostAddress +
+			nic_attributes.NicAddressLen), 0, nic_attributes.MaxDiscriminatorLen);
 
 	return TRUE;
 }
 
-
-
 //
 // Registering memory with the opened VI NIC.
 //
-BOOL VINic::RegisterMemory( void *buffer, DWORD size, VIP_MEM_HANDLE *mem )
+BOOL VINic::RegisterMemory(void *buffer, DWORD size, VIP_MEM_HANDLE * mem)
 {
-	#if VINIC_DETAILS
-		cout << "Registering memory for nic " << nic_attributes.Name << endl;
-	#endif
+#if VINIC_DETAILS
+	cout << "Registering memory for nic " << nic_attributes.Name << endl;
+#endif
 
 	// Register the memory with the VI NIC.
-	return ( vipl.VipRegisterMem( nic, buffer, size, &nic_mem_attributes, mem )
-		== VIP_SUCCESS );
+	return (vipl.VipRegisterMem(nic, buffer, size, &nic_mem_attributes, mem)
+		== VIP_SUCCESS);
 }
 
-
-
 //
 // Deregistering all memory associated with the opened VI NIC.  The memory
 // must have been registered first.
 //
-BOOL VINic::DeregisterMemory( void *buffer, VIP_MEM_HANDLE mem )
+BOOL VINic::DeregisterMemory(void *buffer, VIP_MEM_HANDLE mem)
 {
-	#if VINIC_DETAILS
-		cout << "Deregistering memory for nic " << nic_attributes.Name << endl;
-	#endif
+#if VINIC_DETAILS
+	cout << "Deregistering memory for nic " << nic_attributes.Name << endl;
+#endif
 
-	return ( vipl.VipDeregisterMem( nic, buffer, mem ) == VIP_SUCCESS );
+	return (vipl.VipDeregisterMem(nic, buffer, mem) == VIP_SUCCESS);
 }

Modified: branches/IOMETER-restruct/iometer/src/VINic.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/VINic.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/VINic.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,55 +60,45 @@
 #ifndef	VINIC_DEFINED
 #define	VINIC_DEFINED
 
-
-
 #include "IOVIPL.h"
 
+class VINic {
+      public:
 
-
-class VINic
-{
-public:
-
 	///////////////////////////////////////////////////////////////////////////
 	// Open and close the VI NIC.
 	//
-	BOOL	Open( const char *nic_name );
-	BOOL	Close();
+	BOOL Open(const char *nic_name);
+	BOOL Close();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Register memory with VI hardware for virtual to physical address
 	// translation.  The data buffer needs to be supplied to this class.
 	//
-	BOOL	RegisterMemory( void *buffer, DWORD size, VIP_MEM_HANDLE *mem );
-	BOOL	DeregisterMemory( void *buffer, VIP_MEM_HANDLE mem );
+	BOOL RegisterMemory(void *buffer, DWORD size, VIP_MEM_HANDLE * mem);
+	BOOL DeregisterMemory(void *buffer, VIP_MEM_HANDLE mem);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Attributes of the VI NIC
 	//
-	VIP_NIC_HANDLE		nic;
-	VIP_NIC_ATTRIBUTES	nic_attributes;
-	VIP_MEM_ATTRIBUTES	nic_mem_attributes;
+	VIP_NIC_HANDLE nic;
+	VIP_NIC_ATTRIBUTES nic_attributes;
+	VIP_MEM_ATTRIBUTES nic_mem_attributes;
 	//
-	VIP_NET_ADDRESS		*nic_address;
-	int					nic_address_length;
+	VIP_NET_ADDRESS *nic_address;
+	int nic_address_length;
 	//
 	///////////////////////////////////////////////////////////////////////////
-	
 
-private:
-	VIPL	vipl;		// Dynamically linked library.
+      private:
+	 VIPL vipl;		// Dynamically linked library.
 
 	// Network addresses of VI's to connect together.
-	BOOL	GetLocalAddress();
+	BOOL GetLocalAddress();
 };
 
-
-
-#endif // VINIC_DEFINED
+#endif				// VINIC_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/WaitingForManagers.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/WaitingForManagers.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/WaitingForManagers.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -67,13 +67,11 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "IOCommon.h"
 #include "WaitingForManagers.h"
 #include "GalileoView.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -84,14 +82,13 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 enum { TIMER_COUNTDOWN = 1 };
 
 // Check for an empty waiting list 2 times a second.
@@ -101,7 +98,7 @@
 // CWaitingForManagers dialog
 
 CWaitingForManagers::CWaitingForManagers()
-	: CDialog(CWaitingForManagers::IDD)
+:  CDialog(CWaitingForManagers::IDD)
 {
 	//{{AFX_DATA_INIT(CWaitingForManagers)
 	m_TCountdown = _T("");
@@ -110,8 +107,7 @@
 	Reset();
 }
 
-
-void CWaitingForManagers::DoDataExchange(CDataExchange* pDX)
+void CWaitingForManagers::DoDataExchange(CDataExchange * pDX)
 {
 	CDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CWaitingForManagers)
@@ -120,14 +116,12 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CWaitingForManagers, CDialog)
-	//{{AFX_MSG_MAP(CWaitingForManagers)
-	ON_WM_TIMER()
-	//}}AFX_MSG_MAP
+    //{{AFX_MSG_MAP(CWaitingForManagers)
+ON_WM_TIMER()
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
 
-
 //
 // Prepares the waiting list dialog for reuse.
 //
@@ -138,7 +132,6 @@
 	addresses.RemoveAll();
 }
 
-
 //
 // Overrides the base class Create function for modeless dialog boxes.
 //
@@ -151,76 +144,67 @@
 //
 // If the dialog is aborted or not all managers log in, no callback will occur.
 //
-BOOL CWaitingForManagers::Create( const CString& infilename, BOOL* flags, BOOL replace )
+BOOL CWaitingForManagers::Create(const CString & infilename, BOOL * flags, BOOL replace)
 {
 	// Store the parameters to the callback function (CGalileoView::OpenConfigFile())
 	callback_infilename = infilename;
 	callback_replace = replace;
-	for (int counter=0; counter<NumICFFlags; counter++)
+	for (int counter = 0; counter < NumICFFlags; counter++)
 		callback_flags[counter] = flags[counter];
 
 	// Create the dialog (modeless)
-	if (!CDialog::Create(IDD_WAITING_FOR_MANAGERS))
-	{
-		ErrorMessage("Couldn't create CWaitingForManagers dialog.  "
-			"Please report this as an Iometer bug.");
+	if (!CDialog::Create(IDD_WAITING_FOR_MANAGERS)) {
+		ErrorMessage("Couldn't create CWaitingForManagers dialog.  " "Please report this as an Iometer bug.");
 		return FALSE;
 	}
-
 	// Disable the Iometer main frame
-	GetParent()->EnableWindow( FALSE );
+	GetParent()->EnableWindow(FALSE);
 	// Enable this dialog, specifically (it was disabled by the main frame disable call)
-	EnableWindow( TRUE );
+	EnableWindow(TRUE);
 	// *** Make sure the main frame is always re-enabled!
 
 	return TRUE;
 }
 
-
 //
 // Called to remove the OS resources (timer and window).
 //
 BOOL CWaitingForManagers::Close()
 {
-	if ( !KillTimer(TIMER_COUNTDOWN) )
-	{
+	if (!KillTimer(TIMER_COUNTDOWN)) {
 		ErrorMessage("Couldn't kill the CWaitingForManagers TIMER_COUNTDOWN "
-						"timer.  Please report this as an Iometer bug.");
+			     "timer.  Please report this as an Iometer bug.");
 		return FALSE;
 	}
-
 	// Re-enable the Iometer main frame.
-	GetParent()->EnableWindow( TRUE );
+	GetParent()->EnableWindow(TRUE);
 
-	if ( !DestroyWindow() )
-	{
+	if (!DestroyWindow()) {
 		ErrorMessage("Couldn't close the CWaitingForManagers window.  "
-						"Please report this as an Iometer bug.");
+			     "Please report this as an Iometer bug.");
 		return FALSE;
 	}
 
 	return TRUE;
 }
 
-
 //
 // Abort button handler (there is no Cancel button)
 // Triggered when the user clicks Abort, presses Alt-F4, or closes the window.
 // NOT triggered when countdown reaches zero.
 //
-void CWaitingForManagers::OnCancel() 
+void CWaitingForManagers::OnCancel()
 {
 	// The user performed some mouse or keyboard action to abort
 	// the dialog, so make sure Iometer goes to interactive mode.
 	theApp.OverrideBatchMode();
 
-	(void) Close();
+	(void)Close();
 
 	// Clear the manager map and the CWaitingForManagers waiting list.
 	theApp.manager_list.loadmap.Reset();
 }
 
-
 //
 // Called when Dialog first appears.
 //
@@ -237,68 +221,60 @@
 
 	// Tell Windows to call OnTimer every xxxx ms to check
 	// for an empty list and to decrement the countdown.
-	SetTimer(TIMER_COUNTDOWN, 1000/polling_frequency, NULL);
+	SetTimer(TIMER_COUNTDOWN, 1000 / polling_frequency, NULL);
 
 	// Figure out the width of the waiting manager list control
-	m_LManagers.GetWindowRect( &rect );
+	m_LManagers.GetWindowRect(&rect);
 	width = rect.right - rect.left + 1;
-	width -= 5;	// necessary to avoid seeing a scrollbar (for some reason?)
+	width -= 5;		// necessary to avoid seeing a scrollbar (for some reason?)
 
 	// Initialize the manager waiting list CListCtrl
-	m_LManagers.InsertColumn(0, "Name", LVCFMT_LEFT, width/2);
-	m_LManagers.InsertColumn(1, "Address", LVCFMT_LEFT, width/2, 1);
+	m_LManagers.InsertColumn(0, "Name", LVCFMT_LEFT, width / 2);
+	m_LManagers.InsertColumn(1, "Address", LVCFMT_LEFT, width / 2, 1);
 
 	// Update the waiting list
 	DisplayManagers();
 
-	return TRUE;  // return TRUE unless you set the focus to a control
+	return TRUE;		// return TRUE unless you set the focus to a control
 }
 
-
 //
 // Timer handler -- decrements countdown every second.
 //
-void CWaitingForManagers::OnTimer(UINT nIDEvent) 
+void CWaitingForManagers::OnTimer(UINT nIDEvent)
 {
 	static int accumulator = 0;
 
-	switch (nIDEvent)
-	{
+	switch (nIDEvent) {
 	case TIMER_COUNTDOWN:
-		accumulator += 1000/polling_frequency;
+		accumulator += 1000 / polling_frequency;
 
 		// Has a second gone by?
-		if (accumulator >= 1000)
-		{
+		if (accumulator >= 1000) {
 			accumulator -= 1000;
 			remaining_seconds--;
 			UpdateCountdown();
 		}
 
-		if (names.GetSize() == 0)
-		{
-			theApp.pView->OpenConfigFile(	callback_infilename,
-											callback_flags,
-											callback_replace );
-			(void) Close();
+		if (names.GetSize() == 0) {
+			theApp.pView->OpenConfigFile(callback_infilename, callback_flags, callback_replace);
+			(void)Close();
 
 			// If we are in batch mode, start the test.
 			// (In batch mode, this dialog will always appear.)
-			if ( theApp.IsBatchMode() )
+			if (theApp.IsBatchMode())
 				theApp.pView->Go();
-		}
-		else if (remaining_seconds <= 0)
-		{
+		} else if (remaining_seconds <= 0) {
 			// theApp.OverrideBatchMode();
 
-			if(theApp.IsBatchMode()) {
+			if (theApp.IsBatchMode()) {
 				exit(1);
 			}
 
-			(void) Close();
+			(void)Close();
 
 			ErrorMessage("Time expired.  Not all managers specified in the config file "
-				"were available in Iometer, so loading was aborted.");
+				     "were available in Iometer, so loading was aborted.");
 		}
 		break;
 	default:
@@ -306,7 +282,6 @@
 	}
 }
 
-
 //
 // Displays the countdown notice.
 //
@@ -314,17 +289,16 @@
 {
 	char string[10];	// assuming no delay will be longer than 10 digits long
 
-	_itoa( remaining_seconds, string, 10 );
+	_itoa(remaining_seconds, string, 10);
 
-	m_TCountdown = "Automatically aborting in " + (CString)string + " seconds...";
+	m_TCountdown = "Automatically aborting in " + (CString) string + " seconds...";
 	UpdateData(FALSE);	// update the GUI
 }
 
-
 //
 // Add a manager's entry to the waiting list.
 //
-void CWaitingForManagers::AddWaitingManager(const CString& name, const CString& address)
+void CWaitingForManagers::AddWaitingManager(const CString & name, const CString & address)
 {
 	names.SetSize(names.GetSize() + 1);
 	addresses.SetSize(addresses.GetSize() + 1);
@@ -332,20 +306,16 @@
 	addresses[addresses.GetSize() - 1] = address;
 }
 
-
 //
 // Remove a manager's entry from the waiting list.
 //
-BOOL CWaitingForManagers::RemoveWaitingManager(const CString& name, const CString& address)
+BOOL CWaitingForManagers::RemoveWaitingManager(const CString & name, const CString & address)
 {
-	for (int counter=0; counter<names.GetSize(); counter++)
-	{
+	for (int counter = 0; counter < names.GetSize(); counter++) {
 		// Do these managers match?
-		if ( (name.CompareNoCase(names[counter]) == 0
-			  && address.CompareNoCase(addresses[counter]) == 0)
-			|| ( (addresses[counter] == "") // "special local host" case
-		  && (names[counter].Compare(HOSTNAME_LOCAL) == 0 ) ) )
-		{
+		if ((name.CompareNoCase(names[counter]) == 0 && address.CompareNoCase(addresses[counter]) == 0)
+		    || ((addresses[counter] == "")	// "special local host" case
+			&& (names[counter].Compare(HOSTNAME_LOCAL) == 0))) {
 			// Remove this entry from the waiting list
 			names.RemoveAt(counter);
 			addresses.RemoveAt(counter);
@@ -365,7 +335,6 @@
 	return FALSE;
 }
 
-
 //
 // Fills in the m_LManagers CListCtrl with the contents of the name and address CArrays
 //
@@ -376,24 +345,20 @@
 	// Clear the manager waiting list CListCtrl.
 	m_LManagers.DeleteAllItems();
 
-	for (int counter=0; counter<names.GetSize(); counter++)
-	{
+	for (int counter = 0; counter < names.GetSize(); counter++) {
 		// Insert a row into the list
-		m_LManagers.InsertItem( counter, NULL );
+		m_LManagers.InsertItem(counter, NULL);
 
 		// Fill in the manager name
-		if ( !m_LManagers.SetItemText( counter, 0, names[counter] ) )
-		{
+		if (!m_LManagers.SetItemText(counter, 0, names[counter])) {
 			ErrorMessage("Couldn't SetItemText for the name column in the CListCtrl.  "
-				"Please report this as an Iometer bug.");
+				     "Please report this as an Iometer bug.");
 			return;
 		}
-
 		// Fill in the address
-		if ( !m_LManagers.SetItemText( counter, 1, addresses[counter] ) )
-		{
+		if (!m_LManagers.SetItemText(counter, 1, addresses[counter])) {
 			ErrorMessage("Couldn't SetItemText for the address column in the CListCtrl.  "
-				"Please report this as an Iometer bug.");
+				     "Please report this as an Iometer bug.");
 			return;
 		}
 	}

Modified: branches/IOMETER-restruct/iometer/src/WaitingForManagers.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/WaitingForManagers.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/WaitingForManagers.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -66,27 +66,24 @@
 #ifndef WAITING_FOR_MANAGERS_DEFINED
 #define WAITING_FOR_MANAGERS_DEFINED
 
-
 #include <afxtempl.h>
 #include "resource.h"
 #include "GalileoDefs.h"
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CWaitingForManagers dialog
 
-class CWaitingForManagers : public CDialog
-{
+class CWaitingForManagers:public CDialog {
 // Construction
-public:
-	CWaitingForManagers();   // standard constructor
+      public:
+	CWaitingForManagers();	// standard constructor
 
 	// Create CWaitingForManagers as a modeless dialog
-	BOOL Create( const CString& infilename, BOOL* flags, BOOL replace );
+	BOOL Create(const CString & infilename, BOOL * flags, BOOL replace);
 
 	// Add or remove managers from the waiting list
-	void AddWaitingManager(const CString& name, const CString& address);
-	BOOL RemoveWaitingManager(const CString& name, const CString& address);
+	void AddWaitingManager(const CString & name, const CString & address);
+	BOOL RemoveWaitingManager(const CString & name, const CString & address);
 
 	// Prepares the waiting list dialog for reuse.
 	void Reset();
@@ -94,20 +91,19 @@
 // Dialog Data
 	//{{AFX_DATA(CWaitingForManagers)
 	enum { IDD = IDD_WAITING_FOR_MANAGERS };
-	CListCtrl	m_LManagers;
-	CString	m_TCountdown;
+	CListCtrl m_LManagers;
+	CString m_TCountdown;
 	//}}AFX_DATA
 
-
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CWaitingForManagers)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
+      protected:
 
 	// Update the GUI waiting list to reflect the state of the names and addresses arrays
 	void DisplayManagers();
@@ -124,10 +120,10 @@
 	afx_msg void OnTimer(UINT nIDEvent);
 	virtual BOOL OnInitDialog();
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 
 	int remaining_seconds;	// The remaining seconds before automatic abort.
-							// Reinitialized in OnInitDialog from theApp.cmdline.m_iTimeout.
+	// Reinitialized in OnInitDialog from theApp.cmdline.m_iTimeout.
 
 	// The parameters for the callback to the function which will
 	// receive notification when this dialog is finished
@@ -138,11 +134,11 @@
 	// How many times a second to see whether the waiting list is empty
 	static const int polling_frequency;
 
-	CStringArray			names;
-	CStringArray			addresses;
+	CStringArray names;
+	CStringArray addresses;
 };
 
 //{{AFX_INSERT_LOCATION}}
 // Microsoft Visual C++ will insert additional declarations immediately before the previous line.
 
-#endif	// WAITING_FOR_MANAGERS_DEFINED
+#endif				// WAITING_FOR_MANAGERS_DEFINED

Modified: branches/IOMETER-restruct/iometer/src/Worker.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/Worker.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/Worker.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -69,7 +69,6 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "IOCommon.h"
 #include "stdafx.h"
 #include "GalileoApp.h"
@@ -79,7 +78,6 @@
 #include "ManagerList.h"
 #include "AccessSpecList.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -90,182 +88,148 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 //
 // Initializing information for a new worker.
 //
-Worker::Worker( Manager* mgr, TargetType wkr_type )
+Worker::Worker(Manager * mgr, TargetType wkr_type)
 {
 	manager = mgr;
 
 	net_partner = NULL;
 
 	// Initializing target information.
-	targets.SetSize( INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP );
+	targets.SetSize(INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP);
 
 	ResetAllResults();
 
 	// Set the initial default target information.
-	memset( &spec, 0, sizeof( Target_Spec ) );
+	memset(&spec, 0, sizeof(Target_Spec));
 	spec.type = wkr_type;
 	spec.queue_depth = 1;
 	spec.test_connection_rate = FALSE;
 	spec.trans_per_conn = 1;
 
-	if ( IsType( wkr_type, GenericServerType ) )
-	{
-		SetLocalNetworkInterface( 0, 
-			(TargetType)(wkr_type & NETWORK_COMPATIBILITY_MASK) );
-	}
-	else if ( IsType( wkr_type, GenericClientType ) )
-	{
+	if (IsType(wkr_type, GenericServerType)) {
+		SetLocalNetworkInterface(0, (TargetType) (wkr_type & NETWORK_COMPATIBILITY_MASK));
+	} else if (IsType(wkr_type, GenericClientType)) {
 		net_target_index = 0;
 		return;
 	}
-
 	// Initialize the access spec array and fill in the defaults.
-	access_spec_list.SetSize( INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP );
+	access_spec_list.SetSize(INITIAL_ARRAY_SIZE, ARRAY_GROW_STEP);
 	AssignDefaultAccessSpecs();
 }
 
-
-
 Worker::~Worker()
 {
 	// When a client is removed, its server must remove it as a target.
-	if ( IsType( Type(), GenericClientType ) && net_partner )
-	{
+	if (IsType(Type(), GenericClientType) && net_partner) {
 		net_partner->net_partner = NULL;
-		net_partner->RemoveTarget( net_target_index );
+		net_partner->RemoveTarget(net_target_index);
 	}
-
 	// Free all assigned targets.
 	RemoveTargets();
 	targets.FreeExtra();
 }
 
-
-
 //
 // Copies all settings from the source worker.
 //
-void Worker::Clone( Worker* source_worker )
+void Worker::Clone(Worker * source_worker)
 {
-	int			i;
-	TargetType	type;
+	int i;
+	TargetType type;
 
-	strcpy( name, source_worker->name );
-	memcpy( &spec, &source_worker->spec, sizeof( Target_Spec ) );
+	strcpy(name, source_worker->name);
+	memcpy(&spec, &source_worker->spec, sizeof(Target_Spec));
 
 	// Copy the worker's access specs.
 	RemoveAllAccessSpecs();
-	for ( i = 0; i < source_worker->AccessSpecCount(); i++ )
-	{
-		InsertAccessSpec( source_worker->GetAccessSpec( i ) );
+	for (i = 0; i < source_worker->AccessSpecCount(); i++) {
+		InsertAccessSpec(source_worker->GetAccessSpec(i));
 	}
 
 	// Copy the template's target information.
-	for ( i = 0; i < source_worker->TargetCount(); i++ )
-	{
-		AddTarget( &source_worker->GetTarget( i )->spec );
-		
+	for (i = 0; i < source_worker->TargetCount(); i++) {
+		AddTarget(&source_worker->GetTarget(i)->spec);
+
 		// Create a network client if necessary.
-		type = source_worker->GetTarget( i )->spec.type;
-		if ( IsType( type, GenericClientType ) )
-			CreateNetClient( source_worker->net_partner->manager, type );
+		type = source_worker->GetTarget(i)->spec.type;
+		if (IsType(type, GenericClientType))
+			CreateNetClient(source_worker->net_partner->manager, type);
 	}
 }
 
-
-
 //
 // Getting a worker's target.
 // 
-Target* Worker::GetTarget( int index, TargetType type )
+Target *Worker::GetTarget(int index, TargetType type)
 {
 	int i, target_count;
 
 	// Verify valid index into target array.
-	if ( index < 0 || index >= TargetCount( type ) )
-	{
-		ErrorMessage( "Invalid index in Worker::GetTarget()." );
+	if (index < 0 || index >= TargetCount(type)) {
+		ErrorMessage("Invalid index in Worker::GetTarget().");
 		return NULL;
 	}
 
 	target_count = TargetCount();
-	for ( i = 0; i < target_count; i++ )
-	{
-		if ( IsType( targets[i]->spec.type, type ) )
-		{
-			if ( !index-- )
+	for (i = 0; i < target_count; i++) {
+		if (IsType(targets[i]->spec.type, type)) {
+			if (!index--)
 				return targets[i];
 		}
 	}
 
-	ErrorMessage( "Unexpectedly reached end of Worker::GetTarget()." );
+	ErrorMessage("Unexpectedly reached end of Worker::GetTarget().");
 	return NULL;
 }
 
-
-
 //
 // Getting count of worker's targets of the specified type.
 // 
-int Worker::TargetCount( TargetType type )
+int Worker::TargetCount(TargetType type)
 {
 	int i, count = 0, target_count;
 
 	target_count = targets.GetSize();
-	for ( i = 0; i < target_count; i++ )
-	{
-		if ( IsType( targets[i]->spec.type, type ) )
+	for (i = 0; i < target_count; i++) {
+		if (IsType(targets[i]->spec.type, type))
 			count++;
 	}
 	return count;
 }
 
-
-
 //
 // Determines if a target matching the given target specifications has been
 // assigned to the worker.
 //
-BOOL Worker::IsTargetAssigned( Target_Spec *target_info )
+BOOL Worker::IsTargetAssigned(Target_Spec * target_info)
 {
 	int i, target_count;
 
 	// Network clients have the target assigned if it refers to their server.
-	if ( IsType( Type(), GenericClientType ) && 
-		IsType( target_info->type, GenericNetType ) )
-	{
-		return !strcmp( target_info->name, net_partner->GetTarget( 
-			net_target_index )->spec.name );
+	if (IsType(Type(), GenericClientType) && IsType(target_info->type, GenericNetType)) {
+		return !strcmp(target_info->name, net_partner->GetTarget(net_target_index)->spec.name);
 	}
-
 	// Loop through all of the worker's targets and see if there's a match.
 	target_count = TargetCount();
-	for ( i = 0; i < target_count; i++ )
-	{
+	for (i = 0; i < target_count; i++) {
 		// Currently only a small subset of the target information is compared.
-		if ( IsType( target_info->type, GenericDiskType ) )
-		{
+		if (IsType(target_info->type, GenericDiskType)) {
 			// Look for a disk with the same name.
-			if ( !strcmp( target_info->name, GetTarget(i)->spec.name ) )
+			if (!strcmp(target_info->name, GetTarget(i)->spec.name))
 				return TRUE;
-		}
-		else if ( IsType( target_info->type, GenericNetType ) )
-		{
+		} else if (IsType(target_info->type, GenericNetType)) {
 			// Look for a network target with the given remote address.
-			if ( !strcmp( target_info->name,
-				GetTarget(i)->spec.tcp_info.remote_address ) )
-			{
+			if (!strcmp(target_info->name, GetTarget(i)->spec.tcp_info.remote_address)) {
 				return TRUE;
 			}
 		}
@@ -273,21 +237,19 @@
 	return FALSE;
 }
 
-
-
 //
 // Adding a new target to the end of the worker's list.
 //
-void Worker::AddTarget( Target_Spec *target_info )
+void Worker::AddTarget(Target_Spec * target_info)
 {
-	Target* target;
+	Target *target;
 
 	// Create a new target, copy the specified information, and 
 	// initialize it.
 	target = new Target;
-	memcpy( &(target->spec), target_info, sizeof( Target_Spec ) );
-	memset( &(target->results[WHOLE_TEST_PERF]), 0, sizeof( Results ) );
-	memset( &(target->results[LAST_UPDATE_PERF]), 0, sizeof( Results ) );
+	memcpy(&(target->spec), target_info, sizeof(Target_Spec));
+	memset(&(target->results[WHOLE_TEST_PERF]), 0, sizeof(Results));
+	memset(&(target->results[LAST_UPDATE_PERF]), 0, sizeof(Results));
 
 	// Use the worker's default settings for the target.
 	target->spec.queue_depth = spec.queue_depth;
@@ -296,67 +258,57 @@
 	target->spec.trans_per_conn = spec.trans_per_conn;
 
 	// Copy default settings specific to the target's type.
-	if ( IsType( target->spec.type, GenericDiskType ) )
-		memcpy( &target->spec.disk_info, &spec.disk_info, sizeof( Disk_Spec ) );
-	else if ( IsType( target->spec.type, VIClientType ) )
+	if (IsType(target->spec.type, GenericDiskType))
+		memcpy(&target->spec.disk_info, &spec.disk_info, sizeof(Disk_Spec));
+	else if (IsType(target->spec.type, VIClientType))
 		target->spec.vi_info.outstanding_ios = spec.vi_info.outstanding_ios;
-	else if ( !IsType( target->spec.type, GenericClientType ) )
-	{
-		ErrorMessage("Invalid target type in Worker::AddTarget()." );
+	else if (!IsType(target->spec.type, GenericClientType)) {
+		ErrorMessage("Invalid target type in Worker::AddTarget().");
 		delete target;
+
 		target = NULL;
 		return;
 	}
 
-	targets.Add( target );
+	targets.Add(target);
 }
 
-
-
 //
 // Removing the specified target from the worker's list.
 //
-void Worker::RemoveTarget( int index )
+void Worker::RemoveTarget(int index)
 {
-	if ( index < 0 || index >= TargetCount() )
-	{
-		ErrorMessage( "Invalid index in Worker::RemoveTarget()." );
+	if (index < 0 || index >= TargetCount()) {
+		ErrorMessage("Invalid index in Worker::RemoveTarget().");
 		return;
 	}
-
 	// Remove associated network clients along with target.
-	if ( IsType( targets[index]->spec.type, GenericClientType ) )
-	{
-		if ( net_partner )
-		{
+	if (IsType(targets[index]->spec.type, GenericClientType)) {
+		if (net_partner) {
 			net_partner->net_partner = NULL;
-			theApp.pView->m_pWorkerView->RemoveWorker( net_partner );
+			theApp.pView->m_pWorkerView->RemoveWorker(net_partner);
 			net_partner = NULL;
 		}
 	}
 	delete GetTarget(index);
-	targets.RemoveAt( index );
+
+	targets.RemoveAt(index);
 }
 
-
-
 //
 // Removing all targets of the specified type.
 //
-void Worker::RemoveTargets( TargetType target_type )
+void Worker::RemoveTargets(TargetType target_type)
 {
 	// Walk through the target array backwards and remove all targets of the
 	// given type.  We move backwards to avoid jumping over targets when some
 	// get removed.
-	for ( int i = TargetCount() - 1; i >= 0; i-- )
-	{
-		if ( IsType( targets[i]->spec.type, target_type ) )
-			RemoveTarget( i );
+	for (int i = TargetCount() - 1; i >= 0; i--) {
+		if (IsType(targets[i]->spec.type, target_type))
+			RemoveTarget(i);
 	}
 }
 
-
-
 //
 // Returns if a worker is ready to start a test or if additional work needs
 // to be done, such as preparing a logical drive for access.
@@ -364,107 +316,88 @@
 BOOL Worker::ReadyToRunTests()
 {
 	// Ensure that all targets are ready to run.
-	for ( int i = 0; i < TargetCount(); i++ )
-	{
-		if ( !TargetReadyToRunTests( GetTarget( i ) ) )
+	for (int i = 0; i < TargetCount(); i++) {
+		if (!TargetReadyToRunTests(GetTarget(i)))
 			return FALSE;
 	}
 	return TRUE;
 }
 
-
-
 //
 // Returns whether or not a target is ready to run a test.
 //
-BOOL Worker::TargetReadyToRunTests( Target *target )
+BOOL Worker::TargetReadyToRunTests(Target * target)
 {
 	int i, iface_count;
 
 	// Only logical disk drives need to be prepared.
-	if ( !IsType( target->spec.type, LogicalDiskType ) )
+	if (!IsType(target->spec.type, LogicalDiskType))
 		return TRUE;
-	
+
 	// Disk targets are ready if the disk is marked ready in the manager's
 	// disk list.  Search through the manager's list of drives to find
 	// the corresponding drive and check if it's ready.  We search through the
 	// manager's list in case another worker has prepared the same drive.
-	iface_count = manager->InterfaceCount( GenericDiskType );
-	for ( i = 0; i < iface_count; i++ )
-	{
-		if ( !strcmp( target->spec.name, manager->GetInterface( i, GenericDiskType )->name ) )
-			return manager->GetInterface( i, GenericDiskType )->disk_info.ready;
+	iface_count = manager->InterfaceCount(GenericDiskType);
+	for (i = 0; i < iface_count; i++) {
+		if (!strcmp(target->spec.name, manager->GetInterface(i, GenericDiskType)->name))
+			return manager->GetInterface(i, GenericDiskType)->disk_info.ready;
 	}
 
-	ErrorMessage( "Worker's assigned disk not found in manager's list in "
-		"Worker::TargetReadyToRunTests()." );
+	ErrorMessage("Worker's assigned disk not found in manager's list in " "Worker::TargetReadyToRunTests().");
 	return FALSE;
 }
 
-
-
 //
 // Resetting worker and its targets to indicate that they are not active.
 //
 void Worker::ClearActiveTargets()
 {
 	// Resetting all targets to indicate that they are not running.
-	for ( int i = 0; i < TargetCount(); i++ )
-	{
+	for (int i = 0; i < TargetCount(); i++) {
 		targets[i]->spec.type = (TargetType)
-			(targets[i]->spec.type & ~ActiveType);
+		    (targets[i]->spec.type & ~ActiveType);
 	}
 }
 
-
-
 //
 // Setting a specified number of targets to indicate that they are active.
 // We return the actual number of targets set active.
 //
-int Worker::SetActiveTargets( int targets_to_set )
+int Worker::SetActiveTargets(int targets_to_set)
 {
 	int i, count = 0, target_count = TargetCount();
 
-	for ( i = 0; i < target_count; i++ )
-	{
-		if ( targets_to_set-- > 0 )
-		{
+	for (i = 0; i < target_count; i++) {
+		if (targets_to_set-- > 0) {
 			targets[i]->spec.type = (TargetType)
-				(targets[i]->spec.type | ActiveType);
+			    (targets[i]->spec.type | ActiveType);
 			count++;
-		}
-		else
-		{
+		} else {
 			targets[i]->spec.type = (TargetType)
-				(targets[i]->spec.type & ~ActiveType);
+			    (targets[i]->spec.type & ~ActiveType);
 		}
 	}
 
 	return count;
 }
 
-
-
 //
 // Initializing worker results.
 //
-void Worker::ResetResults( int which_perf )
+void Worker::ResetResults(int which_perf)
 {
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF))
 		return;
 
-	memset( &(results[which_perf]), 0, sizeof( Results ) );
+	memset(&(results[which_perf]), 0, sizeof(Results));
 
 	// Reset results for all targets as well.
-	for ( int i = 0; i < TargetCount(); i++ )
-	{
-		memset( &(GetTarget( i )->results[which_perf]), 0, sizeof( Results ) );
+	for (int i = 0; i < TargetCount(); i++) {
+		memset(&(GetTarget(i)->results[which_perf]), 0, sizeof(Results));
 	}
 }
 
-
-
 //
 // Reset all results stored for an individual worker, along with any results for any 
 // associated devices.
@@ -472,27 +405,22 @@
 void Worker::ResetAllResults()
 {
 	// Reset worker's results.
-	ResetResults( WHOLE_TEST_PERF );
-	ResetResults( LAST_UPDATE_PERF );
+	ResetResults(WHOLE_TEST_PERF);
+	ResetResults(LAST_UPDATE_PERF);
 }
 
-
-
 //
 // Return this worker's index in the manager's worker list.
 //
-int Worker::GetIndex( TargetType list_type )
+int Worker::GetIndex(TargetType list_type)
 {
-	for ( int i = 0; i < manager->WorkerCount( list_type ); i++ )
-	{
-		if ( this == manager->GetWorker( i, list_type ) )
+	for (int i = 0; i < manager->WorkerCount(list_type); i++) {
+		if (this == manager->GetWorker(i, list_type))
 			return i;
 	}
 	return IOERROR;
 }
 
-
-
 //
 // Returning information about what type of worker we're dealing with.
 //
@@ -505,235 +433,200 @@
 // Do not do this until after the IDF release. 8/19/98. - SH
 TargetType Worker::Type()
 {
-	int			i, target_count;
-	TargetType	type, target_type;
+	int i, target_count;
+	TargetType type, target_type;
 
 	// If the worker does not have any targets, use the last stored type.
-	if ( !(target_count = TargetCount()) )
+	if (!(target_count = TargetCount()))
 		return spec.type;
 
 	// Otherwise return a type based on its assigned targets.
 	type = GenericType;
-	for ( i = 0; i < target_count; i++ )
-	{
-		if ( IsType( targets[i]->spec.type, GenericClientType ) )
-		{
+	for (i = 0; i < target_count; i++) {
+		if (IsType(targets[i]->spec.type, GenericClientType)) {
 			// Mark this worker as the server by setting the target's client
 			// bit to 0 and server bit to 1.
-			target_type = (TargetType)( (targets[i]->spec.type & 
-				~(GenericClientType ^ GenericNetType)) | GenericServerType );
+			target_type = (TargetType) ((targets[i]->spec.type &
+						     ~(GenericClientType ^ GenericNetType)) | GenericServerType);
 
-			type = (TargetType)(type | target_type);
-		}
-		else
-			type = (TargetType)(type | targets[i]->spec.type);
+			type = (TargetType) (type | target_type);
+		} else
+			type = (TargetType) (type | targets[i]->spec.type);
 	}
 
 	return type;
 }
 
-
-
 //
 // Sets a worker's nth access spec, where n is specified by access_entry.
 // Also sets any corresponding network clients.
 //
-BOOL Worker::SetAccess( int access_entry )
+BOOL Worker::SetAccess(int access_entry)
 {
-	Message			msg;
-	Data_Message	data_msg;
+	Message msg;
+	Data_Message data_msg;
 
 	// Network clients are set by their server.
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return TRUE;
-	
+
 	// If the worker has an access spec for the specified entry, use it.
 	// If there is no entry, send the idle spec.
-	if ( access_entry < AccessSpecCount() )
-	{
+	if (access_entry < AccessSpecCount()) {
 		// Copy the spec into a message and send it.
-		memcpy( (void*)&( data_msg.data.spec ), 
-			(void*)( GetAccessSpec(access_entry) ),	sizeof( Test_Spec ) );
-	}
-	else
-	{
+		memcpy((void *)&(data_msg.data.spec), (void *)(GetAccessSpec(access_entry)), sizeof(Test_Spec));
+	} else {
 		// Otherwise, send the idle spec.
-		memcpy( (void*)&(data_msg.data.spec), 
-			(void*)(theApp.access_spec_list.Get( IDLE_SPEC )), 
-			sizeof( Test_Spec ) );
+		memcpy((void *)&(data_msg.data.spec),
+		       (void *)(theApp.access_spec_list.Get(IDLE_SPEC)), sizeof(Test_Spec));
 	}
 
 	// Tell Dynamo to set the access spec.
 	msg.purpose = SET_ACCESS;
 	msg.data = GetIndex();
-	manager->Send( &msg );
-	manager->SendData( &data_msg );
-	manager->Receive( &msg );
+	manager->Send(&msg);
+	manager->SendData(&data_msg);
+	manager->Receive(&msg);
 
 	// Set the access spec for the corresponing client, if any.
-	if ( msg.data && IsType( Type(), GenericServerType ) && net_partner )
-	{
+	if (msg.data && IsType(Type(), GenericServerType) && net_partner) {
 		msg.purpose = SET_ACCESS;
 		msg.data = net_partner->GetIndex();
-		net_partner->manager->Send( &msg );
-		net_partner->manager->SendData( &data_msg );
-		net_partner->manager->Receive( &msg );
+		net_partner->manager->Send(&msg);
+		net_partner->manager->SendData(&data_msg);
+		net_partner->manager->Receive(&msg);
 	}
 
-	return msg.data; // msg.data indicates success.
+	return msg.data;	// msg.data indicates success.
 }
 
-
-
 //
 // Sets all targets that are marked as active.  This sends the SET_TARGET
 // message to Dynamo and gets the response.
 //
 BOOL Worker::SetTargets()
 {
-	Target					*target;
-	Message					msg;
-	Data_Message			data_msg;
-	VI_DISCRIMINATOR_TYPE	vi_discriminator;	
-	int						vi_discriminator_length;
-	VIP_NET_ADDRESS			*vi_addr;
-	int						i, target_count;
+	Target *target;
+	Message msg;
+	Data_Message data_msg;
+	VI_DISCRIMINATOR_TYPE vi_discriminator;
+	int vi_discriminator_length;
+	VIP_NET_ADDRESS *vi_addr;
+	int i, target_count;
 
 	// Network clients are set by their servers.
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return TRUE;
 
 	data_msg.count = 0;
 
 	// Loop through all targets and add them to the message if active.
-	target_count = TargetCount( ActiveType );
-	for ( i = 0; i < target_count; i++ )
-	{
-		target = GetTarget( i, ActiveType );
+	target_count = TargetCount(ActiveType);
+	for (i = 0; i < target_count; i++) {
+		target = GetTarget(i, ActiveType);
 
 		// Initialize random number generator.
 		target->spec.random = rdtsc();
 
 		// Initialize unique discriminator for VI targets.
-		if ( IsType( target->spec.type, VIClientType ) )
-		{
+		if (IsType(target->spec.type, VIClientType)) {
 			// Find the smallest of the two NICs' discriminator length and VI_DISCRIMINATOR_SIZE
-			vi_discriminator_length = min( target->spec.vi_info.local_address.DiscriminatorLen,
-			                               target->spec.vi_info.remote_address.DiscriminatorLen );
-			vi_discriminator_length = min( vi_discriminator_length, VI_DISCRIMINATOR_SIZE );
+			vi_discriminator_length = min(target->spec.vi_info.local_address.DiscriminatorLen,
+						      target->spec.vi_info.remote_address.DiscriminatorLen);
+			vi_discriminator_length = min(vi_discriminator_length, VI_DISCRIMINATOR_SIZE);
 
 #if defined(IOMTR_CPU_I386) || defined(IOMTR_CPU_IA64) || defined(IOMTR_CPU_X86_64)
 			// Intel processor (little-endian) -- use the first VI_DISCRIMINATOR_SIZE bytes 
 			// (least significant bytes) of the current 64-bit system time as the discriminator.
-			vi_discriminator = (VI_DISCRIMINATOR_TYPE)rdtsc();
+			vi_discriminator = (VI_DISCRIMINATOR_TYPE) rdtsc();
 
 			// Copy the first vi_discriminator_length bytes of the generated discriminator
 			// to the VI_Spec's local_address.
 			vi_addr = &target->spec.vi_info.local_address;
 			vi_addr->DiscriminatorLen = vi_discriminator_length;
-			memcpy( vi_addr->HostAddress + vi_addr->HostAddressLen, &vi_discriminator, 
-				vi_discriminator_length );
+			memcpy(vi_addr->HostAddress + vi_addr->HostAddressLen, &vi_discriminator,
+			       vi_discriminator_length);
 
 			// Copy the first vi_discriminator_length bytes of the generated discriminator
 			// to the VI_Spec's remote_address.
 			vi_addr = &target->spec.vi_info.remote_address;
 			vi_addr->DiscriminatorLen = vi_discriminator_length;
-			memcpy( vi_addr->HostAddress + vi_addr->HostAddressLen, &vi_discriminator, 
-				vi_discriminator_length );
+			memcpy(vi_addr->HostAddress + vi_addr->HostAddressLen, &vi_discriminator,
+			       vi_discriminator_length);
 #else
 			// Non-Intel processor -- generate a random discriminator and use the first
 			// or last vi_discriminator_length bytes, depending on whether the processor
 			// is big-endian or little-endian.  (Tip: if htonl(1234) == 1234, it's big-endian.)
-			#error "Non-IA version of this code is not yet implemented."
+#error "Non-IA version of this code is not yet implemented."
 #endif
 		}
-
 		// Copy active targets into set target data message.
-		memcpy( &data_msg.data.targets[data_msg.count++], &target->spec, 
-			sizeof( Target_Spec ) );
+		memcpy(&data_msg.data.targets[data_msg.count++], &target->spec, sizeof(Target_Spec));
 	}
 
 	// Send the message of targets to set to Dynamo and get the reply.
-	manager->Send( GetIndex(), SET_TARGETS );
-	manager->SendData( &data_msg );
+	manager->Send(GetIndex(), SET_TARGETS);
+	manager->SendData(&data_msg);
 
 	// Reply message indicates if targets were set successfully along with
 	// additional error data or target settings that can only be determined
 	// by Dynamo (such as TCP port numbers).
-	manager->Receive( &msg );
-	manager->ReceiveData( &data_msg );
+	manager->Receive(&msg);
+	manager->ReceiveData(&data_msg);
 
 	// If a network server set its targets correctly, set its client.
 	// This currently assumes one client per server.
-	if ( msg.data && IsType( Type(), GenericServerType ) && TargetCount() )
-	{
+	if (msg.data && IsType(Type(), GenericServerType) && TargetCount()) {
 		// Set the client's targets if we're not just resetting targets.
-		if ( data_msg.count )
-		{
+		if (data_msg.count) {
 			data_msg.count = 1;
 
-			if ( IsType( targets[0]->spec.type, TCPClientType ) )
-			{
+			if (IsType(targets[0]->spec.type, TCPClientType)) {
 				// Record port used by server
-				targets[0]->spec.tcp_info.local_port = 
-					data_msg.data.targets[0].tcp_info.local_port;
+				targets[0]->spec.tcp_info.local_port = data_msg.data.targets[0].tcp_info.local_port;
 
 				// Set the server's client to use the server as a target.
-				memcpy( &data_msg.data.targets[0], &targets[0]->spec, 
-					sizeof( Target_Spec ) );
+				memcpy(&data_msg.data.targets[0], &targets[0]->spec, sizeof(Target_Spec));
 
 				// Set the client's remote port to the server's local port
-				data_msg.data.targets[0].tcp_info.remote_port = 
-					targets[0]->spec.tcp_info.local_port;
+				data_msg.data.targets[0].tcp_info.remote_port = targets[0]->spec.tcp_info.local_port;
 
 				// Reverse the local and remote addresses for the client.
 				// The *server* is a client's target.
-				strcpy( data_msg.data.targets[0].name, 
-					targets[0]->spec.tcp_info.remote_address );
-				strcpy( data_msg.data.targets[0].tcp_info.remote_address,
-					targets[0]->spec.name );
+				strcpy(data_msg.data.targets[0].name, targets[0]->spec.tcp_info.remote_address);
+				strcpy(data_msg.data.targets[0].tcp_info.remote_address, targets[0]->spec.name);
 				data_msg.data.targets[0].type = TCPServerType;
-			}
-			else if ( IsType( targets[0]->spec.type, VIClientType ) )
-			{
+			} else if (IsType(targets[0]->spec.type, VIClientType)) {
 				// Set the server's client to use the server as the target.
-				memcpy( &data_msg.data.targets[0], &targets[0]->spec,
-					sizeof( Target_Spec ) );
+				memcpy(&data_msg.data.targets[0], &targets[0]->spec, sizeof(Target_Spec));
 
 				// Reverse the local and remote addresses for the client.
 				// The *server* is a client's target.
 				// Set client's local VI NIC to use.
-				strcpy( data_msg.data.targets[0].name, 
-					target->spec.vi_info.remote_nic_name );
+				strcpy(data_msg.data.targets[0].name, target->spec.vi_info.remote_nic_name);
 				// Set address that client should connect to on remote side.
-				memcpy( &data_msg.data.targets[0].vi_info.remote_address,
-					&targets[0]->spec.vi_info.local_address, VI_ADDRESS_SIZE );
-				memcpy( &data_msg.data.targets[0].vi_info.local_address,
-					&targets[0]->spec.vi_info.remote_address, VI_ADDRESS_SIZE );
+				memcpy(&data_msg.data.targets[0].vi_info.remote_address,
+				       &targets[0]->spec.vi_info.local_address, VI_ADDRESS_SIZE);
+				memcpy(&data_msg.data.targets[0].vi_info.local_address,
+				       &targets[0]->spec.vi_info.remote_address, VI_ADDRESS_SIZE);
 				data_msg.data.targets[0].type = VIServerType;
-			}
-			else
-			{
-				ErrorMessage( "Unsupported client target type in Worker::"
-					"SetTargets()." );
+			} else {
+				ErrorMessage("Unsupported client target type in Worker::" "SetTargets().");
 				return FALSE;
 			}
 		}
-
 		// Send the message of targets to set to Dynamo and get the reply.
-		net_partner->manager->Send( net_partner->GetIndex(), SET_TARGETS );
-		net_partner->manager->SendData( &data_msg );
+		net_partner->manager->Send(net_partner->GetIndex(), SET_TARGETS);
+		net_partner->manager->SendData(&data_msg);
 
 		// Reply message indicates if targets were set successfully.
-		net_partner->manager->Receive( &msg );
-		net_partner->manager->ReceiveData( &data_msg );
+		net_partner->manager->Receive(&msg);
+		net_partner->manager->ReceiveData(&data_msg);
 	}
 
-	return ( msg.data );
+	return (msg.data);
 }
 
-
-
 //
 // Checks all targets to make sure that they're prepared to run, and marks those
 // that need to be as active.  If any need to be prepared, it sends a message
@@ -741,271 +634,237 @@
 //
 void Worker::SetTargetsToPrepare()
 {
-	int	i, target_count = TargetCount();
+	int i, target_count = TargetCount();
 
 	// Find which targets need to be prepared and mark them.
-	for ( i = 0; i < target_count; i++ )
-	{
-		if ( TargetReadyToRunTests( targets[i] ) )
-		{
+	for (i = 0; i < target_count; i++) {
+		if (TargetReadyToRunTests(targets[i])) {
 			targets[i]->spec.type = (TargetType)
-				(targets[i]->spec.type & ~ActiveType);
-		}
-		else
-		{
+			    (targets[i]->spec.type & ~ActiveType);
+		} else {
 			// Set targets needing to be prepared as active.
 			targets[i]->spec.type = (TargetType)
-				(targets[i]->spec.type | ActiveType);
+			    (targets[i]->spec.type | ActiveType);
 		}
 	}
 
 	// Send a message to Dynamo to set the targets needing preparation.
 	theApp.test_state = TestPreparing;
 	SetTargets();
-	manager->Send( GetIndex(), PREP_DISKS );
+	manager->Send(GetIndex(), PREP_DISKS);
 }
 
-
-
 //
 // Saving the results for the worker and all its targets.
 //
-void Worker::SaveResults( ostream* file, int access_index, int result_type )
+void Worker::SaveResults(ostream * file, int access_index, int result_type)
 {
-	int		i, stat, target_count;
-	Target*	target;
+	int i, stat, target_count;
+	Target *target;
 
 	// Saving combined results.
-	if ( !ActiveInCurrentTest() )
+	if (!ActiveInCurrentTest())
 		return;
 
 	// Writing results for worker.
-	(*file) << "WORKER" 
-			<< "," << name 
-			<< "," << GetAccessSpec( access_index )->name
-			<< ",,"; // space for managers running and workers running.
+	(*file) << "WORKER" << "," << name << "," << GetAccessSpec(access_index)->name << ",,";	// space for managers running and workers running.
 
-	if ( IsType( Type(), GenericClientType ) )
-		(*file)	<< "," << 1;	// currently only 1 target (server) per client
+	if (IsType(Type(), GenericClientType))
+		(*file) << "," << 1;	// currently only 1 target (server) per client
 	else
-		(*file) << "," << TargetCount( ActiveType );
+		(*file) << "," << TargetCount(ActiveType);
 
-	(*file)	<< "," << results[WHOLE_TEST_PERF].IOps 
-			<< "," << results[WHOLE_TEST_PERF].read_IOps 
-			<< "," << results[WHOLE_TEST_PERF].write_IOps 
-			<< "," << results[WHOLE_TEST_PERF].MBps 
-			<< "," << results[WHOLE_TEST_PERF].read_MBps 
-			<< "," << results[WHOLE_TEST_PERF].write_MBps
-			<< "," << results[WHOLE_TEST_PERF].transactions_per_second 
-			<< "," << results[WHOLE_TEST_PERF].connections_per_second 
-			<< "," << results[WHOLE_TEST_PERF].ave_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_write_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].ave_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_write_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].max_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].total_errors 
-			<< "," << results[WHOLE_TEST_PERF].raw.read_errors 
-			<< "," << results[WHOLE_TEST_PERF].raw.write_errors 
+	(*file) << "," << results[WHOLE_TEST_PERF].IOps
+	    << "," << results[WHOLE_TEST_PERF].read_IOps
+	    << "," << results[WHOLE_TEST_PERF].write_IOps
+	    << "," << results[WHOLE_TEST_PERF].MBps
+	    << "," << results[WHOLE_TEST_PERF].read_MBps
+	    << "," << results[WHOLE_TEST_PERF].write_MBps
+	    << "," << results[WHOLE_TEST_PERF].transactions_per_second
+	    << "," << results[WHOLE_TEST_PERF].connections_per_second
+	    << "," << results[WHOLE_TEST_PERF].ave_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_read_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_write_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].ave_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].max_latency
+	    << "," << results[WHOLE_TEST_PERF].max_read_latency
+	    << "," << results[WHOLE_TEST_PERF].max_write_latency
+	    << "," << results[WHOLE_TEST_PERF].max_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].max_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].total_errors
+	    << "," << results[WHOLE_TEST_PERF].raw.read_errors << "," << results[WHOLE_TEST_PERF].raw.write_errors
+	    // Writing raw result information for completed I/Os.
+	    << "," << results[WHOLE_TEST_PERF].raw.bytes_read
+	    << "," << results[WHOLE_TEST_PERF].raw.bytes_written
+	    << "," << results[WHOLE_TEST_PERF].raw.read_count
+	    << "," << results[WHOLE_TEST_PERF].raw.write_count
+	    << "," << results[WHOLE_TEST_PERF].raw.connection_count << ",";
 
-			// Writing raw result information for completed I/Os.
-			<< "," << results[WHOLE_TEST_PERF].raw.bytes_read 
-			<< "," << results[WHOLE_TEST_PERF].raw.bytes_written 
-			<< "," << results[WHOLE_TEST_PERF].raw.read_count 
-			<< "," << results[WHOLE_TEST_PERF].raw.write_count 
-			<< "," << results[WHOLE_TEST_PERF].raw.connection_count << ",";
-
-	if ( GetConnectionRate( ActiveType ) == ENABLED_VALUE )
-		(*file) << GetTransPerConn( ActiveType );
+	if (GetConnectionRate(ActiveType) == ENABLED_VALUE)
+		(*file) << GetTransPerConn(ActiveType);
 	else
 		(*file) << AMBIGUOUS_VALUE;
 
-	(*file) << "," << results[WHOLE_TEST_PERF].raw.read_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.write_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.transaction_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.connection_latency_sum 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_read_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_write_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_transaction_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.max_raw_connection_latency 
-			<< "," << results[WHOLE_TEST_PERF].raw.counter_time;
+	(*file) << "," << results[WHOLE_TEST_PERF].raw.read_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.write_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.transaction_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.connection_latency_sum
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_read_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_write_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_transaction_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.max_raw_connection_latency
+	    << "," << results[WHOLE_TEST_PERF].raw.counter_time;
 
-	(*file) << "," << GetDiskStart( (TargetType)(GenericDiskType | ActiveType) )
-			<< "," << GetDiskSize( (TargetType)(GenericDiskType | ActiveType) )
-			<< "," << GetQueueDepth( ActiveType );
+	(*file) << "," << GetDiskStart((TargetType) (GenericDiskType | ActiveType))
+	    << "," << GetDiskSize((TargetType) (GenericDiskType | ActiveType))
+	    << "," << GetQueueDepth(ActiveType);
 
-	for ( stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++ )
-		(*file) << ",";// Space for CPU utilization
+	for (stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++)
+		(*file) << ",";	// Space for CPU utilization
 
-	(*file) << "," << manager->processor_speed 
-			<< ",,"; // Space for IRQ/sec, CPU_effectiveness
+	(*file) << "," << manager->processor_speed << ",,";	// Space for IRQ/sec, CPU_effectiveness
 
-	for ( stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++ )
-	{
-		(*file) << ",";// Space for network results
+	for (stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++) {
+		(*file) << ",";	// Space for network results
 	}
 
 	(*file) << endl;
 
 	// If requested, save target results.
-	if ( result_type != RecordAll )
+	if (result_type != RecordAll)
 		return;
 
 	// Saving results for all targets.
-	if ( IsType( Type(), GenericClientType ) )
-	{
+	if (IsType(Type(), GenericClientType)) {
 		// Network clients have their server as their target, but do not have
 		// any other targets.  Eventually, a client may be able to be a client
 		// as well as a server, disk worker, etc.  This will require changes
 		// in how a client's results are gathered and stored, until then, the
 		// following code will work-around the issue by assuming that a client
 		// has only a single server target.
-		if ( !(target = new Target) )
-		{
-			ErrorMessage( "Unable to allocate memory saving results." );
+		if (!(target = new Target)) {
+			ErrorMessage("Unable to allocate memory saving results.");
 			return;
 		}
 		target_count = 1;
-		memcpy( &target->results[WHOLE_TEST_PERF], &results[WHOLE_TEST_PERF], sizeof(Results) );
+		memcpy(&target->results[WHOLE_TEST_PERF], &results[WHOLE_TEST_PERF], sizeof(Results));
 		target->spec.type = Type();
 
 		// Store local and remote addresses.
-		if ( IsType( target->spec.type, TCPClientType ) )
-		{
-			strcpy( target->spec.name, net_partner->GetTarget( 
-				net_target_index )->spec.tcp_info.remote_address );
-			strcpy( target->spec.tcp_info.remote_address, 
-				net_partner->GetTarget( net_target_index )->spec.name );
+		if (IsType(target->spec.type, TCPClientType)) {
+			strcpy(target->spec.name,
+			       net_partner->GetTarget(net_target_index)->spec.tcp_info.remote_address);
+			strcpy(target->spec.tcp_info.remote_address,
+			       net_partner->GetTarget(net_target_index)->spec.name);
+		} else {
+			strcpy(target->spec.name,
+			       net_partner->GetTarget(net_target_index)->spec.vi_info.remote_nic_name);
+			strcpy(target->spec.vi_info.remote_nic_name,
+			       net_partner->GetTarget(net_target_index)->spec.name);
 		}
-		else
-		{
-			strcpy( target->spec.name, net_partner->GetTarget( 
-				net_target_index )->spec.vi_info.remote_nic_name );
-			strcpy( target->spec.vi_info.remote_nic_name, 
-				net_partner->GetTarget( net_target_index )->spec.name );
-		}
-	}
-	else
-	{
+	} else {
 		target_count = TargetCount();
 	}
 
-	for ( i = 0; i < target_count; i++ )
-	{
-		if ( !IsType( Type(), GenericClientType ) )
-			target = GetTarget( i );
-		if ( !IsType( target->spec.type, ActiveType ) )
+	for (i = 0; i < target_count; i++) {
+		if (!IsType(Type(), GenericClientType))
+			target = GetTarget(i);
+		if (!IsType(target->spec.type, ActiveType))
 			continue;
 
 		// Retrieving results for a single target in order to save it to a file.
-		if ( IsType( target->spec.type, GenericDiskType ) )
-		{
-			(*file) << "DISK" << ","
-					<< target->spec.name;
-		}
-		else if ( IsType( target->spec.type, TCPClientType ) )
-		{
+		if (IsType(target->spec.type, GenericDiskType)) {
+			(*file) << "DISK" << "," << target->spec.name;
+		} else if (IsType(target->spec.type, TCPClientType)) {
 			// Show name as local address >> remote address.
-			(*file) << "NETWORK" << ","	<< manager->name << ":" 
-				<< target->spec.name << " >> "
-				<< net_partner->manager->name << ":" 
-				<< target->spec.tcp_info.remote_address;
-		}
-		else if ( IsType( target->spec.type, VIClientType ) )
-		{
+			(*file) << "NETWORK" << "," << manager->name << ":"
+			    << target->spec.name << " >> "
+			    << net_partner->manager->name << ":" << target->spec.tcp_info.remote_address;
+		} else if (IsType(target->spec.type, VIClientType)) {
 			// Show name as local address >> remote address.
-			(*file) << "NETWORK" << ","	<< manager->name << ":"
-				<< target->spec.name << " >> "
-				<< net_partner->manager->name << ":" 
-				<< target->spec.vi_info.remote_nic_name;
-		}
-		else
-		{
+			(*file) << "NETWORK" << "," << manager->name << ":"
+			    << target->spec.name << " >> "
+			    << net_partner->manager->name << ":" << target->spec.vi_info.remote_nic_name;
+		} else {
 			(*file) << "UNKNOWN" << "," << target->spec.name;
 		}
 
-		(*file)	<< ",,,," // space for access spec name, workers, managers and targets running.
-				<< "," << target->results[WHOLE_TEST_PERF].IOps 
-				<< "," << target->results[WHOLE_TEST_PERF].read_IOps 
-				<< "," << target->results[WHOLE_TEST_PERF].write_IOps 
-				<< "," << target->results[WHOLE_TEST_PERF].MBps 
-				<< "," << target->results[WHOLE_TEST_PERF].read_MBps 
-				<< "," << target->results[WHOLE_TEST_PERF].write_MBps 
-				<< "," << target->results[WHOLE_TEST_PERF].transactions_per_second 
-				<< "," << target->results[WHOLE_TEST_PERF].connections_per_second 
-				<< "," << target->results[WHOLE_TEST_PERF].ave_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].ave_read_latency
-				<< "," << target->results[WHOLE_TEST_PERF].ave_write_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].ave_transaction_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].ave_connection_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].max_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].max_read_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].max_write_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].max_transaction_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].max_connection_latency 
-				<< "," << target->results[WHOLE_TEST_PERF].total_errors 
-				<< "," << target->results[WHOLE_TEST_PERF].raw.read_errors 
-				<< "," << target->results[WHOLE_TEST_PERF].raw.write_errors 
-				<< "," << target->results[WHOLE_TEST_PERF].raw.bytes_read 
-				<< "," << target->results[WHOLE_TEST_PERF].raw.bytes_written 
-				<< "," << target->results[WHOLE_TEST_PERF].raw.read_count 
-				<< "," << target->results[WHOLE_TEST_PERF].raw.write_count
-				<< "," << target->results[WHOLE_TEST_PERF].raw.connection_count << ",";
+		(*file) << ",,,,"	// space for access spec name, workers, managers and targets running.
+		    << "," << target->results[WHOLE_TEST_PERF].IOps
+		    << "," << target->results[WHOLE_TEST_PERF].read_IOps
+		    << "," << target->results[WHOLE_TEST_PERF].write_IOps
+		    << "," << target->results[WHOLE_TEST_PERF].MBps
+		    << "," << target->results[WHOLE_TEST_PERF].read_MBps
+		    << "," << target->results[WHOLE_TEST_PERF].write_MBps
+		    << "," << target->results[WHOLE_TEST_PERF].transactions_per_second
+		    << "," << target->results[WHOLE_TEST_PERF].connections_per_second
+		    << "," << target->results[WHOLE_TEST_PERF].ave_latency
+		    << "," << target->results[WHOLE_TEST_PERF].ave_read_latency
+		    << "," << target->results[WHOLE_TEST_PERF].ave_write_latency
+		    << "," << target->results[WHOLE_TEST_PERF].ave_transaction_latency
+		    << "," << target->results[WHOLE_TEST_PERF].ave_connection_latency
+		    << "," << target->results[WHOLE_TEST_PERF].max_latency
+		    << "," << target->results[WHOLE_TEST_PERF].max_read_latency
+		    << "," << target->results[WHOLE_TEST_PERF].max_write_latency
+		    << "," << target->results[WHOLE_TEST_PERF].max_transaction_latency
+		    << "," << target->results[WHOLE_TEST_PERF].max_connection_latency
+		    << "," << target->results[WHOLE_TEST_PERF].total_errors
+		    << "," << target->results[WHOLE_TEST_PERF].raw.read_errors
+		    << "," << target->results[WHOLE_TEST_PERF].raw.write_errors
+		    << "," << target->results[WHOLE_TEST_PERF].raw.bytes_read
+		    << "," << target->results[WHOLE_TEST_PERF].raw.bytes_written
+		    << "," << target->results[WHOLE_TEST_PERF].raw.read_count
+		    << "," << target->results[WHOLE_TEST_PERF].raw.write_count
+		    << "," << target->results[WHOLE_TEST_PERF].raw.connection_count << ",";
 
-		if ( GetConnectionRate( ActiveType ) == ENABLED_VALUE )
-			(*file) << GetTransPerConn( ActiveType );
+		if (GetConnectionRate(ActiveType) == ENABLED_VALUE)
+			(*file) << GetTransPerConn(ActiveType);
 		else
 			(*file) << AMBIGUOUS_VALUE;
 
-		(*file)	<< "," << results[WHOLE_TEST_PERF].raw.read_latency_sum
-				<< "," << results[WHOLE_TEST_PERF].raw.write_latency_sum
-				<< "," << results[WHOLE_TEST_PERF].raw.transaction_latency_sum
-				<< "," << results[WHOLE_TEST_PERF].raw.connection_latency_sum
-				<< "," << results[WHOLE_TEST_PERF].raw.max_raw_read_latency
-				<< "," << results[WHOLE_TEST_PERF].raw.max_raw_write_latency
-				<< "," << results[WHOLE_TEST_PERF].raw.max_raw_transaction_latency
-				<< "," << results[WHOLE_TEST_PERF].raw.max_raw_connection_latency
-				<< "," << results[WHOLE_TEST_PERF].raw.counter_time;
+		(*file) << "," << results[WHOLE_TEST_PERF].raw.read_latency_sum
+		    << "," << results[WHOLE_TEST_PERF].raw.write_latency_sum
+		    << "," << results[WHOLE_TEST_PERF].raw.transaction_latency_sum
+		    << "," << results[WHOLE_TEST_PERF].raw.connection_latency_sum
+		    << "," << results[WHOLE_TEST_PERF].raw.max_raw_read_latency
+		    << "," << results[WHOLE_TEST_PERF].raw.max_raw_write_latency
+		    << "," << results[WHOLE_TEST_PERF].raw.max_raw_transaction_latency
+		    << "," << results[WHOLE_TEST_PERF].raw.max_raw_connection_latency
+		    << "," << results[WHOLE_TEST_PERF].raw.counter_time;
 
-		(*file) << "," << GetDiskStart( (TargetType)(GenericDiskType | ActiveType) )
-				<< "," << GetDiskSize( (TargetType)(GenericDiskType | ActiveType) )
-				<< "," << GetQueueDepth( ActiveType );
+		(*file) << "," << GetDiskStart((TargetType) (GenericDiskType | ActiveType))
+		    << "," << GetDiskSize((TargetType) (GenericDiskType | ActiveType))
+		    << "," << GetQueueDepth(ActiveType);
 
-		for ( stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++ )
-			(*file) << ",";// Space for CPU utilization
-		(*file) << "," << manager->processor_speed 
-				<< ",,"; // Space for IRQ/sec and CPU_effectiveness.
+		for (stat = 0; stat < CPU_UTILIZATION_RESULTS; stat++)
+			(*file) << ",";	// Space for CPU utilization
+		(*file) << "," << manager->processor_speed << ",,";	// Space for IRQ/sec and CPU_effectiveness.
 
-		for ( stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++ )
-			(*file) << ",";// Space for network results
+		for (stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++)
+			(*file) << ",";	// Space for network results
 
 		(*file) << endl;
 	}
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		delete target;
 }
 
-
-
 //
 // Updating the workers results for the last test.  This functions performs
 // some heavy duty calculations.  Enter at your own risk.
 //
-void Worker::UpdateResults( int which_perf )
+void Worker::UpdateResults(int which_perf)
 {
-	Data_Message	data_msg;
-	double		run_time;
-	Worker_Results	*new_wkr_results;
-	Results		*device_results;		// Results for a specific target.
-	Raw_Result	*raw;					// Raw results stored for the worker.
-	Raw_Result	*raw_device_results;	// Raw results returned for a single device.
-	double		processor_speed;
+	Data_Message data_msg;
+	double run_time;
+	Worker_Results *new_wkr_results;
+	Results *device_results;	// Results for a specific target.
+	Raw_Result *raw;	// Raw results stored for the worker.
+	Raw_Result *raw_device_results;	// Raw results returned for a single device.
+	double processor_speed;
 
-	if ( (which_perf < 0) || (which_perf >= MAX_PERF) )
+	if ((which_perf < 0) || (which_perf >= MAX_PERF))
 		return;
 
 	// Initializing worker's results.
@@ -1014,127 +873,101 @@
 
 	// Receive the update from Dynamo.  The manager should have already made
 	// the request.
-	if ( manager->ReceiveData( &data_msg ) == PORT_ERROR )
+	if (manager->ReceiveData(&data_msg) == PORT_ERROR)
 		return;
 
 	new_wkr_results = &(data_msg.data.worker_results);
 	raw = &(results[which_perf].raw);
-	raw->counter_time = new_wkr_results->time[LAST_SNAPSHOT] - 
-		new_wkr_results->time[FIRST_SNAPSHOT];
-	run_time = ( (double) raw->counter_time ) / processor_speed;
+	raw->counter_time = new_wkr_results->time[LAST_SNAPSHOT] - new_wkr_results->time[FIRST_SNAPSHOT];
+	run_time = ((double)raw->counter_time) / processor_speed;
 
 	// Network clients do not *have* targets, but rather, *are* the targets.
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		device_results = new Results;
 
 	// Updating device results for worker reporting results.
-	for ( int i = 0; i < new_wkr_results->target_results.count; i++ )
-	{
-		if ( !IsType( Type(), GenericClientType ) )
-			device_results = &(GetTarget( i )->results[which_perf]);
+	for (int i = 0; i < new_wkr_results->target_results.count; i++) {
+		if (!IsType(Type(), GenericClientType))
+			device_results = &(GetTarget(i)->results[which_perf]);
 
-		raw_device_results = 
-			&(new_wkr_results->target_results.result[i]);
+		raw_device_results = &(new_wkr_results->target_results.result[i]);
 
 		// Copy reported raw results to results stored for the device.
-		memcpy( (void*) &(device_results->raw), raw_device_results, 
-			sizeof( Raw_Result ) );
+		memcpy((void *)&(device_results->raw), raw_device_results, sizeof(Raw_Result));
 
 		//
 		// Updating error results.
 		//
 		// Recording errors which have occurred to the device.
-		device_results->total_errors = raw_device_results->read_errors 
-			+ raw_device_results->write_errors;
+		device_results->total_errors = raw_device_results->read_errors + raw_device_results->write_errors;
 
 		// Updating recorded results for worker.
-		raw->read_errors		+=	raw_device_results->read_errors;
-		raw->write_errors		+=	raw_device_results->write_errors;
-		results[which_perf].total_errors	+=	device_results->total_errors;
+		raw->read_errors += raw_device_results->read_errors;
+		raw->write_errors += raw_device_results->write_errors;
+		results[which_perf].total_errors += device_results->total_errors;
 
 		//
 		// Updating maximum latency information.
 		//
 		// Determining maximum latencies of device.
-		device_results->max_read_latency = ((double) (_int64) 
-			raw_device_results->max_raw_read_latency) * (double) 1000 / 
-			processor_speed;
-		device_results->max_write_latency = ((double) (_int64) 
-			raw_device_results->max_raw_write_latency) * (double) 1000 / 
-			processor_speed;
-		device_results->max_transaction_latency = ((double) (_int64)
-			raw_device_results->max_raw_transaction_latency) * (double) 1000 / 
-			processor_speed;
-		device_results->max_connection_latency = ((double) (_int64) 
-			raw_device_results->max_raw_connection_latency) * (double) 1000 / 
-			processor_speed;
-		if ( device_results->max_read_latency > 
-			device_results->max_write_latency )
-		{
+		device_results->max_read_latency = ((double)(_int64)
+						    raw_device_results->max_raw_read_latency) * (double)1000 /
+		    processor_speed;
+		device_results->max_write_latency = ((double)(_int64)
+						     raw_device_results->max_raw_write_latency) * (double)1000 /
+		    processor_speed;
+		device_results->max_transaction_latency = ((double)(_int64)
+							   raw_device_results->max_raw_transaction_latency) *
+		    (double)1000 / processor_speed;
+		device_results->max_connection_latency = ((double)(_int64)
+							  raw_device_results->max_raw_connection_latency) *
+		    (double)1000 / processor_speed;
+		if (device_results->max_read_latency > device_results->max_write_latency) {
 			device_results->max_latency = device_results->max_read_latency;
-		}
-		else
-		{
+		} else {
 			device_results->max_latency = device_results->max_write_latency;
 		}
 
 		// Determining maximum latencies of worker.
-		if ( device_results->max_read_latency > results[which_perf].max_read_latency )
-		{
+		if (device_results->max_read_latency > results[which_perf].max_read_latency) {
 			results[which_perf].max_read_latency = device_results->max_read_latency;
-			raw->max_raw_read_latency = 
-				raw_device_results->max_raw_read_latency;
+			raw->max_raw_read_latency = raw_device_results->max_raw_read_latency;
 		}
-		if ( device_results->max_write_latency > results[which_perf].max_write_latency )
-		{
+		if (device_results->max_write_latency > results[which_perf].max_write_latency) {
 			results[which_perf].max_write_latency = device_results->max_write_latency;
-			raw->max_raw_write_latency = 
-				raw_device_results->max_raw_write_latency;
+			raw->max_raw_write_latency = raw_device_results->max_raw_write_latency;
 		}
-		if ( device_results->max_transaction_latency > 
-			results[which_perf].max_transaction_latency )
-		{
-			results[which_perf].max_transaction_latency = 
-				device_results->max_transaction_latency;
-			raw->max_raw_transaction_latency = 
-				raw_device_results->max_raw_transaction_latency;
+		if (device_results->max_transaction_latency > results[which_perf].max_transaction_latency) {
+			results[which_perf].max_transaction_latency = device_results->max_transaction_latency;
+			raw->max_raw_transaction_latency = raw_device_results->max_raw_transaction_latency;
 		}
-		if ( device_results->max_latency > results[which_perf].max_latency )
+		if (device_results->max_latency > results[which_perf].max_latency)
 			results[which_perf].max_latency = device_results->max_latency;
-		if ( device_results->max_connection_latency > 
-			results[which_perf].max_connection_latency )
-		{
-			results[which_perf].max_connection_latency = 
-				device_results->max_connection_latency;
-			raw->max_raw_connection_latency = 
-				raw_device_results->max_raw_connection_latency;
+		if (device_results->max_connection_latency > results[which_perf].max_connection_latency) {
+			results[which_perf].max_connection_latency = device_results->max_connection_latency;
+			raw->max_raw_connection_latency = raw_device_results->max_raw_connection_latency;
 		}
-
 		//
 		// Updating throughput data.
 		//
 		// Calculating MB/s and IO/s data rates.
-		if ( run_time )
-		{
+		if (run_time) {
 			// Calculating results on a per drive basis.
-			device_results->read_MBps = ( (double) (_int64) 
-				raw_device_results->bytes_read / (double) MEGABYTE ) / run_time;
-			device_results->write_MBps = ( (double) (_int64) 
-				raw_device_results->bytes_written / (double) MEGABYTE ) / run_time;
-			device_results->MBps = device_results->read_MBps + 
-				device_results->write_MBps;
-			device_results->read_IOps = ( (double) (_int64) 
-				raw_device_results->read_count ) / run_time;
-			device_results->write_IOps = ( (double) (_int64) 
-				raw_device_results->write_count ) / run_time;
-			device_results->IOps = device_results->read_IOps + 
-				device_results->write_IOps;
-			device_results->transactions_per_second = ( (double) (_int64) 
-				raw_device_results->transaction_count ) / run_time;
-			device_results->connections_per_second = ( (double) (_int64) 
-				raw_device_results->connection_count ) / run_time;
+			device_results->read_MBps = ((double)(_int64)
+						     raw_device_results->bytes_read / (double)MEGABYTE) / run_time;
+			device_results->write_MBps = ((double)(_int64)
+						      raw_device_results->bytes_written / (double)MEGABYTE) / run_time;
+			device_results->MBps = device_results->read_MBps + device_results->write_MBps;
+			device_results->read_IOps = ((double)(_int64)
+						     raw_device_results->read_count) / run_time;
+			device_results->write_IOps = ((double)(_int64)
+						      raw_device_results->write_count) / run_time;
+			device_results->IOps = device_results->read_IOps + device_results->write_IOps;
+			device_results->transactions_per_second = ((double)(_int64)
+								   raw_device_results->transaction_count) / run_time;
+			device_results->connections_per_second = ((double)(_int64)
+								  raw_device_results->connection_count) / run_time;
 
-			
 			// Updating results for the worker based on the results reported for individual drives.
 
 			// Raw results.
@@ -1152,194 +985,148 @@
 			results[which_perf].IOps += device_results->IOps;
 			results[which_perf].read_IOps += device_results->read_IOps;
 			results[which_perf].write_IOps += device_results->write_IOps;
-			results[which_perf].transactions_per_second += 
-				device_results->transactions_per_second;
-			results[which_perf].connections_per_second += 
-				device_results->connections_per_second;
+			results[which_perf].transactions_per_second += device_results->transactions_per_second;
+			results[which_perf].connections_per_second += device_results->connections_per_second;
+		} else {
+			device_results->MBps = (double)0;
+			device_results->read_MBps = (double)0;
+			device_results->write_MBps = (double)0;
+			device_results->IOps = (double)0;
+			device_results->read_IOps = (double)0;
+			device_results->write_IOps = (double)0;
+			device_results->transactions_per_second = (double)0;
+			device_results->connections_per_second = (double)0;
 		}
-		else
-		{
-			device_results->MBps = (double) 0;
-			device_results->read_MBps = (double) 0;
-			device_results->write_MBps = (double) 0;
-			device_results->IOps = (double) 0;
-			device_results->read_IOps = (double) 0;
-			device_results->write_IOps = (double) 0;
-			device_results->transactions_per_second = (double) 0;
-			device_results->connections_per_second = (double) 0;
-		}
 
 		// Determining average latencies of transfers to a single drive.
-		if ( raw_device_results->read_count || raw_device_results->write_count )
-		{
-			device_results->ave_latency = ((double) (_int64) 
-				(raw_device_results->read_latency_sum + 
-				raw_device_results->write_latency_sum) )
-				* (double) 1000 / processor_speed / (double) (_int64) 
-				(raw_device_results->read_count + 
-				raw_device_results->write_count);
+		if (raw_device_results->read_count || raw_device_results->write_count) {
+			device_results->ave_latency = ((double)(_int64)
+						       (raw_device_results->read_latency_sum +
+							raw_device_results->write_latency_sum))
+			    * (double)1000 / processor_speed / (double)(_int64)
+			    (raw_device_results->read_count + raw_device_results->write_count);
 
-			if ( raw_device_results->read_count )
-			{
-				device_results->ave_read_latency = ((double) (_int64) 
-					raw_device_results->read_latency_sum ) * (double) 1000 
-					/ processor_speed / (double) (_int64) 
-					raw_device_results->read_count;
-				raw->read_latency_sum += 
-					raw_device_results->read_latency_sum;
+			if (raw_device_results->read_count) {
+				device_results->ave_read_latency = ((double)(_int64)
+								    raw_device_results->read_latency_sum) * (double)1000
+				    / processor_speed / (double)(_int64)
+				    raw_device_results->read_count;
+				raw->read_latency_sum += raw_device_results->read_latency_sum;
+			} else {
+				device_results->ave_read_latency = (double)0;
 			}
-			else
-			{
-				device_results->ave_read_latency = (double) 0;
-			}
 
-			if ( raw_device_results->write_count )
-			{
-				device_results->ave_write_latency = ((double) (_int64) 
-					raw_device_results->write_latency_sum ) * (double) 1000 
-					/ processor_speed / (double) (_int64) 
-					raw_device_results->write_count;
-				raw->write_latency_sum += 
-					raw_device_results->write_latency_sum;
+			if (raw_device_results->write_count) {
+				device_results->ave_write_latency = ((double)(_int64)
+								     raw_device_results->write_latency_sum) *
+				    (double)1000 / processor_speed / (double)(_int64)
+				    raw_device_results->write_count;
+				raw->write_latency_sum += raw_device_results->write_latency_sum;
+			} else {
+				device_results->ave_write_latency = (double)0;
 			}
-			else
-			{
-				device_results->ave_write_latency = (double) 0;
-			}
 
-			if ( raw_device_results->transaction_count )
-			{
-				device_results->ave_transaction_latency = ((double) (_int64) 
-					raw_device_results->transaction_latency_sum ) * (double) 
-					1000 / processor_speed / (double) (_int64) 
-					(raw_device_results->transaction_count);
-				raw->transaction_latency_sum += 
-					raw_device_results->transaction_latency_sum;
+			if (raw_device_results->transaction_count) {
+				device_results->ave_transaction_latency = ((double)(_int64)
+									   raw_device_results->
+									   transaction_latency_sum) * (double)
+				    1000 / processor_speed / (double)(_int64)
+				    (raw_device_results->transaction_count);
+				raw->transaction_latency_sum += raw_device_results->transaction_latency_sum;
+			} else {
+				device_results->ave_transaction_latency = (double)0;
 			}
-			else
-			{
-				device_results->ave_transaction_latency = (double) 0;
-			}
+		} else {
+			device_results->ave_latency = (double)0;
+			device_results->ave_read_latency = (double)0;
+			device_results->ave_write_latency = (double)0;
+			device_results->ave_transaction_latency = (double)0;
 		}
-		else
-		{
-			device_results->ave_latency = (double) 0;
-			device_results->ave_read_latency = (double) 0;
-			device_results->ave_write_latency = (double) 0;
-			device_results->ave_transaction_latency = (double) 0;
-		}
 
 		// Determining the average connection time for each drive.
-		if ( raw_device_results->connection_count )
-		{
+		if (raw_device_results->connection_count) {
 			// Calculate the average connection time.
-			device_results->ave_connection_latency = ((double) (_int64) 
-				(raw_device_results->connection_latency_sum)) * (double ) 1000 / 
-				processor_speed / (double) (_int64) 
-				(raw_device_results->connection_count);
+			device_results->ave_connection_latency = ((double)(_int64)
+								  (raw_device_results->connection_latency_sum)) *
+			    (double)1000 / processor_speed / (double)(_int64)
+			    (raw_device_results->connection_count);
 			raw->connection_latency_sum += raw_device_results->connection_latency_sum;
+		} else {
+			device_results->ave_connection_latency = (double)0;
 		}
-		else
-		{
-			device_results->ave_connection_latency = (double) 0;
-		}
 	}
 
 	// Calculating average latencies for the worker.
-	if ( raw->read_count || raw->write_count )
-	{
-		results[which_perf].ave_latency = (double) (_int64) (raw->read_latency_sum + 
-			raw->write_latency_sum) * (double) 1000 / processor_speed 
-			/ (double) (_int64) (raw->read_count + raw->write_count);
+	if (raw->read_count || raw->write_count) {
+		results[which_perf].ave_latency = (double)(_int64) (raw->read_latency_sum +
+								    raw->write_latency_sum) * (double)1000 /
+		    processor_speed / (double)(_int64) (raw->read_count + raw->write_count);
 
-		if ( raw->read_count )
-		{
-			results[which_perf].ave_read_latency = (double) (_int64) 
-			raw->read_latency_sum * (double) 1000 / processor_speed / 
-			(double) (_int64) raw->read_count;
+		if (raw->read_count) {
+			results[which_perf].ave_read_latency = (double)(_int64)
+			    raw->read_latency_sum * (double)1000 / processor_speed / (double)(_int64) raw->read_count;
+		} else {
+			results[which_perf].ave_read_latency = (double)0;
 		}
-		else
-		{
-			results[which_perf].ave_read_latency = (double) 0;
-		}
 
-		if ( raw->write_count )
-		{
-			results[which_perf].ave_write_latency = (double) (_int64) 
-			raw->write_latency_sum * (double) 1000 / processor_speed / 
-			(double) (_int64) raw->write_count;
+		if (raw->write_count) {
+			results[which_perf].ave_write_latency = (double)(_int64)
+			    raw->write_latency_sum * (double)1000 / processor_speed / (double)(_int64) raw->write_count;
+		} else {
+			results[which_perf].ave_write_latency = (double)0;
 		}
-		else
-		{
-			results[which_perf].ave_write_latency = (double) 0;
-		}
 
-		if ( raw->transaction_count )
-		{
-			results[which_perf].ave_transaction_latency = (double) (_int64) 
-				raw->transaction_latency_sum * (double) 1000 / processor_speed 
-				/ (double) (_int64) (raw->transaction_count);
+		if (raw->transaction_count) {
+			results[which_perf].ave_transaction_latency = (double)(_int64)
+			    raw->transaction_latency_sum * (double)1000 / processor_speed
+			    / (double)(_int64) (raw->transaction_count);
+		} else {
+			results[which_perf].ave_transaction_latency = (double)0;
 		}
-		else
-		{
-			results[which_perf].ave_transaction_latency = (double) 0;
-		}
+	} else {
+		results[which_perf].ave_latency = (double)0;
+		results[which_perf].ave_read_latency = (double)0;
+		results[which_perf].ave_write_latency = (double)0;
+		results[which_perf].ave_transaction_latency = (double)0;
 	}
-	else
-	{
-		results[which_perf].ave_latency = (double) 0;
-		results[which_perf].ave_read_latency = (double) 0;
-		results[which_perf].ave_write_latency = (double) 0;
-		results[which_perf].ave_transaction_latency = (double) 0;
-	}
 
 	// Calculating taverage connection time for the worker.
-	if ( raw->connection_count )
-	{
-		results[which_perf].ave_connection_latency = (double) (_int64) 
-			raw->connection_latency_sum * (double) 1000 
-			/ processor_speed / (double) (_int64) raw->connection_count;
+	if (raw->connection_count) {
+		results[which_perf].ave_connection_latency = (double)(_int64)
+		    raw->connection_latency_sum * (double)1000
+		    / processor_speed / (double)(_int64) raw->connection_count;
+	} else {
+		results[which_perf].ave_connection_latency = (double)0;
 	}
-	else
-	{
-		results[which_perf].ave_connection_latency = (double) 0;
-	}
 
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		delete device_results;
 }
 
-
-
 //
 // Create a network partner (client) for me on the specified manager.  
 // Store a pointer to the newly-created worker in my net_partner member 
 // variable. If there is already a network partner, remove it unless the 
 // requested network partner is on the same manager.
 //
-void Worker::CreateNetClient( Manager *target_manager, TargetType client_type )
+void Worker::CreateNetClient(Manager * target_manager, TargetType client_type)
 {
-	if ( !target_manager )
-	{
-		ErrorMessage( "Invalid parameter in Worker::CreateNetPartner()" );
+	if (!target_manager) {
+		ErrorMessage("Invalid parameter in Worker::CreateNetPartner()");
 		return;
 	}
-
 	// Create the client worker on the target manager (net_partner)
-	if ( !(net_partner = target_manager->AddWorker( client_type ) ) )
-	{
-		ErrorMessage("Could not create new worker in Worker::"
-			"CreateNetPartner().");
+	if (!(net_partner = target_manager->AddWorker(client_type))) {
+		ErrorMessage("Could not create new worker in Worker::" "CreateNetPartner().");
 		return;
 	}
-
 	// Record that I am the client's net_partner and what target it is.
 	net_partner->net_partner = this;
 	net_partner->net_target_index = 0;
-	sprintf( net_partner->name, "[%s]", name );
+	sprintf(net_partner->name, "[%s]", name);
 
 	// add the new worker to the display - this should be handled by the GUI
-	theApp.pView->m_pWorkerView->AddWorker( net_partner );
+	theApp.pView->m_pWorkerView->AddWorker(net_partner);
 
 	// refresh the result display - this should be handled by the GUI
 	theApp.manager_list.ResetAllResults();
@@ -1347,8 +1134,6 @@
 	theApp.pView->ResetDisplayforNewTest();
 }
 
-
-
 ////////////////////////////////////////////////////////////////////////////////////
 //
 // The following functions update the values for the starting sector, the number of
@@ -1358,8 +1143,6 @@
 //
 ////////////////////////////////////////////////////////////////////////////////////
 
-
-
 //
 // Changes the specified value for all targets matching the given type.
 //
@@ -1387,114 +1170,98 @@
 }
 */
 
-
-
-void Worker::SetDiskSize( int disk_size )
+void Worker::SetDiskSize(int disk_size)
 {
-	int	i, target_count;
+	int i, target_count;
 
 	spec.disk_info.maximum_size = disk_size;
 
 	// Loop through all the worker's disks.
-	target_count = TargetCount( GenericDiskType );
-	for ( i = 0; i < target_count; i++ )
-	{
-		GetTarget( i, GenericDiskType )->spec.disk_info.maximum_size = 
-			disk_size;
+	target_count = TargetCount(GenericDiskType);
+	for (i = 0; i < target_count; i++) {
+		GetTarget(i, GenericDiskType)->spec.disk_info.maximum_size = disk_size;
 	}
 }
 
-
-
-void Worker::SetDiskStart( int disk_start )
+void Worker::SetDiskStart(int disk_start)
 {
-	int	i, target_count;
+	int i, target_count;
+
 	spec.disk_info.starting_sector = disk_start;
 
 	// Loop through all the worker's disks.
-	target_count = TargetCount( GenericDiskType );
-	for ( i = 0; i < target_count; i++ )
-	{
-		GetTarget( i, GenericDiskType )->spec.disk_info.starting_sector =
-			disk_start;
+	target_count = TargetCount(GenericDiskType);
+	for (i = 0; i < target_count; i++) {
+		GetTarget(i, GenericDiskType)->spec.disk_info.starting_sector = disk_start;
 	}
 }
 
-
-
 //
 // Sets the queue depth for the worker and all of its targets.
 //
-void Worker::SetQueueDepth( int queue_depth )
+void Worker::SetQueueDepth(int queue_depth)
 {
-	int	i, target_count;
+	int i, target_count;
 
 	// Do not change the queue depth for network workers.  Dynamo does not
 	// support this.
-	if ( !IsType( Type(), GenericDiskType ) )
+	if (!IsType(Type(), GenericDiskType))
 		return;
 
 	// Set the workers queue depth.  We need to do this in case the worker
 	// doesn't have any targets currently assigned.
 	spec.queue_depth = queue_depth;
 
-	if ( !(target_count = TargetCount( GenericDiskType )) )
+	if (!(target_count = TargetCount(GenericDiskType)))
 		return;
 
 	// Set all of the worker's targets.
-	for ( i = 0; i < target_count; i++ )
-		GetTarget( i, GenericDiskType )->spec.queue_depth = queue_depth;
+	for (i = 0; i < target_count; i++)
+		GetTarget(i, GenericDiskType)->spec.queue_depth = queue_depth;
 }
 
-
-
 //
 // Sets the maximum number of sends for the worker and all of its VI targets.
 //
-void Worker::SetMaxSends( int max_sends )
+void Worker::SetMaxSends(int max_sends)
 {
-	int	i, target_count;
+	int i, target_count;
 
 	// Loop through all the worker's targets.
-	target_count = TargetCount( GenericVIType );
-	for ( i = 0; i < target_count; i++ )
-	{
-		GetTarget( i, GenericVIType )->spec.vi_info.outstanding_ios = 
-			max_sends;
+	target_count = TargetCount(GenericVIType);
+	for (i = 0; i < target_count; i++) {
+		GetTarget(i, GenericVIType)->spec.vi_info.outstanding_ios = max_sends;
 	}
 
 	spec.vi_info.outstanding_ios = max_sends;
 }
 
-
-
 //
 // Sets the local address used by network target connections.  It takes as
 // input an index into the worker's manager's interface list.
 //
-void Worker::SetLocalNetworkInterface( int iface_index, TargetType type )
+void Worker::SetLocalNetworkInterface(int iface_index, TargetType type)
 {
-	Target_Spec	*iface;
-	Target		*target;
-	int			i;
+	Target_Spec *iface;
+	Target *target;
+	int i;
 
 	// Only set the address for server workers.  This is not an error.
-	if ( !IsType( Type(), GenericServerType ) )
+	if (!IsType(Type(), GenericServerType))
 		return;
 
 	// Get the new local interface.
-	iface = manager->GetInterface( iface_index, type );
+	iface = manager->GetInterface(iface_index, type);
 
 	// Record what type of worker this is now in case it doesn't have any
 	// targets or they get deleted.
-	switch ( iface->type )
-	{
+	switch (iface->type) {
 	case TCPClientType:
 		spec.type = TCPServerType;
 		break;
 	case VIClientType:
 		// If we're switching types, reset the number of oustanding IOs
-		if ( !IsType( spec.type, GenericVIType ) )
+		if (!IsType(spec.type, GenericVIType))
 			spec.vi_info.outstanding_ios = 1;
 		spec.type = VIServerType;
 		break;
@@ -1502,85 +1269,69 @@
 
 	// Update all targets to be accessed through the specified local interface.
 	// We move backwards to avoid jumping over targets if some get removed.
-	for( i = TargetCount() - 1; i >= 0; i-- )
-	{
-		target = GetTarget( i );
+	for (i = TargetCount() - 1; i >= 0; i--) {
+		target = GetTarget(i);
 
 		// If the target cannot be accessed through the selected interface,
 		// remove it as an active target.
-		if ( !IsType( target->spec.type, iface->type ) )
-		{
-			RemoveTarget( i );
+		if (!IsType(target->spec.type, iface->type)) {
+			RemoveTarget(i);
 			continue;
 		}
-
 		// Update the target information.
-		if ( IsType( target->spec.type, TCPClientType ) )
-		{
+		if (IsType(target->spec.type, TCPClientType)) {
 			// TCP servers only need to copy the address of the interface that
 			// will be used.
-			strcpy( target->spec.name, iface->name );
-		}
-		else if ( IsType( target->spec.type, VIClientType ) )
-		{
+			strcpy(target->spec.name, iface->name);
+		} else if (IsType(target->spec.type, VIClientType)) {
 			// VI servers need the NIC name and network address needed to
 			// make the connection.
-			strcpy( target->spec.name, iface->name );
-			memcpy( &target->spec.vi_info.local_address, 
-				&iface->vi_info.local_address, VI_ADDRESS_SIZE );
+			strcpy(target->spec.name, iface->name);
+			memcpy(&target->spec.vi_info.local_address, &iface->vi_info.local_address, VI_ADDRESS_SIZE);
 			target->spec.vi_info.outstanding_ios = spec.vi_info.outstanding_ios;
 		}
 	}
 
-	strcpy( spec.name, iface->name );
+	strcpy(spec.name, iface->name);
 }
 
-
-
 //
 // Sets the local address used by network target connections.  It takes as
 // input a CString which identifies which network interface is to be used.
 // (FUNCTION OVERLOAD)
 //
-void Worker::SetLocalNetworkInterface(const CString& iface_name)
+void Worker::SetLocalNetworkInterface(const CString & iface_name)
 {
 	int nic_total, nic_counter;
 
 	// Only set the address for server workers.  This is not an error.
-	if ( !IsType( Type(), GenericServerType ) )
+	if (!IsType(Type(), GenericServerType))
 		return;
 
-	nic_total = manager->InterfaceCount( GenericNetType );
+	nic_total = manager->InterfaceCount(GenericNetType);
 
 	// Find the index of the NIC on the manager with the given name.
-	for (nic_counter=0; nic_counter<nic_total; nic_counter++)
-	{
-		if ( iface_name.CompareNoCase(
-			 manager->GetInterface( nic_counter, GenericNetType )->name) == 0 )
-		{
+	for (nic_counter = 0; nic_counter < nic_total; nic_counter++) {
+		if (iface_name.CompareNoCase(manager->GetInterface(nic_counter, GenericNetType)->name) == 0) {
 			break;
 		}
 	}
 
 	// If we went past the end and found no match.  This is an error.
-	if ( nic_counter == nic_total )
-	{
+	if (nic_counter == nic_total) {
 		ErrorMessage("Could not find local network interface \"" + iface_name
-			+ "\" on worker " + (CString)name + ".  Worker::SetLocalNetworkInterface() failed.");
+			     + "\" on worker " + (CString) name + ".  Worker::SetLocalNetworkInterface() failed.");
 		return;
 	}
-
 	// Set the worker to use the specified local
 	// NIC to communicate with the remote target.
-	SetLocalNetworkInterface( nic_counter );
+	SetLocalNetworkInterface(nic_counter);
 }
 
-
-
 // Sets whether the targets will stay open for the duration of the test or 
 // open and close after trans_per_conn transactions.  If test_connection_rate
 // is TRUE, it means that the target will NOT stay open.
-void Worker::SetConnectionRate( BOOL test_connection_rate )
+void Worker::SetConnectionRate(BOOL test_connection_rate)
 {
 	int i, target_count;
 
@@ -1588,12 +1339,11 @@
 
 	// Loop through all the worker's targets.
 	target_count = TargetCount();
-	for ( i = 0; i < target_count; i++ )
+	for (i = 0; i < target_count; i++)
 		GetTarget(i)->spec.test_connection_rate = test_connection_rate;
 }
 
-
-void Worker::SetTransPerConn( int trans_per_conn )
+void Worker::SetTransPerConn(int trans_per_conn)
 {
 	int i, target_count;
 
@@ -1601,11 +1351,10 @@
 
 	// Loop through all the worker's targets.
 	target_count = TargetCount();
-	for ( i = 0; i < target_count; i++ )
+	for (i = 0; i < target_count; i++)
 		GetTarget(i)->spec.trans_per_conn = trans_per_conn;
 }
 
-
 ///////////////////////////////////////////////
 //
 // Functions to retrieve worker information
@@ -1615,7 +1364,6 @@
 //
 ///////////////////////////////////////////////
 
-
 //
 // Get a stored value from the specified offset into the Target_Spec.  Return
 // the value if all similar targets have the same value, otherwise return an
@@ -1651,305 +1399,273 @@
 }
 */
 
-
-
-int Worker::GetConnectionRate( TargetType type )
+int Worker::GetConnectionRate(TargetType type)
 {
-	if ( IsType( Type(), GenericClientType ) )
-		return net_partner->GetConnectionRate( type );
+	if (IsType(Type(), GenericClientType))
+		return net_partner->GetConnectionRate(type);
 
-	if ( !IsType( Type(), type ) )
+	if (!IsType(Type(), type))
 		return AMBIGUOUS_VALUE;
 
 	// Assume that all targets have the same value.
-	if ( spec.test_connection_rate )
+	if (spec.test_connection_rate)
 		return ENABLED_VALUE;
 	else
 		return DISABLED_VALUE;
 }
 
-
-int	Worker::GetDiskStart( TargetType type )
+int Worker::GetDiskStart(TargetType type)
 {
-	if ( !IsType( Type(), type ) )
+	if (!IsType(Type(), type))
 		return AMBIGUOUS_VALUE;
 
 	// Assume that all targets have the same value.
 	return spec.disk_info.starting_sector;
 }
 
-
-int Worker::GetDiskSize( TargetType type )
+int Worker::GetDiskSize(TargetType type)
 {
-	if ( !IsType( Type(), type ) )
+	if (!IsType(Type(), type))
 		return AMBIGUOUS_VALUE;
 
 	// Assume that all targets have the same value.
 	return spec.disk_info.maximum_size;
 }
 
-
-char* Worker::GetLocalNetworkInterface()
+char *Worker::GetLocalNetworkInterface()
 {
-	if ( IsType( Type(), GenericServerType ) )
-	{
+	if (IsType(Type(), GenericServerType)) {
 		return spec.name;
-	}
-	else if ( IsType( Type(), GenericClientType ) )
-	{
-		if ( IsType( Type(), GenericVIType ) )
-		{
-			return net_partner->GetTarget( net_target_index 
-				)->spec.vi_info.remote_nic_name;
+	} else if (IsType(Type(), GenericClientType)) {
+		if (IsType(Type(), GenericVIType)) {
+			return net_partner->GetTarget(net_target_index)->spec.vi_info.remote_nic_name;
+		} else {
+			return net_partner->GetTarget(net_target_index)->spec.tcp_info.remote_address;
 		}
-		else
-		{
-			return net_partner->GetTarget( net_target_index
-				)->spec.tcp_info.remote_address;
-		}
-	}
-	else
-	{
+	} else {
 		return NULL;
 	}
 }
 
-
-
 //
 // Return a valid queue depth if all targets of the specified type
 // have the same one.
 //
-int Worker::GetQueueDepth( TargetType type )
+int Worker::GetQueueDepth(TargetType type)
 {
-	if ( IsType( Type(), GenericClientType ) )
-		return net_partner->GetQueueDepth( type );
+	if (IsType(Type(), GenericClientType))
+		return net_partner->GetQueueDepth(type);
 
-	if ( !IsType( Type(), type ) )
+	if (!IsType(Type(), type))
 		return AMBIGUOUS_VALUE;
 
 	// Assume all targets have the same value.
 	return spec.queue_depth;
 }
 
-
-
 //
 // Return a valid maximum number of outstanding sends if all targets of the 
 // specified type have the same one.
 //
-int Worker::GetMaxSends( TargetType type )
+int Worker::GetMaxSends(TargetType type)
 {
-	if ( IsType( Type(), GenericClientType ) )
-		return net_partner->GetMaxSends( type );
+	if (IsType(Type(), GenericClientType))
+		return net_partner->GetMaxSends(type);
 
-	if ( !IsType( Type(), type ) )
+	if (!IsType(Type(), type))
 		return AMBIGUOUS_VALUE;
 
 	// Assume all targets have the same value.
 	return spec.vi_info.outstanding_ios;
 }
 
-
-
-int Worker::GetTransPerConn( TargetType type )
+int Worker::GetTransPerConn(TargetType type)
 {
-	if ( IsType( Type(), GenericClientType ) )
-		return net_partner->GetTransPerConn( type );
+	if (IsType(Type(), GenericClientType))
+		return net_partner->GetTransPerConn(type);
 
-	if ( !IsType( Type(), type ) )
+	if (!IsType(Type(), type))
 		return AMBIGUOUS_VALUE;
 
 	// Assume all targets have the same value.
 	return spec.trans_per_conn;
 }
 
-
-
 //
 // Return the maximum number of I/Os that can be outstanding to a single
 // target.
 //
-int Worker::MaxOutstandingIOs( int target_index )
+int Worker::MaxOutstandingIOs(int target_index)
 {
 	// The number of outstanding I/Os by a client is controlled by its server.
-	if ( IsType( Type(), GenericClientType ) && !target_index )
-		return net_partner->MaxOutstandingIOs( net_target_index );
+	if (IsType(Type(), GenericClientType) && !target_index)
+		return net_partner->MaxOutstandingIOs(net_target_index);
 
-	if ( target_index < 0 || target_index >= TargetCount() )
-	{
-		ErrorMessage( "Invalid target index in Worker::MaxOutstandingIOs()." );
+	if (target_index < 0 || target_index >= TargetCount()) {
+		ErrorMessage("Invalid target index in Worker::MaxOutstandingIOs().");
 		return 0;
 	}
 
-	if ( IsType( targets[target_index]->spec.type, GenericVIType ) )
-	{
+	if (IsType(targets[target_index]->spec.type, GenericVIType)) {
 		// We need to support the requested number of outstanding sends
 		// (these will result in pre-posted receives) + 1 send descriptor 
 		// per requested queue depth + 2 control descriptors.
 		// See Dynamo - TargetVI for additional details.
-		return ( targets[target_index]->spec.queue_depth * 
-			( targets[target_index]->spec.vi_info.outstanding_ios + 1 ) + 2 );
-	}
-	else
-	{
+		return (targets[target_index]->spec.queue_depth *
+			(targets[target_index]->spec.vi_info.outstanding_ios + 1) + 2);
+	} else {
 		return targets[target_index]->spec.queue_depth;
 	}
 }
 
-
-
 //
 // Return the maximum transfer size that this worker will request from any of
 // its assigned access specs.
 //
 DWORD Worker::MaxTransferSize()
 {
-	int			a, s, spec_count;
-	DWORD		max_size = 0;
-	Access_Spec	*spec;
+	int a, s, spec_count;
+	DWORD max_size = 0;
+	Access_Spec *spec;
 
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return net_partner->MaxTransferSize();
 
 	// Loop through all access specs to find the one with the largest transfer
 	// size.
 	spec_count = AccessSpecCount();
-	for ( a = 0; a < spec_count; a++ )
-	{
+	for (a = 0; a < spec_count; a++) {
 		spec = access_spec_list[a]->access;
 
 		// Loop through all possible transfer sizes for the given spec.
-		for ( s = 0; spec[s].of_size != IOERROR ; s++ )
-		{
+		for (s = 0; spec[s].of_size != IOERROR; s++) {
 			// Mark the spec with the largest request or reply size.
-			if ( spec[s].size > max_size )
+			if (spec[s].size > max_size)
 				max_size = spec[s].size;
 
-			if ( spec[s].reply > max_size )
+			if (spec[s].reply > max_size)
 				max_size = spec[s].reply;
 		}
 	}
 	return max_size;
 }
 
-
-
 /////////////////////////////////////////////////////////////////
 //
 // The following functions handle the management of access specs
 //
 /////////////////////////////////////////////////////////////////
 
-
 //
 // Verify that all assigned test paramters are valid.  This checks that
 // the worker can allocate enough memory to fulfill the largest request
 // size for all access specs and all requests are sector sized aligned.
 //
-BOOL Worker::InvalidSetup( BOOL &invalidSpecOK )
+BOOL Worker::InvalidSetup(BOOL & invalidSpecOK)
 {
-	int			a, s, d;		// loop variables
-	Access_Spec	*spec;
-	DWORD		max_size = 0;
-	int			max_size_index = 0;
-	CString		message;
-	int			mgr_index;
-	int			mgr_target_count = manager->InterfaceCount( GenericDiskType );
+	int a, s, d;		// loop variables
+	Access_Spec *spec;
+	DWORD max_size = 0;
+	int max_size_index = 0;
+	CString message;
+	int mgr_index;
+	int mgr_target_count = manager->InterfaceCount(GenericDiskType);
 
 	// Workers without any targets are automatically valid.
-	if ( !TargetCount() )
+	if (!TargetCount())
 		return FALSE;
 
 	// Verify that all workers with targets have a spec assigned.
-	if ( TargetCount() && !access_spec_list.GetSize() )
-	{
-		ErrorMessage( (CString)"\"" + name + "\" on \"" + manager->name + "\" " +
-			"has targets selected, but no assigned access specifications." );
+	if (TargetCount() && !access_spec_list.GetSize()) {
+		ErrorMessage((CString) "\"" + name + "\" on \"" + manager->name + "\" " +
+			     "has targets selected, but no assigned access specifications.");
 		return TRUE;
 	}
-
 	// Loop through all access specs to verify that the worker can handle them.
-	for ( a = 0; a < AccessSpecCount(); a++ )
-	{
+	for (a = 0; a < AccessSpecCount(); a++) {
 		spec = access_spec_list[a]->access;
 
 		// Loop through all possible transfer sizes for the given spec.
-		for ( s = 0; spec[s].of_size != IOERROR ; s++ )
-		{
+		for (s = 0; spec[s].of_size != IOERROR; s++) {
 			// If the worker is a disk worker, verify that the request size
 			// aligns with all selected disk sector sizes.
-			for ( d = 0; d < TargetCount(); d++ )
-			{
-				if ( !IsType( GetTarget( d )->spec.type, GenericDiskType ) )
+			for (d = 0; d < TargetCount(); d++) {
+				if (!IsType(GetTarget(d)->spec.type, GenericDiskType))
 					continue;
-				
+
 				// For each of assigned worker targets, locate the corresponding target data
 				// in the manager's list.
-				for (mgr_index = 0; mgr_index < mgr_target_count; mgr_index++)
-				{
-					if (strcmp(GetTarget( d )->spec.name, 
-						manager->GetInterface( mgr_index, GenericDiskType )->name) == 0)
+				for (mgr_index = 0; mgr_index < mgr_target_count; mgr_index++) {
+					if (strcmp(GetTarget(d)->spec.name,
+						   manager->GetInterface(mgr_index, GenericDiskType)->name) == 0)
 						break;
 				}
 
-				if ( invalidSpecOK == FALSE ) {
+				if (invalidSpecOK == FALSE) {
 
 					message.Empty();
 
 					// Verify a valid request size.
 
-					if ( spec[s].size % manager->GetInterface( mgr_index, 
-						GenericDiskType )->disk_info.sector_size ) {
+					if (spec[s].size % manager->GetInterface(mgr_index,
+										 GenericDiskType)->disk_info.
+					    sector_size) {
 
-						message.Format( "Access specification %s for \"%s\" on \"%s\" may be invalid.\n\n" 
-							"The request size does not align with disk sector size for disk %s.  " 
-							"Sector size = %i.\n\n"
-							"Would you like to continue anyway?\n\n"
-							"Selecting \"Yes\" will also ignore other potentially invalid "
-							"specifications for this test.", 
-							GetAccessSpec( a )->name, name, manager->name, 
-							manager->GetInterface( mgr_index, GenericDiskType )->name, 
-							manager->GetInterface( mgr_index, GenericDiskType )->disk_info.sector_size );
+						message.
+						    Format
+						    ("Access specification %s for \"%s\" on \"%s\" may be invalid.\n\n"
+						     "The request size does not align with disk sector size for disk %s.  "
+						     "Sector size = %i.\n\n" "Would you like to continue anyway?\n\n"
+						     "Selecting \"Yes\" will also ignore other potentially invalid "
+						     "specifications for this test.", GetAccessSpec(a)->name, name,
+						     manager->name, manager->GetInterface(mgr_index,
+											  GenericDiskType)->name,
+						     manager->GetInterface(mgr_index,
+									   GenericDiskType)->disk_info.sector_size);
 					}
-
 					// Verify I/Os are aligned on sector boundaries.
 
-					else if ( spec[s].align % manager->GetInterface( mgr_index, 
-						GenericDiskType )->disk_info.sector_size ) {
+					else if (spec[s].align % manager->GetInterface(mgr_index,
+										       GenericDiskType)->disk_info.
+						 sector_size) {
 
-						message.Format( "Access specification %s for \"%s\" on \"%s\" may be invalid.\n\n" 
-							"The alignment value is not a multiple of the "
-							"sector size for disk %s.  Sector size = %i.\n\n"
-							"Would you like to continue anyway?\n\n"
-							"Selecting \"Yes\" will also ignore other potentially invalid "
-							"specifications for this test.", 
-							GetAccessSpec( a )->name, name, manager->name, 
-							manager->GetInterface( mgr_index, GenericDiskType )->name, 
-							manager->GetInterface( mgr_index, GenericDiskType )->disk_info.sector_size );
+						message.
+						    Format
+						    ("Access specification %s for \"%s\" on \"%s\" may be invalid.\n\n"
+						     "The alignment value is not a multiple of the "
+						     "sector size for disk %s.  Sector size = %i.\n\n"
+						     "Would you like to continue anyway?\n\n"
+						     "Selecting \"Yes\" will also ignore other potentially invalid "
+						     "specifications for this test.", GetAccessSpec(a)->name, name,
+						     manager->name, manager->GetInterface(mgr_index,
+											  GenericDiskType)->name,
+						     manager->GetInterface(mgr_index,
+									   GenericDiskType)->disk_info.sector_size);
 					}
-
 					// Verify a valid reply size.
 
-					else if ( spec[s].reply % manager->GetInterface( mgr_index, 
-						GenericDiskType )->disk_info.sector_size ) {
+					else if (spec[s].reply % manager->GetInterface(mgr_index,
+										       GenericDiskType)->disk_info.
+						 sector_size) {
 
-						message.Format( "Access specification %s for \"%s\" on \"%s\" may be invalid.\n\n" 
-							"The reply size is not a multiple of the sector size "
-							"for disk %s.  Sector size = %i.\n\n"
-							"Would you like to continue anyway?\n\n"
-							"Selecting \"Yes\" will also ignore other potentially invalid "
-							"specifications for this test.", 
-							GetAccessSpec( a )->name, name, manager->name, 
-							manager->GetInterface( mgr_index, GenericDiskType )->name, 
-							manager->GetInterface( mgr_index, GenericDiskType )->disk_info.sector_size );
+						message.
+						    Format
+						    ("Access specification %s for \"%s\" on \"%s\" may be invalid.\n\n"
+						     "The reply size is not a multiple of the sector size "
+						     "for disk %s.  Sector size = %i.\n\n"
+						     "Would you like to continue anyway?\n\n"
+						     "Selecting \"Yes\" will also ignore other potentially invalid "
+						     "specifications for this test.", GetAccessSpec(a)->name, name,
+						     manager->name, manager->GetInterface(mgr_index,
+											  GenericDiskType)->name,
+						     manager->GetInterface(mgr_index,
+									   GenericDiskType)->disk_info.sector_size);
 					}
 
-					if ( !message.IsEmpty() ) {
-						if ( AfxMessageBox( message, MB_ICONQUESTION | MB_YESNO, 0 ) == IDYES ) {
+					if (!message.IsEmpty()) {
+						if (AfxMessageBox(message, MB_ICONQUESTION | MB_YESNO, 0) == IDYES) {
 							invalidSpecOK = TRUE;
-						}
-						else {
+						} else {
 							return TRUE;
 						}
 					}
@@ -1957,13 +1673,11 @@
 			}
 
 			// Mark the spec with the largest request or reply size.
-			if ( spec[s].size > max_size )
-			{
+			if (spec[s].size > max_size) {
 				max_size = spec[s].size;
 				max_size_index = s;
 			}
-			if ( spec[s].reply > max_size )
-			{
+			if (spec[s].reply > max_size) {
 				max_size = spec[s].reply;
 				max_size_index = s;
 			}
@@ -1972,119 +1686,104 @@
 
 	// Verify that the worker can handle the spec with the largets transfer size.
 	// This checks that Dynamo can create a buffer large enough to handle the spec.
-	if ( !SetAccess( max_size_index ) )
-	{
-		message.Format( "\"%s\" on \"%s\" cannot set specification %s.  "
-			"The largest request or reply size (%i bytes) may be too large.", 
-			name, manager->name, GetAccessSpec( max_size_index )->name, max_size );
-		ErrorMessage( message );
+	if (!SetAccess(max_size_index)) {
+		message.Format("\"%s\" on \"%s\" cannot set specification %s.  "
+			       "The largest request or reply size (%i bytes) may be too large.",
+			       name, manager->name, GetAccessSpec(max_size_index)->name, max_size);
+		ErrorMessage(message);
 		return TRUE;
 	}
 	return FALSE;		// all specs valid
 }
 
-
-
 //
 // Sets all the default access specs for the worker based on the worker's type.
 //
 void Worker::AssignDefaultAccessSpecs()
 {
 	int spec_count;
-	Test_Spec* spec;
+	Test_Spec *spec;
 
 	spec_count = theApp.access_spec_list.Count();
-	for ( int i = 0; i < spec_count; i++ )
-	{
-		spec = theApp.access_spec_list.Get( i );
-		switch ( spec->default_assignment )
-		{
+	for (int i = 0; i < spec_count; i++) {
+		spec = theApp.access_spec_list.Get(i);
+		switch (spec->default_assignment) {
 		case AssignAll:
-			InsertAccessSpec( spec );
+			InsertAccessSpec(spec);
 			break;
 		case AssignDisk:
-			if ( IsType( Type(), GenericDiskType ) )
-				InsertAccessSpec( spec );
+			if (IsType(Type(), GenericDiskType))
+				InsertAccessSpec(spec);
 			break;
 		case AssignNet:
-			if ( IsType( Type(), GenericServerType ) )
-				InsertAccessSpec( spec );
+			if (IsType(Type(), GenericServerType))
+				InsertAccessSpec(spec);
 			break;
 		case AssignNone:
 			break;
 		default:
-			ErrorMessage( "Invalid default assignment in Worker::AssignDefaultAccessSpecs()" );
+			ErrorMessage("Invalid default assignment in Worker::AssignDefaultAccessSpecs()");
 			return;
 		}
 	}
 }
 
-
-
 //
 // Inserts a new entry pointing to access spec 'index' in the global list
 // before the item at 'insert_at_index' in the worker's access spec list.
 //
-BOOL Worker::InsertAccessSpec( Test_Spec *spec, int insert_at_index )
+BOOL Worker::InsertAccessSpec(Test_Spec * spec, int insert_at_index)
 {
 	// Network clients use their server's access spec.
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return FALSE;
 
 	// Inserts to the end of the array by default.
-	if ( insert_at_index == IOERROR || insert_at_index > access_spec_list.GetSize() )
+	if (insert_at_index == IOERROR || insert_at_index > access_spec_list.GetSize())
 		insert_at_index = access_spec_list.GetSize();
 
 	// Validating global_index.
-	if ( theApp.access_spec_list.IndexByRef( spec ) == IOERROR )
+	if (theApp.access_spec_list.IndexByRef(spec) == IOERROR)
 		return FALSE;
 
 	// Add the new index into the local array.
-	access_spec_list.InsertAt( insert_at_index, spec );
+	access_spec_list.InsertAt(insert_at_index, spec);
 	return TRUE;
 }
 
-
-
 //
 // Remove all instances of an access spec from the worker's access spec list.
 //
-void Worker::RemoveAccessSpec( Test_Spec *spec )
+void Worker::RemoveAccessSpec(Test_Spec * spec)
 {
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return;
 
 	// Loop through the worker's access specs and remove any that match.
 	// Loop backwards, so that we don't miss anyone.
-	for ( int i = AccessSpecCount() - 1; i >= 0; i-- )
-	{
+	for (int i = AccessSpecCount() - 1; i >= 0; i--) {
 		// Compare the worker's spec to the one to be removed.
-		if ( GetAccessSpec( i ) == spec )
-		{
+		if (GetAccessSpec(i) == spec) {
 			// Remove the matching spec.
-			access_spec_list.RemoveAt( i );
+			access_spec_list.RemoveAt(i);
 		}
 	}
 }
 
-
-
 //
 // Remove a specific instance of an access spec from the worker's access spec list.
 //
-void Worker::RemoveAccessSpecAt( int index )
+void Worker::RemoveAccessSpecAt(int index)
 {
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return;
 
-	if ( index < 0 || index >= access_spec_list.GetSize() )
+	if (index < 0 || index >= access_spec_list.GetSize())
 		return;
 
-	access_spec_list.RemoveAt( index );
+	access_spec_list.RemoveAt(index);
 }
 
-
-
 //
 // Remove all entries from the worker's access spec list.
 //
@@ -2093,21 +1792,17 @@
 	access_spec_list.RemoveAll();
 }
 
-
-
 //
 // Returns the number of entries in the access spec list.
 //
 int Worker::AccessSpecCount()
 {
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return net_partner->AccessSpecCount();
 
 	return access_spec_list.GetSize();
 }
 
-
-
 //
 // Returns the number of idle specs in the access spec list.
 //
@@ -2115,84 +1810,73 @@
 {
 	int spec_count;
 	int idle_specs = 0;
-	Test_Spec *idle_spec = theApp.access_spec_list.Get( IDLE_SPEC );
+	Test_Spec *idle_spec = theApp.access_spec_list.Get(IDLE_SPEC);
 
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return net_partner->IdleAccessSpecCount();
 
 	// Count the number of idle specs.
 	spec_count = AccessSpecCount();
-	for ( int spec = 0; spec < spec_count; spec++ )
-	{
-		if ( GetAccessSpec( spec ) == idle_spec )
+	for (int spec = 0; spec < spec_count; spec++) {
+		if (GetAccessSpec(spec) == idle_spec)
 			idle_specs++;
 	}
 	return idle_specs;
 }
 
-
-
 //
 // Return a pointer to the desired access spec object.
 // 
-Test_Spec* Worker::GetAccessSpec( int index )
+Test_Spec *Worker::GetAccessSpec(int index)
 {
-	if ( IsType( Type(), GenericClientType ) )
-		return net_partner->GetAccessSpec( index );
+	if (IsType(Type(), GenericClientType))
+		return net_partner->GetAccessSpec(index);
 
-	if ( index < 0 || index >= access_spec_list.GetSize() )
+	if (index < 0 || index >= access_spec_list.GetSize())
 		return NULL;
 
-	return access_spec_list.GetAt( index );
+	return access_spec_list.GetAt(index);
 }
 
-
-
 //
 // Moves the entry at 'index' to before 'before_index'
 //
-void Worker::MoveAccessSpec( int index, int before_index )
+void Worker::MoveAccessSpec(int index, int before_index)
 {
-	Test_Spec*	spec;
-	
+	Test_Spec *spec;
+
 	// Sanity check.
-	if ( index < 0 || index >= access_spec_list.GetSize() )
-	{
-		ErrorMessage( "Invalid index in Worker::MoveAccessSpec()." );
+	if (index < 0 || index >= access_spec_list.GetSize()) {
+		ErrorMessage("Invalid index in Worker::MoveAccessSpec().");
 		return;
 	}
-
 	// Store for later use.
-	spec = GetAccessSpec( index );
+	spec = GetAccessSpec(index);
 
 	// Remove the given entry.  This shifts all the following entries up by one.
-	RemoveAccessSpecAt( index );
+	RemoveAccessSpecAt(index);
 
 	// Insert the stored entry before the before_index.
-	InsertAccessSpec( spec, before_index );
+	InsertAccessSpec(spec, before_index);
 	// NOTE: if the access spec is being moved down (index < before_index),
 	// this will actually insert the acccess spec AFTER the indicated entry
 	// (because all the entries below the original location have been moved
 	// up one).  This is less "correct" but it "feels" better.
 }
 
-
-
 //
 // Returns TRUE if the worker will or is performing I/O in the current test.
 //
 BOOL Worker::ActiveInCurrentTest()
 {
 	// Network clients are active if their servers are.
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return net_partner->ActiveInCurrentTest();
 
 	// The worker is active if it has an active spec and targets to run with.
-	return ( HasActiveCurrentSpec() && TargetCount( ActiveType ) );
+	return (HasActiveCurrentSpec() && TargetCount(ActiveType));
 }
 
-
-
 //
 // Checks to see if there exists an access spec matching the current access 
 // spec index and that it's not the Idle spec.
@@ -2202,22 +1886,19 @@
 	int access_index;
 
 	// Network clients use their corresponding servers access specs.
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return net_partner->HasActiveCurrentSpec();
 
 	// Check to see if the current access spec index is a valid index for 
 	// this worker.
 	access_index = theApp.pView->GetCurrentAccessIndex();
-	if ( access_index < 0 || access_index >= AccessSpecCount() )
+	if (access_index < 0 || access_index >= AccessSpecCount())
 		return FALSE;
 
 	// There exists a spec.  Make sure that it's not the Idle spec.
-	return ( GetAccessSpec( access_index ) != 
-		theApp.access_spec_list.Get( IDLE_SPEC ) );
+	return (GetAccessSpec(access_index) != theApp.access_spec_list.Get(IDLE_SPEC));
 }
 
-
-
 //
 // Checks to see if there exists an access spec matching the current access
 // spec index and that it's the Idle spec.
@@ -2227,62 +1908,51 @@
 	int access_index;
 
 	// Network clients use their corresponding servers access specs.
-	if ( IsType( Type(), GenericClientType ) )
+	if (IsType(Type(), GenericClientType))
 		return net_partner->HasIdleCurrentSpec();
 
 	// Check to see if the current access spec index is a valid index for 
 	// this worker.
 	access_index = theApp.pView->GetCurrentAccessIndex();
-	if ( access_index < 0 || access_index >= AccessSpecCount() )
+	if (access_index < 0 || access_index >= AccessSpecCount())
 		return FALSE;
 
 	// There exists a spec.  Make sure that it's the Idle spec.
-	return ( GetAccessSpec( access_index ) == 
-		theApp.access_spec_list.Get( IDLE_SPEC ) );
+	return (GetAccessSpec(access_index) == theApp.access_spec_list.Get(IDLE_SPEC));
 }
 
-
-
 //
 // Save the worker configuration to the specified stream.
-//		save_aspecs --> should each worker's access spec assignments be saved?
-//		save_targets --> should each worker's target assignments be saved?
+//              save_aspecs --> should each worker's access spec assignments be saved?
+//              save_targets --> should each worker's target assignments be saved?
 //
-BOOL Worker::SaveConfig(ostream& outfile, BOOL save_aspecs, BOOL save_targets)
+BOOL Worker::SaveConfig(ostream & outfile, BOOL save_aspecs, BOOL save_targets)
 {
 	// Don't record network clients.  They are restored when the network
 	// server's targets are examined.
-	if ( IsType(Type(), GenericClientType) )
+	if (IsType(Type(), GenericClientType))
 		return TRUE;
 
-	outfile << "'Worker" << endl
-			<< "\t" << name << endl
-			<< "'Worker type" << endl;
+	outfile << "'Worker" << endl << "\t" << name << endl << "'Worker type" << endl;
 
 	// Determine the worker type.
-	if ( IsType(Type(), GenericDiskType) )
-	{
+	if (IsType(Type(), GenericDiskType)) {
 		outfile << "\tDISK" << endl;
-	}
-	else if ( IsType(Type(), GenericNetType) )
-	{
+	} else if (IsType(Type(), GenericNetType)) {
 		outfile << "\tNETWORK";
 
-		if ( IsType(Type(), GenericTCPType) )
+		if (IsType(Type(), GenericTCPType))
 			outfile << ",TCP" << endl;
-		else if ( IsType(Type(), GenericVIType) )
+		else if (IsType(Type(), GenericVIType))
 			outfile << ",VI" << endl;
-		else
-		{
-			ErrorMessage("Error saving worker \"" + (CString)name + "\": "
-				"Network worker is neither TCP nor VI.");
+		else {
+			ErrorMessage("Error saving worker \"" + (CString) name + "\": "
+				     "Network worker is neither TCP nor VI.");
 			return FALSE;
 		}
-	}
-	else
-	{
-		ErrorMessage("Error saving worker \"" + (CString)name + "\": "
-			"Worker is neither a DISK nor a NETWORK worker.");
+	} else {
+		ErrorMessage("Error saving worker \"" + (CString) name + "\": "
+			     "Worker is neither a DISK nor a NETWORK worker.");
 		return FALSE;
 	}
 
@@ -2290,100 +1960,76 @@
 
 	outfile << "'Number of outstanding IOs,test connection rate,transactions per connection" << endl;
 
-	outfile << "\t" << GetQueueDepth( Type() )
-				<< "," << (GetConnectionRate( Type() ) ? "ENABLED" : "DISABLED")
-				<< "," << GetTransPerConn( Type() ) << endl;
+	outfile << "\t" << GetQueueDepth(Type())
+	    << "," << (GetConnectionRate(Type())? "ENABLED" : "DISABLED")
+	    << "," << GetTransPerConn(Type()) << endl;
 
-	if ( IsType(spec.type, GenericDiskType) )
-	{
+	if (IsType(spec.type, GenericDiskType)) {
 		outfile << "'Disk maximum size,starting sector" << endl;
 
-		outfile << "\t" << GetDiskSize( Type() )
-					<< "," << GetDiskStart( Type() ) << endl;
+		outfile << "\t" << GetDiskSize(Type())
+		    << "," << GetDiskStart(Type()) << endl;
 	}
 
-	if ( IsType(spec.type, GenericNetType) )
-	{
-		outfile << "'Local network interface" << endl
-				<< "\t" << GetLocalNetworkInterface() << endl;
+	if (IsType(spec.type, GenericNetType)) {
+		outfile << "'Local network interface" << endl << "\t" << GetLocalNetworkInterface() << endl;
 	}
 
-	if ( IsType(spec.type, GenericVIType) )
-	{
-		outfile << "'VI outstanding IOs" << endl
-				<< "\t" << GetMaxSends( Type() ) << endl;
+	if (IsType(spec.type, GenericVIType)) {
+		outfile << "'VI outstanding IOs" << endl << "\t" << GetMaxSends(Type()) << endl;
 	}
-	
+
 	outfile << "'End default target settings for worker" << endl;
 
-	if (save_aspecs)
-	{
+	if (save_aspecs) {
 		int spec_count = AccessSpecCount();
 
 		outfile << "'Assigned access specs" << endl;
 
-		for (int counter=0; counter<spec_count; counter++)
+		for (int counter = 0; counter < spec_count; counter++)
 			outfile << "\t" << access_spec_list[counter]->name << endl;
 
 		outfile << "'End assigned access specs" << endl;
 	}
 
-	if (save_targets)
-	{
+	if (save_targets) {
 		Target_Spec tspec;
 		int target_count = TargetCount();
 
 		outfile << "'Target assignments" << endl;
 
-		for (int counter=0; counter<target_count; counter++)
-		{
+		for (int counter = 0; counter < target_count; counter++) {
 			tspec = GetTarget(counter)->spec;
 
 			outfile << "'Target" << endl;
 
 			// Determine the worker type.
-			if ( IsType(tspec.type, GenericDiskType) )
-			{
-				outfile << "\t" << tspec.name << endl
-						<< "'Target type" << endl
-						<< "\tDISK" << endl;
-			}
-			else if ( IsType(tspec.type, GenericNetType) )
-			{
-				if ( IsType(tspec.type, GenericTCPType) )
-				{
+			if (IsType(tspec.type, GenericDiskType)) {
+				outfile << "\t" << tspec.name << endl << "'Target type" << endl << "\tDISK" << endl;
+			} else if (IsType(tspec.type, GenericNetType)) {
+				if (IsType(tspec.type, GenericTCPType)) {
 					outfile << "\t" << tspec.tcp_info.remote_address << endl
-							<< "'Target type" << endl
-							<< "\tNETWORK,TCP" << endl;
-				}
-				else if ( IsType(tspec.type, GenericVIType) )
-				{
+					    << "'Target type" << endl << "\tNETWORK,TCP" << endl;
+				} else if (IsType(tspec.type, GenericVIType)) {
 					outfile << "\t" << tspec.vi_info.remote_nic_name << endl
-							<< "'Target type" << endl
-							<< "\tNETWORK,VI" << endl;
-				}
-				else
-				{
-					ErrorMessage("Error saving target \"" + (CString)tspec.name + "\": "
-						"Network target is neither TCP nor VI.");
+					    << "'Target type" << endl << "\tNETWORK,VI" << endl;
+				} else {
+					ErrorMessage("Error saving target \"" + (CString) tspec.name + "\": "
+						     "Network target is neither TCP nor VI.");
 					return FALSE;
 				}
 
-				if ( net_partner == NULL )
-				{
-					ErrorMessage("Error saving target \"" + (CString)tspec.name + "\": "
-						"Network worker with a selected network target has no net_partner.");
+				if (net_partner == NULL) {
+					ErrorMessage("Error saving target \"" + (CString) tspec.name + "\": "
+						     "Network worker with a selected network target has no net_partner.");
 					return FALSE;
 				}
 
 				outfile << "'Target manager ID, manager name" << endl
-						<< "\t" << net_partner->manager->id
-						<< "," << net_partner->manager->name << endl;
-			}
-			else
-			{
-				ErrorMessage("Error saving target \"" + (CString)tspec.name + "\": "
-					"Target is neither a DISK nor a NETWORK target.");
+				    << "\t" << net_partner->manager->id << "," << net_partner->manager->name << endl;
+			} else {
+				ErrorMessage("Error saving target \"" + (CString) tspec.name + "\": "
+					     "Target is neither a DISK nor a NETWORK target.");
 				return FALSE;
 			}
 
@@ -2398,74 +2044,54 @@
 	return TRUE;
 }
 
-
-
 //
 // Restore the worker configuration from the specified stream.
-//		load_aspecs --> should each worker's access spec assignments be loaded?
-//		load_targets --> should each worker's target assignments be loaded?
+//              load_aspecs --> should each worker's access spec assignments be loaded?
+//              load_targets --> should each worker's target assignments be loaded?
 //
 // Returns TRUE on success, FALSE if any of the requested information
 // couldn't be found in the file.
 //
-BOOL Worker::LoadConfig(ICF_ifstream& infile, BOOL load_aspecs, BOOL load_targets )
+BOOL Worker::LoadConfig(ICF_ifstream & infile, BOOL load_aspecs, BOOL load_targets)
 {
 	CString comment;
 
-	while (1)
-	{
+	while (1) {
 		// The value returned may or may not actually be a comment.
 		// It SHOULD be a comment.
 		comment = infile.GetNextLine();
 
-		if ( comment.CompareNoCase("'End worker") == 0 )
-		{
+		if (comment.CompareNoCase("'End worker") == 0) {
 			break;
-		}
-		else if ( comment.CompareNoCase("'Default target settings for worker") == 0 )
-		{
-			if ( !LoadConfigDefault(infile) )
+		} else if (comment.CompareNoCase("'Default target settings for worker") == 0) {
+			if (!LoadConfigDefault(infile))
 				return FALSE;
-		}
-		else if ( comment.CompareNoCase("'Assigned access specs") == 0 )
-		{
-			if (load_aspecs)
-			{
-				if ( !LoadConfigAccess(infile) )
+		} else if (comment.CompareNoCase("'Assigned access specs") == 0) {
+			if (load_aspecs) {
+				if (!LoadConfigAccess(infile))
 					return FALSE;
-			}
-			else
-			{
-				if ( !infile.SkipTo("'End assigned access specs") )
-				{
+			} else {
+				if (!infile.SkipTo("'End assigned access specs")) {
 					ErrorMessage("File is improperly formatted.  Couldn't "
-						"find an \"End assigned access specs\" comment.");
+						     "find an \"End assigned access specs\" comment.");
 					return FALSE;
 				}
 			}
-		}
-		else if ( comment.CompareNoCase("'Target assignments") == 0 )
-		{
-			if (load_targets)
-			{
-				if ( !LoadConfigTargets(infile) )
+		} else if (comment.CompareNoCase("'Target assignments") == 0) {
+			if (load_targets) {
+				if (!LoadConfigTargets(infile))
 					return FALSE;
-			}
-			else
-			{
-				if ( !infile.SkipTo("'End target assignments") )
-				{
+			} else {
+				if (!infile.SkipTo("'End target assignments")) {
 					ErrorMessage("File is improperly formatted.  Couldn't "
-						"find an \"End target assignments\" comment.");
+						     "find an \"End target assignments\" comment.");
 					return FALSE;
 				}
 			}
 
-		}
-		else
-		{
+		} else {
 			ErrorMessage("File is improperly formatted.  WORKER section "
-				"contained an unrecognized line: \"" + comment + "\".");
+				     "contained an unrecognized line: \"" + comment + "\".");
 			return FALSE;
 		}
 	}
@@ -2477,31 +2103,27 @@
 	return TRUE;
 }
 
-BOOL Worker::LoadConfigDefault(ICF_ifstream& infile)
+BOOL Worker::LoadConfigDefault(ICF_ifstream & infile)
 {
 	CString key, value;
 	CString token;
 	int temp_number;
 
-	while (1)
-	{
-		if ( !infile.GetPair(key, value) )
-		{
+	while (1) {
+		if (!infile.GetPair(key, value)) {
 			ErrorMessage("File is improperly formatted.  Expected more default target "
-				"settings for worker or an \"End default target settings for worker\" comment.");
+				     "settings for worker or an \"End default target settings for worker\" comment.");
 			return FALSE;
 		}
 
-		if ( key.CompareNoCase("'End default target settings for worker") == 0 )
-		{
+		if (key.CompareNoCase("'End default target settings for worker") == 0) {
 			return TRUE;	// This is the only normal exit.
-		}
-		else if ( key.CompareNoCase("'Number of outstanding IOs,test connection rate,transactions per connection") == 0 )
-		{
-			if ( !ICF_ifstream::ExtractFirstInt(value, temp_number) )
-			{
+		} else if (key.
+			   CompareNoCase("'Number of outstanding IOs,test connection rate,transactions per connection")
+			   == 0) {
+			if (!ICF_ifstream::ExtractFirstInt(value, temp_number)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Number of outstanding IOs\" should be specified as an integer value.");
+					     "\"Number of outstanding IOs\" should be specified as an integer value.");
 				return FALSE;
 			}
 
@@ -2509,128 +2131,103 @@
 
 			token = ICF_ifstream::ExtractFirstToken(value);
 
-			if ( token.CompareNoCase("ENABLED") == 0 )
+			if (token.CompareNoCase("ENABLED") == 0)
 				SetConnectionRate(TRUE);
-			else if ( token.CompareNoCase("DISABLED") == 0 )
+			else if (token.CompareNoCase("DISABLED") == 0)
 				SetConnectionRate(FALSE);
-			else
-			{
-				ErrorMessage("Error restoring worker " + (CString)name + ".  "
-					"\"Test connection rate\" should be set to ENABLED or DISABLED.");
+			else {
+				ErrorMessage("Error restoring worker " + (CString) name + ".  "
+					     "\"Test connection rate\" should be set to ENABLED or DISABLED.");
 				return FALSE;
 			}
 
-			if ( !ICF_ifstream::ExtractFirstInt(value, temp_number) )
-			{
+			if (!ICF_ifstream::ExtractFirstInt(value, temp_number)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Transactions per connection\" should "
-					"be specified as an integer value.");
+					     "\"Transactions per connection\" should "
+					     "be specified as an integer value.");
 				return FALSE;
 			}
 
 			SetTransPerConn(temp_number);
-		}
-		else if ( key.CompareNoCase("'Disk maximum size,starting sector") == 0 )
-		{
-			if ( !IsType(Type(), GenericDiskType) )
-			{
-				ErrorMessage("Error restoring worker " + (CString)name + ".  "
-					"Cannot specify \"Disk maximum size,starting sector\" for a non-disk worker.");
+		} else if (key.CompareNoCase("'Disk maximum size,starting sector") == 0) {
+			if (!IsType(Type(), GenericDiskType)) {
+				ErrorMessage("Error restoring worker " + (CString) name + ".  "
+					     "Cannot specify \"Disk maximum size,starting sector\" for a non-disk worker.");
 				return FALSE;
 			}
 
-			if ( !ICF_ifstream::ExtractFirstInt(value, temp_number) )
-			{
+			if (!ICF_ifstream::ExtractFirstInt(value, temp_number)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Disk maximum size\" should be specified as an integer value.");
+					     "\"Disk maximum size\" should be specified as an integer value.");
 				return FALSE;
 			}
 
 			SetDiskSize(temp_number);
 
-			if ( !ICF_ifstream::ExtractFirstInt(value, temp_number) )
-			{
+			if (!ICF_ifstream::ExtractFirstInt(value, temp_number)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Starting sector\" should be specified as an integer value.");
+					     "\"Starting sector\" should be specified as an integer value.");
 				return FALSE;
 			}
 
 			SetDiskStart(temp_number);
-		}
-		else if ( key.CompareNoCase("'Local network interface") == 0 )
-		{
-			if ( !IsType(Type(), GenericNetType) )
-			{
-				ErrorMessage("Error restoring worker " + (CString)name + ".  "
-					"Cannot specify \"Local network interface\" for a non-TCP worker.");
+		} else if (key.CompareNoCase("'Local network interface") == 0) {
+			if (!IsType(Type(), GenericNetType)) {
+				ErrorMessage("Error restoring worker " + (CString) name + ".  "
+					     "Cannot specify \"Local network interface\" for a non-TCP worker.");
 				return FALSE;
 			}
 
-			SetLocalNetworkInterface( value );
-		}
-		else if ( key.CompareNoCase("'VI outstanding IOs") == 0 )
-		{
-			if ( !IsType(Type(), GenericVIType) )
-			{
-				ErrorMessage("Error restoring worker " + (CString)name + ".  "
-					"Cannot specify \"VI outstanding IOs\" for a non-VI worker.");
+			SetLocalNetworkInterface(value);
+		} else if (key.CompareNoCase("'VI outstanding IOs") == 0) {
+			if (!IsType(Type(), GenericVIType)) {
+				ErrorMessage("Error restoring worker " + (CString) name + ".  "
+					     "Cannot specify \"VI outstanding IOs\" for a non-VI worker.");
 				return FALSE;
 			}
 
-			if ( !ICF_ifstream::ExtractFirstInt(value, temp_number) )
-			{
+			if (!ICF_ifstream::ExtractFirstInt(value, temp_number)) {
 				ErrorMessage("Error while reading file.  "
-					"\"VI outstanding IOs\" should be specified as an integer value.");
+					     "\"VI outstanding IOs\" should be specified as an integer value.");
 				return FALSE;
 			}
 
 			SetMaxSends(temp_number);
-		}
-		else
-		{
+		} else {
 			ErrorMessage("File is improperly formatted.  "
-				"DEFAULT TARGET SETTINGS FOR WORKER "
-				"section contained an unrecognized \"" + key + "\""
-				"comment.");
+				     "DEFAULT TARGET SETTINGS FOR WORKER "
+				     "section contained an unrecognized \"" + key + "\"" "comment.");
 			return FALSE;
 		}
 	}
 }
 
-BOOL Worker::LoadConfigAccess(ICF_ifstream& infile)
+BOOL Worker::LoadConfigAccess(ICF_ifstream & infile)
 {
 	CString value;
 	Test_Spec *aspec;
 
-	while (1)
-	{
+	while (1) {
 		value = infile.GetNextLine();
 
-		if ( value.CompareNoCase("'End assigned access specs") == 0 )
-		{
+		if (value.CompareNoCase("'End assigned access specs") == 0) {
 			return TRUE;
-		}
-		else
-		{
+		} else {
 			aspec = theApp.access_spec_list.RefByName(value);
 
-			if (aspec != NULL)
-			{
+			if (aspec != NULL) {
 				InsertAccessSpec(aspec);
-			}
-			else
-			{
+			} else {
 				ErrorMessage("Error restoring access specification "
-					"assignments for worker \"" + (CString)name + "\".  "
-					"Access spec \"" + value + "\" doesn't exist.  "
-					"Ignoring.");
+					     "assignments for worker \"" + (CString) name + "\".  "
+					     "Access spec \"" + value + "\" doesn't exist.  " "Ignoring.");
 				continue;
 			}
 		}
 	}
 }
 
-BOOL Worker::LoadConfigTargets(ICF_ifstream& infile)
+BOOL Worker::LoadConfigTargets(ICF_ifstream & infile)
 {
 	CString tgt_comment, tgt_name;
 	CString tgt_typestring;
@@ -2639,78 +2236,59 @@
 	int mgr_id;
 	TargetType tgt_type;
 
-	while (1)
-	{
+	while (1) {
 		// Expecting "Target" or "End target assignments"
-		if ( !infile.GetPair(tgt_comment, tgt_name) )
-		{
+		if (!infile.GetPair(tgt_comment, tgt_name)) {
 			ErrorMessage("File is improperly formatted.  Expected a "
-				"target or \"End target assignments\".");
+				     "target or \"End target assignments\".");
 			return FALSE;
 		}
 
-		if ( tgt_comment.CompareNoCase("'End target assignments") == 0 )
-		{
+		if (tgt_comment.CompareNoCase("'End target assignments") == 0) {
 			return TRUE;	// This is the only normal exit.
 		}
 
-		if ( tgt_comment.CompareNoCase("'Target") != 0 )
-		{
+		if (tgt_comment.CompareNoCase("'Target") != 0) {
 			ErrorMessage("File is improperly formatted.  Expected "
-				"a \"Target\" comment inside TARGET ASSIGNMENTS "
-				"section.");
+				     "a \"Target\" comment inside TARGET ASSIGNMENTS " "section.");
 			return FALSE;
 		}
-
 		// Expecting "Target type"
-		if ( !infile.GetPair(tgt_comment, tgt_typestring) )
-		{
-			ErrorMessage("File is improperly formatted.  Expected "
-				"\"Target type\".");
+		if (!infile.GetPair(tgt_comment, tgt_typestring)) {
+			ErrorMessage("File is improperly formatted.  Expected " "\"Target type\".");
 			return FALSE;
 		}
 
-		if ( tgt_comment.CompareNoCase("'Target type") != 0 )
-		{
+		if (tgt_comment.CompareNoCase("'Target type") != 0) {
 			ErrorMessage("File is improperly formatted.  Expected "
-				"a \"Target type\" comment after target name.");
+				     "a \"Target type\" comment after target name.");
 			return FALSE;
 		}
 
 		token = ICF_ifstream::ExtractFirstToken(tgt_typestring);
-		if ( token.CompareNoCase("DISK") == 0 )
-		{
+		if (token.CompareNoCase("DISK") == 0) {
 			tgt_type = GenericDiskType;
-		}
-		else if ( token.CompareNoCase("NETWORK") == 0 )
-		{
+		} else if (token.CompareNoCase("NETWORK") == 0) {
 			token = ICF_ifstream::ExtractFirstToken(tgt_typestring);
 
-			if ( token.CompareNoCase("TCP") == 0 )
-			{
+			if (token.CompareNoCase("TCP") == 0) {
 				tgt_type = TCPClientType;
-			}
-			else if ( token.CompareNoCase("VI") == 0 )
-			{
+			} else if (token.CompareNoCase("VI") == 0) {
 				tgt_type = VIClientType;
-			}
-			else
-			{
+			} else {
 				ErrorMessage("Error restoring target " + tgt_name + ".  "
-					"Network target type is neither TCP nor VI.");
+					     "Network target type is neither TCP nor VI.");
 				return FALSE;
 			}
-		}
-		else
-		{
+		} else {
 			ErrorMessage("Error restoring target " + tgt_name + ".  "
-				"Target type is neither DISK nor NETWORK.");
+				     "Target type is neither DISK nor NETWORK.");
 			return FALSE;
 		}
 
-		if ( IsType(Type(), GenericDiskType) )
-		{
-			CString		fileDiskName(tgt_name);	//isolate "drive:" portion of name (bug #369)
+		if (IsType(Type(), GenericDiskType)) {
+			CString fileDiskName(tgt_name);	//isolate "drive:" portion of name (bug #369)
+
 			if (fileDiskName[1] == ':')
 				fileDiskName = fileDiskName.Left(2);
 
@@ -2718,33 +2296,29 @@
 			int interface_count = manager->InterfaceCount(tgt_type);
 			Target_Spec *tspec;
 			int counter;
-			for (counter=0; counter<interface_count; counter++)
-			{
+
+			for (counter = 0; counter < interface_count; counter++) {
 				// Yes, GetInterface is used to get Disk tspecs, too.
 				tspec = manager->GetInterface(counter, tgt_type);
 
-				CString		thisDiskName(tspec->name);
+				CString thisDiskName(tspec->name);
+
 				if (thisDiskName[1] == ':')
 					thisDiskName = thisDiskName.Left(2);
 
-				if ( fileDiskName.CompareNoCase(thisDiskName) == 0 )
+				if (fileDiskName.CompareNoCase(thisDiskName) == 0)
 					break;
 			}
 
-			if (counter >= interface_count)
-			{
+			if (counter >= interface_count) {
 				ErrorMessage("Error loading the ICF file.  A worker "
-					"is assigned a target, \"" + tgt_name +
-					"\", that isn't available.");
+					     "is assigned a target, \"" + tgt_name + "\", that isn't available.");
 				return FALSE;
 			}
-
 			// Don't assign the target if it has already been assigned.
-			if ( !IsTargetAssigned(tspec) )
+			if (!IsTargetAssigned(tspec))
 				AddTarget(tspec);
-		}
-		else if ( IsType(Type(), GenericNetType) )
-		{
+		} else if (IsType(Type(), GenericNetType)) {
 			Manager *remote_manager;
 			int remote_nic_counter, remote_nic_total;
 			Target_Spec *remote_tspec, local_tspec;
@@ -2752,115 +2326,93 @@
 			// Load config information identifying the network worker's target.
 
 			// Expecting "Target manager ID, manager name"
-			if ( !infile.GetPair(tgt_comment, mgr_info) )
-			{
+			if (!infile.GetPair(tgt_comment, mgr_info)) {
 				ErrorMessage("File is improperly formatted.  Expected "
-					"network target manager ID and name.");
+					     "network target manager ID and name.");
 				return FALSE;
 			}
 
-			if ( tgt_comment.CompareNoCase("'Target manager ID, manager name") != 0 )
-			{
+			if (tgt_comment.CompareNoCase("'Target manager ID, manager name") != 0) {
 				ErrorMessage("File is improperly formatted.  Expected "
-					"a \"Target manager ID, manager name\" comment after \"Target type\".");
+					     "a \"Target manager ID, manager name\" comment after \"Target type\".");
 				return FALSE;
 			}
 
-			if ( !ICF_ifstream::ExtractFirstInt(mgr_info, mgr_id) )
-			{
+			if (!ICF_ifstream::ExtractFirstInt(mgr_info, mgr_id)) {
 				ErrorMessage("Error while reading file.  "
-					"\"Target manager ID\" should be specified as an integer value.");
+					     "\"Target manager ID\" should be specified as an integer value.");
 				return FALSE;
 			}
 
-			if ( mgr_info.GetLength() == 0 )
-			{
-				ErrorMessage("File is improperly formatted.  Expected "
-					"a target \"manager name\".");
+			if (mgr_info.GetLength() == 0) {
+				ErrorMessage("File is improperly formatted.  Expected " "a target \"manager name\".");
 				return FALSE;
 			}
 
 			mgr_name = mgr_info;
 
 			// Make sure the worker and target are of compatible types.
-			if ( (Type() & NETWORK_COMPATIBILITY_MASK)
-					!= (tgt_type & NETWORK_COMPATIBILITY_MASK) )
-			{
+			if ((Type() & NETWORK_COMPATIBILITY_MASK)
+			    != (tgt_type & NETWORK_COMPATIBILITY_MASK)) {
 				ErrorMessage("Error loading the ICF file.  A worker "
-					"was assigned a target of an incompatible type.  A "
-					"TCP worker can only have TCP targets, etc.");
+					     "was assigned a target of an incompatible type.  A "
+					     "TCP worker can only have TCP targets, etc.");
 				return FALSE;
 			}
-
 			// Remove any targets previously assigned to this worker.
-			RemoveTargets( GenericNetType );
+			RemoveTargets(GenericNetType);
 
 			remote_manager = theApp.manager_list.loadmap.Retrieve(mgr_name, mgr_id);
 
-			if ( remote_manager == NULL )
-			{
+			if (remote_manager == NULL) {
 				ErrorMessage("While restoring network worker target assignments, "
-					"remote manager could not be found in the ManagerMap.  "
-					"Please report this as an Iometer bug.");
+					     "remote manager could not be found in the ManagerMap.  "
+					     "Please report this as an Iometer bug.");
 			}
 
-			remote_nic_total = remote_manager->InterfaceCount( tgt_type );
+			remote_nic_total = remote_manager->InterfaceCount(tgt_type);
 
-			for (remote_nic_counter=0; remote_nic_counter<remote_nic_total;
-					remote_nic_counter++)
-			{
-				remote_tspec = remote_manager->GetInterface( remote_nic_counter, tgt_type );
-				if ( tgt_name.CompareNoCase(remote_tspec->name) == 0 )
+			for (remote_nic_counter = 0; remote_nic_counter < remote_nic_total; remote_nic_counter++) {
+				remote_tspec = remote_manager->GetInterface(remote_nic_counter, tgt_type);
+				if (tgt_name.CompareNoCase(remote_tspec->name) == 0)
 					break;
 			}
 
-			if ( remote_nic_counter >= remote_nic_total )
-			{
+			if (remote_nic_counter >= remote_nic_total) {
 				ErrorMessage("Error loading the ICF file.  A worker "
-					"is assigned a target, \"" + tgt_name +
-					"\", that isn't available.");
+					     "is assigned a target, \"" + tgt_name + "\", that isn't available.");
 				return FALSE;
 			}
-
 			// Copy the remote NIC's Target_Spec info.
-			memcpy( &local_tspec, remote_tspec, sizeof(Target_Spec) );
+			memcpy(&local_tspec, remote_tspec, sizeof(Target_Spec));
 
 			// Handle TCP-specific stuff.
-			if ( IsType( local_tspec.type, TCPClientType ) )
-			{
-				strcpy( local_tspec.tcp_info.remote_address, local_tspec.name );
+			if (IsType(local_tspec.type, TCPClientType)) {
+				strcpy(local_tspec.tcp_info.remote_address, local_tspec.name);
 			}
-
 			// Handle VI-specific stuff.
-			if ( IsType( local_tspec.type, VIClientType ) )
-			{
-				strcpy( local_tspec.vi_info.remote_nic_name, local_tspec.name );
-				memcpy( &local_tspec.vi_info.remote_address,
-						&local_tspec.vi_info.local_address, VI_ADDRESS_SIZE );
+			if (IsType(local_tspec.type, VIClientType)) {
+				strcpy(local_tspec.vi_info.remote_nic_name, local_tspec.name);
+				memcpy(&local_tspec.vi_info.remote_address,
+				       &local_tspec.vi_info.local_address, VI_ADDRESS_SIZE);
 			}
-
 			// Add the target to the worker's assigned list.
 			AddTarget(&local_tspec);
 
 			// Writes the necessary local NIC information to
 			// the network target's Target_Spec structure.
-			SetLocalNetworkInterface( GetLocalNetworkInterface() );
+			SetLocalNetworkInterface(GetLocalNetworkInterface());
 
 			// Start up the network client.
 			CreateNetClient(remote_manager, remote_tspec->type);
-		}
-		else
-		{
-			ErrorMessage("Error loading the ICF file.  Unknown target "
-				"type encountered.");
+		} else {
+			ErrorMessage("Error loading the ICF file.  Unknown target " "type encountered.");
 			return FALSE;
 		}
 
 		tgt_comment = infile.GetNextLine();
-		if ( tgt_comment.CompareNoCase("'End target") != 0 )
-		{
-			ErrorMessage("File is improperly formatted.  Expected "
-				"an \"End target\" comment.");
+		if (tgt_comment.CompareNoCase("'End target") != 0) {
+			ErrorMessage("File is improperly formatted.  Expected " "an \"End target\" comment.");
 			return FALSE;
 		}
 	}

Modified: branches/IOMETER-restruct/iometer/src/Worker.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/Worker.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/Worker.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,171 +64,153 @@
 #ifndef WORKER_DEFINED
 #define WORKER_DEFINED
 
-
 #include "IOCommon.h"
 #include "IOMessage.h"
 #include "IOTransfers.h"
 #include "ICF_ifstream.h"
 #include <afxtempl.h>
 
+class Manager;			// forward declaration
 
-class Manager; // forward declaration
-
-
 //
 // Structure to store information about a worker's targets.
 //
-struct Target
-{
-	Target_Spec	spec;
+struct Target {
+	Target_Spec spec;
 
 	// Results of last run test.
-	Results		results[MAX_PERF];
+	Results results[MAX_PERF];
 };
 
-
-
 #define AMBIGUOUS_VALUE	-1
 #define DISABLED_VALUE	0
 #define ENABLED_VALUE	1
 
-
 // Class information for a single worker.
-class	Worker
-{
-public:
-	Worker( Manager* mgr = NULL, TargetType wkr_type = GenericType );
+class Worker {
+      public:
+	Worker(Manager * mgr = NULL, TargetType wkr_type = GenericType);
 	~Worker();
 	// Copies all settings from specified worker.
-	void		Clone( Worker* source_worker );
+	void Clone(Worker * source_worker);
 
 	// Uniquely distinguishes workers with the same name on the
 	// same manager.  To fill in this value, call Manager::IndexWorkers().
 	// If any workers are renamed, added, or removed, call its
 	// manager's Manager::IndexWorkers().
-	int			id;
+	int id;
 
 	///////////////////////////////////////////////////////////////////////////
 	// Information about an instance of a worker.
 	//
-	char		name[MAX_WORKER_NAME];		// Displayable name of worker.
-	Manager*	manager;					// Worker's manager.
+	char name[MAX_WORKER_NAME];	// Displayable name of worker.
+	Manager *manager;	// Worker's manager.
 	//
-	TargetType	Type();						// What kind of worker is this?
+	TargetType Type();	// What kind of worker is this?
 	//
 	// Return a worker's index into its manager's worker list.
-	int			GetIndex( TargetType list_type = GenericType );
+	int GetIndex(TargetType list_type = GenericType);
 	//
 	// Settings worker uses for all its targets by default.
 	// Currently all targets for a worker have the same type and settings.
 	// This allows the worker to remember its settings, even if it all of 
 	// its targets are removed.
-	Target_Spec	spec;
+	Target_Spec spec;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Manages a worker's targets.
 	//
-	Target*		GetTarget( int index, TargetType type = GenericType );
-	int			TargetCount( TargetType type = GenericType );
-	BOOL		IsTargetAssigned( Target_Spec *target_info );
+	Target *GetTarget(int index, TargetType type = GenericType);
+	int TargetCount(TargetType type = GenericType);
+	BOOL IsTargetAssigned(Target_Spec * target_info);
 	//
-	void		AddTarget( Target_Spec *target_info );
+	void AddTarget(Target_Spec * target_info);
 	//
-	void		RemoveTarget( int index );
-	void		RemoveTargets( TargetType target_type = GenericType );
+	void RemoveTarget(int index);
+	void RemoveTargets(TargetType target_type = GenericType);
 	//
 	// List of targets belonging to a worker.
-	CTypedPtrArray<CPtrArray, Target*>	targets;
+	 CTypedPtrArray < CPtrArray, Target * >targets;
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Returns information about a worker's current test setup.
 	//
-	int			MaxOutstandingIOs( int target_index );
-	DWORD		MaxTransferSize();
+	int MaxOutstandingIOs(int target_index);
+	DWORD MaxTransferSize();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Retrieving/setting information about a worker's targets.
 	//
-	int			GetConnectionRate( TargetType type );
-	int			GetDiskSize( TargetType type );
-	int			GetDiskStart( TargetType type );
-	char*		GetLocalNetworkInterface();
-	int			GetQueueDepth( TargetType type );
-	int			GetMaxSends( TargetType type );
-	int			GetTransPerConn( TargetType type );
+	int GetConnectionRate(TargetType type);
+	int GetDiskSize(TargetType type);
+	int GetDiskStart(TargetType type);
+	char *GetLocalNetworkInterface();
+	int GetQueueDepth(TargetType type);
+	int GetMaxSends(TargetType type);
+	int GetTransPerConn(TargetType type);
 	// GetValue will replace most Get*() functions.
-	//	int			GetValue( TargetType type, int offset );
+	//      int                     GetValue( TargetType type, int offset );
 	//
-	void		SetConnectionRate( BOOL test_connection_rate );
-	void		SetDiskSize( int disk_size );
-	void		SetDiskStart( int disk_start );
-	void		SetLocalNetworkInterface( int iface_index,
-					TargetType type = GenericNetType );
-	void		SetLocalNetworkInterface( const CString& iface_name );
-	void		SetQueueDepth( int queue_depth );
-	void		SetMaxSends( int queue_depth );
-	void		SetTransPerConn( int trans_per_conn );
-	//	SetValue will replace most Set*() functions.
-	//	void		SetValue( TargetType type, int offset, int value );
+	void SetConnectionRate(BOOL test_connection_rate);
+	void SetDiskSize(int disk_size);
+	void SetDiskStart(int disk_start);
+	void SetLocalNetworkInterface(int iface_index, TargetType type = GenericNetType);
+	void SetLocalNetworkInterface(const CString & iface_name);
+	void SetQueueDepth(int queue_depth);
+	void SetMaxSends(int queue_depth);
+	void SetTransPerConn(int trans_per_conn);
+	//      SetValue will replace most Set*() functions.
+	//      void            SetValue( TargetType type, int offset, int value );
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions dealing with managing which targets are running
 	//
-	int			SetActiveTargets( int targets_to_set );
-	void		ClearActiveTargets();
+	int SetActiveTargets(int targets_to_set);
+	void ClearActiveTargets();
 	//
-	BOOL		ReadyToRunTests();
-	BOOL		TargetReadyToRunTests( Target *target );
+	BOOL ReadyToRunTests();
+	BOOL TargetReadyToRunTests(Target * target);
 	//
-	BOOL		ActiveInCurrentTest();
-	BOOL		HasActiveCurrentSpec();
-	BOOL		HasIdleCurrentSpec();
+	BOOL ActiveInCurrentTest();
+	BOOL HasActiveCurrentSpec();
+	BOOL HasIdleCurrentSpec();
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to deal with specific messages to Dynamo
 	//
-	BOOL		SetTargets();
-	void		SetTargetsToPrepare();
-	BOOL		SetAccess( int access_entry );
+	BOOL SetTargets();
+	void SetTargetsToPrepare();
+	BOOL SetAccess(int access_entry);
 	//
 	// Functions to deal with results.
-	void		ResetResults( int which_perf );
-	void		ResetAllResults();
-	void		SaveResults( ostream* file, int access_index, int result_type );
-	void		UpdateResults( int which_perf );
+	void ResetResults(int which_perf);
+	void ResetAllResults();
+	void SaveResults(ostream * file, int access_index, int result_type);
+	void UpdateResults(int which_perf);
 	//
 	// Results for last run test.
-	Results		results[MAX_PERF];
+	Results results[MAX_PERF];
 	//
 	///////////////////////////////////////////////////////////////////////////
 
 	///////////////////////////////////////////////////////////////////////////
 	// Functions to deal with the saving and loading of config files.
 	//
-	BOOL		SaveConfig( ostream& outfile,
-							BOOL save_aspecs,
-							BOOL save_targets );
-	BOOL		LoadConfig( ICF_ifstream& infile,
-							BOOL load_aspecs,
-							BOOL load_targets );
-	BOOL		LoadConfigDefault(	ICF_ifstream& infile );
-	BOOL		LoadConfigAccess(	ICF_ifstream& infile );
-	BOOL		LoadConfigTargets(	ICF_ifstream& infile );
+	BOOL SaveConfig(ostream & outfile, BOOL save_aspecs, BOOL save_targets);
+	BOOL LoadConfig(ICF_ifstream & infile, BOOL load_aspecs, BOOL load_targets);
+	BOOL LoadConfigDefault(ICF_ifstream & infile);
+	BOOL LoadConfigAccess(ICF_ifstream & infile);
+	BOOL LoadConfigTargets(ICF_ifstream & infile);
 	//
 	///////////////////////////////////////////////////////////////////////////
 
@@ -236,58 +218,54 @@
 	// Functions to manage access specs
 	//
 	// Removes all instances of an access spec from the worker's access spec list.
-	void		RemoveAccessSpec( Test_Spec *spec );	
+	void RemoveAccessSpec(Test_Spec * spec);
 	//
 	// Removes a specific instance of an access spec from the worker's access spec list.
-	void		RemoveAccessSpecAt( int index );	
+	void RemoveAccessSpecAt(int index);
 	//
 	// Removes all entries from the worker's access spec list.
-	void		RemoveAllAccessSpecs();
+	void RemoveAllAccessSpecs();
 	//
 	// Returns the number of entries in the worker's access spec list.
-	int			AccessSpecCount();
-	int			IdleAccessSpecCount();
+	int AccessSpecCount();
+	int IdleAccessSpecCount();
 	//
 	// Returns the pointer to the access spec object specified by the index into 
 	// the global access spec list.  The index into the global access spec list 
 	// is found in the specified entry in the local access spec list.
-	Test_Spec*	GetAccessSpec( int index );
+	Test_Spec *GetAccessSpec(int index);
 	//
 	// Moves the access spec at 'index' to the position before 'before_index'.
-	void		MoveAccessSpec( int index, int before_index );	
+	void MoveAccessSpec(int index, int before_index);
 	//
 	// Inserts the access spec 'index' to the position before 'local_index'.
-	BOOL		InsertAccessSpec( Test_Spec *spec, int insert_at_index 
-					= IOERROR );
+	BOOL InsertAccessSpec(Test_Spec * spec, int insert_at_index = IOERROR);
 	//
 	// Determines if all assigned test parameters are valid for this worker.
-	BOOL		InvalidSetup( BOOL &invalidSpecOK );
+	BOOL InvalidSetup(BOOL & invalidSpecOK);
 	//
 	// Assigns all the specs from the global list that match the  worker's type.
-	void		AssignDefaultAccessSpecs();
-	//	
-protected:
-	CTypedPtrArray<CPtrArray, Test_Spec*> access_spec_list;	// Pointer array to AccessSpecObjects
+	void AssignDefaultAccessSpecs();
+	//      
+      protected:
+	 CTypedPtrArray < CPtrArray, Test_Spec * >access_spec_list;	// Pointer array to AccessSpecObjects
 	//
 	///////////////////////////////////////////////////////////////////////////
 
-
-public:
+      public:
 	///////////////////////////////////////////////////////////////////////////
 	// Network specific information.
 	//
 	// Create a client worker to be my partner.
-	void		CreateNetClient( Manager *selected_manager, 
-					TargetType client_type );
+	void CreateNetClient(Manager * selected_manager, TargetType client_type);
 	//
 	// Worker on the other end of network connection.
-	Worker*		net_partner;
+	Worker *net_partner;
 	//
 	// Client's index into server's target array.
-	int			net_target_index;
+	int net_target_index;
 	//
 	///////////////////////////////////////////////////////////////////////////
 };
 
-
 #endif

Modified: branches/IOMETER-restruct/iometer/src/WorkerView.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/WorkerView.cpp	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/WorkerView.cpp	2006-02-08 01:56:14 UTC (rev 235)
@@ -61,14 +61,12 @@
 /* ##                                                                     ## */
 /* ######################################################################### */
 
-
 #include "stdafx.h"
 #include "ManagerList.h"
 #include "WorkerView.h"
 #include "GalileoView.h"
 #include "resource.h"
 
-
 // Needed for MFC Library support for assisting in finding memory leaks
 //
 // NOTE: Based on the documentation[1] I found, it should be enough to have
@@ -79,31 +77,28 @@
 //       [1] = http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_mfc_debug_new.asp
 //
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
- #ifdef _DEBUG
-  #define new DEBUG_NEW
-  #undef THIS_FILE
-  static char THIS_FILE[] = __FILE__;
- #endif
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#undef THIS_FILE
+static char THIS_FILE[] = __FILE__;
 #endif
+#endif
 
-
 /////////////////////////////////////////////////////////////////////////////
 // CWorkerView dialog
 
-
-CWorkerView::CWorkerView(CWnd* pParent /*=NULL*/)
-	: CDialog(CWorkerView::IDD, pParent)
+CWorkerView::CWorkerView(CWnd * pParent /*=NULL*/ )
+:  CDialog(CWorkerView::IDD, pParent)
 {
 	//{{AFX_DATA_INIT(CWorkerView)
-		// NOTE: the ClassWizard will add member initialization here
+	// NOTE: the ClassWizard will add member initialization here
 	//}}AFX_DATA_INIT
 	selected_type = IOERROR;
 	editing_label = FALSE;
 	old_label_name = NULL;
 }
 
-
-void CWorkerView::DoDataExchange(CDataExchange* pDX)
+void CWorkerView::DoDataExchange(CDataExchange * pDX)
 {
 	CDialog::DoDataExchange(pDX);
 	//{{AFX_DATA_MAP(CWorkerView)
@@ -111,76 +106,65 @@
 	//}}AFX_DATA_MAP
 }
 
-
 BEGIN_MESSAGE_MAP(CWorkerView, CDialog)
-	ON_WM_CONTEXTMENU()
-	//{{AFX_MSG_MAP(CWorkerView)
-	ON_NOTIFY(TVN_SELCHANGED, TWorkers, OnSelchangedTWorkers)
-	ON_NOTIFY(TVN_SELCHANGING, TWorkers, OnSelchangingTWorkers)
-	ON_NOTIFY(TVN_ENDLABELEDIT, TWorkers, OnEndlabeleditTWorkers)
-	ON_NOTIFY(TVN_BEGINDRAG, TWorkers, OnBegindragTWorkers)
-	ON_NOTIFY(NM_RCLICK, TWorkers, OnRclickTWorkers)
-	ON_NOTIFY(TVN_BEGINLABELEDIT, TWorkers, OnBeginlabeleditTWorkers)
-	//}}AFX_MSG_MAP
+ON_WM_CONTEXTMENU()
+    //{{AFX_MSG_MAP(CWorkerView)
+    ON_NOTIFY(TVN_SELCHANGED, TWorkers, OnSelchangedTWorkers)
+    ON_NOTIFY(TVN_SELCHANGING, TWorkers, OnSelchangingTWorkers)
+    ON_NOTIFY(TVN_ENDLABELEDIT, TWorkers, OnEndlabeleditTWorkers)
+    ON_NOTIFY(TVN_BEGINDRAG, TWorkers, OnBegindragTWorkers)
+    ON_NOTIFY(NM_RCLICK, TWorkers, OnRclickTWorkers)
+ON_NOTIFY(TVN_BEGINLABELEDIT, TWorkers, OnBeginlabeleditTWorkers)
+    //}}AFX_MSG_MAP
 END_MESSAGE_MAP()
-
 /////////////////////////////////////////////////////////////////////////////
 // CWorkerView message handlers
-
-
-
 //
 // Retrieving a pointer to a specified manager item in the view.
 //
-HTREEITEM	CWorkerView::GetManager( Manager* manager )
+HTREEITEM CWorkerView::GetManager(Manager * manager)
 {
-	HTREEITEM	hmanager;
+	HTREEITEM hmanager;
 
 	// Get the first manager
-	hmanager = m_TWorkers.GetChildItem( hall_managers );
-	
+	hmanager = m_TWorkers.GetChildItem(hall_managers);
+
 	// Find the referenced manager.
-	while ( m_TWorkers.GetItemData(hmanager) != (DWORD_PTR)manager )
-		hmanager = m_TWorkers.GetNextItem( hmanager, TVGN_NEXT );
+	while (m_TWorkers.GetItemData(hmanager) != (DWORD_PTR) manager)
+		hmanager = m_TWorkers.GetNextItem(hmanager, TVGN_NEXT);
 
 	return hmanager;
 }
 
-
-
 //
 // Retrieving a pointer to a specified worker item in the view.
 //
-HTREEITEM	CWorkerView::GetWorker( Worker* worker )
+HTREEITEM CWorkerView::GetWorker(Worker * worker)
 {
-	HTREEITEM	hworker;
+	HTREEITEM hworker;
 
 	// Get the first worker.
-	hworker = m_TWorkers.GetChildItem( GetManager( worker->manager ) );
-	
+	hworker = m_TWorkers.GetChildItem(GetManager(worker->manager));
+
 	// Loop through manager's workers until we find the correct one.
-	while ( m_TWorkers.GetItemData( hworker ) != (DWORD_PTR) worker )
-		hworker = m_TWorkers.GetNextSiblingItem( hworker );
+	while (m_TWorkers.GetItemData(hworker) != (DWORD_PTR) worker)
+		hworker = m_TWorkers.GetNextSiblingItem(hworker);
 
 	return hworker;
 }
 
-
-
 //
 // Return the type of the selected worker.
 //
 TargetType CWorkerView::GetSelectedWorkerType()
 {
 	// Getting the type of the currently selected worker, if any.
-	if ( selected_type != WORKER )
+	if (selected_type != WORKER)
 		return InvalidType;
 
 	return GetSelectedWorker()->Type();
 }
 
-
-
 //
 // Select the specified item in the worker tree view and scroll it into view.
 // If both mgr and wkr params are NULL, "All Managers" will be selected.
@@ -188,53 +172,44 @@
 // If mgr and wkr are both defined, the appropriate worker on the specified
 // manager will be selected.
 //
-void CWorkerView::SelectItem( Manager *mgr, Worker *wkr )
+void CWorkerView::SelectItem(Manager * mgr, Worker * wkr)
 {
 	HTREEITEM item;
 
-	if ( mgr )
-	{
-		if ( wkr )
-		{
+	if (mgr) {
+		if (wkr) {
 			// The bar is monitoring a worker on the specified manager.
 			// Find the HTREEITEM corresponding to the worker.
-			item = GetWorker( wkr );
-		}
-		else
-		{
+			item = GetWorker(wkr);
+		} else {
 			// The bar is monitoring a manager.
 			// Find the HTREEITEM corresponding to the manager.
-			item = GetManager( mgr );
+			item = GetManager(mgr);
 		}
-	}
-	else
-	{
+	} else {
 		// The bar is monitoring "All Managers".
 		// Find the HTREEITEM corresponding to "All Managers".
 		item = m_TWorkers.GetRootItem();
 	}
 
 	// Select the item and scroll it into view.
-	m_TWorkers.Select( item, TVGN_CARET );
-	m_TWorkers.EnsureVisible( item );
+	m_TWorkers.Select(item, TVGN_CARET);
+	m_TWorkers.EnsureVisible(item);
 }
 
-
-
 //
 // Adding a the specified manager to the display.
 //
-void CWorkerView::AddManager( Manager *manager )
+void CWorkerView::AddManager(Manager * manager)
 {
-	HTREEITEM	hmanager;
-	
+	HTREEITEM hmanager;
+
 	// Insert a new item into the view and sort the view by name.
-	hmanager = m_TWorkers.InsertItem( 
-		manager->name, WORKER_ICON_MANAGER, WORKER_ICON_MANAGER,
-		hall_managers, TVI_SORT );
+	hmanager = m_TWorkers.InsertItem(manager->name, WORKER_ICON_MANAGER, WORKER_ICON_MANAGER,
+					 hall_managers, TVI_SORT);
 	// Store the pointer to the manager in the newly inserted item's data member.
-	m_TWorkers.SetItemData( hmanager, (DWORD_PTR) manager );
-	m_TWorkers.RedrawWindow( NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE );
+	m_TWorkers.SetItemData(hmanager, (DWORD_PTR) manager);
+	m_TWorkers.RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE);
 
 	// Update the network target list.
 	theApp.pView->m_pPageNetwork->ShowData();
@@ -243,49 +218,44 @@
 	theApp.pView->m_pPageAccess->ShowAssignedAccess();
 }
 
-
-
 //
 // Adding the specified worker to the display.
 //
-void CWorkerView::AddWorker( Worker *worker )
+void CWorkerView::AddWorker(Worker * worker)
 {
-	HTREEITEM	hmanager, hworker;
-	int			icon;
+	HTREEITEM hmanager, hworker;
+	int icon;
 
 	// Get the handle to the tree view entry of the worker's manager.
-	hmanager = GetManager( worker->manager );
+	hmanager = GetManager(worker->manager);
 
-	if ( IsType( worker->Type(), GenericDiskType ) )
+	if (IsType(worker->Type(), GenericDiskType))
 		icon = WORKER_ICON_DISKWORKER;
-	else if ( IsType( worker->Type(), GenericServerType ) )
+	else if (IsType(worker->Type(), GenericServerType))
 		icon = WORKER_ICON_NETSERVER;
-	else if ( IsType( worker->Type(), GenericClientType ) )
+	else if (IsType(worker->Type(), GenericClientType))
 		icon = WORKER_ICON_NETCLIENT;
 	else
 		icon = WORKER_ICON_MANAGER;
-	
+
 	// Add the worker to the manager in the tree view.
-	hworker = m_TWorkers.InsertItem( worker->name, icon, icon, hmanager, 
-		TVI_LAST );
-	m_TWorkers.SetItemData( hworker, (DWORD_PTR) worker );
+	hworker = m_TWorkers.InsertItem(worker->name, icon, icon, hmanager, TVI_LAST);
+	m_TWorkers.SetItemData(hworker, (DWORD_PTR) worker);
 	m_TWorkers.RedrawWindow();
 
 	// Update the Assigned Access Specs listbox.
 	theApp.pView->m_pPageAccess->ShowAssignedAccess();
 }
 
-
 //
 // Returning the pointer to a selected manager or selected
 // worker's manager.
 //
-Manager* CWorkerView::GetSelectedManager()
+Manager *CWorkerView::GetSelectedManager()
 {
-	switch ( selected_type )
-	{
+	switch (selected_type) {
 	case MANAGER:
-		return (Manager *) m_TWorkers.GetItemData( m_TWorkers.GetSelectedItem() );
+		return (Manager *) m_TWorkers.GetItemData(m_TWorkers.GetSelectedItem());
 	case WORKER:
 		return GetSelectedWorker()->manager;
 	default:
@@ -294,16 +264,13 @@
 	}
 }
 
-
-
 //
 // Returning the index of a selected manager or selected
 // worker's manager.
 //
 int CWorkerView::GetSelectedManagerIndex()
 {
-	switch ( selected_type )
-	{
+	switch (selected_type) {
 	case ALL_MANAGERS:
 		return ALL_MANAGERS;
 	case MANAGER:
@@ -317,52 +284,44 @@
 	}
 }
 
-
-
 //
 // Returning the index of a selected worker.
 //
-Worker* CWorkerView::GetSelectedWorker()
+Worker *CWorkerView::GetSelectedWorker()
 {
-	if ( selected_type != WORKER )
+	if (selected_type != WORKER)
 		return NULL;
 
-	return (Worker *) m_TWorkers.GetItemData( m_TWorkers.GetSelectedItem() );
+	return (Worker *) m_TWorkers.GetItemData(m_TWorkers.GetSelectedItem());
 }
 
-
-
 //
 // Returning the index of a selected worker.
 //
 int CWorkerView::GetSelectedWorkerIndex()
 {
-	if ( selected_type != WORKER )
+	if (selected_type != WORKER)
 		return IOERROR;
 
 	return GetSelectedWorker()->GetIndex();
 }
 
-
-
 //
 // Clearing display contents.
 //
 void CWorkerView::Reset()
 {
 	HTREEITEM hmanager;
+
 	// Lock the window.
 
-	m_TWorkers.SelectItem( hall_managers );
-	while ( hmanager = m_TWorkers.GetChildItem( hall_managers ) )
-	{
-		m_TWorkers.DeleteItem( hmanager );
+	m_TWorkers.SelectItem(hall_managers);
+	while (hmanager = m_TWorkers.GetChildItem(hall_managers)) {
+		m_TWorkers.DeleteItem(hmanager);
 	}
 	m_TWorkers.RedrawWindow();
 }
 
-
-
 //
 // Removing the selected item from the GUI.
 //
@@ -370,107 +329,93 @@
 {
 	// Removing selected manager or worker.
 	// First make sure that a manager or worker was selected.
-	switch( selected_type )
-	{
+	switch (selected_type) {
 	case IOERROR:
 		break;
 	case ALL_MANAGERS:
 		theApp.manager_list.RemoveAllManagers();
 		break;
 	case MANAGER:
-		RemoveManager( GetSelectedManager() );
+		RemoveManager(GetSelectedManager());
 		break;
 	case WORKER:
-		RemoveWorker( GetSelectedWorker() );
+		RemoveWorker(GetSelectedWorker());
 		break;
 	}
 }
 
-
-
 //
 // Removing manager indicated by index from the display.
 // Update managers with indexes greater than the one removed.
 // This function must be called before removing the manager from 
 // the manager list.
 //
-void CWorkerView::RemoveManager( Manager *manager )
+void CWorkerView::RemoveManager(Manager * manager)
 {
-	HTREEITEM	hworker, hmanager;
+	HTREEITEM hworker, hmanager;
 
-	hmanager = GetManager( manager );
+	hmanager = GetManager(manager);
 	// Remove the manager's workers and associated net clients.
-	while ( hworker = m_TWorkers.GetChildItem( hmanager ) )
-	{
-		RemoveWorker( (Worker *) m_TWorkers.GetItemData( hworker ) );
+	while (hworker = m_TWorkers.GetChildItem(hmanager)) {
+		RemoveWorker((Worker *) m_TWorkers.GetItemData(hworker));
 	}
 
 	// Remove the indicated manager from the display.
-	m_TWorkers.DeleteItem( hmanager );
-	m_TWorkers.RedrawWindow( NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE );
-	theApp.pView->m_pPageNetwork->RemoveManager( manager );
+	m_TWorkers.DeleteItem(hmanager);
+	m_TWorkers.RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_ERASE);
+	theApp.pView->m_pPageNetwork->RemoveManager(manager);
 
 	// Remove the indicated manager from memory.
-	theApp.manager_list.RemoveManager( manager->GetIndex() );
+	theApp.manager_list.RemoveManager(manager->GetIndex());
 }
 
-
-
 //
 // Remove worker from indicated manager.  Update indexes for other
 // workers.  This function must be called before removing the worker
 // from the list of workers.
 //
-void CWorkerView::RemoveWorker( Worker *worker )
+void CWorkerView::RemoveWorker(Worker * worker)
 {
 	// Get the worker tree item.
-	HTREEITEM	hworker = GetWorker( worker );
+	HTREEITEM hworker = GetWorker(worker);
 
 	// If removing a server with an active partner, remove partner as well.
-	if ( IsType( worker->Type(), GenericServerType ) && worker->net_partner )
-	{
+	if (IsType(worker->Type(), GenericServerType) && worker->net_partner) {
 		// Call RemoveWorker recursively to remove the NetClient from the GUI.
-		RemoveWorker( worker->net_partner );
+		RemoveWorker(worker->net_partner);
 	}
-
 	// Remove the indicated worker from memory.
-	worker->manager->RemoveWorker( worker->GetIndex() );
+	worker->manager->RemoveWorker(worker->GetIndex());
 
 	// Remove the indicated worker from the display.
-	m_TWorkers.DeleteItem( hworker );
+	m_TWorkers.DeleteItem(hworker);
 	m_TWorkers.RedrawWindow();
 
 	// Reset the results display tab to its initial state.
 	theApp.pView->m_pPageDisplay->Reset();
 }
 
-
-
 //
 // A new worker or manager is selected.  Update the display.
 //
-void CWorkerView::OnSelchangedTWorkers(NMHDR* pNMHDR, LRESULT* pResult) 
+void CWorkerView::OnSelchangedTWorkers(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
+	NM_TREEVIEW *pNMTreeView = (NM_TREEVIEW *) pNMHDR;
 	HTREEITEM item;
 
 	// If an item is selected, finding out what it is.
 	// Peforming any needed updates after changing selection.
 	item = m_TWorkers.GetSelectedItem();
 	// Is the item selected is all managers?
-	if ( item == hall_managers )
-	{
+	if (item == hall_managers) {
 		selected_type = ALL_MANAGERS;
 		theApp.pView->ChangedSelection();
 	}
 	// If the item's parent is all managers, the item is a manager.
-	else if ( m_TWorkers.GetParentItem( item ) == hall_managers )
-	{
+	else if (m_TWorkers.GetParentItem(item) == hall_managers) {
 		selected_type = MANAGER;
 		theApp.pView->ChangedSelection();
-	}
-	else
-	{
+	} else {
 		// Item is a worker.
 		selected_type = WORKER;
 		theApp.pView->ChangedSelection();
@@ -478,9 +423,7 @@
 	*pResult = 0;
 }
 
-
-
-void CWorkerView::OnSelchangingTWorkers(NMHDR* pNMHDR, LRESULT* pResult) 
+void CWorkerView::OnSelchangingTWorkers(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	// Peforming any needed updates before changing selection.
 	theApp.pView->ChangingSelection();
@@ -488,74 +431,62 @@
 	*pResult = 0;
 }
 
-
-
 //
 // Mark that the user has started editing a label.
 //
-void CWorkerView::OnBeginlabeleditTWorkers(NMHDR* pNMHDR, LRESULT* pResult) 
+void CWorkerView::OnBeginlabeleditTWorkers(NMHDR * pNMHDR, LRESULT * pResult)
 {
 
-	TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR;
+	TV_DISPINFO *pTVDispInfo = (TV_DISPINFO *) pNMHDR;
 
 	editing_label = TRUE;
 
 	// Record the current label name and mark that we're editing the name.
-	if ( !old_label_name )
-	{
-		if ( !(old_label_name = new CString) )
-		{
+	if (!old_label_name) {
+		if (!(old_label_name = new CString)) {
 			ErrorMessage("Unable to allocate memory to store current label name."
-				"  Modifications cannot be undone." );
+				     "  Modifications cannot be undone.");
 			return;
 		}
 	}
-	*old_label_name = m_TWorkers.GetItemText( m_TWorkers.GetSelectedItem() );
+	*old_label_name = m_TWorkers.GetItemText(m_TWorkers.GetSelectedItem());
 
 	*pResult = 0;
 }
 
-
-
 //
 // User renamed one of the workers.  Updating the information in
 // the worker list.
 //
-void CWorkerView::OnEndlabeleditTWorkers(NMHDR* pNMHDR, LRESULT* pResult) 
+void CWorkerView::OnEndlabeleditTWorkers(NMHDR * pNMHDR, LRESULT * pResult)
 {
-	TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR;
+	TV_DISPINFO *pTVDispInfo = (TV_DISPINFO *) pNMHDR;
 	CString new_name = pTVDispInfo->item.pszText;
 
 	// Don't allow renaming of "All Managers" or network clients.
-	if ( pTVDispInfo->item.mask & TVIF_TEXT
-			&& (selected_type == MANAGER || selected_type == WORKER)
-			&& !IsType( GetSelectedWorkerType(), GenericClientType ) )
-	{
+	if (pTVDispInfo->item.mask & TVIF_TEXT && (selected_type == MANAGER || selected_type == WORKER)
+	    && !IsType(GetSelectedWorkerType(), GenericClientType)) {
 		// Don't allow any leading or trailing spaces.
 		new_name.TrimLeft();
 		new_name.TrimRight();
 
 		// It's okay to put the string back into the array of unknown
 		// size because we know we have not lengthened the string.
-		strcpy( pTVDispInfo->item.pszText, (LPCTSTR)new_name );
+		strcpy(pTVDispInfo->item.pszText, (LPCTSTR) new_name);
 
-		if ( !new_name.IsEmpty() )
-		{
+		if (!new_name.IsEmpty()) {
 			// New name is non-empty; change it.  (If new name is an empty string, 
 			// do nothing -- old name remains unchanged.)
 
-			if ( selected_type == WORKER )
-			{
+			if (selected_type == WORKER) {
 				// Modify worker's name.
-				strcpy( GetSelectedWorker()->name, pTVDispInfo->item.pszText );
+				strcpy(GetSelectedWorker()->name, pTVDispInfo->item.pszText);
 
 				// Assign disambiguating integer identifiers to same-named managers.
 				GetSelectedManager()->IndexWorkers();
-			}
-			else
-			{
+			} else {
 				// Modify manager's name.
-				strcpy( GetSelectedManager()->name, pTVDispInfo->item.pszText );
+				strcpy(GetSelectedManager()->name, pTVDispInfo->item.pszText);
 				theApp.pView->m_pPageNetwork->ShowData();
 
 				// Assign disambiguating integer identifiers to same-named managers.
@@ -563,26 +494,25 @@
 			}
 
 			// Changing name of selected item.
-			m_TWorkers.SetItemText( m_TWorkers.GetSelectedItem(), pTVDispInfo->item.pszText );
+			m_TWorkers.SetItemText(m_TWorkers.GetSelectedItem(), pTVDispInfo->item.pszText);
 
 			// See if a network server worker is selected.
-			if ( IsType( GetSelectedWorkerType(), GenericServerType ) )
-			{
-				Worker* server = GetSelectedWorker();
+			if (IsType(GetSelectedWorkerType(), GenericServerType)) {
+				Worker *server = GetSelectedWorker();
 
 				// See if this server has a client worker assigned to it.
-				if ( server->net_partner )
-				{
+				if (server->net_partner) {
 					// Change the worker's name.
-					strcpy(server->net_partner->name, "[" + (CString)pTVDispInfo->item.pszText + "]");
+					strcpy(server->net_partner->name,
+					       "[" + (CString) pTVDispInfo->item.pszText + "]");
 
 					// Update the tree control to reflect the new name.
-					m_TWorkers.SetItemText( GetWorker(server->net_partner), server->net_partner->name );
+					m_TWorkers.SetItemText(GetWorker(server->net_partner),
+							       server->net_partner->name);
 				}
 			}
-
 			// Re-sort the manager list.
-			m_TWorkers.SortChildren( m_TWorkers.GetRootItem() );
+			m_TWorkers.SortChildren(m_TWorkers.GetRootItem());
 
 			// Update the Results Display page.
 			theApp.pView->m_pPageDisplay->Update();
@@ -590,39 +520,38 @@
 	}
 
 	editing_label = FALSE;
-	if ( old_label_name )
-	{
+	if (old_label_name) {
 		delete old_label_name;
+
 		old_label_name = NULL;
 	}
 	*pResult = 0;
 }
 
-
-
-LRESULT CWorkerView::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
+LRESULT CWorkerView::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam)
 {
-	if ( message == WM_WINDOWPOSCHANGING )
-		((WINDOWPOS*)lParam)->flags = ((WINDOWPOS*)lParam)->flags & ( 0xffffffff ^ SWP_NOACTIVATE ) & ( 0xffffffff ^ SWP_HIDEWINDOW );
+	if (message == WM_WINDOWPOSCHANGING)
+		((WINDOWPOS *) lParam)->flags =
+		    ((WINDOWPOS *) lParam)->flags & (0xffffffff ^ SWP_NOACTIVATE) & (0xffffffff ^ SWP_HIDEWINDOW);
 	return CDialog::DefWindowProc(message, wParam, lParam);
 }
 
-
-
-BOOL CWorkerView::PreTranslateMessage(MSG* pMsg)
+BOOL CWorkerView::PreTranslateMessage(MSG * pMsg)
 {
 	// CG: This block was added by the Pop-up Menu component
 	{
 		// Shift+F10: show pop-up menu.
-		if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
-			(pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||	// it's Shift+F10 OR
-			(pMsg->message == WM_CONTEXTMENU))									// Natural keyboard key
+		if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) &&	// If we hit a key and
+		      (pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||	// it's Shift+F10 OR
+		    (pMsg->message == WM_CONTEXTMENU))	// Natural keyboard key
 		{
 			CRect rect;
+
 			GetClientRect(rect);
 			ClientToScreen(rect);
 
 			CPoint point = rect.TopLeft();
+
 			point.Offset(5, 5);
 			OnContextMenu(NULL, point);
 
@@ -633,114 +562,103 @@
 	return CDialog::PreTranslateMessage(pMsg);
 }
 
-
-
-void CWorkerView::OnBegindragTWorkers(NMHDR* pNMHDR, LRESULT* pResult) 
+void CWorkerView::OnBegindragTWorkers(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	// check that input parameter is valid
-	if ( !pNMHDR )
-	{
+	if (!pNMHDR) {
 		return;
 	}
-
 	// Select the item to drag.
-	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
-	m_TWorkers.SelectItem( pNMTreeView->itemNew.hItem );
+	NM_TREEVIEW *pNMTreeView = (NM_TREEVIEW *) pNMHDR;
 
+	m_TWorkers.SelectItem(pNMTreeView->itemNew.hItem);
+
 	// Check to see if dragging is apropriate.
-	if ( theApp.pView->m_pPropSheet->GetActiveIndex() == DISPLAY_PAGE )
-	{
+	if (theApp.pView->m_pPropSheet->GetActiveIndex() == DISPLAY_PAGE) {
 		CPoint point;
 
 		theApp.pView->dragging = TRUE;	// Set flag indicating that a drag operation is underway.
-		
+
 		// set hot spot to middle of 16x16 icon
 		point.x = 8;
 		point.y = 8;
 
 		// set drag icon to icon of current selection
-		theApp.pView->p_DragImage = m_TWorkers.CreateDragImage( pNMTreeView->itemNew.hItem );
-		theApp.pView->p_DragImage->BeginDrag( 0, point );
+		theApp.pView->p_DragImage = m_TWorkers.CreateDragImage(pNMTreeView->itemNew.hItem);
+		theApp.pView->p_DragImage->BeginDrag(0, point);
 	}
 	*pResult = 0;
 }
 
-
-
 int CWorkerView::GetSelectedType()
 {
 	return selected_type;
 }
 
-
 //
 // This function selects the manager that the user just right clicked on.
 // It removes anoying flickering when right clicking on a manager.
 // 
-void CWorkerView::OnRclickTWorkers(NMHDR* pNMHDR, LRESULT* pResult) 
+void CWorkerView::OnRclickTWorkers(NMHDR * pNMHDR, LRESULT * pResult)
 {
 	CPoint point;
 	TV_HITTESTINFO test_info;
+
 	// Get the cursor position.
-	GetCursorPos( &point );
+	GetCursorPos(&point);
 	test_info.pt = point;
-	m_TWorkers.ScreenToClient( &(test_info.pt) );
+	m_TWorkers.ScreenToClient(&(test_info.pt));
 	// Check to see whether the cursor is on an item, and if the item a manager.
-	m_TWorkers.HitTest( &test_info );
-	if ( test_info.hItem )
-	{
-		if ( m_TWorkers.GetParentItem( test_info.hItem ) &&
-			!m_TWorkers.GetParentItem( m_TWorkers.GetParentItem( test_info.hItem ) ) )
-		{
+	m_TWorkers.HitTest(&test_info);
+	if (test_info.hItem) {
+		if (m_TWorkers.GetParentItem(test_info.hItem) &&
+		    !m_TWorkers.GetParentItem(m_TWorkers.GetParentItem(test_info.hItem))) {
 			// Item is a manager, select it.
-			m_TWorkers.SelectItem( test_info.hItem );
+			m_TWorkers.SelectItem(test_info.hItem);
 			// CG: This function was added by the Pop-up Menu component
 			CMenu menu;
+
 			VERIFY(menu.LoadMenu(CG_IDR_POPUP_WORKER_VIEW));
 
-			CMenu* pPopup = menu.GetSubMenu(0);
+			CMenu *pPopup = menu.GetSubMenu(0);
+
 			ASSERT(pPopup != NULL);
 
 			// Get the first non-child window.
-			CWnd* pWndPopupOwner = this;
+			CWnd *pWndPopupOwner = this;
+
 			while (pWndPopupOwner->GetStyle() & WS_CHILD)
 				pWndPopupOwner = pWndPopupOwner->GetParent();
 
 			// Save the item so that the user can refresh.
 			theApp.pView->right_clicked_item = test_info.hItem;
 
-			pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y,
-				pWndPopupOwner);
+			pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, pWndPopupOwner);
 		}
 	}
 	*pResult = 0;
 }
 
-
-
-void CWorkerView::Initialize() 
+void CWorkerView::Initialize()
 {
 	// Associate the image list with the worker tree control.
 	m_ImageList.Create(IDB_WORKER_ICONS, WORKER_ICON_SIZE, WORKER_ICON_EXPAND, WORKER_ICON_BGCOLOR);
-	m_TWorkers.SetImageList( &m_ImageList, TVSIL_NORMAL );
-	
+	m_TWorkers.SetImageList(&m_ImageList, TVSIL_NORMAL);
+
 	// Insert all managers item at the root of the tree view.
-	hall_managers = m_TWorkers.InsertItem( "All Managers", 
-		WORKER_ICON_ALLMGRS, WORKER_ICON_ALLMGRS,
-		TVI_ROOT, TVI_SORT );
-	
+	hall_managers = m_TWorkers.InsertItem("All Managers",
+					      WORKER_ICON_ALLMGRS, WORKER_ICON_ALLMGRS, TVI_ROOT, TVI_SORT);
+
 	// Expand the all managers item so that managers will be visible.
-	m_TWorkers.SetItemState( hall_managers, TVIS_EXPANDED, TVIS_EXPANDED );
-	
+	m_TWorkers.SetItemState(hall_managers, TVIS_EXPANDED, TVIS_EXPANDED);
+
 	// Set the All Managers item's data.
-	m_TWorkers.SetItemData( hall_managers, (DWORD) NULL );
+	m_TWorkers.SetItemData(hall_managers, (DWORD) NULL);
 
 	// Select all managers by default.
-	m_TWorkers.SelectItem( hall_managers );
+	m_TWorkers.SelectItem(hall_managers);
 }
 
-
-
 //
 // Since CWorkerView is based on the Dialog class, the OnOK handler is called
 // whenever the user presses the <Enter> key.  The <Enter> key being pressed
@@ -749,7 +667,7 @@
 void CWorkerView::OnOK()
 {
 	// Only trap the enter key if we're editing a label.
-	if ( !editing_label )
+	if (!editing_label)
 		return;
 
 	// Set the focus to the tree control to end the editing session.
@@ -757,8 +675,6 @@
 	m_TWorkers.SetFocus();
 }
 
-
-
 //
 // Since CWorkerView is based on the Dialog class, the OnCancel handler is 
 // called whenever the user presses the <Esc> key.  The <Esc> key being pressed
@@ -766,21 +682,19 @@
 //
 void CWorkerView::OnCancel()
 {
-	CEdit	*label_edit;
+	CEdit *label_edit;
 
 	// Only trap the escape key if we're editing a label and we know its
 	// original value.
-	if ( !editing_label || !old_label_name)
+	if (!editing_label || !old_label_name)
 		return;
 
 	// Set the label to the original text.
-	if ( !(label_edit = m_TWorkers.GetEditControl()) )
-	{
-		ErrorMessage( "Unable to retrieve edit box used to modify label in "
-			"CWorkerView::OnCancel()." );
+	if (!(label_edit = m_TWorkers.GetEditControl())) {
+		ErrorMessage("Unable to retrieve edit box used to modify label in " "CWorkerView::OnCancel().");
 		return;
 	}
-	label_edit->SetWindowText( *old_label_name );
+	label_edit->SetWindowText(*old_label_name);
 
 	// Set the focus to the tree control to end the editing session.
 	// This will remove it from the temporary edit control.

Modified: branches/IOMETER-restruct/iometer/src/WorkerView.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/WorkerView.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/WorkerView.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -60,10 +60,9 @@
 #ifndef	WORKER_VIEW_DEFINED
 #define WORKER_VIEW_DEFINED
 
-
 #if _MSC_VER >= 1000
 #pragma once
-#endif // _MSC_VER >= 1000
+#endif				// _MSC_VER >= 1000
 // WorkerView.h : header file
 //
 
@@ -71,7 +70,7 @@
 
 // Info for Workers image list
 #define WORKER_ICON_SIZE					16
-#define WORKER_ICON_EXPAND					10 // number of icons to add to ImageList when expanding
+#define WORKER_ICON_EXPAND					10	// number of icons to add to ImageList when expanding
 #define WORKER_ICON_BGCOLOR					0x00ff00ff
 
 // Icons for Worker pane (position of icon in bitmap)
@@ -84,75 +83,74 @@
 /////////////////////////////////////////////////////////////////////////////
 // CWorkerView dialog
 
-class CWorkerView : public CDialog
-{
+class CWorkerView:public CDialog {
 // Construction
-public:
-	CWorkerView(CWnd* pParent = NULL);   // standard constructor
+      public:
+	CWorkerView(CWnd * pParent = NULL);	// standard constructor
 
-	TargetType	GetSelectedWorkerType();
+	TargetType GetSelectedWorkerType();
 
-	void		AddManager( Manager *manager );
-	void		AddWorker( Worker *worker );
+	void AddManager(Manager * manager);
+	void AddWorker(Worker * worker);
 
-	void		Initialize();
-	void		Reset();
+	void Initialize();
+	void Reset();
 
-	void		RemoveSelectedItem();
-	void		RemoveManager( Manager *manager );
-	void		RemoveWorker( Worker *worker );
+	void RemoveSelectedItem();
+	void RemoveManager(Manager * manager);
+	void RemoveWorker(Worker * worker);
 
-	Manager*	GetSelectedManager();
-	Worker*		GetSelectedWorker();
-	int			GetSelectedManagerIndex();
-	int			GetSelectedWorkerIndex();
-	int			GetSelectedType();
+	Manager *GetSelectedManager();
+	Worker *GetSelectedWorker();
+	int GetSelectedManagerIndex();
+	int GetSelectedWorkerIndex();
+	int GetSelectedType();
 
-	void		SelectItem( Manager *mgr, Worker *wkr );
+	void SelectItem(Manager * mgr, Worker * wkr);
 
 // Dialog Data
 	//{{AFX_DATA(CWorkerView)
 	enum { IDD = IDD_MANAGER_VIEW };
-	CTreeCtrl	m_TWorkers;
+	CTreeCtrl m_TWorkers;
 	//}}AFX_DATA
-	CImageList	m_ImageList;
+	CImageList m_ImageList;
 
 // Overrides
 	// ClassWizard generated virtual function overrides
 	//{{AFX_VIRTUAL(CWorkerView)
-	protected:
-	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
+      protected:
+	 virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
 	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);
 	//}}AFX_VIRTUAL
 
 // Implementation
-protected:
-	virtual BOOL PreTranslateMessage(MSG* pMsg);
+      protected:
+	 virtual BOOL PreTranslateMessage(MSG * pMsg);
 
 	// The OK and Cancel buttons do not exist, but are called when the enter
 	// and escape key are pressed.  Use these functions to trap on these keys.
 	virtual void OnOK();
 	virtual void OnCancel();
 
-	HTREEITEM	GetManager( Manager* manager );
-	HTREEITEM	GetWorker( Worker* worker );
+	HTREEITEM GetManager(Manager * manager);
+	HTREEITEM GetWorker(Worker * worker);
 
-	HTREEITEM	hall_managers;
-	int			selected_type;
+	HTREEITEM hall_managers;
+	int selected_type;
 
-	BOOL		editing_label;
-	CString		*old_label_name;
+	BOOL editing_label;
+	CString *old_label_name;
 
 	// Generated message map functions
 	//{{AFX_MSG(CWorkerView)
-	afx_msg void OnSelchangedTWorkers(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnSelchangingTWorkers(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnEndlabeleditTWorkers(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnBegindragTWorkers(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnRclickTWorkers(NMHDR* pNMHDR, LRESULT* pResult);
-	afx_msg void OnBeginlabeleditTWorkers(NMHDR* pNMHDR, LRESULT* pResult);
+	afx_msg void OnSelchangedTWorkers(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnSelchangingTWorkers(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnEndlabeleditTWorkers(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnBegindragTWorkers(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnRclickTWorkers(NMHDR * pNMHDR, LRESULT * pResult);
+	afx_msg void OnBeginlabeleditTWorkers(NMHDR * pNMHDR, LRESULT * pResult);
 	//}}AFX_MSG
-	DECLARE_MESSAGE_MAP()
+	 DECLARE_MESSAGE_MAP()
 };
 
 //{{AFX_INSERT_LOCATION}}

Modified: branches/IOMETER-restruct/iometer/src/ostream64.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/ostream64.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/ostream64.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -64,50 +64,44 @@
 #ifndef	OSTREAM64_DEFINED
 #define OSTREAM64_DEFINED
 
-
-
 // Uncomment if the workaround is needed. This
 // - was needed prior to Win64 2239 IDW SDK and
 // - is needed as of latest Win32 SDK
 #if defined(IOMTR_OS_WIN32)
  //#define WORKAROUND_FOR_INT64_OFSTREAM
 
- #include <stdio.h>
- #include <ostream>
- using namespace std;
+#include <stdio.h>
+#include <ostream>
+using namespace std;
 
- #define INT64_DIGITS	21
+#define INT64_DIGITS	21
 
  //
  // Extension to ostream to permit int64.
  //
- inline ostream& operator << ( ostream& s, _int64 i )
- {
-     char buf[INT64_DIGITS];
-     sprintf( buf, "%I64i", i );  
-     return( s << buf );
- }
+inline ostream & operator <<(ostream & s, _int64 i)
+{
+	char buf[INT64_DIGITS];
 
+	sprintf(buf, "%I64i", i);
+	return (s << buf);
+}
+
  //
  // Extension to ostream to permit unsigned int64.
  //
- inline ostream& operator << ( ostream& s, unsigned _int64 i )
- {
-    char buf[INT64_DIGITS];
-    sprintf( buf, "%I64i", i );
-    return( s << buf );
- }
+inline ostream & operator <<(ostream & s, unsigned _int64 i)
+{
+	char buf[INT64_DIGITS];
 
+	sprintf(buf, "%I64i", i);
+	return (s << buf);
+}
+
 #elif defined(IOMTR_OS_WIN64)
  //#define WORKAROUND_FOR_INT64_OFSTREAM
 #else
- #warning ===> WARNING: You have to do some coding here to get the port done!
+#warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-
-
 #endif
-
-
-
-

Modified: branches/IOMETER-restruct/iometer/src/scripts/iom-indent
===================================================================
--- branches/IOMETER-restruct/iometer/src/scripts/iom-indent	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/scripts/iom-indent	2006-02-08 01:56:14 UTC (rev 235)
@@ -7,4 +7,4 @@
 # Note:
 # Linux kernel suggests to use -l80 but I believe -l120 is better in Iometer case.
 # Any modern monitors and editors (even my vi under gnome) can support a much longer line.
-indent -kr -i8 -ts8 -sob -l120 -ss -ncs "$@"
+indent -bad -kr -i8 -ts8 -sob -l120 -ss -ncs "$@"

Modified: branches/IOMETER-restruct/iometer/src/vipl.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/vipl.h	2006-02-06 19:50:33 UTC (rev 234)
+++ branches/IOMETER-restruct/iometer/src/vipl.h	2006-02-08 01:56:14 UTC (rev 235)
@@ -68,7 +68,6 @@
 #ifndef _VIPL_
 #define _VIPL_  1
 
-
 /**********************************************************************
  * Constants
 **********************************************************************/
@@ -76,7 +75,6 @@
 #define IN
 #define OUT
 
-
 /*
  * This constant is used only by the user and the VIPL library.
  */
@@ -85,38 +83,34 @@
 
 #define VIP_INFINITE INFINITE
 
-#endif  /* !VIP_KERNEL */
+#endif				/* !VIP_KERNEL */
 
-
 /**********************************************************************
  * Data Types
  **********************************************************************/
 
-
 /*
  * Generic types for portability
  */
-typedef     void *            VIP_PVOID;
-typedef     int               VIP_BOOLEAN;
-typedef     char              VIP_CHAR;
-typedef     unsigned char     VIP_UCHAR;
-typedef     unsigned short    VIP_USHORT;
-typedef     unsigned long     VIP_ULONG;
-typedef     unsigned __int64  VIP_UINT64;
-typedef     unsigned __int32  VIP_UINT32;
-typedef     unsigned __int16  VIP_UINT16;
-typedef     unsigned __int8   VIP_UINT8;
+typedef void *VIP_PVOID;
+typedef int VIP_BOOLEAN;
+typedef char VIP_CHAR;
+typedef unsigned char VIP_UCHAR;
+typedef unsigned short VIP_USHORT;
+typedef unsigned long VIP_ULONG;
+typedef unsigned __int64 VIP_UINT64;
+typedef unsigned __int32 VIP_UINT32;
+typedef unsigned __int16 VIP_UINT16;
+typedef unsigned __int8 VIP_UINT8;
 
+typedef VIP_PVOID VIP_QOS;	/* details are not defined */
 
-typedef     VIP_PVOID   VIP_QOS;        /* details are not defined */
-
 /*
  * Constants used with VIP_BOOLEAN
  */
 #define VIP_TRUE    (1)
 #define VIP_FALSE   (0)
 
-
 /*
  * Handles are used for opaque objects.
  */
@@ -141,17 +135,17 @@
  * order to maintain network independence. 
  */
 typedef struct {
-        VIP_UINT16      HostAddressLen;
-        VIP_UINT16      DiscriminatorLen;
-        VIP_UINT8       HostAddress[1]; 
-	
+	VIP_UINT16 HostAddressLen;
+	VIP_UINT16 DiscriminatorLen;
+	VIP_UINT8 HostAddress[1];
+
 	// architecture difference between IA32 and ARM
-	char		padding[8 - sizeof(VIP_UINT16) * 2 - sizeof(VIP_UINT8)];
-} VIP_NET_ADDRESS;
+	char padding[8 - sizeof(VIP_UINT16) * 2 - sizeof(VIP_UINT8)];
+}
+VIP_NET_ADDRESS;
 
+typedef VIP_USHORT VIP_RELIABILITY_LEVEL;
 
-typedef VIP_USHORT	VIP_RELIABILITY_LEVEL;
-
 /*
  *	Bit values for VIP_RELIABILITY_LEVEL
  */
@@ -160,7 +154,6 @@
 #define VIP_SERVICE_RELIABLE_DELIVERY   0x02
 #define VIP_SERVICE_RELIABLE_RECEPTION  0x04
 
-
 /*
  * A VIP_NIC_ATTRIBUTES describes a nic.
  *
@@ -171,30 +164,28 @@
  * Provider at the time that it is initialized.
  */
 typedef struct {
-        VIP_CHAR                Name [64];
-        VIP_ULONG               HardwareVersion;
-        VIP_ULONG               ProviderVersion;
-        VIP_UINT16              NicAddressLen;
-        const VIP_UINT8         *LocalNicAddress;
-        VIP_BOOLEAN             ThreadSafe;
-        VIP_UINT16              MaxDiscriminatorLen;
-        VIP_ULONG               MaxRegisterBytes;
-        VIP_ULONG               MaxRegisterRegions;
-        VIP_ULONG               MaxRegisterBlockBytes;
-        VIP_ULONG               MaxVI;
-        VIP_ULONG               MaxDescriptorsPerQueue;
-        VIP_ULONG               MaxSegmentsPerDesc;
-        VIP_ULONG               MaxCQ;
-        VIP_ULONG               MaxCQEntries;
-        VIP_ULONG               MaxTransferSize;
-        VIP_ULONG               NativeMTU;
-        VIP_ULONG               MaxPtags;
-        VIP_RELIABILITY_LEVEL   ReliabilityLevelSupport;
-        VIP_RELIABILITY_LEVEL   RDMAReadSupport;
+	VIP_CHAR Name[64];
+	VIP_ULONG HardwareVersion;
+	VIP_ULONG ProviderVersion;
+	VIP_UINT16 NicAddressLen;
+	const VIP_UINT8 *LocalNicAddress;
+	VIP_BOOLEAN ThreadSafe;
+	VIP_UINT16 MaxDiscriminatorLen;
+	VIP_ULONG MaxRegisterBytes;
+	VIP_ULONG MaxRegisterRegions;
+	VIP_ULONG MaxRegisterBlockBytes;
+	VIP_ULONG MaxVI;
+	VIP_ULONG MaxDescriptorsPerQueue;
+	VIP_ULONG MaxSegmentsPerDesc;
+	VIP_ULONG MaxCQ;
+	VIP_ULONG MaxCQEntries;
+	VIP_ULONG MaxTransferSize;
+	VIP_ULONG NativeMTU;
+	VIP_ULONG MaxPtags;
+	VIP_RELIABILITY_LEVEL ReliabilityLevelSupport;
+	VIP_RELIABILITY_LEVEL RDMAReadSupport;
 } VIP_NIC_ATTRIBUTES;
 
-
-
 /*
  * Memory alignment required by the NIC for descriptors, in bytes.  
  */
@@ -204,53 +195,47 @@
  *  The address structure for registered memory accesses.
  */
 typedef union {
-     VIP_UINT64     AddressBits;
-     VIP_PVOID      Address;
+	VIP_UINT64 AddressBits;
+	VIP_PVOID Address;
 } VIP_PVOID64;
 
-
 /*
  * The control portion of the descriptor.
  */
 typedef struct {
-      VIP_PVOID64       Next;
-      VIP_MEM_HANDLE    NextHandle; 
-      VIP_UINT16        SegCount;
-      VIP_UINT16        Control;
-      VIP_UINT32        Reserved;
-      VIP_UINT32        ImmediateData;
-      VIP_UINT32        Length;
-      VIP_UINT32        Status;
+	VIP_PVOID64 Next;
+	VIP_MEM_HANDLE NextHandle;
+	VIP_UINT16 SegCount;
+	VIP_UINT16 Control;
+	VIP_UINT32 Reserved;
+	VIP_UINT32 ImmediateData;
+	VIP_UINT32 Length;
+	VIP_UINT32 Status;
 } VIP_CONTROL_SEGMENT;
 
-
 /*
  * Descriptor RDMA Segment
  */
 typedef struct {
-      VIP_PVOID64       Data;
-      VIP_MEM_HANDLE    Handle;
-      VIP_UINT32        Reserved;
+	VIP_PVOID64 Data;
+	VIP_MEM_HANDLE Handle;
+	VIP_UINT32 Reserved;
 } VIP_ADDRESS_SEGMENT;
 
-
 /*
  * Descriptor Data Segment
  */
 typedef struct {
-      VIP_PVOID64       Data;
-      VIP_MEM_HANDLE    Handle;
-      VIP_UINT32        Length;
+	VIP_PVOID64 Data;
+	VIP_MEM_HANDLE Handle;
+	VIP_UINT32 Length;
 } VIP_DATA_SEGMENT;
 
-
-
 typedef union {
-     VIP_ADDRESS_SEGMENT     Remote;
-     VIP_DATA_SEGMENT        Local;
+	VIP_ADDRESS_SEGMENT Remote;
+	VIP_DATA_SEGMENT Local;
 } VIP_DESCRIPTOR_SEGMENT;
 
-
 /*
  * Complete VI Descriptor
  */
@@ -259,15 +244,14 @@
 //       this stuff. Current knowledge is Sparc build without underscore and i386
 //       build with it (otherwise it conflicts with /usr/include/ia32/sys/reg.h).
 #if defined(IOMTR_OS_SOLARIS) && defined(IOMTR_CPU_I386)
-      VIP_CONTROL_SEGMENT     _CS;
-      VIP_DESCRIPTOR_SEGMENT  _DS[2];
+	VIP_CONTROL_SEGMENT _CS;
+	VIP_DESCRIPTOR_SEGMENT _DS[2];
 #else
-      VIP_CONTROL_SEGMENT     CS;
-      VIP_DESCRIPTOR_SEGMENT  DS[2];
+	VIP_CONTROL_SEGMENT CS;
+	VIP_DESCRIPTOR_SEGMENT DS[2];
 #endif
 } VIP_DESCRIPTOR;
 
-
 /*
  * Bit field macros for descriptor control segment: Control field
  */
@@ -280,7 +264,6 @@
 #define     VIP_CONTROL_QFENCE                        0x0008
 #define     VIP_CONTROL_RESERVED                      0xFFF0
 
-
 /*
  * Bit field macros for descriptor control segment: Status field
  */
@@ -306,355 +289,256 @@
 
 #define     VIP_STATUS_RESERVED                       0xFFF0FE00
 
-
-
 /*
  * VIP_VI_STATE is used in the return of VipQueryVi.
  */
 typedef enum {
-      VIP_STATE_IDLE,
-      VIP_STATE_CONNECTED,
-      VIP_STATE_CONNECT_PENDING,
-      VIP_STATE_ERROR
+	VIP_STATE_IDLE,
+	VIP_STATE_CONNECTED,
+	VIP_STATE_CONNECT_PENDING,
+	VIP_STATE_ERROR
 } VIP_VI_STATE;
 
-
 /*
  * VIP_VI_ATTRIBUTES is used to create and query VIs.
  */
 typedef struct {
-      VIP_RELIABILITY_LEVEL         ReliabilityLevel;
-      VIP_ULONG                     MaxTransferSize;
-      VIP_QOS                       QoS;
-      VIP_PROTECTION_HANDLE         Ptag;
-      VIP_BOOLEAN                   EnableRdmaWrite;
-      VIP_BOOLEAN                   EnableRdmaRead;
+	VIP_RELIABILITY_LEVEL ReliabilityLevel;
+	VIP_ULONG MaxTransferSize;
+	VIP_QOS QoS;
+	VIP_PROTECTION_HANDLE Ptag;
+	VIP_BOOLEAN EnableRdmaWrite;
+	VIP_BOOLEAN EnableRdmaRead;
 } VIP_VI_ATTRIBUTES;
 
-
 /*
  * VIP_MEM_ATTRIBUTES is used to create and query Memory regions.
  */
-typedef struct _VIP_MEM_ATTRIBUTES  {
-      VIP_PROTECTION_HANDLE         Ptag;
-      VIP_BOOLEAN                   EnableRdmaWrite;
-      VIP_BOOLEAN                   EnableRdmaRead;
+typedef struct _VIP_MEM_ATTRIBUTES {
+	VIP_PROTECTION_HANDLE Ptag;
+	VIP_BOOLEAN EnableRdmaWrite;
+	VIP_BOOLEAN EnableRdmaRead;
 } VIP_MEM_ATTRIBUTES;
 
-
 /*
  * Error Descriptor Error Codes
  */
 typedef enum _VIP_ERROR_CODE {
-      VIP_ERROR_POST_DESC,
-      VIP_ERROR_CONN_LOST,
-      VIP_ERROR_RECVQ_EMPTY,
-      VIP_ERROR_VI_OVERRUN,
-      VIP_ERROR_RDMAW_PROT,
-      VIP_ERROR_RDMAW_DATA,
-      VIP_ERROR_RDMAW_ABORT,
-      VIP_ERROR_RDMAR_PROT,
-      VIP_ERROR_COMP_PROT,
-      VIP_ERROR_RDMA_TRANSPORT,
-      VIP_ERROR_CATASTROPHIC
+	VIP_ERROR_POST_DESC,
+	VIP_ERROR_CONN_LOST,
+	VIP_ERROR_RECVQ_EMPTY,
+	VIP_ERROR_VI_OVERRUN,
+	VIP_ERROR_RDMAW_PROT,
+	VIP_ERROR_RDMAW_DATA,
+	VIP_ERROR_RDMAW_ABORT,
+	VIP_ERROR_RDMAR_PROT,
+	VIP_ERROR_COMP_PROT,
+	VIP_ERROR_RDMA_TRANSPORT,
+	VIP_ERROR_CATASTROPHIC
 } VIP_ERROR_CODE;
 
-
 /*
  * Error Descriptor Resource Codes
  */
 typedef enum _VIP_RESOURCE_CODE {
-      VIP_RESOURCE_NIC,
-      VIP_RESOURCE_VI,
-      VIP_RESOURCE_CQ,
-      VIP_RESOURCE_DESCRIPTOR
+	VIP_RESOURCE_NIC,
+	VIP_RESOURCE_VI,
+	VIP_RESOURCE_CQ,
+	VIP_RESOURCE_DESCRIPTOR
 } VIP_RESOURCE_CODE;
 
 /*
  * Error Descriptor for Asynch. errors
  */
 typedef struct _VIP_ERROR_DESCRIPTOR {
-      VIP_NIC_HANDLE          NicHandle;
-      VIP_VI_HANDLE           ViHandle;
-      VIP_CQ_HANDLE           CQHandle;
-      VIP_DESCRIPTOR          *DescriptorPtr;
-      VIP_ULONG               OpCode;
-      VIP_RESOURCE_CODE       ResourceCode;
-      VIP_ERROR_CODE          ErrorCode;
+	VIP_NIC_HANDLE NicHandle;
+	VIP_VI_HANDLE ViHandle;
+	VIP_CQ_HANDLE CQHandle;
+	VIP_DESCRIPTOR *DescriptorPtr;
+	VIP_ULONG OpCode;
+	VIP_RESOURCE_CODE ResourceCode;
+	VIP_ERROR_CODE ErrorCode;
 } VIP_ERROR_DESCRIPTOR;
 
 /*
  * Return codes from the functions.
  */
 typedef enum {
-      VIP_SUCCESS,
-      VIP_NOT_DONE,
-      VIP_INVALID_PARAMETER,
-      VIP_ERROR_RESOURCE,
-      VIP_TIMEOUT,
-      VIP_REJECT,
-      VIP_INVALID_RELIABILITY_LEVEL,
-      VIP_INVALID_MTU,
-      VIP_INVALID_QOS,
-      VIP_INVALID_PTAG,
-      VIP_INVALID_RDMAREAD,
-      VIP_DESCRIPTOR_ERROR,
-      VIP_INVALID_STATE,
-      VIP_ERROR_NAMESERVICE,
-      VIP_NO_MATCH
- } VIP_RETURN;
+	VIP_SUCCESS,
+	VIP_NOT_DONE,
+	VIP_INVALID_PARAMETER,
+	VIP_ERROR_RESOURCE,
+	VIP_TIMEOUT,
+	VIP_REJECT,
+	VIP_INVALID_RELIABILITY_LEVEL,
+	VIP_INVALID_MTU,
+	VIP_INVALID_QOS,
+	VIP_INVALID_PTAG,
+	VIP_INVALID_RDMAREAD,
+	VIP_DESCRIPTOR_ERROR,
+	VIP_INVALID_STATE,
+	VIP_ERROR_NAMESERVICE,
+	VIP_NO_MATCH
+} VIP_RETURN;
 
-
 /*
  * InfoType values
  */
 #define VIP_SMI_AUTODISCOVERY   ((VIP_ULONG) 1)
 
-
 /*
  * AutoDiscovery List fields
  */
 typedef struct {
-    VIP_ULONG        NumberOfHops;
-    VIP_NET_ADDRESS  **ADAddrArray;
-    VIP_ULONG        NumAdAddrs;
- } VIP_AUTODISCOVERY_LIST;
+	VIP_ULONG NumberOfHops;
+	VIP_NET_ADDRESS **ADAddrArray;
+	VIP_ULONG NumAdAddrs;
+} VIP_AUTODISCOVERY_LIST;
 
-
 /**********************************************************************
  * Functions
 **********************************************************************/
 
-extern VIP_RETURN
-VipOpenNic( IN  const VIP_CHAR      *DeviceName,
-            OUT VIP_NIC_HANDLE      *NicHandle);
+extern VIP_RETURN VipOpenNic(IN const VIP_CHAR * DeviceName, OUT VIP_NIC_HANDLE * NicHandle);
 
-extern VIP_RETURN
-VipCloseNic( IN VIP_NIC_HANDLE  NicHandle);
+extern VIP_RETURN VipCloseNic(IN VIP_NIC_HANDLE NicHandle);
 
 extern VIP_RETURN
-VipCreateVi( IN     VIP_NIC_HANDLE      NicHandle,
-             IN     VIP_VI_ATTRIBUTES   *ViAttribs,
-             IN     VIP_CQ_HANDLE       SendCQHandle,
-             IN     VIP_CQ_HANDLE       RecvCQHandle,
-             OUT    VIP_VI_HANDLE       *ViHandle);
+VipCreateVi(IN VIP_NIC_HANDLE NicHandle,
+	    IN VIP_VI_ATTRIBUTES * ViAttribs,
+	    IN VIP_CQ_HANDLE SendCQHandle, IN VIP_CQ_HANDLE RecvCQHandle, OUT VIP_VI_HANDLE * ViHandle);
 
-extern VIP_RETURN
-VipDestroyVi( IN    VIP_VI_HANDLE   ViHandle);
+extern VIP_RETURN VipDestroyVi(IN VIP_VI_HANDLE ViHandle);
 
 extern VIP_RETURN
-VipConnectWait( IN      VIP_NIC_HANDLE      NicHandle,
-                IN      VIP_NET_ADDRESS     *LocalAddr,
-                IN      VIP_ULONG           Timeout,
-                OUT     VIP_NET_ADDRESS     *RemoteAddr,
-                OUT     VIP_VI_ATTRIBUTES   *RemoteViAttribs,
-                OUT     VIP_CONN_HANDLE     *ConnHandle);
+VipConnectWait(IN VIP_NIC_HANDLE NicHandle,
+	       IN VIP_NET_ADDRESS * LocalAddr,
+	       IN VIP_ULONG Timeout,
+	       OUT VIP_NET_ADDRESS * RemoteAddr,
+	       OUT VIP_VI_ATTRIBUTES * RemoteViAttribs, OUT VIP_CONN_HANDLE * ConnHandle);
 
-extern VIP_RETURN
-VipConnectAccept( IN    VIP_CONN_HANDLE ConnHandle,
-                  IN    VIP_VI_HANDLE   ViHandle);
+extern VIP_RETURN VipConnectAccept(IN VIP_CONN_HANDLE ConnHandle, IN VIP_VI_HANDLE ViHandle);
 
-extern VIP_RETURN
-VipConnectReject( IN    VIP_CONN_HANDLE ConnHandle);
+extern VIP_RETURN VipConnectReject(IN VIP_CONN_HANDLE ConnHandle);
 
 extern VIP_RETURN
-VipConnectRequest( IN   VIP_VI_HANDLE       ViHandle,
-                   IN   VIP_NET_ADDRESS     *LocalAddr,
-                   IN   VIP_NET_ADDRESS     *RemoteAddr,
-                   IN   VIP_ULONG           Timeout,
-                   OUT  VIP_VI_ATTRIBUTES   *RemoteViAttribs);
+VipConnectRequest(IN VIP_VI_HANDLE ViHandle,
+		  IN VIP_NET_ADDRESS * LocalAddr,
+		  IN VIP_NET_ADDRESS * RemoteAddr, IN VIP_ULONG Timeout, OUT VIP_VI_ATTRIBUTES * RemoteViAttribs);
 
-extern VIP_RETURN
-VipDisconnect( IN    VIP_VI_HANDLE      ViHandle);
+extern VIP_RETURN VipDisconnect(IN VIP_VI_HANDLE ViHandle);
 
-extern VIP_RETURN
-VipCreatePtag( IN   VIP_NIC_HANDLE          NicHandle,
-               OUT  VIP_PROTECTION_HANDLE   *Ptag);
+extern VIP_RETURN VipCreatePtag(IN VIP_NIC_HANDLE NicHandle, OUT VIP_PROTECTION_HANDLE * Ptag);
 
-extern VIP_RETURN
-VipDestroyPtag( IN  VIP_NIC_HANDLE          NicHandle,
-                IN  VIP_PROTECTION_HANDLE   Ptag);
+extern VIP_RETURN VipDestroyPtag(IN VIP_NIC_HANDLE NicHandle, IN VIP_PROTECTION_HANDLE Ptag);
 
 extern VIP_RETURN
-VipRegisterMem( IN  VIP_NIC_HANDLE      NicHandle,
-                IN  VIP_PVOID           VirtualAddress, 
-                IN  VIP_ULONG           Length,
-                IN  VIP_MEM_ATTRIBUTES  *MemAttribs,
-                OUT VIP_MEM_HANDLE      *MemoryHandle);
+VipRegisterMem(IN VIP_NIC_HANDLE NicHandle,
+	       IN VIP_PVOID VirtualAddress,
+	       IN VIP_ULONG Length, IN VIP_MEM_ATTRIBUTES * MemAttribs, OUT VIP_MEM_HANDLE * MemoryHandle);
 
 extern VIP_RETURN
-VipDeregisterMem( IN    VIP_NIC_HANDLE  NicHandle,
-                  IN    VIP_PVOID       VirtualAddress,
-                  IN    VIP_MEM_HANDLE  MemoryHandle);
+VipDeregisterMem(IN VIP_NIC_HANDLE NicHandle, IN VIP_PVOID VirtualAddress, IN VIP_MEM_HANDLE MemoryHandle);
 
 extern VIP_RETURN
-VipPostSend( IN VIP_VI_HANDLE   ViHandle,
-             IN VIP_DESCRIPTOR  *DescriptorPtr,
-             IN VIP_MEM_HANDLE  MemoryHandle);
+VipPostSend(IN VIP_VI_HANDLE ViHandle, IN VIP_DESCRIPTOR * DescriptorPtr, IN VIP_MEM_HANDLE MemoryHandle);
 
-extern VIP_RETURN
-VipSendDone( IN     VIP_VI_HANDLE   ViHandle, 
-             OUT    VIP_DESCRIPTOR  **DescriptorPtr);
+extern VIP_RETURN VipSendDone(IN VIP_VI_HANDLE ViHandle, OUT VIP_DESCRIPTOR ** DescriptorPtr);
 
-extern VIP_RETURN
-VipSendWait( IN     VIP_VI_HANDLE   ViHandle,
-             IN     VIP_ULONG       Timeout,
-             OUT    VIP_DESCRIPTOR  **DescriptorPtr);
+extern VIP_RETURN VipSendWait(IN VIP_VI_HANDLE ViHandle, IN VIP_ULONG Timeout, OUT VIP_DESCRIPTOR ** DescriptorPtr);
 
 extern VIP_RETURN
-VipPostRecv( IN VIP_VI_HANDLE   ViHandle, 
-             IN VIP_DESCRIPTOR  *DescriptorPtr, 
-             IN VIP_MEM_HANDLE  MemoryHandle);
+VipPostRecv(IN VIP_VI_HANDLE ViHandle, IN VIP_DESCRIPTOR * DescriptorPtr, IN VIP_MEM_HANDLE MemoryHandle);
 
-extern VIP_RETURN
-VipRecvDone( IN     VIP_VI_HANDLE       ViHandle,
-             OUT    VIP_DESCRIPTOR      **DescriptorPtr);
+extern VIP_RETURN VipRecvDone(IN VIP_VI_HANDLE ViHandle, OUT VIP_DESCRIPTOR ** DescriptorPtr);
 
-extern VIP_RETURN
-VipRecvWait( IN     VIP_VI_HANDLE   ViHandle,
-             IN     VIP_ULONG       Timeout,
-             OUT    VIP_DESCRIPTOR  **DescriptorPtr);
+extern VIP_RETURN VipRecvWait(IN VIP_VI_HANDLE ViHandle, IN VIP_ULONG Timeout, OUT VIP_DESCRIPTOR ** DescriptorPtr);
 
-extern VIP_RETURN
-VipCQDone( IN   VIP_CQ_HANDLE   CQHandle,
-           OUT  VIP_VI_HANDLE   *ViHandle,
-           OUT  VIP_BOOLEAN     *RecvQueue);
+extern VIP_RETURN VipCQDone(IN VIP_CQ_HANDLE CQHandle, OUT VIP_VI_HANDLE * ViHandle, OUT VIP_BOOLEAN * RecvQueue);
 
 extern VIP_RETURN
-VipCQWait( IN   VIP_CQ_HANDLE   CQHandle,
-           IN   VIP_ULONG       Timeout,
-           OUT  VIP_VI_HANDLE   *ViHandle,
-           OUT  VIP_BOOLEAN     *RecvQueue);
+VipCQWait(IN VIP_CQ_HANDLE CQHandle, IN VIP_ULONG Timeout, OUT VIP_VI_HANDLE * ViHandle, OUT VIP_BOOLEAN * RecvQueue);
 
 extern VIP_RETURN
-VipSendNotify( IN    VIP_VI_HANDLE  ViHandle,
-               IN    VIP_PVOID      Context,
-               IN    void(*Handler)(
-                        IN  VIP_PVOID       Context,
-                        IN  VIP_NIC_HANDLE  NicHandle,
-                        IN  VIP_VI_HANDLE   ViHandle,
-                        IN  VIP_DESCRIPTOR  *DescriptorPtr
-               )
-);
+VipSendNotify(IN VIP_VI_HANDLE ViHandle,
+	      IN VIP_PVOID Context,
+	      IN void (*Handler) (IN VIP_PVOID Context,
+				  IN VIP_NIC_HANDLE NicHandle,
+				  IN VIP_VI_HANDLE ViHandle, IN VIP_DESCRIPTOR * DescriptorPtr)
+    );
 
 extern VIP_RETURN
-VipRecvNotify( IN   VIP_VI_HANDLE   ViHandle,
-               IN   VIP_PVOID       Context,
-               IN   void(*Handler)(
-                        IN  VIP_PVOID       Context,
-                        IN  VIP_NIC_HANDLE  NicHandle,
-                        IN  VIP_VI_HANDLE   ViHandle,
-                        IN  VIP_DESCRIPTOR  *DescriptorPtr
-               )
-);
+VipRecvNotify(IN VIP_VI_HANDLE ViHandle,
+	      IN VIP_PVOID Context,
+	      IN void (*Handler) (IN VIP_PVOID Context,
+				  IN VIP_NIC_HANDLE NicHandle,
+				  IN VIP_VI_HANDLE ViHandle, IN VIP_DESCRIPTOR * DescriptorPtr)
+    );
 
 extern VIP_RETURN
-VipCQNotify(   IN   VIP_CQ_HANDLE   CQHandle,
-               IN   VIP_PVOID       Context,
-               IN   void(*Handler)(
-                        IN  VIP_PVOID       Context,
-                        IN  VIP_NIC_HANDLE  NicHandle,
-                        IN  VIP_VI_HANDLE   ViHandle,
-                        IN  VIP_BOOLEAN     RecvQueue
-               )
-);
+VipCQNotify(IN VIP_CQ_HANDLE CQHandle,
+	    IN VIP_PVOID Context,
+	    IN void (*Handler) (IN VIP_PVOID Context,
+				IN VIP_NIC_HANDLE NicHandle, IN VIP_VI_HANDLE ViHandle, IN VIP_BOOLEAN RecvQueue)
+    );
 
-extern VIP_RETURN
-VipCreateCQ( IN     VIP_NIC_HANDLE  NicHandle,
-             IN     VIP_ULONG       EntryCount,
-             OUT    VIP_CQ_HANDLE   *CQHandle);
+extern VIP_RETURN VipCreateCQ(IN VIP_NIC_HANDLE NicHandle, IN VIP_ULONG EntryCount, OUT VIP_CQ_HANDLE * CQHandle);
 
-extern VIP_RETURN
-VipDestroyCQ( IN    VIP_CQ_HANDLE   CQHandle);
+extern VIP_RETURN VipDestroyCQ(IN VIP_CQ_HANDLE CQHandle);
 
-extern VIP_RETURN
-VipResizeCQ( IN VIP_CQ_HANDLE   CQHandle,
-             IN VIP_ULONG       EntryCount);
+extern VIP_RETURN VipResizeCQ(IN VIP_CQ_HANDLE CQHandle, IN VIP_ULONG EntryCount);
 
-extern VIP_RETURN
-VipQueryNic( IN     VIP_NIC_HANDLE      NicHandle,
-             OUT    VIP_NIC_ATTRIBUTES  *NicAttribs);
+extern VIP_RETURN VipQueryNic(IN VIP_NIC_HANDLE NicHandle, OUT VIP_NIC_ATTRIBUTES * NicAttribs);
 
-extern VIP_RETURN
-VipSetViAttributes(IN   VIP_VI_HANDLE       ViHandle,
-                   IN   VIP_VI_ATTRIBUTES   *ViAttribs);
+extern VIP_RETURN VipSetViAttributes(IN VIP_VI_HANDLE ViHandle, IN VIP_VI_ATTRIBUTES * ViAttribs);
 
 extern VIP_RETURN
-VipQueryVi( IN  VIP_VI_HANDLE       ViHandle,
-            OUT VIP_VI_STATE        *State,
-            OUT VIP_VI_ATTRIBUTES   *ViAttribs,
-            OUT VIP_BOOLEAN         *ViSendQEmpty,
-            OUT VIP_BOOLEAN         *ViRecvQEmpty
-            );
+VipQueryVi(IN VIP_VI_HANDLE ViHandle,
+	   OUT VIP_VI_STATE * State,
+	   OUT VIP_VI_ATTRIBUTES * ViAttribs, OUT VIP_BOOLEAN * ViSendQEmpty, OUT VIP_BOOLEAN * ViRecvQEmpty);
 
 extern VIP_RETURN
-VipSetMemAttributes( IN VIP_NIC_HANDLE      NicHandle,
-                     IN VIP_PVOID           Address,
-                     IN VIP_MEM_HANDLE      MemHandle,
-                     IN VIP_MEM_ATTRIBUTES  *MemAttribs);
+VipSetMemAttributes(IN VIP_NIC_HANDLE NicHandle,
+		    IN VIP_PVOID Address, IN VIP_MEM_HANDLE MemHandle, IN VIP_MEM_ATTRIBUTES * MemAttribs);
 
 extern VIP_RETURN
-VipQueryMem( IN     VIP_NIC_HANDLE           NicHandle,
-             IN     VIP_PVOID                Address,
-             IN     VIP_MEM_HANDLE           MemHandle,
-             OUT    VIP_MEM_ATTRIBUTES       *MemAttribs);
+VipQueryMem(IN VIP_NIC_HANDLE NicHandle,
+	    IN VIP_PVOID Address, IN VIP_MEM_HANDLE MemHandle, OUT VIP_MEM_ATTRIBUTES * MemAttribs);
 
 extern VIP_RETURN
-VipQuerySystemManagementInfo( IN     VIP_NIC_HANDLE  NicHandle,
-                              IN     VIP_ULONG       InfoType,
-                              OUT    VIP_PVOID       SysManInfo);
+VipQuerySystemManagementInfo(IN VIP_NIC_HANDLE NicHandle, IN VIP_ULONG InfoType, OUT VIP_PVOID SysManInfo);
 
 extern VIP_RETURN
-VipErrorCallback( IN    VIP_NIC_HANDLE  NicHandle,
-                  IN    VIP_PVOID       Context,
-                  IN    void(*Handler)(
-                           IN   VIP_PVOID               Context,
-                           IN   VIP_ERROR_DESCRIPTOR    *ErrorDesc
-                      )
-);
+VipErrorCallback(IN VIP_NIC_HANDLE NicHandle,
+		 IN VIP_PVOID Context, IN void (*Handler) (IN VIP_PVOID Context, IN VIP_ERROR_DESCRIPTOR * ErrorDesc)
+    );
 
 /**********************************************************************
  * Peer-to-Peer Connection Model APIs
  *********************************************************************/
 
 extern VIP_RETURN
-VipConnectPeerRequest( IN   VIP_VI_HANDLE   ViHandle,
-                       IN   VIP_NET_ADDRESS *LocalAddr,
-                       IN   VIP_NET_ADDRESS *RemoteAddr,
-                       IN   VIP_ULONG       Timeout);
+VipConnectPeerRequest(IN VIP_VI_HANDLE ViHandle,
+		      IN VIP_NET_ADDRESS * LocalAddr, IN VIP_NET_ADDRESS * RemoteAddr, IN VIP_ULONG Timeout);
 
-extern VIP_RETURN
-VipConnectPeerDone( IN  VIP_VI_HANDLE      ViHandle,
-                    OUT VIP_VI_ATTRIBUTES  *RemoteViAttribs);
+extern VIP_RETURN VipConnectPeerDone(IN VIP_VI_HANDLE ViHandle, OUT VIP_VI_ATTRIBUTES * RemoteViAttribs);
 
-extern VIP_RETURN
-VipConnectPeerWait( IN  VIP_VI_HANDLE       ViHandle,
-                    OUT VIP_VI_ATTRIBUTES   *RemoteViAttribs);
+extern VIP_RETURN VipConnectPeerWait(IN VIP_VI_HANDLE ViHandle, OUT VIP_VI_ATTRIBUTES * RemoteViAttribs);
 
-
 /**********************************************************************
  * Name service APIs
  *********************************************************************/
 
-extern VIP_RETURN
-VipNSInit( IN   VIP_NIC_HANDLE  NicHandle,
-           IN   VIP_PVOID       NSInitInfo);
+extern VIP_RETURN VipNSInit(IN VIP_NIC_HANDLE NicHandle, IN VIP_PVOID NSInitInfo);
 
 extern VIP_RETURN
-VipNSGetHostByName( IN  VIP_NIC_HANDLE  NicHandle,
-                    IN  VIP_CHAR        *Name,
-                    OUT VIP_NET_ADDRESS *Address,
-                    IN  VIP_ULONG       NameIndex);
+VipNSGetHostByName(IN VIP_NIC_HANDLE NicHandle,
+		   IN VIP_CHAR * Name, OUT VIP_NET_ADDRESS * Address, IN VIP_ULONG NameIndex);
 
 extern VIP_RETURN
-VipNSGetHostByAddr( IN  VIP_NIC_HANDLE  NicHandle,
-                    IN  VIP_NET_ADDRESS *Address,
-                    OUT VIP_CHAR        *Name,
-                    IN  OUT VIP_ULONG   *NameLen);
+VipNSGetHostByAddr(IN VIP_NIC_HANDLE NicHandle,
+		   IN VIP_NET_ADDRESS * Address, OUT VIP_CHAR * Name, IN OUT VIP_ULONG * NameLen);
 
-extern VIP_RETURN
-VipNSShutdown( IN   VIP_NIC_HANDLE  NicHandle);
+extern VIP_RETURN VipNSShutdown(IN VIP_NIC_HANDLE NicHandle);
 
-
-
-#endif /* _VIPL_ */
+#endif				/* _VIPL_ */



From cheungming at berlios.de  Wed Feb  8 03:20:42 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Wed, 8 Feb 2006 03:20:42 +0100
Subject: [Iometer-svn] r236 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602080220.k182Kgxv008561@sheep.berlios.de>

Author: cheungming
Date: 2006-02-08 03:20:20 +0100 (Wed, 08 Feb 2006)
New Revision: 236

Modified:
   branches/IOMETER-restruct/iometer/src/IOVersion.h
Log:
IOVersion.h contains a special character (copyright symbol) that indent cannot handle. indent delete that line silently.



Modified: branches/IOMETER-restruct/iometer/src/IOVersion.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOVersion.h	2006-02-08 01:56:14 UTC (rev 235)
+++ branches/IOMETER-restruct/iometer/src/IOVersion.h	2006-02-08 02:20:20 UTC (rev 236)
@@ -76,13 +76,16 @@
 #ifndef _IOVERSION
 #define _IOVERSION
 
+
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-#include <winver.h>
-#endif				/* !UNIX */
+ #include <winver.h>
+#endif /* !UNIX */
 
+
 // The maximum size allowed for the version string.
 #define MAX_VERSION_LENGTH 80
 
+
 // Note that the DEBUG version should have an identical version string as the release version,
 // with an added " DEBUG" - the Dynamo/Iometer version comparison in CGalileoApp::OnIdle() ignores
 // the " DEBUG" qualifier when verifying that the two programs are the same version.
@@ -92,8 +95,10 @@
 #define		VERSION_DEBUG	""
 #endif
 
+
 #if defined (__cplusplus)
-extern "C" {
+extern "C"
+{
 #endif
 
 // Iometer has been using date stamps as the version strings, and currently
@@ -101,42 +106,44 @@
 // The last "official" version was "2001.07.19", which is the version
 // you will find in iometer-initial.tar.gz at the Sourceforge page
 // (http://sourceforge.net/projects/iometer).
-//#define IOVER_FILEVERSION                             "2003.02.15\0"
-//#define IOVER_FILEVERSION                             "2003.02.15-post\0"
-//#define IOVER_FILEVERSION                             "2003.05.10\0"
-//#define IOVER_FILEVERSION                             "2003.05.10-post\0"
-//#define IOVER_FILEVERSION                             "2003.12.16\0"
-//#define IOVER_FILEVERSION                             "2003.12.16-post\0"
-//#define IOVER_FILEVERSION                             "2004.07.30-RC1\0"
-//#define IOVER_FILEVERSION                             "2004.07.30\0"
-//#define IOVER_FILEVERSION                             "2003.12.16-post\0"
-//#define IOVER_FILEVERSION                             "2004.07.30\0"   // => Has never been active; see IOMETER1 branch!
+//#define IOVER_FILEVERSION				"2003.02.15\0"
+//#define IOVER_FILEVERSION				"2003.02.15-post\0"
+//#define IOVER_FILEVERSION				"2003.05.10\0"
+//#define IOVER_FILEVERSION				"2003.05.10-post\0"
+//#define IOVER_FILEVERSION				"2003.12.16\0"
+//#define IOVER_FILEVERSION				"2003.12.16-post\0"
+//#define IOVER_FILEVERSION				"2004.07.30-RC1\0"
+//#define IOVER_FILEVERSION				"2004.07.30\0"
+//#define IOVER_FILEVERSION				"2003.12.16-post\0"
+//#define IOVER_FILEVERSION				"2004.07.30\0"   // => Has never been active; see IOMETER1 branch!
 #define IOVER_FILEVERSION				"2004.07.30-post\0"
 #define IOVER_PRODUCTVERSION				IOVER_FILEVERSION
 
+
+
 #if defined(IOMTR_OSFAMILY_WINDOWS)
 
-
+#define IOVER_LEGALCOPYRIGHT			"Copyright ? 1996-2001 Intel Corporation\0"
 #define IOVER_LEGALTRADEMARKS			"\0"
 #define IOVER_COMPANYNAME			"Intel Corporation\0"
 
 #ifdef _DEBUG
-#if defined(IOMTR_OS_WIN64)
-#define IOVER_PRODUCT_NAME			"Iometer 64-bit (DEBUG)\0"
-#elif defined(IOMTR_OS_WIN32)
-#define IOVER_PRODUCT_NAME			"Iometer (DEBUG)\0"
+ #if defined(IOMTR_OS_WIN64)
+  #define IOVER_PRODUCT_NAME			"Iometer 64-bit (DEBUG)\0"
+ #elif defined(IOMTR_OS_WIN32)
+  #define IOVER_PRODUCT_NAME			"Iometer (DEBUG)\0"
+ #else
+  #warning ===> WARNING: You have to do some coding here to get the port done! 
+ #endif
 #else
-#warning ===> WARNING: You have to do some coding here to get the port done!
-#endif
-#else
-#if defined(IOMTR_OS_WIN64)
-#define IOVER_PRODUCT_NAME			"Iometer 64-bit\0"
-#elif defined(IOMTR_OS_WIN32)
-#define IOVER_PRODUCT_NAME			"Iometer\0"
-#else
-#warning ===> WARNING: You have to do some coding here to get the port done!
-#endif
-#endif				// _DEBUG
+ #if defined(IOMTR_OS_WIN64)
+  #define IOVER_PRODUCT_NAME			"Iometer 64-bit\0"
+ #elif defined(IOMTR_OS_WIN32)
+  #define IOVER_PRODUCT_NAME			"Iometer\0"
+ #else
+  #warning ===> WARNING: You have to do some coding here to get the port done! 
+ #endif
+#endif // _DEBUG
 
 ////////
 // The following are based on unique (for each component) resource variables
@@ -148,11 +155,11 @@
 #define IOVER_INTERNAL_NAME		"Galileo\0"
 #define IOVER_ORIGINAL_FILE_NAME	"Iometer.exe\0"
 #if defined(IOMTR_OS_WIN64)
-#define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI (64-bit)\0"
+ #define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI (64-bit)\0"
 #elif defined(IOMTR_OS_WIN32)
-#define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI\0"
+ #define IOVER_FILE_DESCRIPTION		"Iometer Control/GUI\0"
 #else
-#warning ===> WARNING: You have to do some coding here to get the port done!
+ #warning ===> WARNING: You have to do some coding here to get the port done! 
 #endif
 #define IOVER_COMMENTS			"\0"
 #endif
@@ -162,18 +169,23 @@
 #define IOVER_INTERNAL_NAME		"Pulsar\0"
 #define IOVER_ORIGINAL_FILE_NAME	"Dynamo.exe\0"
 #if defined(IOMTR_OS_WIN64)
-#define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator (64-bit)\0"
+ #define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator (64-bit)\0"
 #elif defined(IOMTR_OS_WIN32)
-#define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator\0"
+ #define IOVER_FILE_DESCRIPTION		"Iometer Workload Generator\0"
 #else
-#warning ===> WARNING: You have to do some coding here to get the port done!
+ #warning ===> WARNING: You have to do some coding here to get the port done! 
 #endif
 #define IOVER_COMMENTS			"\0"
 #endif
 
 #endif
 
+
 #if defined (__cplusplus)
 }
 #endif
-#endif				// _IOVERSION
+
+
+#endif // _IOVERSION
+
+



From cheungming at berlios.de  Wed Feb  8 20:09:31 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Wed, 8 Feb 2006 20:09:31 +0100
Subject: [Iometer-svn] r237 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602081909.k18J9Vei014429@sheep.berlios.de>

Author: cheungming
Date: 2006-02-08 20:08:18 +0100 (Wed, 08 Feb 2006)
New Revision: 237

Modified:
   branches/IOMETER-restruct/iometer/src/IOCommon.h
   branches/IOMETER-restruct/iometer/src/IOGrunt.cpp
Log:
fix some strange indent in IOGrunt.cpp.
also revert IOCommon.h back to original, much easier to read. 

so indent can not do a good work on file with tons of #if, #else, ...



Modified: branches/IOMETER-restruct/iometer/src/IOCommon.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 02:20:20 UTC (rev 236)
+++ branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 19:08:18 UTC (rev 237)
@@ -155,6 +155,8 @@
 #ifndef	___IOCOMMON_H_DEFINED___
 #define ___IOCOMMON_H_DEFINED___
 
+
+
 // Check and map the different global defines for Operating
 // System family, Operating System and CPU (see README).
 // ----------------------------------------------------------------------------
@@ -163,8 +165,8 @@
     (!defined(IOMTR_OSFAMILY_NETWARE) &&  defined(IOMTR_OSFAMILY_UNIX) && !defined(IOMTR_OSFAMILY_WINDOWS)) || \
     (!defined(IOMTR_OSFAMILY_NETWARE) && !defined(IOMTR_OSFAMILY_UNIX) &&  defined(IOMTR_OSFAMILY_WINDOWS))
  // nop
-#else
-#error ===> ERROR: Check the Operating System to Operating System family mapping!
+#else    
+ #error ===> ERROR: Check the Operating System to Operating System family mapping!
 #endif
 // ----------------------------------------------------------------------------
 // Check the Operating System mapping
@@ -175,8 +177,8 @@
     (!defined(IOMTR_OS_LINUX) && !defined(IOMTR_OS_NETWARE) && !defined(IOMTR_OS_OSX) && !defined(IOMTR_OS_SOLARIS) &&  defined(IOMTR_OS_WIN32) && !defined(IOMTR_OS_WIN64)) || \
     (!defined(IOMTR_OS_LINUX) && !defined(IOMTR_OS_NETWARE) && !defined(IOMTR_OS_OSX) && !defined(IOMTR_OS_SOLARIS) && !defined(IOMTR_OS_WIN32) &&  defined(IOMTR_OS_WIN64))
  // nop
-#else
-#error ===> ERROR: You have to define exactly one IOMTR_OS_* global define!
+#else    
+ #error ===> ERROR: You have to define exactly one IOMTR_OS_* global define!
 #endif
 // ----------------------------------------------------------------------------
 // Check the Processor mapping
@@ -189,29 +191,31 @@
     (!defined(IOMTR_CPU_ALPHA) && !defined(IOMTR_CPU_I386) && !defined(IOMTR_CPU_IA64) && !defined(IOMTR_CPU_MIPS) && !defined(IOMTR_CPU_PPC) && !defined(IOMTR_CPU_SPARC) &&  defined(IOMTR_CPU_X86_64) && !defined(IOMTR_CPU_XSCALE)) || \
     (!defined(IOMTR_CPU_ALPHA) && !defined(IOMTR_CPU_I386) && !defined(IOMTR_CPU_IA64) && !defined(IOMTR_CPU_MIPS) && !defined(IOMTR_CPU_PPC) && !defined(IOMTR_CPU_SPARC) && !defined(IOMTR_CPU_X86_64) &&  defined(IOMTR_CPU_XSCALE))
  // nop
-#else
-#error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
+#else    
+ #error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
 #endif
 // ----------------------------------------------------------------------------
 
+
+
 // Include the different header files
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
-#if defined(IOMTR_OSFAMILY_WINDOWS)	// Only first, because it is needed here!
-#define VC_EXTRALEAN
-#pragma warning (disable: 4242)
-#include <process.h>
-#include <io.h>
-#include <direct.h>
-#include <afxwin.h>
-#include <afxext.h>
-#include <afxcmn.h>
-#include <winioctl.h>
-#include <iomanip>
-#include <winperf.h>
-#include <winreg.h>
-#include <afxmt.h>
-#include <malloc.h>
+#if defined(IOMTR_OSFAMILY_WINDOWS)   // Only first, because it is needed here!
+ #define VC_EXTRALEAN
+ #pragma warning (disable: 4242)
+ #include <process.h>
+ #include <io.h>
+ #include <direct.h>
+ #include <afxwin.h>
+ #include <afxext.h>
+ #include <afxcmn.h>
+ #include <winioctl.h>
+ #include <iomanip>
+ #include <winperf.h>
+ #include <winreg.h>
+ #include <afxmt.h>
+ #include <malloc.h>
 #endif
 // ----------------------------------------------------------------------------
 #include <stdio.h>
@@ -228,192 +232,193 @@
 #include <iostream>
 #include <fstream>
 using namespace std;
-
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE)
-#include <sys/timeval.h>
-#include <sys/time.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <signal.h>
-#include <netinet/in.h>		// in_addr_t
-#include <nks/memory.h>
-#include <nks/fsio.h>
-#include <pthread.h>
-#include <mmpublic.h>
-#include <malloc.h>
+ #include <sys/timeval.h>
+ #include <sys/time.h>
+ #include <sys/socket.h>
+ #include <unistd.h>
+ #include <signal.h>
+ #include <netinet/in.h>   // in_addr_t
+ #include <nks/memory.h>
+ #include <nks/fsio.h>
+ #include <pthread.h>
+ #include <mmpublic.h>
+ #include <malloc.h>
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX)
-#include <sys/timeb.h>
-#include <unistd.h>
-#include <pthread.h>
-#include <signal.h>
-#include <netinet/in.h>		// in_addr_t
+ #include <sys/timeb.h>
+ #include <unistd.h>
+ #include <pthread.h>
+ #include <signal.h>
+ #include <netinet/in.h>   // in_addr_t
 
-#if defined(IOMTR_OS_OSX)
-#include <sys/aio.h>
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-#include <malloc.h>
-#include <aio.h>
-#else
-#error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
-#endif
+ #if defined(IOMTR_OS_OSX)
+  #include <sys/aio.h>
+ #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+  #include <malloc.h>
+  #include <aio.h>
+ #else
+  #error ===> ERROR: You have to define exactly one IOMTR_CPU_* global define!
+ #endif
 
-#if defined(IOMTR_OS_LINUX)
-#include <sys/ioctl.h>
+ #if defined(IOMTR_OS_LINUX)
+  #include <sys/ioctl.h>
+ #endif
+ #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
+  #include <syslog.h>
+ #endif
 #endif
-#if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-#include <syslog.h>
-#endif
-#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-#include <sys/timeb.h>
-#if (_MSC_VER < 1300) || defined(USING_DDK)
-#include "ostream64.h"
+ #include <sys/timeb.h>
+ #if (_MSC_VER < 1300) || defined(USING_DDK)
+  #include "ostream64.h"
+ #endif
 #endif
-#endif
 // ----------------------------------------------------------------------------
-#include "IOVersion.h"		// version info definitions
+#include "IOVersion.h"   // version info definitions
 // ----------------------------------------------------------------------------
 
+
+
+
 // Define the different data types
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-#define __int64   long long
-#define __int32   long
-#define __int16   short
-#define __int8    char
+ #define __int64   long long
+ #define __int32   long
+ #define __int16   short
+ #define __int8    char
 
-#if defined(IOMTR_SETTING_GCC_M64)
+ #if defined(IOMTR_SETTING_GCC_M64)
   // in the gcc on x86_64 environment long is 64 bits
-#undef __int32
-#define __int32 int
-#endif
+  #undef __int32
+  #define __int32 int
+ #endif
 
-typedef long long _int64;
+ typedef long long	       _int64;
+ //typedef long long	       LARGE_INTEGER; 
+ typedef unsigned long long    DWORDLONG;
 
- //typedef long long           LARGE_INTEGER; 
-typedef unsigned long long DWORDLONG;
-
-#if defined(IOMTR_OSFAMILY_NETWARE)
-#ifndef LONG
-#define LONG	unsigned long
-#endif
-#ifndef WORD
-#define WORD	unsigned short
-#endif
-#elif defined(IOMTR_OSFAMILY_UNIX)
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+  #ifndef LONG
+   #define LONG	unsigned long
+  #endif
+  #ifndef WORD
+   #define WORD	unsigned short
+  #endif
+ #elif defined(IOMTR_OSFAMILY_UNIX)
   // This is OK for x86-64 processors because LONG is only used in Netware or
   // in MeterCtrl.cpp.or safely internally in IOTargetDisk.cpp.
   // It could cause problems because in the x86-64 environment long is 64 bits.
-typedef long LONG;
-
-#if defined(IOMTR_OS_OSX)
-#define off64_t	off_t
-#endif
-#else
-#warning ===> WARNING: You have to do some coding here to get the port done!
-#endif
-
-#if defined(IOMTR_SETTING_GCC_M64)
+  typedef long		       LONG;
+  #if defined(IOMTR_OS_OSX)
+   #define off64_t	off_t  
+  #endif 
+ #else
+  #warning ===> WARNING: You have to do some coding here to get the port done!
+ #endif
+ 
+ #if defined(IOMTR_SETTING_GCC_M64)
   // DWORD is supposed to be an unsigned 32 bit number.
-typedef unsigned int DWORD;
-#else
-typedef unsigned long DWORD;
-#endif
+  typedef unsigned int	       DWORD;
+ #else
+  typedef unsigned long	       DWORD;
+ #endif
+ 
+ typedef int		       INT;
+ typedef int		       BOOL;
+ typedef int		       BOOLEAN;
+ typedef unsigned int	       UINT;
+ typedef unsigned int	      *PUINT;
 
-typedef int INT;
-typedef int BOOL;
-typedef int BOOLEAN;
-typedef unsigned int UINT;
-typedef unsigned int *PUINT;
+ typedef unsigned short	       WCHAR;
+ typedef unsigned short	      *LPWSTR;
 
-typedef unsigned short WCHAR;
-typedef unsigned short *LPWSTR;
+ typedef char		      *LPSTR;
+ typedef unsigned char	       BYTE;
+ typedef const char	      *LPCSTR;
 
-typedef char *LPSTR;
-typedef unsigned char BYTE;
-typedef const char *LPCSTR;
+ typedef void		      *HANDLE;
+ typedef void		      *LPVOID;
 
-typedef void *HANDLE;
-typedef void *LPVOID;
-
  //  The places in the Iometer code that now use CONNECTION used to use
  //  SOCKET. But SOCKET is a defined type in winsock2.h used for network
  //  access. Iometer defined a type called SOCKET used in NetTCP.cpp but 
  //  the original winsock SOCKET was used in IOPortTCP.cpp. Defining
  //  a new CONNECTION type allows me to separate the two different concepts
  //  cleanly.
-typedef void *CONNECTION;
+ typedef void                 *CONNECTION;
+ 
+ typedef int		       SOCKET;
+ typedef const void	      *LPCVOID;
 
-typedef int SOCKET;
-typedef const void *LPCVOID;
+ typedef DWORD		      *LPDWORD;
+ typedef BYTE		      *LPBYTE;
+ typedef LPCSTR		       LPCTSTR;
 
-typedef DWORD *LPDWORD;
-typedef BYTE *LPBYTE;
-typedef LPCSTR LPCTSTR;
-
-typedef unsigned long ULONG_PTR, *PULONG_PTR;
-typedef ULONG_PTR DWORD_PTR;
-#endif
+ typedef unsigned long         ULONG_PTR, *PULONG_PTR;
+ typedef ULONG_PTR             DWORD_PTR;
+#endif 
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-#ifndef USING_DDK
-#if defined(IOMTR_OS_WIN32)
+ #ifndef USING_DDK
+  #if defined(IOMTR_OS_WIN32)
    // dps: Was __int32 in before, but conflicts while conversion
    //      from unsigned __int32 to unsigned long for instance
    //      (using Microsoft Visual C++).
-typedef long LONG_PTR, *PLONG_PTR;
-typedef unsigned long ULONG_PTR, *PULONG_PTR;
-typedef ULONG_PTR DWORD_PTR;
-#endif
-#if defined(IOMTR_OS_WIN64)
-typedef __int64 LONG_PTR, *PLONG_PTR;
-typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
-typedef ULONG_PTR DWORD_PTR;
-#endif
-#endif				// USING_DDK
+   typedef long LONG_PTR, *PLONG_PTR;
+   typedef unsigned long  ULONG_PTR, *PULONG_PTR;
+   typedef ULONG_PTR      DWORD_PTR;
+  #endif
+  #if defined(IOMTR_OS_WIN64)
+   typedef __int64 LONG_PTR, *PLONG_PTR;
+   typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
+   typedef ULONG_PTR        DWORD_PTR;
+  #endif
+ #endif // USING_DDK
  //  The places in the Iometer code that now use CONNECTION used to use
  //  SOCKET. But SOCKET is a defined type in winsock2.h used for network
  //  access. Iometer defined a type called SOCKET used in NetTCP.cpp but 
  //  the original winsock SOCKET was used in IOPortTCP.cpp. Defining
  //  a new CONNECTION type allows me to separate the two different concepts
  //  cleanly.
-typedef ULONG_PTR CONNECTION;
-#endif
+ typedef ULONG_PTR CONNECTION;
+#endif 
 // ----------------------------------------------------------------------------
 
 // Because of some of the memory over writing issues in the 64 bit environment
 // and the typing required by the windows environment, variables need to be cast
 // differently depending on OSFAMILY. this gets the job done... 
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-#define IOMTR_MACRO_INTERLOCK_CAST(a) (long *)
+ #define IOMTR_MACRO_INTERLOCK_CAST(a) (long *)
 #elif defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
-#define IOMTR_MACRO_INTERLOCK_CAST(a) (a *)
+ #define IOMTR_MACRO_INTERLOCK_CAST(a) (a *)
 #else
-#error ===> ERROR: You have to do some coding here to get the port done!
+ #error ===> ERROR: You have to do some coding here to get the port done!
 #endif
 
 // ----------------------------------------------------------------------------
 
+
 // Definition of the defines itself
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 // Different return values for the Iometer and Dynamo function calls.
-#define IOERROR	-1		// keep negative
+#define IOERROR	-1   // keep negative
 
-#define RETRY_DELAY   200	// msec. to wait before reattempting an action
-#define LONG_DELAY    3000	// msec. to wait before reattempting an action
-#define IDLE_DELAY    1000	// max msec to wait between calls to CGalileoApp::OnIdle()
+#define RETRY_DELAY   200    // msec. to wait before reattempting an action
+#define LONG_DELAY    3000   // msec. to wait before reattempting an action
+#define IDLE_DELAY    1000   // max msec to wait between calls to CGalileoApp::OnIdle()
 
 #define KILOBYTE   1024
 #define MEGABYTE   1048576
 
-#define MAX_NAME	      80	// xca1019: Was 64 - changed according to
-				   // the Solaris 2.6 man page for swapctl(2)
+#define MAX_NAME	      80   // xca1019: Was 64 - changed according to
+                                   // the Solaris 2.6 man page for swapctl(2)
 #define	MAX_CPUS	      32
 #define	MAX_WORKERS	      100
 #define MAX_TARGETS	      512
@@ -440,22 +445,22 @@
 #define CPU_IRQ			     5
 
 // Definitions for network tcp results
-#define TCP_RESULTS           1	// total number of network results
+#define TCP_RESULTS           1   // total number of network results
 // List all specific performance results that are desired.
 #define TCP_SEGMENTS_RESENT   0
 
 // Definitions for network interface results
-#define NI_RESULTS	     3	// total number of network interface results reported
-#define NI_COMBINE_RESULTS   2	// combine some reported results together
+#define NI_RESULTS	     3   // total number of network interface results reported
+#define NI_COMBINE_RESULTS   2   // combine some reported results together
 // List all specific performance results that are desired.
 #define NI_PACKETS	     0
 #define NI_OUT_ERRORS	     1
 #define NI_IN_ERRORS	     2
-#define NI_ERRORS	     1	// combine in and out errors together when saving
+#define NI_ERRORS	     1   // combine in and out errors together when saving
 
 // Initialization parameters for CArray and related classes.
-#define INITIAL_ARRAY_SIZE   0	// Sets the size of the array.
-#define ARRAY_GROW_STEP	     10	// Sets the amount of memory to allocate when the array is grown.
+#define INITIAL_ARRAY_SIZE   0    // Sets the size of the array.
+#define ARRAY_GROW_STEP	     10   // Sets the amount of memory to allocate when the array is grown.
 
 // To record performance statistics, two snapshots of specific counters are needed.
 #define FIRST_SNAPSHOT	 0
@@ -474,65 +479,65 @@
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
  //param does not contain a valid internet address
  // (For Win32 || _WIN64, INADDR_NONE is defined as 0xffffffff)
-#ifndef INADDR_NONE
-#define INADDR_NONE   (in_addr_t)-1
-#endif
+ #ifndef INADDR_NONE
+  #define INADDR_NONE   (in_addr_t)-1
+ #endif
 
  // Needed to get the CDECL stuff thru (under non Windows platforms)
-#define CDECL
+ #define CDECL
 
-#define FALSE			0
-#define TRUE			1
-#define INVALID_HANDLE_VALUE   (HANDLE)-1
-#define INVALID_SOCKET		(~0L)
-#define PERF_NO_INSTANCES	-1
-#define SOCKET_ERROR		-1
-#define SD_BOTH		2
-#define INFINITE		(unsigned)~0
-#define ERROR_IO_PENDING	501
-#define WAIT_TIMEOUT		ERROR_IO_PENDING
-#define ERROR_IO_INCOMPLETE	ERROR_IO_PENDING
+ #define FALSE			0
+ #define TRUE			1
+ #define INVALID_HANDLE_VALUE   (HANDLE)-1
+ #define INVALID_SOCKET		(~0L)
+ #define PERF_NO_INSTANCES	-1
+ #define SOCKET_ERROR		-1
+ #define SD_BOTH		2
+ #define INFINITE		(unsigned)~0
+ #define ERROR_IO_PENDING	501
+ #define WAIT_TIMEOUT		ERROR_IO_PENDING
+ #define ERROR_IO_INCOMPLETE	ERROR_IO_PENDING
 
-#define FILE_ELEMENT		1
-#define CQ_ELEMENT		0
+ #define FILE_ELEMENT		1
+ #define CQ_ELEMENT		0
 
-#if defined(IOMTR_OSFAMILY_NETWARE)
-#define SIGEV_NONE		0
-#define AIO_NOTCANCELED	1
-#endif
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+  #define SIGEV_NONE		0
+  #define AIO_NOTCANCELED	1
+ #endif
 
-#if defined(IOMTR_OS_LINUX)
+ #if defined(IOMTR_OS_LINUX)
   // different Linux kernel has different /proc/stat style.
   // Currently we only support vanilla 2.4 and 2.6 alike
-#define PROCSTATUNKNOWN	0x00
-#define PROCSTAT24STYLE	0x01
-#define PROCSTAT26STYLE	0x02
+  #define PROCSTATUNKNOWN	0x00
+  #define PROCSTAT24STYLE	0x01
+  #define PROCSTAT26STYLE	0x02
+ #endif
 #endif
-#endif
 // ----------------------------------------------------------------------------
 
+
+
 // Define the enumerations, structures etc.
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
 enum ReturnVal {
-	ReturnError = IOERROR,	// catch all unexpected errors
-	ReturnSuccess = 0,	// Normal completion
-	ReturnTimeout,		// Operation timed out
-	ReturnPending,		// Request has been queued
-	ReturnAbort,		// Operation aborted
-	ReturnRetry		// Operation was interrupted and can be retried
+	ReturnError   = IOERROR,   // catch all unexpected errors
+	ReturnSuccess = 0,	   // Normal completion
+	ReturnTimeout,		   // Operation timed out
+	ReturnPending,		   // Request has been queued
+	ReturnAbort,		   // Operation aborted
+	ReturnRetry	   	   // Operation was interrupted and can be retried
 };
-
 // Testing states that Iometer and worker threads go through
 enum TestState {
-	TestIdle,		// before Start_Test() and after Stop_Test()
+	TestIdle,	  // before Start_Test() and after Stop_Test()
 	TestPreparing,
-	TestOpening,		// after Start_Test()
-	TestRampingUp,		// after Begin_IO()
-	TestRecording,		// after Record_On()
-	TestRampingDown		// after Record_Off()
+	TestOpening,	  // after Start_Test()
+	TestRampingUp,	  // after Begin_IO()
+	TestRecording,	  // after Record_On()
+	TestRampingDown	  // after Record_Off()
 };
-
 // Specified on the Test Setup tab: which test results to record.
 // (In IOCommon.h because Dynamo uses these as parameters.)
 enum {
@@ -542,127 +547,126 @@
 	RecordNoManagers,
 	RecordNone
 };
-
 // ----------------------------------------------------------------------------
-struct Manager_Info {
-	char version[MAX_VERSION_LENGTH];
-	char names[2][MAX_NETWORK_NAME];
-	unsigned short port_number;	// used only with TCP/IP.
-#if defined(IOMTR_OSFAMILY_NETWARE)
+struct Manager_Info
+{
+	char	       version[MAX_VERSION_LENGTH];
+	char	       names[2][MAX_NETWORK_NAME];
+	unsigned short port_number;   // used only with TCP/IP.
+#if defined(IOMTR_OSFAMILY_NETWARE)	
 	char pad[2];
-#endif
-	int processors;
-	double processor_speed;
+#endif	
+	int	       	   processors;
+	double	       processor_speed;
 };
-
 // Basic result information stored by worker threads.
-struct Raw_Result {
-	DWORDLONG bytes_read;	// Number of bytes transferred.
-	DWORDLONG bytes_written;
-	DWORDLONG read_count;	// Number of I/Os completed.
-	DWORDLONG write_count;
-	DWORDLONG transaction_count;	// Number of transactions completed.
-	DWORDLONG connection_count;
-	unsigned int read_errors;	// Number of errors seen.
+struct Raw_Result
+{
+	DWORDLONG    bytes_read;   	       // Number of bytes transferred.
+	DWORDLONG    bytes_written;
+	DWORDLONG    read_count;	       // Number of I/Os completed.
+	DWORDLONG    write_count;
+	DWORDLONG    transaction_count;	       // Number of transactions completed.
+	DWORDLONG    connection_count;
+	unsigned int read_errors;	       // Number of errors seen.
 	unsigned int write_errors;
-	DWORDLONG max_raw_read_latency;	// Application latencies for an I/O to complete, recorded
-	DWORDLONG read_latency_sum;	// using the processor counter clock.
-	DWORDLONG max_raw_write_latency;
-	DWORDLONG write_latency_sum;
-	DWORDLONG max_raw_transaction_latency;
-	DWORDLONG max_raw_connection_latency;
-	DWORDLONG transaction_latency_sum;
-	DWORDLONG connection_latency_sum;	// Application latencies for a Connection.
-	__int64 counter_time;	// Difference between ending and starting counter time stamps.
+	DWORDLONG    max_raw_read_latency;     // Application latencies for an I/O to complete, recorded
+	DWORDLONG    read_latency_sum;	       // using the processor counter clock.
+	DWORDLONG    max_raw_write_latency;
+	DWORDLONG    write_latency_sum;
+	DWORDLONG    max_raw_transaction_latency;
+	DWORDLONG    max_raw_connection_latency;
+	DWORDLONG    transaction_latency_sum;
+	DWORDLONG    connection_latency_sum;   // Application latencies for a Connection.
+	__int64	     counter_time;	       // Difference between ending and starting counter time stamps.
 };
-
 // Storing results for all targets in a single structure.
-struct Target_Results {
-	int count;		// Number of targets.
-	char pad[4];		// padding
+struct Target_Results
+{
+	int	   count;    // Number of targets.
+	char	   pad[4];   // padding
 	Raw_Result result[MAX_TARGETS];
 };
-
 // Storing results for a worker.  This includes the worker's target results.
-struct Worker_Results {
-	DWORDLONG time[MAX_SNAPSHOTS];	// Processor based counters to provide time stamps.
+struct Worker_Results
+{
+	DWORDLONG      time[MAX_SNAPSHOTS];   // Processor based counters to provide time stamps.
 	Target_Results target_results;
 };
-
 // All CPU related results are stored in a single structure.
-struct CPU_Results {
-	int count;		// Number of processors.
-	char pad[4];		// padding
+struct CPU_Results
+{
+	int    count;	 // Number of processors.
+	char   pad[4];   // padding
 	double CPU_utilization[MAX_CPUS][CPU_RESULTS];
 };
-
 // All network related results are stored in a single structure.
-struct Net_Results {
+struct Net_Results
+{
 	double tcp_stats[TCP_RESULTS];
-	int ni_count;		// Number of NICs.
-	char pad[4];		// padding
+	int    ni_count;   // Number of NICs.
+	char   pad[4];     // padding
 	double ni_stats[MAX_NUM_INTERFACES][NI_RESULTS];
 };
-
 // Results SPECIFIC to a single system.  This is NOT compiled system results.
-struct Manager_Results {
-	__int64 time_counter[MAX_SNAPSHOTS];
+struct Manager_Results
+{
+	__int64	    time_counter[MAX_SNAPSHOTS];
 	CPU_Results cpu_results;
 	Net_Results net_results;
 };
-
 // Result structure used by the manager list, managers, and workers to store
 // results that will be saved.
-struct Results {
-	Raw_Result raw;
-	double IOps;
-	double read_IOps;
-	double write_IOps;
-	double MBps;
-	double read_MBps;
-	double write_MBps;
-	double ave_latency;
-	double max_latency;
-	double ave_read_latency;
-	double max_read_latency;
-	double ave_write_latency;
-	double max_write_latency;
-	double transactions_per_second;
-	double ave_transaction_latency;
-	double max_transaction_latency;
+struct Results
+{
+	Raw_Result   raw;
+	double	     IOps;
+	double	     read_IOps;
+	double	     write_IOps;
+	double	     MBps;
+	double	     read_MBps;
+	double	     write_MBps;
+	double	     ave_latency;
+	double	     max_latency;
+	double	     ave_read_latency;
+	double	     max_read_latency;
+	double	     ave_write_latency;
+	double	     max_write_latency;
+	double	     transactions_per_second;
+	double	     ave_transaction_latency;
+	double	     max_transaction_latency;
 	unsigned int total_errors;
-	double CPU_utilization[CPU_RESULTS];
-	double CPU_effectiveness;
-	double individual_CPU_utilization[MAX_CPUS][CPU_RESULTS];
-	double tcp_statistics[TCP_RESULTS];
-	double ni_statistics[NI_COMBINE_RESULTS];
-	double connections_per_second;
-	double ave_connection_latency;
-	double max_connection_latency;
+	double	     CPU_utilization[CPU_RESULTS];
+	double	     CPU_effectiveness;
+	double	     individual_CPU_utilization[MAX_CPUS][CPU_RESULTS];
+	double	     tcp_statistics[TCP_RESULTS];
+	double	     ni_statistics[NI_COMBINE_RESULTS];
+	double	     connections_per_second;
+	double	     ave_connection_latency;
+	double	     max_connection_latency;
 };
-
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
  // This LPOVERLAPPED typedef is from WINBASE.H
-#if defined(IOMTR_OSFAMILY_NETWARE)
-struct aiocb64 {
-	int aio_fildes;
-	void *aio_buf;
-	size_t aio_nbytes;
-	off_t aio_offset;
-	int aio_flag;
-	int error;
-	int returnval;
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+ struct  aiocb64 {
+ 	int		aio_fildes;
+ 	void		*aio_buf;
+ 	size_t		aio_nbytes;
+ 	off_t		aio_offset;
+ 	int		aio_flag;
+ 	int		error;
+ 	int		returnval;
 #if defined(IOMTR_SETTING_GCC_M64)
-	unsigned int completion_key;
+ 	unsigned int	completion_key;
 #else
-	unsigned long completion_key;
+ 	unsigned long	completion_key;
 #endif
-	struct {
-		int sigev_notify;
-	} aio_sigevent;
-};
-struct timeb {
+ 	struct {
+ 		int sigev_notify;
+ 		}	aio_sigevent;
+	};
+ struct timeb {
 #if defined(IOMTR_SETTING_GCC_M64)
 	int time;
 #else
@@ -671,299 +675,304 @@
 	unsigned short millitm;
 	short timezone;
 	short dstflag;
-};
-#endif
-typedef struct _OVERLAPPED {
-	DWORD Internal;
-	DWORD InternalHigh;
-	DWORD Offset;
-	DWORD OffsetHigh;
+	};
+ #endif
+ typedef struct _OVERLAPPED {   
+	DWORD  Internal;
+       	DWORD  InternalHigh;
+	DWORD  Offset;
+	DWORD  OffsetHigh;
 	HANDLE hEvent;
-} OVERLAPPED, *LPOVERLAPPED;
-typedef struct _LARGE_INTEGER {
+ } OVERLAPPED, *LPOVERLAPPED;
+ typedef struct _LARGE_INTEGER {
 	long LowPart;
 	long HighPart;
-} LARGE_INTEGER;
-struct CQ_Element {
-	struct aiocb64 aiocbp;
-	void *data;
-	int done;
-	int error;
-	int completion_key;
+ } LARGE_INTEGER;
+ struct CQ_Element {
+	struct  aiocb64 aiocbp;
+	void   *data;
+	int	done;
+	int	error;
+	int	completion_key;
 #if defined(IOMTR_SETTING_GCC_M64)
-	long bytes_transferred;
+	long	bytes_transferred;
 #else
-	int bytes_transferred;
+	int	bytes_transferred;
 #endif
-};
-struct IOCQ {
-	CQ_Element *element_list;
+ };
+ struct IOCQ {
+	CQ_Element      *element_list;
 	struct aiocb64 **aiocb_list;
-	int size;
-	int last_freed;
-	int position;
-};
-struct File {
-	int fd;
-	int completion_key;
+	int	         size;
+	int	         last_freed;
+	int	         position;
+ };
+ struct File {
+	int   fd;
+	int   completion_key;
 	IOCQ *iocq;
-#if defined(IOMTR_OSFAMILY_NETWARE)
+ #if defined(IOMTR_OSFAMILY_NETWARE)
 	int type;
-#endif
-};
-#endif
+ #endif
+ };
+#endif 
 // ----------------------------------------------------------------------------
 
+
+
 // Define the global variables
 // (both, OS family based and common)
 // ----------------------------------------------------------------------------
-const char NEW_WORKER_COMMAND[] = "start /MIN ";
+const char NEW_WORKER_COMMAND[]    = "start /MIN ";
 const char NEW_WORKER_EXECUTABLE[] = "dynamo";
-
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_UNIX) || defined(IOMTR_OSFAMILY_NETWARE)
-extern pthread_mutex_t lock_mt;	// we use one global locking mutex
+ extern pthread_mutex_t lock_mt;   // we use one global locking mutex
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_CPU_SPARC) || defined(IOMTR_CPU_PPC)
-extern double processor_speed_to_nsecs;
+ extern double processor_speed_to_nsecs;
 #endif
 // ----------------------------------------------------------------------------
 
+
+
 // Define the different function prototypes and macros for
 // global functions - including the Strip() and IsBigEndian()
 // function (both, OS family based and common)
 // ----------------------------------------------------------------------------
-extern void GetAppFileVersionString(char **ppStrStandard, char **ppStrWithDebug);
+extern void GetAppFileVersionString( char **ppStrStandard, char **ppStrWithDebug );
 
 inline void rotate(char *ptr, int size);
-template < class T > inline void reorder(T &);
-inline void reorder(CPU_Results &, int);
-inline void reorder(Net_Results &, int);
-inline void reorder(Raw_Result &);
+template <class T> inline void reorder(T&);
+inline void reorder(CPU_Results&, int);
+inline void reorder(Net_Results&, int);
+inline void reorder(Raw_Result&);
 
-inline char *Strip(char *pcString)
+inline char *Strip( char *pcString )
 {
-	unsigned int uiLength = strlen(pcString);
-	int I;
-	int iIndex = 0;
-	int iPos1, iPos2;
-
-	for (iPos1 = 0; ((iPos1 < (int)uiLength) && (pcString[iPos1] == (int)' ')); iPos1++) {	/* NOP */
-	}
-	for (iPos2 = uiLength - 1; ((iPos2 >= 0) && (pcString[iPos2] == (int)' ')); iPos2--) {	/* NOP */
-	}
-
-	if ((iPos1 != 0) || (iPos2 != ((int)uiLength - 1))) {
-		for (I = iPos1; I <= iPos2; I++) {
-			pcString[iIndex] = pcString[I];
-			iIndex++;
-		}
-		pcString[iIndex] = '\0';
-	}
-
-	return (pcString);
+ unsigned int uiLength = strlen(pcString);
+ int          I;
+ int          iIndex = 0;
+ int          iPos1, iPos2; 
+ 
+ for( iPos1 = 0;            ( (iPos1<(int)uiLength) && (pcString[iPos1]==(int)' ') ); iPos1++ ) { /* NOP */ }
+ for( iPos2 = uiLength - 1; ( (iPos2>=0)            && (pcString[iPos2]==(int)' ') ); iPos2-- ) { /* NOP */ }
+ 
+ if( (iPos1 != 0) || (iPos2 != ((int)uiLength - 1)) )
+ {    
+  for( I = iPos1; I <= iPos2; I++ )
+  {
+   pcString[iIndex] = pcString[I];
+   iIndex++;
+  }
+  pcString[iIndex] = '\0';
+ }
+ 
+ return(pcString);
 }
 
-inline int IsBigEndian(void)
+inline int IsBigEndian( void )
 {
-	union EndianUnion {
-		struct EndianStruct {
-			unsigned ubBit1:1;
-			unsigned ubBit2:1;
-			unsigned ubBit3:1;
-			unsigned ubBit4:1;
-			unsigned ubBit5:1;
-			unsigned ubBit6:1;
-			unsigned ubBit7:1;
-			unsigned ubBit8:1;
-			unsigned ubBitN:8;
-		} sStruct;
-		unsigned char ucNumber;
-	} sUnion;
+ union EndianUnion
+ {
+  struct EndianStruct
+  {
+   unsigned ubBit1 :1;
+   unsigned ubBit2 :1;
+   unsigned ubBit3 :1;
+   unsigned ubBit4 :1;
+   unsigned ubBit5 :1;
+   unsigned ubBit6 :1;
+   unsigned ubBit7 :1;
+   unsigned ubBit8 :1;
+   unsigned ubBitN :8;
+  } sStruct;
+  unsigned char ucNumber;
+ } sUnion;
+ sUnion.sStruct.ubBit1 = 0;
+ sUnion.sStruct.ubBit2 = 0;
+ sUnion.sStruct.ubBit3 = 0;
+ sUnion.sStruct.ubBit4 = 0;
+ sUnion.sStruct.ubBit5 = 0;
+ sUnion.sStruct.ubBit6 = 0;
+ sUnion.sStruct.ubBit7 = 0;
+ sUnion.sStruct.ubBit8 = 0;
+ sUnion.sStruct.ubBitN = 0;
+ sUnion.ucNumber       = 5;
 
-	sUnion.sStruct.ubBit1 = 0;
-	sUnion.sStruct.ubBit2 = 0;
-	sUnion.sStruct.ubBit3 = 0;
-	sUnion.sStruct.ubBit4 = 0;
-	sUnion.sStruct.ubBit5 = 0;
-	sUnion.sStruct.ubBit6 = 0;
-	sUnion.sStruct.ubBit7 = 0;
-	sUnion.sStruct.ubBit8 = 0;
-	sUnion.sStruct.ubBitN = 0;
-	sUnion.ucNumber = 5;
-
-	if ((sUnion.sStruct.ubBit1 == 1) && (sUnion.sStruct.ubBit3 == 1)) {
-		return (0);
-	} /* ##### Little Endian */
-	else {
-		if ((sUnion.sStruct.ubBit6 == 1) && (sUnion.sStruct.ubBit8 == 1)) {
-			return (1);
-		} /* ##### Big Endian    */
-		else {
-			return (-42);
-		}		/* ##### Unknown       */
-	}
+ if( (sUnion.sStruct.ubBit1 == 1) && (sUnion.sStruct.ubBit3 == 1) )
+ { return(0); }      /* ##### Little Endian */
+ else
+ {
+  if( (sUnion.sStruct.ubBit6 == 1) && (sUnion.sStruct.ubBit8 == 1) )
+  { return(1); }     /* ##### Big Endian    */
+  else
+  { return(-42); }   /* ##### Unknown       */
+ }
 }
 
 #if defined(_DEBUG)
-void Dump_Raw_Result(struct Raw_Result *res);
-void Dump_Manager_Results(struct Manager_Results *res);
-void Dump_CPU_Results(struct CPU_Results *res);
-void Dump_Net_Results(struct Net_Results *res);
+ void	Dump_Raw_Result(struct Raw_Result *res);
+ void	Dump_Manager_Results(struct Manager_Results *res);
+ void	Dump_CPU_Results(struct CPU_Results *res);
+ void	Dump_Net_Results(struct Net_Results *res);
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-BOOL SetQueueSize(HANDLE, int);
-HANDLE CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);
-BOOL GetQueuedCompletionStatus(HANDLE, LPDWORD, LPDWORD, LPOVERLAPPED *, DWORD);
+ BOOL    SetQueueSize(HANDLE, int);
+ HANDLE  CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);
+ BOOL    GetQueuedCompletionStatus(HANDLE, LPDWORD, LPDWORD, LPOVERLAPPED *, DWORD);
 
-BOOL ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
-BOOL WriteFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
-HANDLE CreateEvent(void *, BOOL, BOOL, LPCSTR);
-BOOL GetOverlappedResult(HANDLE, LPOVERLAPPED, LPDWORD, BOOL);
+ BOOL    ReadFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
+ BOOL    WriteFile(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
+ HANDLE  CreateEvent(void *, BOOL, BOOL, LPCSTR);
+ BOOL    GetOverlappedResult( HANDLE, LPOVERLAPPED, LPDWORD, BOOL );
 
-void SetLastError(DWORD);
-DWORD GetLastError(void);
-int WSAGetLastError(void);
-void WSASetLastError(DWORD);
+ void    SetLastError(DWORD);
+ DWORD   GetLastError(void);
+ int     WSAGetLastError(void);
+ void    WSASetLastError(DWORD);
 
-BOOL CloseHandle(HANDLE, int object_type = 0);
-char *_itoa(int, char *, int);
-DWORD WaitForSingleObject(HANDLE h, DWORD milliSecs);
+ BOOL    CloseHandle(HANDLE, int object_type = 0);
+ char   *_itoa(int, char *, int);
+ DWORD   WaitForSingleObject(HANDLE h, DWORD milliSecs);
 
-#ifndef NOMINMAX
-#ifndef max
-#define max(a,b)             (((a) > (b)) ? (a) : (b))
-#endif
-#ifndef min
-#define min(a,b)             (((a) < (b)) ? (a) : (b))
-#endif
-#endif
-#ifndef __max
-#define __max(a,b)            (((a) < (b)) ? (b) : (a))
-#endif
+ #ifndef NOMINMAX
+  #ifndef max
+   #define max(a,b)             (((a) > (b)) ? (a) : (b))
+  #endif
+  #ifndef min
+   #define min(a,b)             (((a) < (b)) ? (a) : (b))
+  #endif
+ #endif 
+ #ifndef __max
+  #define __max(a,b)            (((a) < (b)) ? (b) : (a))
+ #endif
 
-#if defined(IOMTR_OSFAMILY_NETWARE)
-#define _timeb		timeb
-#define _ftime		nwtime
-#define _time			time
-#define _millitm		millitm
-#define Sleep(x)		delay((x))
-#elif defined(IOMTR_OSFAMILY_UNIX)
-#if defined(IOMTR_OS_OSX)
-#define aiocb64 		aiocb
-#define aio_suspend64	aio_suspend
-#define aio_error64		aio_error
-#define aio_cancel64		aio_cancel
-#define aio_read64		aio_read
-#define aio_write64		aio_write
-#define aio_return64		aio_return
+ #if defined(IOMTR_OSFAMILY_NETWARE)
+  #define _timeb		timeb
+  #define _ftime		nwtime
+  #define _time			time
+  #define _millitm		millitm
+  #define Sleep(x)		delay((x))
+ #elif defined(IOMTR_OSFAMILY_UNIX)
+  #if defined(IOMTR_OS_OSX)
+   #define aiocb64 		aiocb
+   #define aio_suspend64	aio_suspend
+   #define aio_error64		aio_error
+   #define aio_cancel64		aio_cancel
+   #define aio_read64		aio_read
+   #define aio_write64		aio_write
+   #define aio_return64		aio_return
 
-#define _timeb		timeval
-#define _ftime(x)		gettimeofday(x,NULL)
-#define _time		tv_sec
-#define _millitm		tv_usec
-#define Sleep(x) 		usleep((x) * 1000)
-#elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
-#define _timeb		timeb
-#define _ftime		ftime
-#define _time			time
-#define _millitm		millitm
-#define Sleep(x) 		usleep((x) * 1000)
-#else
-#error ===> ERROR: You have to do some coding here to get the port done!
-#endif
-#else
-#warning ===> WARNING: You have to do some coding here to get the port done!
-#endif
+   #define _timeb		timeval
+   #define _ftime(x)		gettimeofday(x,NULL)
+   #define _time		tv_sec
+   #define _millitm		tv_usec
+   #define Sleep(x) 		usleep((x) * 1000)
+  #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
+   #define _timeb		timeb
+   #define _ftime		ftime
+   #define _time			time
+   #define _millitm		millitm
+   #define Sleep(x) 		usleep((x) * 1000)
+  #else
+   #error ===> ERROR: You have to do some coding here to get the port done!
+  #endif
+ #else
+  #warning ===> WARNING: You have to do some coding here to get the port done!
+ #endif
 
-#define LOCK					    \
+ #define LOCK					    \
 	 if (pthread_mutex_lock(&lock_mt))          \
 	 {					    \
 		cout << "unable to lock" << endl;   \
 		exit(1);			    \
 	 }
-#define UNLOCK					      \
+ #define UNLOCK					      \
 	 if (pthread_mutex_unlock(&lock_mt))	      \
 	 {					      \
 		cout << "unable to unlock" << endl;   \
 		exit(1);			      \
 	 }
 
-#define InterlockedExchange(a,b)   \
+ #define InterlockedExchange(a,b)   \
 	 LOCK;			    \
 	 *(a) = (b);		    \
 	 UNLOCK;
-#define InterlockedDecrement(a)   \
+ #define InterlockedDecrement(a)   \
 	 LOCK;			   \
 	 --*(a);		   \
 	 UNLOCK;
-#define InterlockedIncrement(a)   \
+ #define InterlockedIncrement(a)   \
 	 LOCK;			   \
 	 ++*(a);		   \
 	 UNLOCK;
-#endif
+#endif 
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_LINUX)
-extern DWORDLONG jiffies(void);
-extern DWORDLONG rdtsc(void);
+ extern DWORDLONG jiffies(void);
+ extern DWORDLONG rdtsc(void);
 
-#if defined(IOMTR_CPU_PPC)
-extern DWORD get_tbl();
-extern DWORD get_tbu();
-#endif
+ #if defined(IOMTR_CPU_PPC)
+  extern DWORD get_tbl();
+  extern DWORD get_tbu();
+ #endif
 
-#if defined(IOMTR_CPU_XSCALE)
-extern void double_wordswap(double *d);
-extern void Manager_Info_double_swap(struct Manager_Info *p);
-extern void Manager_Results_double_swap(struct Manager_Results *p);
-extern void CPU_Results_double_swap(struct CPU_Results *p);
-extern void Net_Results_double_swap(struct Net_Results *p);
-#endif
-
-#if defined(_IO)  && !defined(BLKSSZGET)
-#define BLKSSZGET    _IO(0x12,104)
-#endif
-#if defined(_IOR) && !defined(BLKBSZGET)
-#define BLKBSZGET    _IOR(0x12,112,size_t)
-#endif
-#if defined(_IO)  && !defined(BLKGETSIZE)
-#define BLKGETSIZE   _IO(0x12,96)
-#endif
-#if defined(_IO)  && !defined(BLKGETSIZE64)
-#define BLKGETSIZE64 _IOR(0x12,114, size_t)
-#endif
-#endif
+ #if defined(IOMTR_CPU_XSCALE)
+  extern void double_wordswap(double *d);
+  extern void Manager_Info_double_swap(struct Manager_Info *p);
+  extern void Manager_Results_double_swap(struct Manager_Results *p);
+  extern void CPU_Results_double_swap(struct CPU_Results *p);
+  extern void Net_Results_double_swap(struct Net_Results *p);
+ #endif
+ 
+ #if defined(_IO)  && !defined(BLKSSZGET)
+  #define BLKSSZGET    _IO(0x12,104)
+ #endif
+ #if defined(_IOR) && !defined(BLKBSZGET)
+  #define BLKBSZGET    _IOR(0x12,112,size_t)
+ #endif
+ #if defined(_IO)  && !defined(BLKGETSIZE)
+  #define BLKGETSIZE   _IO(0x12,96)
+ #endif
+ #if defined(_IO)  && !defined(BLKGETSIZE64)
+  #define BLKGETSIZE64 _IOR(0x12,114, size_t)
+ #endif
+#endif 
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_NETWARE)
-int aio_suspend64(struct aiocb64 **cb, int a, struct timespec *);
-int aio_error64(struct aiocb64 *cb);
-int aio_return64(struct aiocb64 *cb);
-int aio_read64(struct aiocb64 *cb, int type);
-int aio_write64(struct aiocb64 *cb, int type);
-int aio_cancel64(int a, struct aiocb64 *cb);
+ int aio_suspend64(struct aiocb64 **cb, int a, struct timespec *);
+ int aio_error64(struct aiocb64 *cb);
+ int aio_return64(struct aiocb64 *cb);
+ int aio_read64(struct aiocb64 *cb, int type);
+ int aio_write64(struct aiocb64 *cb, int type);
+ int aio_cancel64(int a, struct aiocb64 *cb);
 
-#ifdef __cplusplus
-extern "C" {
+ #ifdef __cplusplus
+ extern "C"
+ {
+ #endif
+ extern LONG  GetTimerMinorTicksPerSecond(void);
+ extern unsigned long kGetProcessorInterruptCount(unsigned int, unsigned int *);
+ extern void  EnterDebugger();
+ extern LONG SSGetLANCommonCounters(unsigned long, unsigned long, unsigned char *, unsigned int);
+ #ifdef __cplusplus
+ }
+ #endif
+
+ extern DWORDLONG rdtsc(void); 
 #endif
-	extern LONG GetTimerMinorTicksPerSecond(void);
-	extern unsigned long kGetProcessorInterruptCount(unsigned int, unsigned int *);
-	extern void EnterDebugger();
-	extern LONG SSGetLANCommonCounters(unsigned long, unsigned long, unsigned char *, unsigned int);
-#ifdef __cplusplus
-}
-#endif
-extern DWORDLONG rdtsc(void);
-#endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-extern "C" DWORDLONG rdtsc();
+ extern "C" DWORDLONG rdtsc();
 #endif
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-extern DWORDLONG rdtsc();
+ extern DWORDLONG rdtsc();
 #endif
 // ----------------------------------------------------------------------------
 
-#endif				// ___IOCOMMON_H_DEFINED___
+
+#endif	// ___IOCOMMON_H_DEFINED___

Modified: branches/IOMETER-restruct/iometer/src/IOGrunt.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOGrunt.cpp	2006-02-08 02:20:20 UTC (rev 236)
+++ branches/IOMETER-restruct/iometer/src/IOGrunt.cpp	2006-02-08 19:08:18 UTC (rev 237)
@@ -162,19 +162,19 @@
 	// Release grunt's I/O data buffers if they are in use.
 	if (data_size)
 #if defined(IOMTR_OSFAMILY_NETWARE)
-		NXMemFree(read_data);
+	NXMemFree(read_data);
 	NXMemFree(write_data);
 #elif defined(IOMTR_OSFAMILY_UNIX)
-		free(read_data);
+	free(read_data);
 	free(write_data);
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
-		VirtualFree(read_data, 0, MEM_RELEASE);
+	VirtualFree(read_data, 0, MEM_RELEASE);
 	VirtualFree(write_data, 0, MEM_RELEASE);
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-		Free_Transaction_Arrays();
+	Free_Transaction_Arrays();
 }
 
 //



From cheungming at berlios.de  Wed Feb  8 20:20:49 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Wed, 8 Feb 2006 20:20:49 +0100
Subject: [Iometer-svn] r238 - trunk/iometer/src
Message-ID: <200602081920.k18JKnrp022230@sheep.berlios.de>

Author: cheungming
Date: 2006-02-08 20:20:47 +0100 (Wed, 08 Feb 2006)
New Revision: 238

Modified:
   trunk/iometer/src/IOCommon.h
Log:
the MacOSX port broke the compile on windows. there were 2 structure member name changed and needed to be defined for windows.



Modified: trunk/iometer/src/IOCommon.h
===================================================================
--- trunk/iometer/src/IOCommon.h	2006-02-08 19:08:18 UTC (rev 237)
+++ trunk/iometer/src/IOCommon.h	2006-02-08 19:20:47 UTC (rev 238)
@@ -819,6 +819,12 @@
  void	Dump_Net_Results(struct Net_Results *res);
 #endif
 // ----------------------------------------------------------------------------
+
+#if defined(IOMTR_OSFAMILY_WINDOWS)
+ #define _time			time
+ #define _millitm		millitm
+#endif
+
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
  BOOL    SetQueueSize(HANDLE, int);
  HANDLE  CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);



From cheungming at berlios.de  Wed Feb  8 20:36:15 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Wed, 8 Feb 2006 20:36:15 +0100
Subject: [Iometer-svn] r239 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602081936.k18JaFDf001314@sheep.berlios.de>

Author: cheungming
Date: 2006-02-08 20:36:12 +0100 (Wed, 08 Feb 2006)
New Revision: 239

Modified:
   branches/IOMETER-restruct/iometer/src/IOCommon.h
Log:
the MacOSX port broke the compile on windows. there were 2 structure member name changed and needed to be defined for windows.
[this patch already applied on trunk, also need on this branch as well.]



Modified: branches/IOMETER-restruct/iometer/src/IOCommon.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 19:20:47 UTC (rev 238)
+++ branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 19:36:12 UTC (rev 239)
@@ -819,6 +819,12 @@
  void	Dump_Net_Results(struct Net_Results *res);
 #endif
 // ----------------------------------------------------------------------------
+
+#if defined(IOMTR_OSFAMILY_WINDOWS)
+ #define _time			time
+ #define _millitm		millitm
+#endif
+
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
  BOOL    SetQueueSize(HANDLE, int);
  HANDLE  CreateIoCompletionPort(HANDLE, HANDLE, DWORD, DWORD);



From cheungming at berlios.de  Wed Feb  8 20:44:45 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Wed, 8 Feb 2006 20:44:45 +0100
Subject: [Iometer-svn] r240 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602081944.k18JijT2004984@sheep.berlios.de>

Author: cheungming
Date: 2006-02-08 20:44:42 +0100 (Wed, 08 Feb 2006)
New Revision: 240

Modified:
   branches/IOMETER-restruct/iometer/src/IOTime.cpp
Log:
indent format the asm code in wrong way. fixed it.



Modified: branches/IOMETER-restruct/iometer/src/IOTime.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTime.cpp	2006-02-08 19:36:12 UTC (rev 239)
+++ branches/IOMETER-restruct/iometer/src/IOTime.cpp	2006-02-08 19:44:42 UTC (rev 240)
@@ -234,9 +234,10 @@
 extern DWORDLONG rdtsc()
 {
 	__asm__ {
-		_emit 0F h	// Store low  32-bits of counter in EAX.
-		    _emit 31 h	// Store high 32-bits of counter in EDX.
-	ret}
+		_emit 0Fh	// Store low  32-bits of counter in EAX.
+		_emit 31h	// Store high 32-bits of counter in EDX.
+		ret
+	}
 }
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!



From cheungming at berlios.de  Tue Feb 21 01:54:15 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 01:54:15 +0100
Subject: [Iometer-svn] r241 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602210054.k1L0sFV1004088@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 01:54:08 +0100 (Tue, 21 Feb 2006)
New Revision: 241

Modified:
   branches/IOMETER-restruct/iometer/src/IOCommon.h
Log:
From: 	Rick Altherr <raltherr at apple.com>
To: 	iometer-devel-list <iometer-devel at lists.sourceforge.net>
Subject: 	[Iometer-devel] IOmeter OS X patch
Date: 	Wed, 8 Feb 2006 11:37:03 -0800  (14:37 EST)

As part of the OS X merge, a few structures were included too late in  
IOCommon.h for the compile to succeed.  The attached patch fixes this  
issue and should allow OS X builds again.



Modified: branches/IOMETER-restruct/iometer/src/IOCommon.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-08 19:44:42 UTC (rev 240)
+++ branches/IOMETER-restruct/iometer/src/IOCommon.h	2006-02-21 00:54:08 UTC (rev 241)
@@ -256,6 +256,14 @@
 
  #if defined(IOMTR_OS_OSX)
   #include <sys/aio.h>
+  #define aiocb64 		aiocb
+  #define aio_suspend64	aio_suspend
+  #define aio_error64		aio_error
+  #define aio_cancel64		aio_cancel
+  #define aio_read64		aio_read
+  #define aio_write64		aio_write
+  #define aio_return64		aio_return
+
  #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
   #include <malloc.h>
   #include <aio.h>
@@ -864,14 +872,6 @@
   #define Sleep(x)		delay((x))
  #elif defined(IOMTR_OSFAMILY_UNIX)
   #if defined(IOMTR_OS_OSX)
-   #define aiocb64 		aiocb
-   #define aio_suspend64	aio_suspend
-   #define aio_error64		aio_error
-   #define aio_cancel64		aio_cancel
-   #define aio_read64		aio_read
-   #define aio_write64		aio_write
-   #define aio_return64		aio_return
-
    #define _timeb		timeval
    #define _ftime(x)		gettimeofday(x,NULL)
    #define _time		tv_sec



From cheungming at berlios.de  Tue Feb 21 01:59:51 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 01:59:51 +0100
Subject: [Iometer-svn] r242 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602210059.k1L0xppK005987@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 01:59:45 +0100 (Tue, 21 Feb 2006)
New Revision: 242

Modified:
   branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp
Log:
fix from ganderson-eql at users.sourceforge.net
	- Initialize iocq structure member for all necessary platforms.



Modified: branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp	2006-02-21 00:54:08 UTC (rev 241)
+++ branches/IOMETER-restruct/iometer/src/IOTargetDisk.cpp	2006-02-21 00:59:45 UTC (rev 242)
@@ -176,10 +176,8 @@
 
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 	disk_file = (HANDLE) & file_handle;
-#if defined(IOMTR_SETTING_GCC_M64) || defined(IOMTR_OS_OSX)
 	file_handle.iocq = NULL;
 #endif
-#endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
 	mmAppTag = (LONG) AllocateResourceTag(getnlmhandle(), "dynamo", (LONG) MM_APPLICATION_SIGNATURE);



From cheungming at berlios.de  Tue Feb 21 02:04:45 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 02:04:45 +0100
Subject: [Iometer-svn] r243 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602210104.k1L14jCI007599@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 02:04:40 +0100 (Tue, 21 Feb 2006)
New Revision: 243

Modified:
   branches/IOMETER-restruct/iometer/src/Makefile-Linux.ppc
Log:
Removed wrongly included IOManagerSolaris.o from Makefile-Linux.ppc.



Modified: branches/IOMETER-restruct/iometer/src/Makefile-Linux.ppc
===================================================================
--- branches/IOMETER-restruct/iometer/src/Makefile-Linux.ppc	2006-02-21 00:59:45 UTC (rev 242)
+++ branches/IOMETER-restruct/iometer/src/Makefile-Linux.ppc	2006-02-21 01:04:40 UTC (rev 243)
@@ -97,7 +97,7 @@
 
 OBJECTS= IOGlobals.o \
          Pulsar.o \
-         IOManager.o IOManagerLinux.o IOManagerSolaris.o \
+         IOManager.o IOManagerLinux.o \
 	 IOGrunt.o \
 	 IOTarget.o IOTargetDisk.o IOTargetTCP.o \
 	 IOPort.o IOPortTCP.o \



From cheungming at berlios.de  Tue Feb 21 02:08:37 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 02:08:37 +0100
Subject: [Iometer-svn] r244 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602210108.k1L18b7F009714@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 02:08:33 +0100 (Tue, 21 Feb 2006)
New Revision: 244

Modified:
   branches/IOMETER-restruct/iometer/src/IOCQ.h
Log:
Added virtual destructor to avoid compile warning under new GCC.



Modified: branches/IOMETER-restruct/iometer/src/IOCQ.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOCQ.h	2006-02-21 01:04:40 UTC (rev 243)
+++ branches/IOMETER-restruct/iometer/src/IOCQ.h	2006-02-21 01:08:33 UTC (rev 244)
@@ -75,7 +75,7 @@
 
 class CQ {
       public:
-
+	virtual ~CQ() { };
 	virtual ReturnVal GetStatus(int *bytes, int *data, int delay) = 0;
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 	virtual BOOL SetQueueSize(int size) {



From cheungming at berlios.de  Tue Feb 21 02:28:46 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 02:28:46 +0100
Subject: [Iometer-svn] r245 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602210128.k1L1SkrI014015@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 02:27:31 +0100 (Tue, 21 Feb 2006)
New Revision: 245

Modified:
   branches/IOMETER-restruct/iometer/src/PageSetup.cpp
   branches/IOMETER-restruct/iometer/src/Worker.cpp
Log:

From cheungming at berlios.de  Tue Feb 21 02:35:52 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 02:35:52 +0100
Subject: [Iometer-svn] r246 - in branches/IOMETER-restruct/iometer/src: . scripts
Message-ID: <200602210135.k1L1Zq1K015929@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 02:35:44 +0100 (Tue, 21 Feb 2006)
New Revision: 246

Added:
   branches/IOMETER-restruct/iometer/src/scripts/ccntmknod
   branches/IOMETER-restruct/iometer/src/scripts/ccntmknod.README
Removed:
   branches/IOMETER-restruct/iometer/src/ccnt/
Log:
Moved ccntmknod script to scripts subdirectory.



Copied: branches/IOMETER-restruct/iometer/src/scripts/ccntmknod (from rev 240, branches/IOMETER-restruct/iometer/src/ccnt/ccntmknod)

Copied: branches/IOMETER-restruct/iometer/src/scripts/ccntmknod.README (from rev 240, branches/IOMETER-restruct/iometer/src/ccnt/README)



From cheungming at berlios.de  Tue Feb 21 02:40:34 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 02:40:34 +0100
Subject: [Iometer-svn] r247 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602210140.k1L1eYC0016467@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 02:39:59 +0100 (Tue, 21 Feb 2006)
New Revision: 247

Modified:
   branches/IOMETER-restruct/iometer/src/IOGlobals.cpp
Log:
Removed windows specific method to get version string. Use unified method now.



Modified: branches/IOMETER-restruct/iometer/src/IOGlobals.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOGlobals.cpp	2006-02-21 01:35:44 UTC (rev 246)
+++ branches/IOMETER-restruct/iometer/src/IOGlobals.cpp	2006-02-21 01:39:59 UTC (rev 247)
@@ -114,41 +114,6 @@
 {
 	char *pStrStandard = NULL;
 
-#if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	ASSERT((ppStrStandard != NULL) && (ppStrWithDebug != NULL));
-
-	//Get app(EXE module)'s file path
-	char modulePathBuff[MAX_PATH];
-
-	if (::GetModuleFileName(NULL, modulePathBuff, sizeof(modulePathBuff)) != 0) {
-		DWORD dwHandle = 0;	//not used
-		DWORD dwVerInfoSize =::GetFileVersionInfoSize(modulePathBuff, &dwHandle);
-
-		//The module provides VersionInfo data
-		if (dwVerInfoSize != 0) {
-			//ptr to buffer to hold version information
-			char *pVerInfo = new char[dwVerInfoSize];
-
-			if (::GetFileVersionInfo(modulePathBuff, NULL, dwVerInfoSize, pVerInfo)) {
-				UINT dataLen;	//receives size of fixed data area (not used)
-				char *pFileVersion;
-
-				//04b0 == 1200 codepage denoting Unicode used for win95 and NT resource dlls (see Iometer.rc2)
-				if (::VerQueryValue(pVerInfo, TEXT("\\StringFileInfo\\040904b0\\FileVersion"),
-						    (void **)&pFileVersion, &dataLen)) {
-					pStrStandard = new char[strlen(pFileVersion) + 1];
-
-					strcpy(pStrStandard, pFileVersion);
-				}
-			}
-			delete[]pVerInfo;
-		}
-		//It should have VersionInfo!
-		else
-			ASSERT(0);
-	}
-#endif				/* IOMTR_OS_WIN32 || IOMTR_OS_WIN64 */
-
 	//UNIX or last resort, use product-wide constant
 	if (pStrStandard == NULL) {
 		pStrStandard = new char[strlen(IOVER_FILEVERSION) + 1];



From cheungming at berlios.de  Tue Feb 21 21:53:49 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 21:53:49 +0100
Subject: [Iometer-svn] r248 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602212053.k1LKrndm011272@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 21:53:45 +0100 (Tue, 21 Feb 2006)
New Revision: 248

Modified:
   branches/IOMETER-restruct/iometer/src/NetTCP.cpp
   branches/IOMETER-restruct/iometer/src/NetTCP.h
Log:
Removed WORKAROUND_LISTEN_BUG define and related code. My understanding is that it
handles the situation that trying to listen multiple times. But will this happen in
our code at all?



Modified: branches/IOMETER-restruct/iometer/src/NetTCP.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/NetTCP.cpp	2006-02-21 01:39:59 UTC (rev 247)
+++ branches/IOMETER-restruct/iometer/src/NetTCP.cpp	2006-02-21 20:53:45 UTC (rev 248)
@@ -137,10 +137,6 @@
 	client_socket = (CONNECTION)&client_fp;
 	maxfd = sysconf(_SC_OPEN_MAX);    // the max # of file descriptors that select() handles.
 
-#ifdef WORKAROUND_LISTEN_BUG
-	listening = FALSE;
-#endif
-
 #endif // IOMTR_OSFAMILY_UNIX
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
@@ -486,10 +482,6 @@
 	// It's ok to listen more than once on a socket.
 	// allow only a single connection.
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
-	#ifdef WORKAROUND_LISTEN_BUG
-	if ( ! listening )
-	{
-	#endif // WORKAROUND_LISTEN_BUG
 		if ( listen ( fp->fd, 1 ) != 0 )
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
 		if ( listen ( server_socket, 1 ) != 0 ) 
@@ -502,12 +494,6 @@
 			OutputErrMsg();
 			return ReturnError;
 		}
-#if defined(IOMTR_OSFAMILY_UNIX)
-	#ifdef WORKAROUND_LISTEN_BUG
-		listening =	TRUE;
-	}
-	#endif // WORKAROUND_LISTEN_BUG
-#endif // IOMTR_OSFAMILY_UNIX
 
 	// Accept connections to socket.
 	#if NETWORK_DETAILS || _DEBUG
@@ -903,9 +889,6 @@
 	if ( close_server )
 	{
 		s = &server_socket;
-#if defined(IOMTR_OSFAMILY_UNIX) && defined(WORKAROUND_LISTEN_BUG)
-		listening = FALSE;
-#endif // UNIX && WORKAROUND_LISTEN_BUG
 	}
 	else
 		s = &client_socket;

Modified: branches/IOMETER-restruct/iometer/src/NetTCP.h
===================================================================
--- branches/IOMETER-restruct/iometer/src/NetTCP.h	2006-02-21 01:39:59 UTC (rev 247)
+++ branches/IOMETER-restruct/iometer/src/NetTCP.h	2006-02-21 20:53:45 UTC (rev 248)
@@ -137,15 +137,11 @@
 	struct File client_fp;	// the client and server sockets on UNIX.
 	int maxfd;		// The max nos of fds' for select() call.
 
-#ifdef WORKAROUND_LISTEN_BUG
-	BOOL listening;		// flag to indicate if a socket is listening or not.
-#endif				// WORKAROUND_LISTEN_BUG
-
 #endif				// IOMTR_OSFAMILY_UNIX
 
       protected:
 	// Member Functions.
-	 ReturnVal CreateSocket(CONNECTION * s);
+	ReturnVal CreateSocket(CONNECTION * s);
 	ReturnVal BindSocket(CONNECTION * s, SOCKADDR_IN * address);
 	ReturnVal CloseSocket(CONNECTION * s);
 	void SetOptions(CONNECTION * s);



From cheungming at berlios.de  Tue Feb 21 22:44:32 2006
From: cheungming at berlios.de (cheungming at BerliOS)
Date: Tue, 21 Feb 2006 22:44:32 +0100
Subject: [Iometer-svn] r249 - branches/IOMETER-restruct/iometer/src
Message-ID: <200602212144.k1LLiWrn017545@sheep.berlios.de>

Author: cheungming
Date: 2006-02-21 22:44:32 +0100 (Tue, 21 Feb 2006)
New Revision: 249

Modified:
   branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp
Log:
use sysconf to get processor count for Linux.



Modified: branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp
===================================================================
--- branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp	2006-02-21 20:53:45 UTC (rev 248)
+++ branches/IOMETER-restruct/iometer/src/IOPerformanceLinux.cpp	2006-02-21 21:44:32 UTC (rev 249)
@@ -156,65 +156,10 @@
 {
 }
 
-//
-// Getting the number of processors in the system.
-//
 int Performance::Get_Processor_Count()
 {
-	// The file "/proc/stat" enumerates the CPUs, one per line, each line starting
-	// with the string "cpu". I prepend a '\n' to the file, then search for the
-	// string "\ncpu"; that way, I will find every time that "cpu" appears as the
-	// first thing in a line.
-	//
-	// Example /proc/stat file: (Note: On a two CPU system, you will see two
-	// cpu lines, beginning "cpu0 ..." and "cpu1 ...")
-	//////////////////////////////////////////////////////////////////////
-	// cpu  1847686 355419 509281 14738354
-	// disk 69683 0 22232 0
-	// disk_rio 18236 0 302 0
-	// disk_wio 51447 0 21930 0
-	// disk_rblk 145876 0 2374 0
-	// disk_wblk 411576 0 173352 0
-	// page 76934 442943
-	// swap 1410 2465
-	// intr 21377391 17450740 101201 0 2 2 0 3 0 1 0 0 69197 724623 1 340233 2691388 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
-	// ctxt 175242460
-	// btime 942875987
-	//////////////////////////////////////////////////////////////////////
-	char stats[16 * 1024 + 1], *search;
-	int fd, byteCount, cpuCount;
-
-	int nr_cpu = 0;
-
-	if (kstatfd > 0 && ioctl(kstatfd, IM_IOC_GETCPUNUM, &nr_cpu) >= 0) {
-		cout << "# CPU: " << nr_cpu << endl;
-		return nr_cpu;
-	}
-
-	fd = open("/proc/stat", O_RDONLY);
-	if (fd < 0) {
-		cout << "*** Unable to determine number of processors in system.";
-		return 0;
-	}
-	byteCount = read(fd, stats + 1, sizeof(stats) - 1);
-	close(fd);
-	if ((byteCount < 0) || (byteCount == sizeof(stats) - 1)) {
-		cout << "*** Unable to determine number of processors in system.";
-		return 0;
-	}
-	stats[0] = '\n';	// Make the first line begin with a \n, like the others.
-	stats[byteCount + 1] = '\0';
-	search = stats;
-	cpuCount = 0;
-	while ((search = strstr(search, "\ncpu")) != NULL) {
-		++cpuCount;
-		++search;	// Make sure we don't find the same CPU again!
-	}
-
-	// Decrease result by one, because on a single processor
-	// machine, the code above counts "cpu" and "cpu0"!
-	cpuCount--;
-	return (cpuCount);
+	/* glib will do all parsing work for us from /proc/stat */
+	return (sysconf(_SC_NPROCESSORS_CONF));
 }
 
 //



